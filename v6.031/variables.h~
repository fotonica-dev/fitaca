// Tipos
typedef unsigned char BYTE;		// 8 bits
typedef unsigned short int WORD;	// 16 bits

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Variables Globales
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// Velocidad de marcaje
static int VelocidadMarcaje;

// Potencia Láser
static int PotenciaLaser;

// Periodo del tren de pulsos utilizado para excitar el Láser
static int PeriodoTrenPulsos;

// Retardo Láser On
static int RetardoLaserOn;

// Retardo Láser Off
static int RetardoLaserOff;

// Velocidad de salto
static int VelocidadSalto;

// Retardo de salto
static int RetardoSalto;

// Retardo de polígono
static int RetardoPoligono;

// Retardo de marcaje
static int RetardoMarcaje;

// Factor de calibración del fichero de corrección
static float CalibracionCorreccion;

// Marcaje Dinámico Activo: 
// 0 - desactivado 
// 1 - activado con velocidad variable (usa encoder)
// 2 - activado con velocidad constante (no usa encoder)
static int MarcajeDinamicoActivo;

// Calibración del encoder
static float CalibracionEncoder;

// Velocidad de la línea: se utiliza cuando la velocidad de la línea es constante
static float VelocidadLinea;

// Incremento de cuentas del encoder en cada periodo: es un float porque si la velocidad es constante hae falta precisión float
static float IncrementoCuentasPeriodo;
static float IncrementoAcumulado;

// Valor de activación de los galvos
static int ValorActivacionGalvos;		// Valor digital (0 o 1) que se escribe para activar los galvos (multiscanx.conf)

// Tensión de alimentación del galvo que desplaza al extremo del campo (V), 
// que corresponde al máximo desplazamiento horizontal o vertical en bits
static float VGalvoRef_MaximoBits;

// Máxima tensión aplicable a los galvos, se calculará como un 1% más que la anterior
static float VGalvoMax;

// Valor digital (0 o 1) que se considera de disparo de la fotocélula
static unsigned int ValorDisparo;

// Retardo de disparo tras la detección de la fotocélula
static int RetardoDisparo_mm, RetardoDisparo_cuentas;

// Retardo de disparo adicional generado por el offset
static int RetardoDisparo_cuentas_adicional;

// Variable de estado para controlar si se está esperando el retardo de disparo de la fotocélula
static int EsperaRetardoDisparo;		

// Variables relacionadas con el número de lecturas consecutivas de la fotocélula para considerar un disparo
static int LecturasConsecutivasDisparo;
static int MinimoLecturasConsecutivasDisparo = 1; // Por si acaso el fichero de configuración no tiene la variable se predefine un valor

// Ventana activa desde donde se invoca la ventana de mensajes
static unsigned int VentanaActiva = VPrincipal;	// Ventana Principal

// Idioma del interfaz
static int Idioma;

// Funcionalidad
static int Funcionalidad;

// Control de acceso
static int ControlAcceso;
static char Password[10], PasswordUsuario[10];

// Estrategia de marcaje
static int Estrategia;			// 0-carácter, 1-átomos, 2-átomos fuera de campo

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Datos de las líneas de texto

// Numero de bloques reales
static int NumeroBloques;

// Texto de las líneas
// Línea 1
static char LineaTexto1[NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

// Línea 2
static char LineaTexto2[NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

// Línea 3
static char LineaTexto3[NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

// Línea 4
static char LineaTexto4[NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

// Altura de las líneas
static float AlturaLineaTexto1[NumeroBloquesLinea];
static float AlturaLineaTexto2[NumeroBloquesLinea];
static float AlturaLineaTexto3[NumeroBloquesLinea];
static float AlturaLineaTexto4[NumeroBloquesLinea];

// Anchura de las líneas
static float AnchuraLineaTexto1;
static float AnchuraLineaTexto2;
static float AnchuraLineaTexto3;
static float AnchuraLineaTexto4;

// textos entre campos variables
static char lineaanterior[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char lineamedio[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char lineamedio2[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char lineafinal[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

// línea que se está calculando para EncontrarParametros y para lanzar la ventana de campos variables
static int LineaCalcular;

// bloque que se está calculando para EncontrarParametros y para lanzar la ventana de campos variables
static int BloqueCalcular;

// Marca centrada
static bool Centrado;

// Impresión en el reverso del material (en espajo)
static bool Reverso;

// Marca fuera de límites
static bool FueraLimites;

// Para controlar que el plt no se pasa de tamaño (número de líneas >= MaximoLineasArchivoPlt)
static bool pltDemasiadoGrande; 

// Para controlar que el plt no sea incorrecto: menos de 2 líneas (PU y PD) o altura 0
static bool pltIncorrecto; 

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Campos variables

static int StatusFecha[NumeroLineasTexto][NumeroBloquesLinea], 
	       StatusHora[NumeroLineasTexto][NumeroBloquesLinea], 
	       StatusNumeroSerie[NumeroLineasTexto][NumeroBloquesLinea]; 	// Controlan si hay definidos campos variables

static int OrdenFecha[NumeroLineasTexto][NumeroBloquesLinea], 
	       OrdenHora[NumeroLineasTexto][NumeroBloquesLinea], 
	       OrdenNumeroSerie[NumeroLineasTexto][NumeroBloquesLinea];	// Guarda el orden de los campos para cada línea

// Texto antes y después de los campos
static char textoanteriorfecha[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea]; 
static char textoposteriorfecha[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];	
static char textoanteriorhora[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char textoposteriorhora[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char textoanteriorserie[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];
static char textoposteriorserie[NumeroLineasTexto][NumeroBloquesLinea][NumeroMaximoCaracteresLinea];

static int ValorFormatoFecha1[NumeroLineasTexto][NumeroBloquesLinea];
static int ValorFormatoFecha2[NumeroLineasTexto][NumeroBloquesLinea];
static int ValorFormatoFecha3[NumeroLineasTexto][NumeroBloquesLinea];
static int ValorSeparadorFecha[NumeroLineasTexto][NumeroBloquesLinea];

static int ValorFormatoHora1[NumeroLineasTexto][NumeroBloquesLinea];		
static int ValorFormatoHora2[NumeroLineasTexto][NumeroBloquesLinea];
static int ValorFormatoHora3[NumeroLineasTexto][NumeroBloquesLinea];
static int ValorSeparadorHora[NumeroLineasTexto][NumeroBloquesLinea];

static int ValorFuente;			                

// Almacena los formatos de la fecha: 3 idiomas (ESP, ING, ITA), 9 formatos, LongitudMaximaStringFecha caracteres
static char FormatoFecha[Idiomas][FormatosFecha][LongitudMaximaStringFecha] = {
	{ " ", "DD", "DDD", "DIA", "MM", "MMM", "MES", "AA", "AAAA", "SS", "DS", "JJ" },
	{ " ", "DD", "DDD", "DAY", "MM", "MMM", "MONTH", "YY", "YYYY", "WW", "DW", "JJ" },
	{ " ", "GG", "GGG", "GIORNO", "MM", "MMM", "MESI", "AA", "AAAA", "SS", "GS", "JJ" }
};	

static char FormatoCompletoFecha[NumeroLineasTexto][NumeroBloquesLinea][LongitudMaximaStringFecha];

static char SeparadorFecha[SeparadoresFecha][2] = { " ", "/", ":", "-", "." };

// String donde se almacena la fecha formateada
static char Fecha[NumeroLineasTexto][NumeroBloquesLinea][LongitudMaximaStringFecha];

// Caducidad en meses
static int Caducidad[NumeroLineasTexto][NumeroBloquesLinea];	

// Almacena los formatos de la hora: 3 idiomas (ESP, ING, ITA), 4 formatos, LongitudMaximaStringHora caracteres
static char FormatoHora[Idiomas][FormatosHora][LongitudMaximaStringHora] = { 
	{ " ", "HH", "hh", "MM", "SS", "turno" }, 
	{ " ", "HH", "hh", "MM", "SS", "shift" }, 
	{ " ", "OO", "oo", "MM", "SS", "spostare" }
};

static char FormatoCompletoHora[NumeroLineasTexto][NumeroBloquesLinea][LongitudMaximaStringHora];

static char SeparadorHora[SeparadoresHora][2] = { " ", "/", ":", "-", "." };

// String donde se almacena la hora formateada
static char Hora[NumeroLineasTexto][NumeroBloquesLinea][LongitudMaximaStringHora];

// Almacena los nombres de fuentes: 3 idiomas (ESP, ING, ITA), 10 fonts, LongitudMaximaStringFuente caracteres
static char Fuentes[Idiomas][NumeroFuentes][LongitudMaximaStringFuente] = {
	{"arial", "book antigua", "courier", "palatino", "rápida", "rápida doble", "rápida pet", "sencilla", "times new roman", "india"},
	{"arial", "book antigua", "courier", "palatino", "speed", "speed double", "speed pet", "simple", "times new roman", "india"},
	{"arial", "book antigua", "courier", "palatino", "veloce", "veloce doppia", "veloce pet", "semplice", "times new roman", "india"}
};

// String donde se almacena la fuente actual
//static char Fuente[LongitudMaximaStringFuente];

// Número de serie
static long int NumeroSerie[NumeroLineasTexto][NumeroBloquesLinea];		
static long int NumeroSerieInicial[NumeroLineasTexto][NumeroBloquesLinea];
static long int NumeroSerieFinal[NumeroLineasTexto][NumeroBloquesLinea];
static unsigned int NumeroDigitosNumeroSerie[NumeroLineasTexto][NumeroBloquesLinea];

// Número de serie en formato string
static char strNumeroSerie[NumeroLineasTexto][NumeroBloquesLinea][20];	

// Número de unidades por lote
static long int NumeroUnidadesLote[NumeroLineasTexto][NumeroBloquesLinea];
static long int NumeroUnidadesLoteActual[NumeroLineasTexto][NumeroBloquesLinea];		

static int indice = 0;		// indice para saber cuál es el cuadro de texto activo
            			// al utilizar el teclado en pantalla

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Códigos de barras

struct zint_symbol *BarcodeSymbol[NumeroLineasTexto][NumeroBloquesLinea];		// Objeto código de barras

//static int StatusBarcode[NumeroLineasTexto];    		// Controla si está activo el código de barras en cada línea
//static int TipoBarcode[NumeroLineasTexto]; 			// Guarda el tipo de código de barras

static int InvertirBarcode[NumeroLineasTexto][NumeroBloquesLinea]; 			// Controla si hay que invertir el código de barras
static int SeparacionBarrasBarcode[NumeroLineasTexto][NumeroBloquesLinea]; 		// Guarda la separación entre barras del código, en %
static int EscalaBarcode[NumeroLineasTexto][NumeroBloquesLinea]; 			// Guarda la escala del código, en %

//static int MostrarTextoBarcode[NumeroLineasTexto]; 		// Controla si hay que mostrar el texto del código
//static float AlturaTextoBarcode[NumeroLineasTexto]; 		// Guarda la altura del texto del código, en mm
//static float SeparacionTextoBarcode[NumeroLineasTexto]; 	// Guarda la separación del texto al código, en mm

// Nombre del archivo plt
static char NombreArchivoPlt[NumeroLineasTexto][NumeroBloquesLinea][50];
static int xMaxPlt, yMaxPlt, xMinPlt, yMinPlt;

// Tamaño del spot - afecta sólo al número de líneas verticales de cada barra, al generar barcodes
static int Spot;			// tamaño del spot en micras
static int SpotBits;			// tamaño del spot en bits

// Nombre del archivo del trabajo seleccionado
//static char NombreTrabajo[50];
static int ValorTrabajo;		// guarda el índice del trabajo actual seleccionado

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tipos de línea

// Almacena los nombres de los tipos de línea: 3 idiomas (ESP, ING, ITA), 9 tipos, LongitudMaximaStringTipoLinea caracteres
//static char strTiposLinea[Idiomas][NumeroTiposLinea][LongitudMaximaStringTipoLinea] = {
//	{"Texto", "Gráfico", "Código 128", "Código 39", "Código EAN", "Código Entrelazado 2-5", "Código Datamatrix", "Código PDF417", "Código ITF-14" },
//	{"Text", "Graph", "Barcode 128", "Barcode 39", "Barcode EAN", "Barcode Interleaved 2-5", "Barcode Datamatrix", "Barcode PDF417", "Barcode ITF-14" },
//	{"Text", "Graph", "Barcode 128", "Barcode 39", "Barcode EAN", "Barcode Interleaved 2-5", "Barcode Datamatrix", "Barcode PDF417", "Barcode ITF-14" },
//};

// Almacena los números de los tipos de línea: 9 tipos; los dos primeros corresponden a texto y gráfico
//static int numTiposLinea[NumeroTiposLinea] = {0, 1, 20, 8, 13, 3, 71, 55, 89};

static char strTiposLinea[Idiomas][NumeroTiposLinea][LongitudMaximaStringTipoLinea] = {
	{"Texto", "Gráfico", "Código 128", "Código 39", "EAN", "Datamatrix", "ITF-14" },
	{"Text", "Graph", "Barcode 128", "Barcode 39", "EAN", "Datamatrix", "ITF-14" },
	{"Text", "Graph", "Barcode 128", "Barcode 39", "EAN", "Datamatrix", "ITF-14" },
};

// Almacena los números de los tipos de línea: 9 tipos; los dos primeros corresponden a texto y gráfico
static int numTiposLinea[NumeroTiposLinea] = {0, 1, 20, 8, 13, 71, 89};

static int ValorTipoLinea[NumeroLineasTexto][NumeroBloquesLinea]; 		// Guarda el tipo de cada línea

// Turnos
static int HoraInicioTurno[NumeroTurnos];
static int MinutoInicioTurno[NumeroTurnos];

static int HoraFinTurno[NumeroTurnos];
static int MinutoFinTurno[NumeroTurnos];

static int MinutoDiaInicioTurno[NumeroTurnos]; // el minuto de todos los minutos del día
static int MinutoDiaFinTurno[NumeroTurnos];

static char TextoTurno[NumeroTurnos][NumeroCaracteresTextoTurnos];

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Otras variables

// Proceso
static char LineaTexto[NumeroMaximoCaracteresLinea];

// Offsets de la pantalla
static int xOffsetPantalla, yOffsetPantalla; // en bits
static int Horizontal, Vertical; // en mm

// Semicampo
static float Semicampo; // Mitad del campo en mm

// Orientación y avance
static int Orientacion, Avance;

// Justificación
static int JustificacionIzquierda, JustificacionDerecha, JustificacionCentro;

// Estado
static int ArchivoFuentesAbierto;	// Controla si ya se ha leido el archivo de fuentes
static int Actualizar;			// Controla si hay que actualizar la matriz
static int PruebaMarcaje;		// Controla si se trata de una prueba de marcaje
static int EnEjecucion;			// Controla si se está en el bucle de ejecución
static int SistemaOk;			// Controla si las variables de estado del laser están OK
static int MarcajeOk;			// Controla si el proceso de marcaje esta ok (campo, tensión máxima galvos...)
static int Apagar;			// Para una salida ordenada del programa
static unsigned long long Contador;	// Almacena el número de marcas realizadas

//static int actualizarfecha, actualizarhora, actualizarserie; // Control de la actualización de campos variables

// Duración de marca
static RTIME tInicioMarca, tFinMarca;

// Disparo interno
static int TipoDisparo;
static int SeparacionEntreDisparos_mm, EsperaSeparacionEntreDisparos;
static long SeparacionEntreDisparos_cuentas;
static float IncrementoAcumulado_Espera;
static lsampl_t ValorCuentasActual_Espera, ValorCuentasAnterior_Espera;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Datos del archivo de fuentes
static unsigned int xMaxFont, yMaxFont;
static char ArchivoFuentes[3000][50]; // 3.000 líneas de hasta 50 caracteres cada una
static int NumeroLineasArchivoFuentes;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Proceso de líneas: intercambio de información entre CalcularMatriz y EncontrarParametros
static unsigned int AnchuraCaracterAnterior;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vectores
static char TipoMarcaje[NumeroMaximoVectores][3];// PU o PD. Número de líneas igual al número máximo de vectores
static int SaltoDentroAtomo[NumeroMaximoVectores];	// vale 1 cuando un salto (PU) está dentro de una letra, para no crear un átomo nuevo
static int xValues[NumeroMaximoVectores];	// Coordenada X. Número de líneas igual al número máximo de vectores
static int yValues[NumeroMaximoVectores];	// Coordenada Y. Número de líneas igual al número máximo de vectores
static int uValues[NumeroMaximoVectores];	// Umbral correspondiente al átomo al que corresponde el vector

static unsigned long NumeroVectores;		// Número de vectores de la marca en curso
static long xValuesOrigenMV, yValuesOrigenMV;	// Guarda las coordenadas de origen de nuevos microvectores
static long xValuesPosicion, yValuesPosicion;	// Guarda las coordenadas de posición durante la ejecución
static long xValuesPosicionMedida, yValuesPosicionMedida;	// Guarda las coordenadas de posición medidas
static long xValuesMax, xValuesMin, yValuesMax, yValuesMin; // Guarda máximos y mínimos de la matriz
static double xBitsDouble, yBitsDouble;		// Para hacer la mmultiplicación en EjecutarMicrovector sólo una vez

// para operaciones sobre la matriz, guardar valores temporalmente
static char TipoMarcaje_tmp[NumeroMaximoVectores][3];// PU o PD. Número de líneas igual al número máximo de vectores
static int xValues_tmp[NumeroMaximoVectores];	// Coordenada X. Número de líneas igual al número máximo de vectores
static int yValues_tmp[NumeroMaximoVectores];	// Coordenada Y. Número de líneas igual al número máximo de vectores

//static int xValuesInicioMarca, yValuesInicioMarca;	// Guarda las coordenadas del inicio de la marca
//static int xValuesFinMarca, yValuesFinMarca;		// Guarda las coordenadas del final de la marca

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Átomos
typedef struct {

	unsigned int Inicio;
	unsigned int Longitud;
	int Xmin;
	int Xmax;
	int Ymin;
	int Ymax;
	int Umbral; // una de las cuatro variables anteriores, dependiendo de la combinación Orientación - Avance

} tipo_atomo;

static tipo_atomo Atomos[NumeroMaximoAtomos];
static unsigned long NumeroAtomos;		// Número de atomos de la marca en curso

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Micro Vectores

// Mark Step Size en bits
static unsigned int MarkStepSize;

// Jump Step Size en bits
static unsigned int JumpStepSize;

// Retardo de laser On en número de periodos RT
unsigned int PeriodosRetardoLaserOn;

// Retardo de laser Off en número de periodos RT
unsigned int PeriodosRetardoLaserOff;

// Retardo de marcaje en número de periodos RT
unsigned int PeriodosRetardoMarcaje;

// Retardo de polígono en número de periodos RT
unsigned int PeriodosRetardoPoligono;

// Retardo de salto en número de periodos RT
unsigned int PeriodosRetardoSalto;

// Lista 0 - Sólo paraMoverGalvos
static int Lista0_Open;					// Para controlar si la lista está abierta
static int Lista0_Exe;					// Para controlar la ejecución de la lista
static unsigned long Lista0_NumeroMicroVectores;	// Número de micro vectores
static int Lista0_EstadoLaser[NumeroMaximoMicroVectores];	// Estado del láser en cada microvector
static int Lista0_xBits[NumeroMaximoMicroVectores];	// 
static int Lista0_yBits[NumeroMaximoMicroVectores];	// 

// Lista 1
static int Lista1_Open;					// Para controlar si la lista está abierta
static int Lista1_Exe;					// Para controlar la ejecución de la lista
static unsigned long Lista1_NumeroMicroVectores;	// Número de micro vectores
static int Lista1_EstadoLaser[NumeroMaximoMicroVectores];	// Estado del láser en cada microvector
static long Lista1_xBits[NumeroMaximoMicroVectores];	// 
static long Lista1_yBits[NumeroMaximoMicroVectores];	// 

static long Lista1_Umbral[NumeroMaximoMicroVectores];

// Lista 2
static int Lista2_Open;					// Para controlar si la lista está abierta
static int Lista2_Exe;					// Para controlar la ejecución de la lista
static unsigned long Lista2_NumeroMicroVectores;	// Número de micro vectores
static int Lista2_EstadoLaser[NumeroMaximoMicroVectores];	// Estado del láser en cada microvector
static int Lista2_xBits[NumeroMaximoMicroVectores];	// 
static int Lista2_yBits[NumeroMaximoMicroVectores];	// 

static long Lista2_Umbral[NumeroMaximoMicroVectores];

// Ejecución de listas
static unsigned long MicroVector;	// Microvector en ejecución
static int EsperaFotocelula;		// Variable de estado para controlar si se está esperando el
					// disparo de la fotocélula
static int CambioFotocelula;		// Variable de estado para controlar si ha cambiado el
					// valor de la fotocélula
static int ResetJumpList;		// Variable de estado para controlar si hay que volver 
					// dinámicamente al origen

static long xOffsetDinamico, yOffsetDinamico;	// Número de bits que hay que desplazar la marca para sacarla del campo
static long uOffsetDinamico;	// Para que con el umbral no haya que saber si es en x o en y, será igual a uno de los anteriores

static long UmbralActual;		// guarda el umbral actual

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constantes para conversiones

// Pasar de Bits a Voltios
static double Kx_Bits_a_Voltios;	// Galvo x
static double Ky_Bits_a_Voltios;	// Galvo y

// Pasar de Cuentas a Bits, en la coordenada X y en la Y
static double Kx_Cuentas_a_Bits, Ky_Cuentas_a_Bits;
static double Ku_Cuentas_a_Bits;	// esta variable se usa para no tener que saber si el cálculo del umbral se hace en X o en Y
					// será igual a una de las variables anteriores

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Watchdog
static int fd_watchdog; 		// file descriptor
static int ErrorWatchdog;		// Controla errores de vectores, listas, etc

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Puerto serie
static int fd_puertoserie; 		// file descriptor
static int ErrorPuertoSerie;		// Controla errores relacionados con el puerto serie
static bool ModoImpresionSerie;		// para controlar si se activa la impresión desde el puerto serie
static int ErrorEjecucionListas;	// Controla errores relacionados con el bucle de ejecución de listas

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// GUI fltk
static int Anchura;
static int Espaciado;
static float SeparacionLineas;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tarjeta Control
static unsigned int FotocelulaDIValue;		// Variable para la lectura de la fotocélula
static unsigned int LaserOkDIValue = LOW; 	// Variable para la lectura de la entrada digital del pedal
static int ErrorLaserOk;			// Controla el error de LaserOK
//static unsigned int TemperaturaDIValue = LOW; 	// Variable para la lectura de la entrada digital del pedal
static int ErrorTemperatura;			// Controla el error de Temperatura
static unsigned int ExtractorDIValue = LOW; 	// Variable para la lectura de la entrada digital del pedal
static int ErrorExtractor;			// Controla el error de Extractor
static int ExtractorActivado;			// Variable de estado para saber si el extractor está activado
static int ErrorVectores;			// Controla errores de vectores, listas, etc
static int ErrorCampo;				// Controla errores de campo insuficiente durante la ejecución
static int ErrorDAQ;				// Variable de estado para propagar el error en la tarjeta DAQ
static int ErrorFPGA;				// Variable de estado para propagar el error en la tarjeta FPGA
static int ErrorEncoder;			// Variable de estado para controlar el error de encoder con marcaje dinámico
static int ErrorValidacion;			// Variable de estado para controlar el error de validación del SW

// Control de errores
static int ErroresConsecutivosCampoX=0;		// Número de errores consecutivos de campo en X
static int ErroresConsecutivosCampoY=0;		// Número de errores consecutivos de campo en Y
static int ErroresConsecutivosGalvos=0;		// Número de errores consecutivos de galvos
static int ErroresConsecutivosLaserOk=0;	// Número de errores consecutivos de galvos
static int ErroresConsecutivosExtractor=0;	// Número de errores consecutivos de galvos
//static int ErroresConsecutivosTemperatura=0;	// Número de errores consecutivos de galvos
static int ContadorDisparosParado = 0;		// Cuenta los disparos mientras el equipo está parado y hay marcaje dinámico

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Control de errores en galvos
//static F64 VanteriorX, VanteriorY;	// Variables para guardar los últimos voltajes escritos a los galvos
//static double VposicionX, VposicionY;	// Variables para leer la posición de los galvos
static int ErrorGalvos;			// Variable de estado para propagar el error en los galvos
//static int PosicionControlada;	// Variable de estado para saber si los galvos están en posición controlada

// Variables para la lectura de las cuentas del encoder
static lsampl_t ValorCuentasActual, ValorCuentasAnterior;
static lsampl_t ValorCuentasActual_Estado, ValorCuentasAnterior_Estado;
static float IncrementoCuentas_Estado;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Control de estado
static volatile int endhandler = ON;
static volatile int endthread = ON;
static int EstadoLaser = OFF;
static int PuertoSerieActivo;
static int ActualizarPuertoSerie;
static char Str_Modoreposo[] = {0x07, 0x08, 0x07, 0x05};
static char Str_Modoimpresion[] = {0x07, 0x08, 0x07, 0x06};


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// variables de RTAI
static RT_TASK *maint;				// Tarea buddy en tiempo real
static int timerthread;				// Thread del timer
static RT_TASK *timer_task_handler;		// Task RTAI del timer
static int ErrorRTAI;				// Variable de estado para propagar el error en RTAI
static RTIME Periodo;				// Periodo en internal counts
static pthread_t id_thread_timer_estado;	// Thread del timer de estado (no RT)
static int ErrorTimerEstado;			// Variable de estado para propagar el error de creación del thread
//static pthread_t id_thread_timer_puerto_serie;	// Thread del timer de escucha del puerto serie (no RT)
//static int ErrorTimerPuertoSerie;		// Variable de estado para propagar el error de creación del thread

/////////////////////////////////////////////////////////////////////////////////////////////////////////
static int PERIODO_MICROSEGUNDOS; 	// Periodo del sistema en microsegundos
static int ServicioTecnico;	 	// Activación de la funcionalidad de Servico Técnico
static bool ConfiguracionModificada;	// Para saber si se ha cambiado algún dato de configuración y hay que escribir el archivo itaca.conf

// Tipo de sistema de control
static int Control;			// 0-DAQ, 1-FPGA

// Control de errores

// Define si se controla o no el error de campo
static int ControlarErrorCampo; 

// Define si se controla o no el error de los galvos
static int ControlarErrorGalvos;

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMEDI variables
comedi_t *comedi_device;		// dispositivo comedi
//comedi_range *RangoAI, *RangoAO;	// rangos de entrada y salida analógica
lsampl_t MaxdataAI, MaxdataAO;		// máximos en los canales de entrada y salida analógica
unsigned laser_up_ticks, laser_down_ticks;
lsampl_t MaxdataContadorEncoder;	// máximo en el contador del encoder
double kFromPhysAO;			// para calcular el valor en las escrituras analógicas en comedi
double kFromPhysFPGA;			// para calcular el valor en las escrituras analógicas en la FPGA
lsampl_t Counter_Mode;			// configuración del contador del tren de pulsos

static unsigned short int Laser_Up_Ticks, Laser_Down_Ticks;	// 16 bits

unsigned Clock_Period_ns;		// clock para el tren de pulsos

//static bool ImprimirMV = false;

// Mensaje parcial del puerto serie
static char StrParcial[NumeroMaximoCaracteresLinea];

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// TABLA Y PRECORTE
/////////////////////////////////////////////////////////////////////////////////////////////////////////
static int ControlTablaPrecorte;
static int NumeroFilas = 1;
static float SeparacionFilas = 0.0;
static int NumeroColumnas = 1;
static float SeparacionColumnas = 0.0;
static int xSeparacionColumnas, ySeparacionFilas;
//static int NumeroVectoresCelda, XMaxCelda, YMaxCelda;
static int Precorte;
static float SeparacionPrecorte = 0.0;
static int SeparacionPrecorteBits, LongitudPrecorte;


