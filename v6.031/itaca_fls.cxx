//==============================================================================
//
// Título:      Itaca
//
// Objetivo:    Coder en Linux aprovechando la infraestructura de tiempo real 
//		desarrollada para Resurfacing, y utilizando driver Comedi
//		
// 
//
//		Las versiones anteriores son para la DAQ NI pci6221 de 68 pines
//		Esta versión v1.3 es para la DAQ NI pci6221 de 37 pines
//		
//		Para versiones posteriors ver readme.txt
//
//		kernel 2.6.23.9 - vanilla compilado con genkernel 
//		(a partir de una instalación de gentoo)	
//
//		rtai 3.6
//		comedi 0.7.76 
//		comedilib 0.9.0
//		fltk/fluid 1.1.7
//		i686-pc-linux-gnu-g++ (GCC) 4.1.1 (Gentoo 4.1.1-r3)
//		Qt: 3.3.8
//		KDE: 3.5.8
//
// Copyright:   
//
//==============================================================================

// /*

// Versiones:	
// 		v1.0 Septiembre 2008
		
// 		v1.1 Febrero 2009

// 		v1.2 Abril 2009
		
// 		v1.3 Mayo 2009
		
// 		- Adaptación a DAQ NI pci6221 37 pines
// 		- Comprobación de posición de galvos 
// 		- Comprobación de que la marca ha cabido en el campo
// 		- Velocidad constante (sin encoder)
// 		- Presentación de velocidad y tiempo marca
// 		- Control de overflow de encoder
		
// 		Para versiones posteriors ver readme.txt

// */

//==============================================================================
// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "itaca_fls.h"

Fl_Double_Window *VentanaPrueba=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaPrueba=(Fl_Button *)0;

static void cb_Aceptar_VentanaPrueba(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaPrueba->hide();

// Activa la ventana principal para desactivar sólo lo necesario
VentanaPrincipal->activate();

// Activa el flag de prueba de marcaje
PruebaMarcaje = true;

// Calcula la matriz
if (CalcularMatriz() != NoError) {

	rt_printk("Error CalcularMatriz\n");

	// Apaga el botón de prueba
	BotonPrueba->value(OFF);
	
	//StopEjecucion();
	return;

}

// Desactiva los grupos de control de intensidad, de marca y de texto
GrupoControlIntensidad->deactivate();
GrupoControlMarca->deactivate();
GrupoControlTexto->deactivate();
GrupoControlTextoBloques->deactivate();

// Desactiva los botones de operaciones
BotonMarcar->deactivate();
BotonPrueba->deactivate();
BotonTrabajos->deactivate();
BotonTablaPrecorte->deactivate();

CounterVelocidadLinea->deactivate();
CounterEncoder->deactivate();
BotonLaser->deactivate();
BotonCampo->deactivate();
BotonApagar->deactivate();

// Activa el botón de stop
BotonStop->activate();

// Actualiza el led del láser
LedLaser->color(FL_YELLOW);
LedLaser->redraw();

//Inicia Oscilador Fibra
switch(TipoLaser){
case 1:
Iniciar_Oscilador_Fibra();
sleep(1);
break;
}

		
// Fuerza la actualización del interfaz
Fl::flush();

// Mueve los galvos al inicio de la lista si es necesario
if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
	MoverGalvos();
}

// Descarga la lista 1
DescargarLista(1);

// Desactiva la espera del disparo de la fotocélula
EsperaFotocelula = false;

// Desactiva la espera del retardo de disparo
EsperaRetardoDisparo = false;

// Desactiva la espera de la separación entre disparos
EsperaSeparacionEntreDisparos = false;

// Desactiva las cuentas de marcaje dinámico 
IncrementoAcumulado = 0;

// Actualiza la señal de MarkInProgress y el Led del láser
ControlMarkInProgress(ON);
				
//rt_printk("inicia Prueba de Marcaje\n");
	
// Ejecuta la lista 1
MarcajeOk = true;
EjecutarLista(1);

// Espera a que termine la ejecución de la lista actual:
while (((Lista1_Exe) || (Lista0_Exe)) && (PruebaMarcaje) && (SistemaOk) && (MarcajeOk)) {
        
	// Espera un periodo
        Fl::wait(PERIODO_WAIT);
        	
}

//rt_printk("termina Prueba de Marcaje\n");

// Presenta en pantalla el valor del tiempo de la marca formateado en ms     
CuadroTextoTMarca->value((double)(tFinMarca - tInicioMarca)/1E6);
//Para el Oscilador Fibra
switch(TipoLaser){
case 1:
Parar_Oscilador_Fibra();
break;
}        
// Restaura el interfaz
StopEjecucion();
}

Fl_Button *Cancelar_VentanaPrueba=(Fl_Button *)0;

static void cb_Cancelar_VentanaPrueba(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaPrueba->hide();

// Apaga el botón de prueba
BotonPrueba->value(OFF);

// Desactiva el botón de stop
BotonStop->deactivate();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();
}

Fl_Double_Window* Make_Window_Confirmar_Prueba() {
  { VentanaPrueba = new Fl_Double_Window(460, 230);
    VentanaPrueba->box(FL_BORDER_FRAME);
    VentanaPrueba->color((Fl_Color)92);
    VentanaPrueba->selection_color((Fl_Color)1);
    VentanaPrueba->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)92);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277Prueba de marcaje?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Prueba de marcaje?");break; case ING:o->label("Test marking?");break; case ITA:o->label("Prova di stampa?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaPrueba = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaPrueba->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaPrueba->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaPrueba->labelfont(8);
        Aceptar_VentanaPrueba->labelsize(20);
        Aceptar_VentanaPrueba->callback((Fl_Callback*)cb_Aceptar_VentanaPrueba);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaPrueba
      { Fl_Button* o = Cancelar_VentanaPrueba = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaPrueba->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaPrueba->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaPrueba->labelfont(8);
        Cancelar_VentanaPrueba->labelsize(20);
        Cancelar_VentanaPrueba->callback((Fl_Callback*)cb_Cancelar_VentanaPrueba);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaPrueba
      o->end();
    } // Fl_Group* o
    VentanaPrueba->set_modal();
    VentanaPrueba->clear_border();
    VentanaPrueba->end();
  } // Fl_Double_Window* VentanaPrueba
  return VentanaPrueba;
}

Fl_Double_Window *VentanaMarcar=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaMarcar=(Fl_Button *)0;

static void cb_Aceptar_VentanaMarcar(Fl_Button*, void*) {
  // Ha sido ordenado desde el interfaz:
ModoImpresionSerie = false;

// Oculta la ventana emergente actual
VentanaMarcar->hide();

//Inicia Oscilador Fibra
switch(TipoLaser){
case 1:
Iniciar_Oscilador_Fibra();
sleep(1);
break;
}
// Variables para el cálculo de fecha y hora si hay que resetear el numero de serie por cambio de fecha
static time_t curtimeserie;
static struct tm *loctimeserie;
static char tmpfechaserie[LongitudMaximaStringFecha];
// Get the current time
	curtimeserie = time (NULL);
     	
	// Convert it to local time representation
	loctimeserie = localtime (&curtimeserie);
				
	strftime (tmpfechaserie, LongitudMaximaStringFecha, "%d", loctimeserie);
	strcpy(FechaInicioMarca,tmpfechaserie);


// Inicia la ejecución
StartEjecucion();
}

Fl_Button *Cancelar_VentanaMarcar=(Fl_Button *)0;

static void cb_Cancelar_VentanaMarcar(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaMarcar->hide();

// Apaga el botón de marcar
BotonMarcar->value(OFF);

// Desactiva el botón de stop
BotonStop->deactivate();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();
}

Fl_Double_Window* Make_Window_Confirmar_Marcar() {
  { VentanaMarcar = new Fl_Double_Window(460, 230);
    VentanaMarcar->box(FL_BORDER_FRAME);
    VentanaMarcar->color((Fl_Color)92);
    VentanaMarcar->selection_color((Fl_Color)1);
    VentanaMarcar->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)92);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277Iniciar el marcaje?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Iniciar el marcaje?");break; case ING:o->label("Start marking?");break; case ITA:o->label("Iniziare la stampa?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaMarcar = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaMarcar->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaMarcar->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaMarcar->labelfont(8);
        Aceptar_VentanaMarcar->labelsize(20);
        Aceptar_VentanaMarcar->callback((Fl_Callback*)cb_Aceptar_VentanaMarcar);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaMarcar
      { Fl_Button* o = Cancelar_VentanaMarcar = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaMarcar->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaMarcar->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaMarcar->labelfont(8);
        Cancelar_VentanaMarcar->labelsize(20);
        Cancelar_VentanaMarcar->callback((Fl_Callback*)cb_Cancelar_VentanaMarcar);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaMarcar
      o->end();
    } // Fl_Group* o
    VentanaMarcar->set_modal();
    VentanaMarcar->clear_border();
    VentanaMarcar->end();
  } // Fl_Double_Window* VentanaMarcar
  return VentanaMarcar;
}

Fl_Double_Window *VentanaApagarSistema=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaApagarSistema=(Fl_Button *)0;

static void cb_Aceptar_VentanaApagarSistema(Fl_Button*, void*) {
  // Guarda los datos definidos en el interfaz; serán los que se cargarán en el próximo arranque de la máquina
Escribir_DAT("itaca.dat");

// sale del programa	
ExitOrdenadamente();
}

Fl_Button *Cancelar_VentanaApagarSistema=(Fl_Button *)0;

static void cb_Cancelar_VentanaApagarSistema(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaApagarSistema->hide();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();
}

Fl_Double_Window* Make_Window_Confirmar_Apagar() {
  { VentanaApagarSistema = new Fl_Double_Window(460, 230);
    VentanaApagarSistema->box(FL_BORDER_FRAME);
    VentanaApagarSistema->color((Fl_Color)1);
    VentanaApagarSistema->selection_color((Fl_Color)1);
    VentanaApagarSistema->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)1);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277""Apagar el sistema?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Apagar el sistema?");break; case ING:o->label("Power off the system?");break; case ITA:o->label("Spegnere il sistema?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaApagarSistema = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaApagarSistema->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaApagarSistema->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaApagarSistema->labelfont(8);
        Aceptar_VentanaApagarSistema->labelsize(20);
        Aceptar_VentanaApagarSistema->callback((Fl_Callback*)cb_Aceptar_VentanaApagarSistema);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaApagarSistema
      { Fl_Button* o = Cancelar_VentanaApagarSistema = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaApagarSistema->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaApagarSistema->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaApagarSistema->labelfont(8);
        Cancelar_VentanaApagarSistema->labelsize(20);
        Cancelar_VentanaApagarSistema->callback((Fl_Callback*)cb_Cancelar_VentanaApagarSistema);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaApagarSistema
      o->end();
    } // Fl_Group* o
    VentanaApagarSistema->set_modal();
    VentanaApagarSistema->clear_border();
    VentanaApagarSistema->end();
  } // Fl_Double_Window* VentanaApagarSistema
  return VentanaApagarSistema;
}

Fl_Double_Window *VentanaModificarTexto=(Fl_Double_Window *)0;

Fl_Box *LogoItacaVentanaModificar=(Fl_Box *)0;

#include <FL/Fl_Image.H>
static unsigned char idata_fls[] =
{255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,252,
251,250,251,248,246,250,246,241,244,239,232,232,226,212,222,213,188,216,206,164,
208,200,142,196,191,114,198,199,102,197,206,94,180,196,80,154,179,58,135,167,44,
124,164,40,116,164,41,108,163,42,100,162,44,96,165,48,99,172,59,107,183,76,113,
192,90,115,199,99,111,198,101,107,194,104,107,191,109,110,189,118,113,186,124,
114,185,129,118,187,137,127,190,149,139,197,163,149,201,174,156,205,183,164,207,
190,174,210,198,181,212,204,190,216,211,202,221,218,212,227,225,225,235,235,233,
242,242,239,245,246,242,247,248,245,249,250,246,249,250,248,250,250,250,251,252,
252,252,253,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,
254,254,250,246,245,246,235,230,237,219,209,219,189,166,208,165,122,200,149,83,
198,144,55,202,152,42,206,163,37,209,176,38,208,187,38,207,196,38,204,206,39,
194,206,40,181,204,41,170,201,44,162,202,50,154,202,56,147,202,62,142,203,68,
134,201,71,126,198,74,120,195,79,115,194,83,110,193,86,104,192,88,97,192,88,90,
191,87,86,191,89,83,191,94,80,191,97,77,192,103,76,193,110,75,194,117,72,191,
122,67,188,126,67,187,133,66,188,140,62,185,145,60,182,150,58,179,153,56,174,
156,58,173,162,65,178,174,71,177,178,76,159,166,91,161,171,119,177,190,132,177,
192,149,181,195,172,194,207,192,207,218,211,220,229,224,231,238,230,234,241,235,
238,243,241,243,247,245,246,248,251,251,251,254,254,254,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,251,
251,251,246,246,246,244,244,244,244,244,244,244,244,244,244,244,244,245,245,245,
251,251,251,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
254,254,254,247,239,238,238,213,208,221,172,156,204,122,87,203,101,43,213,110,
33,213,122,33,212,133,34,211,144,35,210,156,36,210,167,37,209,177,38,208,187,
38,204,193,42,202,203,55,198,207,71,188,204,85,185,204,106,189,209,132,195,213,
157,203,216,181,219,230,206,223,228,217,227,229,226,242,242,242,254,254,254,255,
255,255,255,255,255,255,255,255,255,255,255,253,253,253,245,245,245,232,233,232,
222,226,223,217,229,220,212,234,220,195,220,206,172,204,188,165,207,188,157,210,
189,142,202,182,127,193,176,117,192,176,107,191,178,100,189,180,90,187,183,87,
186,187,82,178,186,72,165,179,67,157,179,61,147,176,60,141,176,59,135,177,59,
126,174,59,114,164,77,122,172,92,125,172,116,140,182,143,159,196,163,173,202,
189,194,217,206,209,227,219,221,235,229,229,239,238,238,243,248,247,249,253,253,
253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,251,251,251,227,227,227,192,192,192,165,165,165,148,148,148,143,143,143,
142,142,142,142,142,142,142,142,142,151,151,151,207,207,207,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,251,247,247,239,210,208,219,147,137,207,90,
65,213,76,33,215,86,31,215,99,32,214,110,33,213,122,33,212,133,34,212,144,36,
210,155,36,206,164,42,207,179,63,210,195,88,210,204,115,214,214,154,226,228,196,
234,236,227,250,250,248,254,254,254,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,250,250,
250,245,248,247,239,244,243,217,226,226,203,222,223,189,218,220,163,198,203,147,
192,202,128,177,193,114,168,191,100,155,186,87,142,181,74,127,175,64,115,172,61,
107,173,61,101,173,61,95,173,62,88,170,65,84,167,74,86,166,95,100,172,120,122,
182,148,146,194,175,172,208,197,193,220,214,210,228,227,224,234,243,242,245,253,
253,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,242,242,242,183,183,183,104,104,104,42,42,42,9,
9,9,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,18,18,18,146,146,146,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,248,241,240,231,181,178,212,93,84,215,55,36,217,61,31,
216,74,30,215,86,31,215,99,32,214,110,33,213,122,33,209,133,37,206,149,57,211,
172,90,215,192,127,223,212,171,234,231,216,249,248,247,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,250,250,250,235,238,240,214,222,228,190,206,218,165,187,207,142,169,199,
122,150,191,103,132,182,82,110,176,66,91,168,62,82,170,62,76,170,62,71,170,64,
66,169,67,63,168,73,64,163,88,75,164,112,96,171,136,121,181,170,155,199,192,
180,211,213,205,224,235,231,238,250,250,251,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,243,243,243,157,157,157,50,50,50,3,3,3,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,18,18,18,146,146,146,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
249,244,243,229,173,169,215,76,67,216,43,31,218,49,30,217,61,31,216,74,30,215,
86,31,215,99,32,213,110,34,210,130,54,214,168,112,224,201,166,235,226,211,248,
247,244,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,254,254,250,250,251,232,234,238,
208,214,225,182,193,216,155,167,203,131,142,193,105,115,180,77,84,168,65,67,166,
67,63,168,74,64,167,80,64,167,86,64,166,91,64,165,98,66,163,107,74,161,131,100,
171,160,133,188,187,166,204,213,202,221,240,238,242,253,253,253,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,251,
251,178,178,178,38,38,38,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
18,18,18,146,146,146,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,237,207,205,213,91,84,
217,40,30,218,41,29,218,49,30,217,61,31,216,74,30,215,86,31,214,99,32,212,121,
56,222,184,150,241,234,226,253,252,252,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
249,249,250,233,234,239,210,212,228,184,186,215,157,157,202,126,123,186,97,88,
170,82,67,164,86,64,166,92,64,165,98,65,165,103,65,164,109,65,163,114,66,162,
123,75,162,144,101,172,170,136,187,199,178,207,233,227,235,253,252,253,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,232,232,232,67,67,67,1,
1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,18,18,146,146,
146,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,232,176,173,210,54,45,218,39,29,218,41,29,
218,50,30,217,61,31,216,74,30,215,86,31,213,101,38,213,151,107,246,241,237,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,254,254,254,244,244,247,226,225,236,205,202,224,175,170,206,140,
128,185,103,81,162,98,65,164,103,65,164,109,65,163,114,65,163,119,65,162,124,66,
161,129,69,159,143,87,164,164,118,177,193,163,198,230,224,231,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,172,172,172,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,9,9,9,34,34,34,43,43,43,44,44,44,44,44,44,59,59,59,165,165,165,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,254,254,254,234,168,165,213,45,36,218,39,29,218,41,29,218,49,30,217,
61,31,216,74,30,215,86,31,214,106,45,220,175,144,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,254,254,254,247,246,248,232,230,239,216,
210,229,176,164,200,133,107,173,111,71,161,114,65,163,119,65,162,123,66,161,129,
67,160,134,67,159,138,68,158,148,81,161,164,105,171,193,161,195,236,230,236,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,102,102,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,44,44,
154,154,154,212,212,212,220,220,220,220,220,220,220,220,220,222,222,222,240,240,
240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,254,254,254,231,174,171,209,51,42,218,39,29,218,41,29,
218,50,30,217,61,31,216,74,30,215,86,31,212,101,38,211,152,110,249,248,247,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,246,245,247,233,229,239,203,192,217,153,126,180,122,75,159,
124,66,161,129,67,160,134,67,159,139,67,159,143,67,158,147,67,156,156,79,160,
169,108,169,203,178,202,245,244,245,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,71,71,71,0,0,0,0,0,0,0,0,0,0,0,0,18,18,
18,150,150,150,246,246,246,254,254,254,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,239,215,214,215,100,93,216,
39,29,218,41,29,218,49,30,217,61,31,216,74,30,215,86,31,215,99,33,211,120,55,
221,187,157,250,249,248,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,252,251,252,244,242,
247,216,206,223,160,128,179,131,75,160,134,67,159,139,67,159,143,68,158,148,67,
157,153,68,157,156,69,154,158,80,153,177,127,171,227,216,225,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,
0,0,0,0,0,64,64,64,202,202,202,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,
254,234,203,201,215,96,89,216,48,37,217,50,31,217,61,31,216,74,30,215,86,31,215,
99,32,214,110,33,208,125,45,207,162,108,230,217,200,248,245,240,252,251,249,
254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,254,255,250,249,251,212,200,218,157,114,173,142,75,
160,143,68,158,148,67,157,153,68,157,156,68,154,155,68,149,154,69,143,161,93,
149,205,179,199,248,245,247,255,255,255,255,255,255,255,255,255,255,255,255,65,
65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,242,228,228,217,146,141,213,86,70,215,76,48,214,
78,37,214,86,32,215,99,32,214,110,33,213,122,33,212,133,34,205,143,44,201,163,
84,212,195,148,234,229,207,246,244,234,250,250,247,254,254,254,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,
250,251,249,248,250,248,254,254,253,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,243,
241,244,191,166,198,155,94,166,148,70,157,153,68,157,156,68,154,155,68,149,155,
68,143,154,68,138,156,82,138,198,164,188,244,239,242,254,254,254,255,255,255,
255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,64,64,64,186,186,186,228,228,228,
228,228,228,228,228,228,228,228,228,228,228,228,232,232,232,253,253,253,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,253,253,253,237,229,
227,221,180,171,213,138,115,213,118,77,212,114,58,210,115,45,210,121,35,212,133,
34,211,144,35,210,156,36,208,166,37,199,170,49,203,190,100,218,215,161,236,236,
206,242,243,225,243,244,234,247,248,243,251,251,250,254,254,254,255,255,255,252,
252,251,229,240,221,196,221,179,185,216,168,214,233,206,246,249,245,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,254,254,254,222,210,224,170,118,177,155,73,158,156,
68,154,155,68,149,155,68,143,154,68,138,153,68,132,155,82,133,200,168,190,245,
241,244,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,27,27,27,77,77,
77,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,118,118,118,243,243,243,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,254,254,254,240,232,228,222,195,180,216,171,137,213,157,101,
212,154,80,209,155,65,206,158,51,206,165,42,206,175,39,207,187,38,203,192,38,
196,197,59,196,203,98,196,207,126,204,216,154,211,223,174,220,232,194,228,237,
212,213,228,196,148,200,102,109,195,49,99,197,45,104,191,69,185,220,174,252,253,
252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,238,232,239,182,134,184,
158,78,156,155,68,149,155,68,143,154,68,138,153,68,132,152,69,127,157,88,133,
208,183,199,250,247,249,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,39,39,236,236,236,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,246,246,
212,212,212,196,196,196,196,196,196,196,196,196,211,211,211,246,246,246,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,254,254,254,246,244,242,230,222,210,224,208,
179,219,198,151,215,194,129,214,196,113,209,195,98,209,202,89,208,209,82,190,
199,69,178,196,63,170,198,62,159,194,61,153,191,74,158,195,101,144,194,85,122,
198,52,109,199,45,100,198,46,90,197,47,111,197,84,234,240,233,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,242,238,242,189,146,188,158,80,
152,155,68,143,154,68,138,153,68,132,152,69,127,151,69,122,161,100,138,225,211,
219,253,253,253,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,39,39,39,236,236,236,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,225,225,225,109,109,109,55,55,
55,55,55,55,55,55,55,106,106,106,224,224,224,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,249,249,
248,245,244,239,234,232,220,233,231,209,233,233,199,218,221,181,211,218,173,211,
221,170,209,224,167,205,225,165,192,217,155,145,201,81,119,199,46,109,199,45,
100,198,46,89,198,46,101,199,72,216,229,213,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,254,254,254,241,234,240,190,147,186,156,75,145,154,
68,138,153,69,133,152,69,127,151,69,122,150,69,120,177,134,160,246,242,245,65,
65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,39,
39,236,236,236,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,65,65,65,215,
215,215,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,251,
250,176,212,138,123,198,55,109,199,45,100,198,46,90,197,47,114,197,89,235,240,
233,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
254,254,254,235,225,233,179,126,171,153,69,138,153,68,132,152,69,127,151,69,122,
151,69,120,150,78,122,220,205,215,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,39,39,236,236,236,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,217,217,217,
69,69,69,0,0,0,0,0,0,0,0,0,65,65,65,215,215,215,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,224,235,212,156,205,112,110,191,
52,96,191,45,111,193,77,188,220,178,253,253,253,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,252,250,251,216,193,
212,160,91,147,153,68,132,152,69,127,151,69,122,151,69,120,150,69,119,183,148,
170,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,33,33,33,96,96,96,117,117,117,117,117,117,
117,117,117,117,117,117,117,117,117,138,138,138,244,244,244,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,252,252,252,239,239,239,206,206,206,192,
192,192,197,197,197,221,221,221,246,246,246,254,254,254,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,217,217,
217,69,69,69,0,0,0,0,0,0,0,0,0,65,65,65,216,216,216,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,252,252,252,235,235,
235,206,206,206,192,192,192,198,198,198,224,224,224,247,247,247,254,254,254,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,251,251,251,243,243,243,239,239,239,241,241,241,248,
248,248,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,252,253,252,231,241,222,200,224,
183,190,220,173,215,235,207,246,249,245,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,251,251,251,244,244,244,240,240,240,
239,239,239,241,241,241,246,246,246,253,253,253,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,240,234,
239,184,141,176,151,68,131,152,69,127,151,69,122,151,69,120,151,69,120,167,115,
148,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,67,67,67,194,194,194,237,237,237,237,237,
237,237,237,237,237,237,237,237,237,237,239,239,239,254,254,254,255,255,255,255,
255,255,255,255,255,238,238,238,173,173,173,98,98,98,55,55,55,37,37,37,33,33,33,
34,34,34,44,44,44,71,71,71,131,131,131,210,210,210,251,251,251,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,217,217,217,69,69,69,0,
0,0,0,0,0,0,0,0,54,54,54,178,178,178,210,210,210,210,210,210,210,210,210,210,
210,210,210,210,210,216,216,216,240,240,240,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,247,247,247,164,164,164,92,92,92,51,51,51,37,37,37,33,
33,33,35,35,35,44,44,44,73,73,73,133,133,133,215,215,215,253,253,253,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,254,254,234,234,234,157,157,157,
91,91,91,56,56,56,48,48,48,51,51,51,72,72,72,123,123,123,205,205,205,252,252,
252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,231,231,231,201,201,201,192,192,191,190,191,189,196,196,196,220,220,220,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,252,252,252,232,232,232,206,206,206,200,
200,200,200,200,200,200,200,200,200,200,200,215,215,215,249,249,249,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,251,251,251,212,212,212,144,144,
144,90,90,90,59,59,59,48,48,48,47,47,47,51,51,51,64,64,64,100,100,100,154,154,
154,221,221,221,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,252,252,252,208,182,202,153,80,134,152,69,127,151,69,122,151,69,
120,151,69,120,147,88,125,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,251,251,251,188,188,188,74,74,74,20,20,20,7,7,7,1,1,1,0,0,0,0,0,
0,0,0,0,0,0,0,3,3,3,12,12,12,37,37,37,129,129,129,229,229,229,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,
0,0,6,6,6,20,20,20,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,58,58,58,180,
180,180,255,255,255,255,255,255,255,255,255,253,253,253,186,186,186,64,64,64,16,
16,16,6,6,6,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,12,12,12,32,32,32,126,126,126,
246,246,246,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,254,254,254,172,172,172,51,51,51,15,15,
15,6,6,6,1,1,1,0,0,0,1,1,1,3,3,3,10,10,10,26,26,26,110,110,110,240,240,240,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,163,163,163,
45,45,45,21,21,21,21,21,21,26,26,26,116,116,116,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,233,233,233,
139,139,139,63,63,63,33,33,33,23,23,23,21,21,21,21,21,21,21,21,21,21,21,21,85,
85,85,230,230,230,255,255,255,255,255,255,255,255,255,253,253,253,217,217,217,
111,111,111,34,34,34,13,13,13,6,6,6,2,2,2,0,0,0,0,0,0,1,1,1,2,2,2,7,7,7,15,15,
15,45,45,45,141,141,141,235,235,235,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,226,212,223,169,111,154,152,69,127,151,69,122,151,
69,120,151,69,120,129,67,105,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,
209,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,241,241,241,148,148,148,29,29,29,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,1,1,5,5,5,74,74,74,208,208,208,252,252,252,255,255,
255,255,255,255,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,38,38,173,173,173,255,255,255,255,255,255,
245,245,245,137,137,137,23,23,23,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,4,4,4,71,71,71,221,221,221,254,254,254,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,250,250,139,139,139,
9,9,9,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,61,61,61,
223,223,223,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,155,155,
155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,254,254,254,244,244,244,152,152,152,33,33,33,4,4,4,1,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,69,69,69,228,228,228,255,255,255,255,
255,255,251,251,251,194,194,194,51,51,51,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,10,10,10,101,101,101,220,220,220,254,254,
254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,238,233,237,182,136,169,151,69,
126,151,69,122,151,69,120,151,69,120,125,62,101,65,65,65,0,0,0,0,0,0,0,0,0,0,0,
0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,240,240,240,144,144,144,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,2,2,5,5,5,4,4,4,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55,55,55,206,206,
206,253,253,253,255,255,255,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,38,38,38,173,173,173,255,255,255,
241,241,241,126,126,126,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,4,4,4,3,3,
3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,59,59,59,216,216,216,254,254,254,255,
255,255,255,255,255,255,255,255,255,255,255,250,250,250,144,144,144,11,11,11,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,65,65,
65,224,224,224,255,255,255,255,255,255,255,255,255,255,255,255,155,155,155,26,
26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,255,255,255,255,255,
255,255,254,254,254,224,224,224,93,93,93,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,69,69,69,228,228,228,255,255,255,252,252,252,196,196,
196,42,42,42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3,3,3,90,90,90,219,219,219,254,254,254,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,248,247,248,195,156,184,151,72,127,151,69,122,151,69,120,151,69,120,
128,64,103,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,249,249,249,174,174,174,28,28,
28,0,0,0,0,0,0,0,0,0,0,0,0,13,13,13,38,38,38,65,65,65,82,82,82,76,76,76,52,52,
52,26,26,26,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,85,85,85,231,231,231,255,255,255,255,
255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,1,1,1,6,6,6,7,7,7,7,7,7,7,7,7,7,
7,7,7,7,7,44,44,44,175,175,175,249,249,249,157,157,157,32,32,32,0,0,0,0,0,0,0,
0,0,1,1,1,15,15,15,41,41,41,66,66,66,81,81,81,74,74,74,52,52,52,25,25,25,5,5,
5,0,0,0,0,0,0,0,0,0,7,7,7,88,88,88,231,231,231,255,255,255,255,255,255,255,
255,255,255,255,255,195,195,195,36,36,36,1,1,1,0,0,0,0,0,0,1,1,1,9,9,9,29,29,29,
40,40,40,37,37,37,19,19,19,3,3,3,0,0,0,0,0,0,0,0,0,12,12,12,115,115,115,247,
247,247,255,255,255,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,
6,6,103,103,103,255,255,255,255,255,255,255,255,255,255,255,255,226,226,226,
97,97,97,11,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,9,9,9,10,10,10,10,10,10,
10,10,10,76,76,76,229,229,229,255,255,255,227,227,227,67,67,67,0,0,0,0,0,0,0,0,
0,0,0,0,2,2,2,17,17,17,38,38,38,54,54,54,61,61,61,58,58,58,39,39,39,15,15,15,
1,1,1,0,0,0,0,0,0,0,0,0,4,4,4,125,125,125,238,238,238,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,253,253,253,196,164,187,147,73,124,151,69,122,151,69,120,151,69,120,148,
91,126,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,
255,255,255,255,255,255,255,255,254,254,254,221,221,221,69,69,69,0,0,0,0,0,0,0,
0,0,2,2,2,36,36,36,113,113,113,200,200,200,250,250,250,255,255,255,253,253,
253,231,231,231,162,162,162,74,74,74,15,15,15,0,0,0,0,0,0,0,0,0,5,5,5,146,146,
146,255,255,255,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,19,19,19,79,
79,79,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,119,119,119,203,203,203,206,
206,206,68,68,68,2,2,2,0,0,0,0,0,0,0,0,0,39,39,39,122,122,122,206,206,206,250,
250,250,255,255,255,254,254,254,229,229,229,158,158,158,70,70,70,11,11,11,0,0,0,
0,0,0,0,0,0,23,23,23,144,144,144,250,250,250,255,255,255,255,255,255,247,247,
247,95,95,95,8,8,8,0,0,0,0,0,0,1,1,1,24,24,24,96,96,96,172,172,172,207,207,207,
196,196,196,137,137,137,53,53,53,6,6,6,0,0,0,0,0,0,0,0,0,43,43,43,198,198,198,
255,255,255,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,
103,103,255,255,255,255,255,255,255,255,255,242,242,242,132,132,132,21,21,21,0,
0,0,0,0,0,0,0,0,1,1,1,12,12,12,49,49,49,82,82,82,102,102,102,107,107,107,107,
107,107,107,107,107,147,147,147,239,239,239,254,254,254,143,143,143,1,1,1,0,0,0,
0,0,0,0,0,0,7,7,7,49,49,49,127,127,127,198,198,198,242,242,242,254,254,254,
249,249,249,202,202,202,119,119,119,38,38,38,2,2,2,0,0,0,0,0,0,0,0,0,24,24,24,
191,191,191,252,252,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,254,254,196,166,188,147,73,124,
151,69,122,151,69,120,151,69,120,177,135,161,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,
72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,250,250,
250,161,161,161,7,7,7,0,0,0,0,0,0,1,1,1,40,40,40,157,157,157,241,241,241,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,253,253,253,211,211,211,
98,98,98,15,15,15,0,0,0,0,0,0,0,0,0,39,39,39,240,240,240,255,255,255,217,217,
217,69,69,69,0,0,0,0,0,0,0,0,0,49,49,49,206,206,206,250,250,250,250,250,250,250,
250,250,250,250,250,250,250,250,251,251,251,246,246,246,138,138,138,17,17,17,0,
0,0,0,0,0,0,0,0,33,33,33,171,171,171,250,250,250,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,254,254,254,210,210,210,89,89,89,7,7,7,0,0,0,0,
0,0,2,2,2,71,71,71,219,219,219,255,255,255,255,255,255,209,209,209,47,47,47,0,
0,0,0,0,0,0,0,0,15,15,15,120,120,120,234,234,234,255,255,255,255,255,255,255,
255,255,252,252,252,186,186,186,48,48,48,2,2,2,0,0,0,0,0,0,17,17,17,129,129,129,
252,252,252,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,
103,103,255,255,255,255,255,255,254,254,254,189,189,189,53,53,53,0,0,0,0,0,0,0,
0,0,0,0,0,26,26,26,112,112,112,197,197,197,243,243,243,253,253,253,254,254,
254,254,254,254,254,254,254,254,254,254,255,255,255,244,244,244,43,43,43,0,0,0,
0,0,0,0,0,0,6,6,6,66,66,66,183,183,183,247,247,247,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,242,242,242,158,158,158,38,38,38,0,0,0,0,0,
0,0,0,0,0,0,0,115,115,115,245,245,245,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,250,251,196,160,
186,150,72,126,151,69,122,151,69,120,150,73,121,211,193,204,65,65,65,0,0,0,0,0,
0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,
255,255,241,241,241,81,81,81,0,0,0,0,0,0,0,0,0,18,18,18,134,134,134,238,238,238,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,254,254,254,205,205,205,70,70,70,3,3,3,0,0,0,0,0,0,0,0,0,182,182,182,255,
255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,50,50,50,210,210,210,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,221,221,221,87,87,
87,0,0,0,0,0,0,0,0,0,7,7,7,144,144,144,254,254,254,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,212,212,212,
50,50,50,0,0,0,0,0,0,0,0,0,33,33,33,164,164,164,255,255,255,255,255,255,164,
164,164,30,30,30,0,0,0,0,0,0,1,1,1,50,50,50,223,223,223,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,253,253,253,136,136,136,9,9,9,0,0,0,0,0,0,4,
4,4,87,87,87,241,241,241,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,
0,0,6,6,6,103,103,103,255,255,255,255,255,255,243,243,243,127,127,127,11,11,
11,0,0,0,0,0,0,0,0,0,10,10,10,139,139,139,241,241,241,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,204,204,
204,4,4,4,0,0,0,0,0,0,0,0,0,44,44,44,174,174,174,250,250,250,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,236,236,236,
123,123,123,10,10,10,0,0,0,0,0,0,0,0,0,51,51,51,239,239,239,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
242,240,242,188,145,177,152,70,127,151,69,122,151,69,120,164,110,144,242,237,
240,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,
255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,67,67,67,204,
204,204,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,249,249,249,137,137,137,21,21,21,0,0,0,0,0,
0,0,0,0,112,112,112,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,50,50,
50,210,210,210,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,188,188,188,48,48,48,0,0,0,0,0,0,0,0,0,55,55,55,229,229,229,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,253,253,253,142,142,142,0,0,0,0,0,0,0,0,0,10,10,10,120,120,120,
250,250,250,255,255,255,136,136,136,19,19,19,0,0,0,0,0,0,5,5,5,87,87,87,253,253,
253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,203,
203,203,18,18,18,0,0,0,0,0,0,0,0,0,69,69,69,226,226,226,255,255,255,255,255,255,
155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,255,214,
214,214,79,79,79,0,0,0,0,0,0,0,0,0,0,0,0,80,80,80,242,242,242,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,150,150,150,0,0,0,0,0,0,0,0,0,7,7,7,104,104,104,237,237,237,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,254,254,254,181,181,181,40,40,40,0,0,0,0,0,0,0,0,0,21,21,21,235,235,235,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,230,219,227,173,119,159,152,69,127,151,69,122,150,73,121,
205,181,196,252,251,251,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,
255,255,255,255,255,255,255,255,255,255,255,255,204,204,204,2,2,2,0,0,0,0,0,0,1,
1,1,111,111,111,241,241,241,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,187,187,
187,46,46,46,0,0,0,0,0,0,0,0,0,70,70,70,254,254,254,217,217,217,69,69,69,0,0,0,
0,0,0,0,0,0,50,50,50,210,210,210,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,254,254,254,168,168,168,25,25,25,0,0,0,0,0,0,0,0,0,120,120,120,
246,246,246,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,221,221,221,2,2,2,0,0,0,0,0,
0,1,1,1,96,96,96,241,241,241,255,255,255,123,123,123,14,14,14,0,0,0,0,0,0,6,6,
6,102,102,102,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,223,223,223,23,23,23,0,0,0,0,0,0,0,0,0,65,65,65,220,220,220,
255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,
255,255,255,255,255,187,187,187,46,46,46,0,0,0,0,0,0,0,0,0,3,3,3,179,179,179,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,114,114,114,0,0,0,0,0,0,0,0,0,24,24,24,
147,147,147,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,201,201,201,63,63,63,0,0,0,
0,0,0,0,0,0,18,18,18,235,235,235,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,253,254,213,190,208,157,87,139,
152,69,127,151,69,122,168,115,148,237,229,234,255,254,255,65,65,65,0,0,0,0,0,0,
0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,
255,186,186,186,0,0,0,0,0,0,0,0,0,4,4,4,130,130,130,253,253,253,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,216,216,216,63,63,63,0,0,0,0,0,0,0,0,0,57,57,57,252,252,
252,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,50,50,50,210,210,210,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,254,254,161,161,161,18,18,18,0,
0,0,0,0,0,1,1,1,158,158,158,250,250,250,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,251,251,251,8,8,8,0,0,0,0,0,0,0,0,0,87,87,87,232,232,232,255,255,255,122,
122,122,14,14,14,0,0,0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,
0,0,0,0,0,0,65,65,65,219,219,219,255,255,255,255,255,255,155,155,155,26,26,26,
0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,255,172,172,172,28,28,28,0,
0,0,0,0,0,0,0,0,19,19,19,229,229,229,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
97,97,97,0,0,0,0,0,0,0,0,0,40,40,40,176,176,176,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,204,204,204,66,66,66,0,0,0,0,0,0,0,0,0,18,18,18,235,235,235,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
242,237,241,189,147,180,153,71,132,152,69,127,153,81,128,210,187,202,251,249,
250,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,
255,255,255,255,255,255,255,255,255,255,190,190,190,0,0,0,0,0,0,0,0,0,3,3,3,129,
129,129,253,253,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,212,212,212,60,60,
60,0,0,0,0,0,0,0,0,0,58,58,58,253,253,253,217,217,217,69,69,69,0,0,0,0,0,0,0,0,
0,49,49,49,210,210,210,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,254,254,254,162,162,162,18,18,18,0,0,0,0,0,0,0,0,0,152,152,152,249,249,
249,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,250,250,250,5,5,5,0,0,0,0,0,0,0,0,0,
89,89,89,234,234,234,255,255,255,122,122,122,14,14,14,0,0,0,0,0,0,6,6,6,104,
104,104,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,219,219,219,255,255,
255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,
255,255,255,169,169,169,24,24,24,0,0,0,0,0,0,0,0,0,28,28,28,237,237,237,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,95,95,95,0,0,0,0,0,0,0,0,0,44,44,44,183,183,183,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,204,204,204,66,66,66,0,0,0,0,0,0,0,0,0,
18,18,18,235,235,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,254,253,254,222,204,219,161,94,148,153,68,132,151,71,127,
188,147,174,241,236,240,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,
0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,208,
208,208,1,1,1,0,0,0,0,0,0,0,0,0,105,105,105,236,236,236,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,180,180,180,42,42,42,0,0,0,0,0,0,0,0,0,75,75,75,255,255,255,217,
217,217,69,69,69,0,0,0,0,0,0,0,0,0,49,49,49,210,210,210,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,170,170,170,26,26,26,0,0,0,0,0,
0,0,0,0,111,111,111,245,245,245,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,210,
210,210,0,0,0,0,0,0,0,0,0,1,1,1,98,98,98,243,243,243,255,255,255,122,122,122,14,
14,14,0,0,0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,
0,0,65,65,65,219,219,219,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,
0,0,6,6,6,103,103,103,255,255,255,255,255,255,173,173,173,29,29,29,0,0,0,0,0,
0,0,0,0,13,13,13,229,229,229,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,111,111,
111,0,0,0,0,0,0,0,0,0,29,29,29,158,158,158,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,204,204,204,66,66,66,0,0,0,0,0,0,0,0,0,18,18,18,235,235,235,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,242,237,242,187,147,
181,153,70,138,153,69,133,172,118,157,229,216,225,254,253,254,255,255,255,255,
255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,
255,255,255,255,255,255,255,255,232,232,232,34,34,34,0,0,0,0,0,0,0,0,0,52,52,52,
191,191,191,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,247,247,247,120,120,120,12,12,12,0,0,0,
0,0,0,0,0,0,131,131,131,255,255,255,217,217,217,69,69,69,0,0,0,0,0,0,0,0,0,49,
49,49,210,210,210,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,196,196,196,57,57,57,0,0,0,0,0,0,0,0,0,31,31,31,224,224,224,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,253,253,253,112,112,112,0,0,0,0,0,0,0,0,0,15,15,15,131,131,
131,253,253,253,255,255,255,122,122,122,14,14,14,0,0,0,0,0,0,6,6,6,104,104,104,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,219,219,219,255,255,255,255,
255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,
255,193,193,193,53,53,53,0,0,0,0,0,0,0,0,0,0,0,0,157,157,157,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,141,141,141,0,0,0,0,0,0,0,0,0,8,8,8,112,112,112,246,246,
246,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,245,245,245,173,173,173,50,50,50,0,0,0,0,0,0,0,0,0,18,18,18,
235,235,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,252,
252,252,218,198,216,155,79,145,154,69,138,163,101,149,219,201,214,254,253,253,
255,255,255,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,
209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,244,244,244,100,100,
100,1,1,1,0,0,0,0,0,0,4,4,4,109,109,109,227,227,227,254,254,254,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,250,250,179,179,179,
48,48,48,0,0,0,0,0,0,0,0,0,4,4,4,204,204,204,255,255,255,217,217,217,69,69,69,
0,0,0,0,0,0,0,0,0,49,49,49,210,210,210,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,230,230,230,99,99,99,2,2,2,0,0,0,0,0,0,0,0,
0,113,113,113,245,245,245,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,251,251,251,190,190,190,22,22,22,0,0,0,0,0,0,0,
0,0,42,42,42,179,179,179,255,255,255,255,255,255,122,122,122,14,14,14,0,0,0,0,
0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,219,
219,219,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,
103,255,255,255,255,255,255,223,223,223,91,91,91,1,1,1,0,0,0,0,0,0,0,0,0,44,44,
44,233,233,233,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,204,204,204,3,3,3,0,0,0,0,0,0,0,0,0,
50,50,50,184,184,184,251,251,251,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,247,247,247,171,171,171,66,66,66,36,36,36,0,0,0,0,0,
0,0,0,0,18,18,18,235,235,235,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,254,254,254,236,225,235,169,110,164,155,69,144,163,96,151,211,188,206,252,
251,252,255,255,255,255,255,255,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,
0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,
255,252,252,252,184,184,184,16,16,16,0,0,0,0,0,0,0,0,0,13,13,13,123,123,123,217,
217,217,248,248,248,254,254,254,255,255,255,255,255,255,253,253,253,239,239,239,
184,184,184,67,67,67,2,2,2,0,0,0,0,0,0,0,0,0,61,61,61,253,253,253,255,255,255,
217,217,217,68,68,68,0,0,0,0,0,0,0,0,0,46,46,46,208,208,208,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,156,156,156,26,
26,26,0,0,0,0,0,0,0,0,0,4,4,4,136,136,136,227,227,227,249,249,249,255,255,255,
255,255,255,255,255,255,253,253,253,238,238,238,187,187,187,47,47,47,2,2,2,0,0,
0,0,0,0,6,6,6,89,89,89,234,234,234,255,255,255,255,255,255,122,122,122,14,14,
14,0,0,0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,
65,65,65,219,219,219,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,
6,6,6,103,103,103,255,255,255,255,255,255,251,251,251,145,145,145,19,19,19,0,
0,0,0,0,0,0,0,0,0,0,0,98,98,98,222,222,222,249,249,249,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,248,248,248,49,
49,49,0,0,0,0,0,0,0,0,0,3,3,3,77,77,77,196,196,196,245,245,245,254,254,254,255,
255,255,255,255,255,254,254,254,242,242,242,175,175,175,45,45,45,30,30,30,36,36,
36,0,0,0,0,0,0,0,0,0,18,18,18,235,235,235,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,244,240,245,187,146,186,154,69,147,164,94,155,207,179,203,251,
251,251,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,65,65,65,0,
0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,233,233,233,96,96,96,5,5,5,0,0,0,0,0,0,0,0,0,8,8,8,
78,78,78,162,162,162,198,198,198,212,212,212,207,207,207,187,187,187,127,127,
127,42,42,42,1,1,1,0,0,0,0,0,0,0,0,0,21,21,21,178,178,178,255,255,255,255,255,
255,217,217,217,68,68,68,0,0,0,0,0,0,0,0,0,26,26,26,168,168,168,223,223,223,226,
226,226,228,228,228,230,230,230,233,233,233,239,239,239,250,250,250,221,221,221,
92,92,92,8,8,8,0,0,0,0,0,0,0,0,0,8,8,8,83,83,83,167,167,167,201,201,201,210,
210,210,206,206,206,185,185,185,124,124,124,34,34,34,2,2,2,0,0,0,0,0,0,1,1,1,40,
40,40,173,173,173,255,255,255,255,255,255,255,255,255,122,122,122,14,14,14,0,0,
0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,
219,219,219,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,
103,103,255,255,255,255,255,255,255,255,255,208,208,208,74,74,74,4,4,4,0,0,0,0,
0,0,0,0,0,5,5,5,72,72,72,167,167,167,204,204,204,217,217,217,219,219,219,219,
219,219,219,219,219,230,230,230,251,251,251,255,255,255,152,152,152,9,9,9,0,0,0,
0,0,0,0,0,0,4,4,4,60,60,60,151,151,151,200,200,200,217,217,217,218,218,218,
198,198,198,144,144,144,39,39,39,0,0,0,30,30,30,36,36,36,0,0,0,0,0,0,0,0,0,18,
18,18,235,235,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,248,250,202,171,
203,153,74,152,165,95,161,206,175,203,250,248,250,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,
72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
252,252,252,199,199,199,59,59,59,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,36,36,36,
64,64,64,53,53,53,25,25,25,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,14,14,14,120,120,120,
244,244,244,255,255,255,255,255,255,223,223,223,85,85,85,0,0,0,0,0,0,0,0,0,0,0,
0,48,48,48,90,90,90,97,97,97,101,101,101,106,106,106,113,113,113,142,142,142,
217,217,217,254,254,254,184,184,184,56,56,56,4,4,4,0,0,0,0,0,0,0,0,0,1,1,1,11,
11,11,41,41,41,60,60,60,51,51,51,22,22,22,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,19,19,
19,128,128,128,244,244,244,255,255,255,255,255,255,255,255,255,122,122,122,14,
14,14,0,0,0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,
0,0,65,65,65,219,219,219,255,255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,
0,0,6,6,6,103,103,103,255,255,255,255,255,255,255,255,255,251,251,251,162,162,
162,38,38,38,2,2,2,0,0,0,0,0,0,0,0,0,1,1,1,12,12,12,48,48,48,76,76,76,81,81,81,
81,81,81,81,81,81,133,133,133,238,238,238,255,255,255,234,234,234,84,84,84,5,5,
5,0,0,0,0,0,0,0,0,0,0,0,0,9,9,9,43,43,43,76,76,76,79,79,79,39,39,39,6,6,6,0,0,
0,0,0,0,30,30,30,36,36,36,0,0,0,0,0,0,0,0,0,18,18,18,235,235,235,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,249,247,250,209,185,212,156,82,159,167,101,167,208,180,207,251,
249,251,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,246,246,177,177,
177,57,57,57,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,17,17,17,104,104,104,226,226,226,254,254,254,255,255,255,255,255,
255,240,240,240,135,135,135,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,44,44,44,184,184,184,255,255,255,248,248,248,165,165,165,51,51,51,4,4,
4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,
16,16,114,114,114,230,230,230,255,255,255,255,255,255,255,255,255,255,255,255,
122,122,122,14,14,14,0,0,0,0,0,0,6,6,6,104,104,104,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,225,225,225,24,24,24,0,
0,0,0,0,0,0,0,0,65,65,65,219,219,219,255,255,255,255,255,255,155,155,155,26,
26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,255,255,255,255,255,255,
255,255,239,239,239,140,140,140,30,30,30,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,77,77,77,230,230,230,255,255,255,253,253,253,206,206,
206,75,75,75,6,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,30,30,30,36,36,36,0,0,0,0,0,0,0,0,0,18,18,18,235,235,235,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,248,246,249,206,181,211,155,89,163,171,113,175,214,193,215,250,250,250,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,0,72,72,72,209,209,209,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,244,244,
244,182,182,182,80,80,80,15,15,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,2,2,2,36,36,36,123,123,123,221,221,221,253,253,253,255,255,255,255,
255,255,255,255,255,253,253,253,201,201,201,66,66,66,3,3,3,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,44,44,184,184,184,255,255,255,255,255,255,246,
246,246,176,176,176,75,75,75,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,1,1,31,31,31,133,133,133,230,230,230,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,122,122,122,14,14,14,0,0,0,0,0,0,6,6,6,104,104,
104,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,219,219,219,255,255,255,
255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,236,236,236,147,147,147,48,48,48,3,
3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,77,77,77,230,230,230,255,
255,255,255,255,255,250,250,250,202,202,202,94,94,94,18,18,18,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,8,49,49,49,43,43,43,0,0,0,0,0,0,0,0,0,
18,18,18,235,235,235,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,239,235,241,197,169,204,156,99,166,176,131,182,226,
212,227,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,65,65,65,0,0,0,0,0,0,0,0,0,0,0,
0,72,72,72,209,209,209,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,249,249,249,210,210,210,139,139,139,
63,63,63,12,12,12,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,30,30,30,94,94,94,169,
169,169,233,233,233,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,245,245,245,180,180,180,68,68,68,8,8,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,44,44,44,184,184,184,255,255,255,255,255,255,255,255,255,251,
251,251,207,207,207,135,135,135,55,55,55,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
2,2,30,30,30,98,98,98,172,172,172,242,242,242,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,122,122,122,14,14,14,0,0,0,0,0,0,6,6,6,
104,104,104,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,225,225,225,24,24,24,0,0,0,0,0,0,0,0,0,65,65,65,219,219,219,255,
255,255,255,255,255,155,155,155,26,26,26,0,0,0,0,0,0,6,6,6,103,103,103,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,243,243,243,186,
186,186,107,107,107,30,30,30,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,77,77,77,
230,230,230,255,255,255,255,255,255,255,255,255,252,252,252,219,219,219,141,141,
141,60,60,60,11,11,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,39,39,39,119,119,119,
147,147,147,61,61,61,2,2,2,2,2,2,2,2,2,20,20,20,235,235,235,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,254,253,254,227,219,231,179,146,191,157,
111,170,194,163,200,233,226,234,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,127,127,127,83,83,83,83,83,83,83,83,83,83,83,83,132,132,132,224,224,224,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,254,254,254,241,241,241,208,208,208,168,168,168,125,125,
125,94,94,94,84,84,84,87,87,87,105,105,105,145,145,145,185,185,185,223,223,223,
249,249,249,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,246,246,246,206,206,206,144,144,144,98,98,98,84,84,
84,83,83,83,83,83,83,83,83,83,83,83,83,83,83,83,113,113,113,207,207,207,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,241,241,241,203,203,203,
164,164,164,122,122,122,92,92,92,84,84,84,88,88,88,108,108,108,145,145,145,186,
186,186,226,226,226,252,252,252,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,154,154,154,72,72,72,61,61,61,61,61,61,66,
66,66,140,140,140,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,235,235,235,99,99,99,83,83,83,83,83,83,83,83,83,127,127,
127,231,231,231,255,255,255,255,255,255,187,187,187,101,101,101,83,83,83,83,83,
83,87,87,87,153,153,153,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,253,253,253,229,229,229,188,188,188,144,144,144,
105,105,105,87,87,87,83,83,83,83,83,83,83,83,83,83,83,83,135,135,135,238,238,
238,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,241,241,241,206,
206,206,164,164,164,118,118,118,91,91,91,83,83,83,85,85,85,102,102,102,149,149,
149,194,194,194,234,234,234,234,234,234,182,182,182,157,157,157,157,157,157,157,
157,157,163,163,163,247,247,247,255,255,255,255,255,255,255,255,255,255,255,255,
245,244,246,204,188,213,160,125,177,170,137,183,214,198,219,245,242,246,255,254,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,232,232,232,224,224,224,
224,224,224,224,224,224,224,224,224,233,233,233,249,249,249,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,250,250,250,238,238,238,228,228,228,
225,225,225,226,226,226,232,232,232,244,244,244,253,253,253,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,254,254,254,243,243,243,229,229,229,224,224,224,
224,224,224,224,224,224,224,224,224,224,224,224,224,224,224,229,229,229,246,246,
246,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,250,250,250,237,237,237,227,227,227,225,225,225,226,226,226,232,232,232,
244,244,244,253,253,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,235,235,235,219,219,219,217,
217,217,217,217,217,218,218,218,232,232,232,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,251,251,251,227,227,227,224,224,
224,224,224,224,224,224,224,232,232,232,251,251,251,255,255,255,255,255,255,243,
243,243,227,227,227,224,224,224,224,224,224,225,225,225,237,237,237,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,254,254,254,244,244,244,231,231,231,225,225,225,224,224,224,224,
224,224,224,224,224,224,224,224,234,234,234,252,252,252,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,249,249,249,236,236,
236,227,227,227,224,224,224,225,225,225,230,230,230,245,245,245,254,254,254,255,
255,255,254,254,254,250,250,250,248,248,248,248,248,248,248,248,248,249,249,249,
254,254,254,255,255,255,255,255,255,252,251,252,221,214,227,166,141,186,157,126,
177,198,180,207,235,228,237,252,251,252,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,
254,230,227,235,171,153,192,145,118,171,186,170,200,230,224,234,249,248,250,254,
254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,254,254,254,252,252,253,226,224,232,158,144,183,135,116,167,189,
178,204,237,233,239,251,250,252,254,254,254,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,252,252,252,247,247,249,240,239,243,199,
196,213,146,138,176,149,139,179,209,204,219,250,250,250,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,237,237,237,234,234,234,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,251,252,243,
243,244,236,237,239,216,216,224,181,180,200,162,159,186,189,187,205,238,238,241,
254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,148,148,148,130,130,130,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,254,254,254,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,251,251,251,224,224,224,217,217,217,254,254,
254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,247,247,247,240,240,241,227,228,230,203,204,209,193,193,202,
205,206,216,236,236,239,253,253,253,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,126,126,126,106,106,106,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,254,254,254,216,216,216,176,176,176,
177,177,177,213,213,213,251,251,251,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,240,240,240,209,209,209,207,207,207,219,
219,219,248,248,248,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,242,242,242,202,202,202,195,195,195,226,226,226,252,252,
252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,
254,254,241,241,241,223,223,223,224,224,224,248,248,248,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,239,239,239,209,209,209,207,207,207,219,219,219,248,248,248,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,249,249,249,214,214,
214,248,248,248,242,242,242,224,224,224,244,244,244,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,251,251,251,225,225,225,207,207,207,
208,208,208,231,231,231,254,254,254,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,240,240,240,131,131,131,85,85,85,205,205,205,235,235,235,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,
241,241,241,204,204,204,194,194,194,225,225,225,252,252,252,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,248,248,248,220,
220,220,206,206,206,217,217,217,206,206,206,214,214,214,248,248,248,255,255,255,
235,235,235,220,220,221,225,225,226,251,251,252,255,255,255,255,255,255,245,245,
245,218,218,218,207,207,207,207,207,207,244,244,244,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,126,
126,126,106,106,106,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,218,218,218,91,91,91,74,74,74,79,79,79,93,93,93,205,205,
205,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,150,150,150,99,99,99,113,113,113,148,148,148,234,234,234,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,246,246,156,156,
156,111,111,111,102,102,102,121,121,121,212,212,212,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,247,247,247,182,182,182,110,110,110,
166,166,166,239,239,239,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,144,144,144,100,100,100,
113,113,113,149,149,149,234,234,234,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,230,230,230,96,96,96,229,229,229,206,206,206,133,
133,133,212,212,212,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
254,254,254,224,224,224,112,112,112,109,109,109,116,116,116,183,183,183,251,251,
251,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,239,239,239,121,
121,121,38,38,38,115,115,115,197,197,197,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,242,242,242,162,162,162,111,111,111,100,100,
100,120,120,120,211,211,211,254,254,254,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,252,252,252,201,201,201,115,115,115,102,102,102,97,97,97,
104,104,104,104,104,104,195,195,195,252,252,252,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,183,183,183,111,111,111,110,110,110,114,
114,114,223,223,223,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,126,126,126,106,106,106,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,139,139,
139,55,55,55,193,193,193,183,183,183,69,69,69,130,130,130,254,254,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,81,81,81,61,61,
61,129,129,129,185,185,185,244,244,244,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,215,215,215,63,63,63,136,136,136,93,93,93,89,89,
89,196,196,196,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,242,242,242,141,141,141,79,79,79,210,210,210,249,249,249,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,72,72,72,64,64,64,131,131,131,187,187,187,244,244,244,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,221,221,221,
40,40,40,220,220,220,189,189,189,91,91,91,197,197,197,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,254,254,254,204,204,204,42,42,42,96,96,96,
148,148,148,212,212,212,253,253,253,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,239,239,239,122,122,122,64,64,64,183,183,183,227,227,227,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,213,213,213,
77,77,77,129,129,129,93,93,93,88,88,88,196,196,196,253,253,253,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,243,243,243,149,149,149,101,101,101,
148,148,148,71,71,71,145,145,145,110,110,110,126,126,126,245,245,245,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,136,136,136,57,
57,57,108,108,108,159,159,159,237,237,237,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,126,126,126,
106,106,106,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,113,113,113,77,77,77,253,253,253,227,227,227,81,81,81,110,110,
110,253,253,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,180,180,180,105,105,105,97,97,97,133,133,133,227,227,227,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,197,197,197,38,38,
38,112,112,112,135,135,135,144,144,144,173,173,173,248,248,248,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,243,243,243,149,149,149,122,122,122,
254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,177,177,177,106,106,106,
97,97,97,133,133,133,227,227,227,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,222,222,222,40,40,40,218,218,218,187,187,187,88,88,
88,197,197,197,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,234,234,234,141,141,141,100,100,100,102,102,102,175,175,175,247,247,247,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,239,239,239,122,122,
122,91,91,91,250,250,250,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,253,253,253,201,201,201,45,45,45,110,110,110,136,136,136,
140,140,140,179,179,179,246,246,246,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,238,238,238,142,142,142,137,137,137,206,206,206,108,108,108,194,
194,194,157,157,157,112,112,112,243,243,243,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,205,205,205,127,127,127,97,97,97,100,100,
100,213,213,213,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,126,126,126,106,106,106,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,176,176,176,
42,42,42,122,122,122,108,108,108,35,35,35,109,109,109,253,253,253,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,202,202,202,151,151,
151,105,105,105,64,64,64,179,179,179,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,227,227,227,67,67,67,87,87,87,145,145,145,105,
105,105,163,163,163,251,251,251,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,243,243,243,150,150,150,125,125,125,254,254,254,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,201,201,201,151,151,151,104,104,104,63,63,63,179,179,
179,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,230,
230,230,53,53,53,116,116,116,109,109,109,87,87,87,216,216,216,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,241,241,241,176,176,176,
137,137,137,75,75,75,102,102,102,227,227,227,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,241,241,241,130,130,130,53,53,53,155,155,155,215,
215,215,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
222,222,222,78,78,78,85,85,85,145,145,145,102,102,102,165,165,165,248,248,248,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,238,238,238,143,143,
143,138,138,138,206,206,206,109,109,109,195,195,195,158,158,158,113,113,113,243,
243,243,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
221,221,221,167,167,167,131,131,131,41,41,41,145,145,145,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,157,157,157,141,141,141,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,243,243,243,161,161,161,95,95,95,103,103,103,
120,120,120,166,166,166,254,254,254,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,144,144,144,100,100,100,96,96,96,121,121,121,219,
219,219,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
251,251,251,195,195,195,124,124,124,115,115,115,164,164,164,232,232,232,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,246,246,246,176,
176,176,156,156,156,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,142,
142,142,100,100,100,96,96,96,121,121,121,219,219,219,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,248,248,248,168,168,168,63,63,
63,72,72,72,182,182,182,248,248,248,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,254,254,254,225,225,225,111,111,111,99,99,99,97,97,97,161,
161,161,243,243,243,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
251,251,251,198,198,198,95,95,95,103,103,103,192,192,192,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,249,249,249,198,198,198,126,
126,126,115,115,115,162,162,162,231,231,231,254,254,254,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,243,243,243,171,171,171,166,166,166,219,219,
219,146,146,146,210,210,210,184,184,184,149,149,149,246,246,246,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,182,182,182,110,110,110,
99,99,99,90,90,90,200,200,200,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,241,241,241,238,238,238,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,247,247,247,231,231,231,233,233,233,238,238,238,244,244,244,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
235,235,235,227,227,227,227,227,227,236,236,236,252,252,252,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,251,251,236,
236,236,232,232,232,245,245,245,254,254,254,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,254,254,254,243,243,243,240,240,240,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,234,234,234,227,227,227,227,227,
227,236,236,236,252,252,252,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,234,234,234,123,123,123,110,110,110,247,247,247,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,249,249,249,229,229,229,227,227,227,230,230,230,243,243,243,254,254,254,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,249,249,249,
232,232,232,230,230,230,245,245,245,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,251,251,251,236,236,236,232,232,232,244,
244,244,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,253,253,253,243,243,243,242,242,242,250,250,250,239,239,239,248,248,
248,245,245,245,240,240,240,254,254,254,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,242,242,242,228,228,228,227,227,227,230,230,230,
250,250,250,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,243,243,243,165,165,165,152,152,152,254,254,254,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255};
static Fl_RGB_Image image_fls(idata_fls, 165, 56, 3, 0);

Fl_Group *GrupoFecha=(Fl_Group *)0;

Fl_Button *BotonFecha=(Fl_Button *)0;

static void cb_BotonFecha(Fl_Button*, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Actualiza los campos variables para reflejar el valor actual
//ActualizarFechaHora();
//ActualizarFechaHoraSerie();

// Compone el formato de la fecha
// inicializa la variable del formato
strcpy(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], "");

// primer campo
if (ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// segundo campo
if (ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], SeparadorFecha[ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]]);
	}

	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// tercer campo
if (ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], SeparadorFecha[ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]]);
	}
	
	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// Presenta un mensaje de error y sale si no hay campos definidos:
if (strlen(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]) == 0) {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un valor");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a value");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezionare valore");
		break;
			
	}

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	//VentanaPrincipal->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	return;
	
}

// Procesa el texto
switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
case 0: //no tiene la hora
        
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: // no tiene numero de serie
 
        	// el primer campo variable es la fecha
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            	// guarda el texto anterior a la fecha
            	strcpy(textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
		// Actualiza el cuadro de texto
		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
            		
        case 1: //tiene ya el numero de serie
            		
            	// la fecha es el segundo campo variable
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 2;
            		
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
	        break;
	           	
        }
	
	break;
		
case 1: //tiene ya la hora y va en primer lugar
    
	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        case 0: // no tiene numero de serie
        	
        	// la fecha es el segundo campo variable
        	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 2;

		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
        	
        case 2:  // también tiene el número de serie
        
        	// la fecha es el tercer campo variable
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
		CuadroTextoLinea->value(str);
			
        	break;
        		
        }
        	
        break;
        	
case 2: //tiene ya la hora y va en segundo lugar
    	
        switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       	case 1:
       		
       		// la fecha es el tercer campo variable
		OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
	        // Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
	            	
        	break;
        		
        }
        	
	break;
	
}
	
	
// Activa el flag de la fecha
StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
// Ahora desactiva los widgets relacionados con la fecha
BotonFecha->deactivate();
ChoiceFormatoFecha1->deactivate();
ChoiceFormatoFecha2->deactivate();
ChoiceFormatoFecha3->deactivate();
ChoiceSeparadorFecha->deactivate();
IndicadorCaducidad->deactivate();
}

Fl_Choice *ChoiceFormatoFecha1=(Fl_Choice *)0;

static void cb_ChoiceFormatoFecha1(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceFormatoFecha2=(Fl_Choice *)0;

static void cb_ChoiceFormatoFecha2(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceFormatoFecha3=(Fl_Choice *)0;

static void cb_ChoiceFormatoFecha3(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceSeparadorFecha=(Fl_Choice *)0;

static void cb_ChoiceSeparadorFecha(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado
ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Counter *IndicadorCaducidad=(Fl_Counter *)0;

static void cb_IndicadorCaducidad(Fl_Counter* o, void*) {
  // Cambia la caducidad
Caducidad[LineaCalcular - 1][BloqueCalcular - 1] = (int) o->value();	// en meses;
}

Fl_Group *GrupoHora=(Fl_Group *)0;

Fl_Button *BotonHora=(Fl_Button *)0;

static void cb_BotonHora(Fl_Button*, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Actualiza los campos variables para reflejar el valor actual
//ActualizarFechaHora();
//ActualizarFechaHoraSerie();

// Compone el formato de la hora
// inicializa la variable del formato
strcpy(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], "");

// primer campo
if (ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	strcpy(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// segundo campo
if (ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], SeparadorHora[ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]]);
	}

	strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// tercer campo
if (ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	
	// separador
	if (ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], SeparadorHora[ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]]);
	}
	
	strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// Presenta un mensaje de error y sale si no hay campos de finidos:
if (strlen(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]) == 0) {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un valor");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a value");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezionare valore");
		break;
			
	}

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	//VentanaPrincipal->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	return;
	
}

// Procesa el texto
switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
case 0: //no tiene la fecha
        
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: // no tiene número de serie

       		// el primer campo variable es la hora
          	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            	// guarda el texto anterior a la hora
            	strcpy(textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
		// Actualiza el cuadro de texto
		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            	
            	break;
            		
        case 1: //ya tiene número de serie
            		
           	// la hora es el segundo campo variable
            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 2; 
            		
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
	        break;
	            	
        }
	
	break;
    	
case 1: //tiene ya la fecha y va en primer lugar

     	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        case 0: // no tiene número de serie

		// la hora es el segundo campo variable
        	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 2;

		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
        	
        case 2: // ya tiene número de serie
            	
            	// la hora es el tercer campo variable
            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
		CuadroTextoLinea->value(str);
			
        	break;
        		
        }
        	
        break;
        	
case 2: //tiene ya la fecha y va en segundo lugar
        	
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
     	case 1:
	
		// la hora es el tercer campo variable
		OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
	            	
        	break;
        		
        }
        	
	break;
	
}
	
// Activa el flag de la hora
StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
// Ahora desactiva los widgets relacionados con el número de serie
BotonHora->deactivate();
ChoiceFormatoHora1->deactivate();
ChoiceFormatoHora2->deactivate();
ChoiceFormatoHora3->deactivate();
ChoiceSeparadorHora->deactivate();
}

Fl_Choice *ChoiceFormatoHora1=(Fl_Choice *)0;

static void cb_ChoiceFormatoHora1(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceFormatoHora2=(Fl_Choice *)0;

static void cb_ChoiceFormatoHora2(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceFormatoHora3=(Fl_Choice *)0;

static void cb_ChoiceFormatoHora3(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Choice *ChoiceSeparadorHora=(Fl_Choice *)0;

static void cb_ChoiceSeparadorHora(Fl_Choice* o, void*) {
  // Almacena el valor seleccionado
ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] = o->value();
}

Fl_Group *GrupoSerie=(Fl_Group *)0;

Fl_Button *BotonSerie=(Fl_Button *)0;

static void cb_BotonSerie(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// variables de estado para comprobar los campos
bool inicioOK, finalOK, unidadesloteOK, actualOK;

// control de estado de las variables

// número de inicio: basta con que exista
if (strlen(CuadroTextoSerie->value())) {
	inicioOK = true;
}

else {	
	inicioOK = false;
}

// número final, en caso de existir
if ( strlen(CuadroTextoSerieFinal->value()) ) {
	
	// si existe debe ser mayor que 0 y mayor que el de inicio
	if ( atoi(CuadroTextoSerieFinal->value()) > atoi(CuadroTextoSerie->value()) ){
		finalOK = true;
	}
	
	else {
		finalOK = false;
	}
}

// si no existe es correcto
else {	
	finalOK = true;
} 


// unidades por lote: tiene que ser mayor que 0 en caso de estar definido
if ( strlen(CuadroTextoUnidadesLote->value()) ) {
	
	// si existe debe ser mayor que el de inicio
	if ( atoi(CuadroTextoUnidadesLote->value()) > 0 ) {
		unidadesloteOK = true;
	}
	
	else {
		unidadesloteOK = false;
	}
}

// si no existe no es correcto
else {	
	unidadesloteOK = false;
}

// unidad actual, en caso de existir
if ( strlen(CuadroTextoUnidadesLoteActual->value()) ) {
	
	// si existe debe ser mayor o igual que 0 y menor o igual al número de unidades por lote
	if ( (atoi(CuadroTextoUnidadesLoteActual->value())>=0) && (atoi(CuadroTextoUnidadesLoteActual->value()) <= atoi(CuadroTextoUnidadesLote->value())) ){
		actualOK = true;
	}
	
	else {
		actualOK = false;
	}
}

// si no existe no es correcto
else {	
	actualOK = false;
} 


// si todo es correcto se sigue adelante
if ((inicioOK) && (finalOK) && (unidadesloteOK) && (actualOK)) {

	// Número de serie:
	NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoSerie->value());
	NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1] = NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1];
	NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoSerieFinal->value());
	
	// Guarda el número de dígitos para formatear
	NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = strlen(CuadroTextoSerie->value());
	
	// Escribe el valor formateado en un string
	sprintf(strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
	
	// Mira a ver si hay lote
	if (strlen(CuadroTextoUnidadesLote->value())) { // con lote
		
		NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoUnidadesLote->value());
		NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoUnidadesLoteActual->value());
	}	
		
	else { // sin lote
		
		NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1] = 1;
		CuadroTextoUnidadesLote->value("1");
		NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = 1;
		CuadroTextoUnidadesLoteActual->value("1");
	}
	
	//printf("NumeroSerie:%ld %s NumeroUnidadesLote:%d\n", NumeroSerie, strNumeroSerie, NumeroUnidadesLote);
	
	// Procesa el texto
	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
	
	case 0: //no tiene la hora
        
        	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: // no tiene la fecha

        		// el primer campo variable es el número de serie
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            		// guarda el texto anterior al número de serie
            		strcpy(textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
			// Actualiza el cuadro de texto
			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
            		//printf("textoanteriorserie:%s strNumeroSerie:%s\n", textoanteriorserie,strNumeroSerie);   
            		
            		break;
            		
        	case 1: //tiene ya la fecha
            		
            		// el número de serie es el segundo campo variable
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 2;
            		
            		// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
	            	break;
	            	
        	}
	
		break;
	
		
	case 1: //tiene ya la hora y va en primer lugar

       	 	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: // no tiene la fecha
        	
        		// el número de serie es el segundo campo variable
        		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 2;

			// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
            		break;
        	
        	case 2:  // también tiene la fecha
        	
        		// el número de serie es el tercer campo variable
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            		// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
			
        		break;
        		
        	}
        	
        	break;
        
        	
        case 2: //tiene ya la hora y va en segundo lugar
        	
        	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 1:
       		
       			// el número de serie es el tercer campo variable
	            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
	            	// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
	            	
        		break;
        		
        	}
        	
		break;
	
	}
	
	// Activa el flag del número de serie
	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
	// Ahora desactiva los widgets relacionados con el número de serie
	BotonSerie->deactivate();
	CuadroTextoSerie->deactivate();
	CuadroTextoSerieFinal->deactivate();
	FrameLote->deactivate();
	CuadroTextoUnidadesLote->deactivate();
	CuadroTextoUnidadesLoteActual->deactivate();
	
	// El de actual se desactiva sólo si no hay lote; si hay lote se deja, para que pueda modificarse
	//if (NumeroUnidadesLote[LineaCalcular - 1] == 1) {
	//	CuadroTextoUnidadesLoteActual->deactivate();
	//}
	
	// Activa el botón de reiniciar
	BotonReiniciarSerie->activate();
	
	// Y pasa el cursor al cuadro de texto
	indice = 0;
	
}

// Agún campo es incorrecto: saca los mensajes apropiados
else {

	if (inicioOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca el número de inicio de la serie");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter the series start number");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre il numero di inizio della serie");
			break;
			
		}

	}
	
	if (finalOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número final superior al número de inicio de la serie");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter an end number higher than the start number");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero finale superiore al numero di inizio della serie");
			break;
			
		}	

	}
	
	if (unidadesloteOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número de unidades por lote mayor que 0");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter a number of units per batch higher than 0");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero per il lotto maggiore di 0");
			break;
			
		}

	}
	
	if (actualOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número actual mayor que cero e inferior o igual al número de unidades por lote");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter a current number bigger than 0 and equal or less than the number of units per batch");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero attuale maggiore di 0 e inferiore o pari al numero di unità del lotto");
			break;
			
		}

	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaModificarTexto->deactivate();
	
	// Presenta la ventana con el mensaje emergente correspondiente al último error
	VentanaMensaje->show();

};
}

Fl_Output *CuadroTextoSerie=(Fl_Output *)0;

static void cb_CuadroTextoSerie(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 1;
}

Fl_Output *CuadroTextoSerieFinal=(Fl_Output *)0;

static void cb_CuadroTextoSerieFinal(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 3;
}

Fl_Group *FrameLote=(Fl_Group *)0;

Fl_Output *CuadroTextoUnidadesLote=(Fl_Output *)0;

static void cb_CuadroTextoUnidadesLote(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 2;
}

Fl_Output *CuadroTextoUnidadesLoteActual=(Fl_Output *)0;

static void cb_CuadroTextoUnidadesLoteActual(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 4;
}

Fl_Button *BotonReiniciarSerie=(Fl_Button *)0;

static void cb_BotonReiniciarSerie(Fl_Button*, void*) {
  char record[12];

// Carga el número de serie inicial
NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1];

// Carga el número inicial de unidades del lote
NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = 1;
sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLoteActual->value(record);

// Actualiza los campos
//actualizarserie = true;
ActualizarFechaHoraSerie();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
CargarTexto();
}

Fl_Check_Button *CheckResetSerieFecha=(Fl_Check_Button *)0;

static void cb_CheckResetSerieFecha(Fl_Check_Button* o, void*) {
  ResetSerieFecha = (int) o->value();
rt_printk("ResetSerieFecha: %ld\n", ResetSerieFecha);

/*if (o->value(ON)){
	ResetSerieFecha = (int) o->value();
	rt_printk("ResetSerieFecha: %ld\n", ResetSerieFecha);
	}
	else {
	ResetSerieFecha = (int) o->value();
	rt_printk("ResetSerieFecha: %ld\n", ResetSerieFecha);
	}
	*/;
}

Fl_Output *CuadroTextoLinea=(Fl_Output *)0;

static void cb_CuadroTextoLinea(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;
}

Fl_Group *GrupoTeclado=(Fl_Group *)0;

Fl_Button *Boton1=(Fl_Button *)0;

static void cb_Boton1(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton2=(Fl_Button *)0;

static void cb_Boton2(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton3=(Fl_Button *)0;

static void cb_Boton3(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton4=(Fl_Button *)0;

static void cb_Boton4(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton5=(Fl_Button *)0;

static void cb_Boton5(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton6=(Fl_Button *)0;

static void cb_Boton6(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton7=(Fl_Button *)0;

static void cb_Boton7(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton8=(Fl_Button *)0;

static void cb_Boton8(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton9=(Fl_Button *)0;

static void cb_Boton9(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

};
}

Fl_Button *Boton0=(Fl_Button *)0;

static void cb_Boton0(Fl_Button* o, void*) {
  switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "0");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// sólo permite añadir un 0 si no es el primer carácter
	if ( strlen(CuadroTextoUnidadesLote->value()) ) {
	
		// duplica el texto actual en una nueva variable
		strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

		// concatena el nuevo carácter
		strcat(LineaTexto, "0");

		// asigna el nuevo texto al cuadro de texto
		CuadroTextoUnidadesLote->value(LineaTexto);
	
	}
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "0");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// sólo permite añadir un 0 si no es el primer carácter
	if ( strlen(CuadroTextoUnidadesLoteActual->value()) ) {
	
		// duplica el texto actual en una nueva variable
		strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

		// concatena el nuevo caracter
		strcat(LineaTexto, "0");

		// asigna el nuevo texto al cuadro de texto
		CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	}
	
	break;

};
}

Fl_Button *BotonBorrar=(Fl_Button *)0;

static void cb_BotonBorrar(Fl_Button*, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// según qué campo está activo hay que proceder de distinta forma
switch (indice) {

/////////////////////////////////////////////////////////////////////////////////////////////	
// se esta editando la linea de texto
case 0: 
	// Codificación para entender los anidamientos: Fecha,Hora,Serie
	
	// Procesa el texto
	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
 	//////////////////////////////////////////////////////////////////////////////////////	
	case 0: //0
        
		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
		case 0: //0,0
        
		       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
		       	case 0: //0,0,0
 
 				if (strlen(CuadroTextoLinea->value())) {
        		
        				// copia el texto actual en una nueva variable
					strcpy(str, CuadroTextoLinea->value());

					// adelanta el carácter de fin de string un carácter, para borrar el último
					str[strlen(str) - 1] = '\0';

					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
				
				}
            		
            			break; //0,0,0
            		
		        case 1: //0,0,1
		        
		        	// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	
		        	}
		        	
			        break; //0,0,1
	           	
        		}
	
			break; //0,0
		
		case 1: //0,1
    
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 			case 0: //0,1,0
       	
		        	// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				CuadroTextoLinea->value(textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	}
            		
            			break;//0,1,0
        	
        		case 2: //0,1,2
   
        			// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
			
        			break; //0,1,0
        		
        		}
        	
        		break; //0,1
        	
		case 2: //0,2
    	
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       			case 1: //0,2,1
   		
       				// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
	            	
        			break; //0,2,1
        		
        		}
        		
        		break; //0,2
        		
        	}
       	
		break; //0
		
        //////////////////////////////////////////////////////////////////////////////////////	    	
	case 1: //1

		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
		case 0: //1,0
        
		       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
		       	case 0: //1,0,0
 		
 				// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				CuadroTextoLinea->value(textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	}
	            	
            			break;//1,0,0
            		
		        case 2: //1,0,2
	        
		        	// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
        	    			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
			        break; //1,0,2
	           	
        		}
	
			break; //1,0
		
		case 2: //1,2
    
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 			case 0: //1,2,0
       	
		        	// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto					
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
            		
            			break; //1,2,0
        	
        		case 3: //1,2,3
   
        			// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';
					
					// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
			
        			break; //1,2,3
        		
        		}
        	
        		break; //1,2
        	
		case 3: //1,3
    	
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       			case 2: //1,3,2
 		
       				// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
	            	
        			break; //1,3,2
        		
        		} 
        		
        		break; //1,3
        		        	
        	} 
        	
        	break; //1
        
        //////////////////////////////////////////////////////////////////////////////////////	
	case 2: //2
        	
        	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: //2,0
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //2,0,1
        		
        			// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	
        			break; //2,0,1
        		
        		}
        		
        		break; //2,0
        	
        	case 1: //2,1
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 0: //2,1,0       	
                		
                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	
        			break; //2,1,0
        		
        		case 3: //2,1,3
      	
                		// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
        		
        			break; //2,1,3
        		
        		}
        		
        		break; //2,1
        	
        	case 3: //2,3
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //2,3,1
   	
                		// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        		
        			break; //2,3,1
        		
        		}
        		
        		break; //2,3
        	
        	}
        	
		break; //2
	
        //////////////////////////////////////////////////////////////////////////////////////	
	case 3: //3
        	
        	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 1: //3,1 
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 2: //3,1,2

                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
					strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	        		
        			break; //3,1,2
        		
        		}
        		
        		break; //3,1
        	
        	case 2: //3,2
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //3,2,1

                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\0';

					// actualiza el texto
					strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	        		
        			break; //3,2,1
        		
        		}
        		
        		break; //3,2
        	
        	}
        	
		break; //3
		
	} // de switch (OrdenFecha) inicial
		
	// Actualiza el estado de widgets
	// Fecha
	if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {		// Si ya está definida la fecha

		// Desactiva los widgets
		BotonFecha->deactivate();  
		ChoiceFormatoFecha1->deactivate();
		ChoiceFormatoFecha2->deactivate();
		ChoiceFormatoFecha3->deactivate();
		ChoiceSeparadorFecha->deactivate();
		IndicadorCaducidad->deactivate();
	
	}

	else {

		// Activa los widgets
		BotonFecha->activate();  
		ChoiceFormatoFecha1->activate();
		ChoiceFormatoFecha2->activate();
		ChoiceFormatoFecha3->activate();
		ChoiceSeparadorFecha->activate();
		IndicadorCaducidad->activate();

	}

	// Hora
	if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {		// Si ya está definida la hora

		// Desactiva los widgets
		BotonHora->deactivate();  
		ChoiceFormatoHora1->deactivate();
		ChoiceFormatoHora2->deactivate();
		ChoiceFormatoHora3->deactivate();
		ChoiceSeparadorHora->deactivate();
	
	}

	else {

		// Activa los widgets
		BotonHora->activate();  
		ChoiceFormatoHora1->activate();
		ChoiceFormatoHora2->activate();
		ChoiceFormatoHora3->activate();
		ChoiceSeparadorHora->activate();

	}

	// Número de serie
	if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {	// Si ya está definido el número de serie

		// Desactiva el botón y los cuadros de texto
		BotonSerie->deactivate();  
		CuadroTextoSerie->deactivate();
		CuadroTextoSerieFinal->deactivate();
		FrameLote->deactivate();
		CuadroTextoUnidadesLote->deactivate();
		CuadroTextoUnidadesLoteActual->deactivate();
	
		// Activa el botón de reiniciar
		BotonReiniciarSerie->activate();
	}

	else {

		// Activa el botón y los cuadros de texto
		BotonSerie->activate();  
		CuadroTextoSerie->activate();
		CuadroTextoSerieFinal->activate();
		FrameLote->activate();
		CuadroTextoUnidadesLote->activate();
		CuadroTextoUnidadesLoteActual->activate();
	
		// Desactiva el botón de reiniciar
		BotonReiniciarSerie->deactivate();

	}
	
	break; // de case 0 de switch(indice)
	
/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoSerie->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(str);
	
	break;

/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoUnidadesLote->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(str);
	
	break;
	
/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoSerieFinal->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(str);
	
	break;

/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoUnidadesLoteActual->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(str);
	
	break;
	
};
}

Fl_Button *BotonQ=(Fl_Button *)0;

static void cb_BotonQ(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonW=(Fl_Button *)0;

static void cb_BotonW(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonE=(Fl_Button *)0;

static void cb_BotonE(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonR=(Fl_Button *)0;

static void cb_BotonR(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonT=(Fl_Button *)0;

static void cb_BotonT(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonY=(Fl_Button *)0;

static void cb_BotonY(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonU=(Fl_Button *)0;

static void cb_BotonU(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonI=(Fl_Button *)0;

static void cb_BotonI(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonO=(Fl_Button *)0;

static void cb_BotonO(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonP=(Fl_Button *)0;

static void cb_BotonP(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonA=(Fl_Button *)0;

static void cb_BotonA(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonS=(Fl_Button *)0;

static void cb_BotonS(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonD=(Fl_Button *)0;

static void cb_BotonD(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonF=(Fl_Button *)0;

static void cb_BotonF(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonG=(Fl_Button *)0;

static void cb_BotonG(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonH=(Fl_Button *)0;

static void cb_BotonH(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonJ=(Fl_Button *)0;

static void cb_BotonJ(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonK=(Fl_Button *)0;

static void cb_BotonK(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonL=(Fl_Button *)0;

static void cb_BotonL(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonEnhe=(Fl_Button *)0;

static void cb_BotonEnhe(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonX=(Fl_Button *)0;

static void cb_BotonX(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonC=(Fl_Button *)0;

static void cb_BotonC(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonV=(Fl_Button *)0;

static void cb_BotonV(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonB=(Fl_Button *)0;

static void cb_BotonB(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonN=(Fl_Button *)0;

static void cb_BotonN(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonM=(Fl_Button *)0;

static void cb_BotonM(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonComa=(Fl_Button *)0;

static void cb_BotonComa(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonPunto=(Fl_Button *)0;

static void cb_BotonPunto(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonZ=(Fl_Button *)0;

static void cb_BotonZ(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonEspacio=(Fl_Button *)0;

static void cb_BotonEspacio(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonBarra=(Fl_Button *)0;

static void cb_BotonBarra(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonDosPuntos=(Fl_Button *)0;

static void cb_BotonDosPuntos(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonMas=(Fl_Button *)0;

static void cb_BotonMas(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonMenos=(Fl_Button *)0;

static void cb_BotonMenos(Fl_Button* o, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());
}

Fl_Button *BotonRupia=(Fl_Button *)0;

static void cb_BotonRupia(Fl_Button*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la r para indicar la rupia
ProcesarCaracter("r");
}

Fl_Button *BotonISI=(Fl_Button *)0;

static void cb_BotonISI(Fl_Button*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la i para indicar el logo de ISI
ProcesarCaracter("i");
}

Fl_Button *BotonDiametro=(Fl_Button *)0;

static void cb_BotonDiametro(Fl_Button*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la i para indicar el logo de ISI
ProcesarCaracter("f");
}

Fl_Button *Cancelar_VentanaModificarTexto=(Fl_Button *)0;

static void cb_Cancelar_VentanaModificarTexto(Fl_Button*, void*) {
  //Vuelve a la ventana principal sin hacer nada
char record[12];

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

// Actualiza el valor de los botones, etc

// Fecha
ChoiceFormatoFecha1->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha2->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha3->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorFecha->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);
IndicadorCaducidad->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonFecha->deactivate();
	ChoiceFormatoFecha1->deactivate();
	ChoiceFormatoFecha2->deactivate();
	ChoiceFormatoFecha3->deactivate();
	ChoiceSeparadorFecha->deactivate();
	IndicadorCaducidad->deactivate();
}

else {
	BotonFecha->activate();
	ChoiceFormatoFecha1->activate();
	ChoiceFormatoFecha2->activate();
	ChoiceFormatoFecha3->activate();
	ChoiceSeparadorFecha->activate();
	IndicadorCaducidad->activate();
}

// Hora
ChoiceFormatoHora1->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora2->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora3->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorHora->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonHora->deactivate();
	ChoiceFormatoHora1->deactivate();
	ChoiceFormatoHora2->deactivate();
	ChoiceFormatoHora3->deactivate();
	ChoiceSeparadorHora->deactivate();
}

else {
	BotonHora->activate();
	ChoiceFormatoHora1->activate();
	ChoiceFormatoHora2->activate();
	ChoiceFormatoHora3->activate();
	ChoiceSeparadorHora->activate();
}

// Serie
sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoSerie->value(record);

if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);
	CuadroTextoSerieFinal->value(record);
}

sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLote->value(record);

sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLoteActual->value(record);


// Activa el número actual y el botón de reinicio sólo si se trata de la línea con el numero de serie
// y el número de serie está activado
if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
	
	BotonSerie->deactivate();
	CuadroTextoSerie->deactivate();
	CuadroTextoSerieFinal->deactivate();
	FrameLote->deactivate();
	CuadroTextoUnidadesLote->deactivate();
	CuadroTextoUnidadesLoteActual->deactivate();
	BotonReiniciarSerie->activate();
	
}

else {
	
	BotonSerie->activate();
	CuadroTextoSerie->activate();
	CuadroTextoSerieFinal->activate();
	FrameLote->activate();
	CuadroTextoUnidadesLote->activate();
	CuadroTextoUnidadesLoteActual->activate();
	BotonReiniciarSerie->deactivate();
	
}

// Actualiza los campos
ActualizarFechaHoraSerie();

// Carga el cuadro de texto de la ventana que saldrá con el texto de la línea 1
CargarTexto();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
		break;	
	
	}
		
	break;

case 2:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 3:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 4:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
			
}

// Vacía el cuadro de texto, para evitar líos...
CuadroTextoLinea->value("");

// Oculta la ventana emergente actual
VentanaModificarTexto->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Aceptar_VentanaModificarTexto=(Fl_Button *)0;

static void cb_Aceptar_VentanaModificarTexto(Fl_Button*, void* v) {
  int tmpactual, error;

// Actualiza el número actual de unidades en el lote, si hubiera cambiado
tmpactual = atoi(CuadroTextoUnidadesLoteActual->value());

if (!(tmpactual == NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]) && (tmpactual>0) ){

	NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = tmpactual;

}

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
		break;	
	
	}
		
	break;

case 2:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 3:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;

case 4:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
				
}

// Si la línea tiene un código de barras y no está vacía, comprueba si el texto introducido es válido
if ((ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] > TEXTOCIRCULAR) && (strlen(CuadroTextoLinea->value()))) {

	// Crea el código de barras
	error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);
	
	// Comprueba que se ha creado correctamente
        if(error) {
        
        	// Asigna el mensaje de error
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Código de barras inválido");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Invalid barcode");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Invalido di codici a barre");
			break;
			
		}
	
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		VentanaModificarTexto->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		
		// Desactiva el botón de Aceptar, para no poder consolidar un cambio erróneo
		//Aceptar_VentanaModificarTexto->deactivate();
		
		// No prosigue
		return;
			
        }
        
        else {
        	// Activa el botón de Aceptar
		//Aceptar_VentanaModificarTexto->activate();
	
	}
	
}

// Guarda todo
Escribir_DAT("itaca.dat");

// Vacía el cuadro de texto, para evitar líos...
CuadroTextoLinea->value("");

// Oculta la ventana emergente actual
VentanaModificarTexto->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Double_Window* Make_Window_Modificar_Texto() {
  { VentanaModificarTexto = new Fl_Double_Window(800, 600);
    VentanaModificarTexto->color(FL_BACKGROUND2_COLOR);
    VentanaModificarTexto->selection_color(FL_BACKGROUND2_COLOR);
    VentanaModificarTexto->when(FL_WHEN_RELEASE_ALWAYS);
    { LogoItacaVentanaModificar = new Fl_Box(630, 0, 165, 75);
      LogoItacaVentanaModificar->color(FL_BACKGROUND2_COLOR);
      LogoItacaVentanaModificar->image(image_fls);
      LogoItacaVentanaModificar->labelsize(12);
      LogoItacaVentanaModificar->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
    } // Fl_Box* LogoItacaVentanaModificar
    { GrupoFecha = new Fl_Group(10, 10, 615, 80);
      GrupoFecha->box(FL_PLASTIC_DOWN_BOX);
      GrupoFecha->color(FL_DARK1);
      GrupoFecha->labelcolor((Fl_Color)1);
      { Fl_Button* o = BotonFecha = new Fl_Button(20, 21, 150, 60, "A\361""adir Fecha");
        BotonFecha->box(FL_PLASTIC_UP_BOX);
        BotonFecha->down_box(FL_PLASTIC_DOWN_BOX);
        BotonFecha->color(FL_FOREGROUND_COLOR);
        BotonFecha->labelfont(8);
        BotonFecha->labelsize(18);
        BotonFecha->callback((Fl_Callback*)cb_BotonFecha);
        if (StatusFecha[LineaCalcular - 1]) {o->deactivate();} // si ya está definida la fecha, desactivar
        else {o->activate();} // y si no, activar
        switch (Idioma) {case ESP:o->label("Añadir Fecha");break; case ING:o->label("Add Date");break; case ITA:o->label("Creare Data");break;}
      } // Fl_Button* BotonFecha
      { Fl_Choice* o = ChoiceFormatoFecha1 = new Fl_Choice(180, 44, 80, 36, "primero");
        ChoiceFormatoFecha1->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoFecha1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoFecha1->selection_color(FL_YELLOW);
        ChoiceFormatoFecha1->labelfont(8);
        ChoiceFormatoFecha1->labelsize(15);
        ChoiceFormatoFecha1->textfont(8);
        ChoiceFormatoFecha1->textsize(15);
        ChoiceFormatoFecha1->callback((Fl_Callback*)cb_ChoiceFormatoFecha1);
        ChoiceFormatoFecha1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización
        if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar
        o->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);
        switch (Idioma) {case ESP:o->label("primero");break; case ING:o->label("first");break; case ITA:o->label("primo");break;}
      } // Fl_Choice* ChoiceFormatoFecha1
      { Fl_Choice* o = ChoiceFormatoFecha2 = new Fl_Choice(265, 44, 80, 36, "segundo");
        ChoiceFormatoFecha2->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoFecha2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoFecha2->selection_color(FL_YELLOW);
        ChoiceFormatoFecha2->labelfont(8);
        ChoiceFormatoFecha2->labelsize(15);
        ChoiceFormatoFecha2->textfont(8);
        ChoiceFormatoFecha2->textsize(15);
        ChoiceFormatoFecha2->callback((Fl_Callback*)cb_ChoiceFormatoFecha2);
        ChoiceFormatoFecha2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización
        if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar
        o->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);
        switch (Idioma) {case ESP:o->label("segundo");break; case ING:o->label("second");break; case ITA:o->label("secondo");break;}
      } // Fl_Choice* ChoiceFormatoFecha2
      { Fl_Choice* o = ChoiceFormatoFecha3 = new Fl_Choice(350, 44, 80, 36, "tercero");
        ChoiceFormatoFecha3->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoFecha3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoFecha3->selection_color(FL_YELLOW);
        ChoiceFormatoFecha3->labelfont(8);
        ChoiceFormatoFecha3->labelsize(15);
        ChoiceFormatoFecha3->textfont(8);
        ChoiceFormatoFecha3->textsize(15);
        ChoiceFormatoFecha3->callback((Fl_Callback*)cb_ChoiceFormatoFecha3);
        ChoiceFormatoFecha3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización
        if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar
        o->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);
        switch (Idioma) {case ESP:o->label("tercero");break; case ING:o->label("third");break; case ITA:o->label("terzo");break;}
      } // Fl_Choice* ChoiceFormatoFecha3
      { Fl_Choice* o = ChoiceSeparadorFecha = new Fl_Choice(435, 44, 60, 36, "sep.");
        ChoiceSeparadorFecha->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceSeparadorFecha->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceSeparadorFecha->selection_color(FL_YELLOW);
        ChoiceSeparadorFecha->labelfont(8);
        ChoiceSeparadorFecha->labelsize(15);
        ChoiceSeparadorFecha->textfont(8);
        ChoiceSeparadorFecha->textsize(15);
        ChoiceSeparadorFecha->callback((Fl_Callback*)cb_ChoiceSeparadorFecha);
        ChoiceSeparadorFecha->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<SeparadoresFecha; i++) {o->add(SeparadorFecha[i]);}//inicialización
        if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar
        o->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);
        switch (Idioma) {case ESP:o->label("sep.");break; case ING:o->label("sep.");break; case ITA:o->label("sep.");break;}
      } // Fl_Choice* ChoiceSeparadorFecha
      { Fl_Counter* o = IndicadorCaducidad = new Fl_Counter(505, 44, 110, 36, "Cad.(meses)");
        IndicadorCaducidad->type(1);
        IndicadorCaducidad->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorCaducidad->color(FL_FOREGROUND_COLOR);
        IndicadorCaducidad->labelfont(8);
        IndicadorCaducidad->labelsize(15);
        IndicadorCaducidad->minimum(0);
        IndicadorCaducidad->maximum(120);
        IndicadorCaducidad->step(1);
        IndicadorCaducidad->textfont(8);
        IndicadorCaducidad->textsize(15);
        IndicadorCaducidad->callback((Fl_Callback*)cb_IndicadorCaducidad);
        IndicadorCaducidad->align(Fl_Align(FL_ALIGN_TOP));
        o->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]); //inicialización
        if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar
        switch (Idioma) {case ESP:o->label("Cad.(meses)");break; case ING:o->label("Exp.(months)");break; case ITA:o->label("Scad.(mesi)");break;}
      } // Fl_Counter* IndicadorCaducidad
      GrupoFecha->end();
    } // Fl_Group* GrupoFecha
    { GrupoHora = new Fl_Group(10, 95, 615, 80);
      GrupoHora->box(FL_PLASTIC_DOWN_BOX);
      GrupoHora->color(FL_DARK1);
      { Fl_Button* o = BotonHora = new Fl_Button(20, 106, 150, 60, "A\361""adir Hora");
        BotonHora->box(FL_PLASTIC_UP_BOX);
        BotonHora->down_box(FL_PLASTIC_DOWN_BOX);
        BotonHora->color(FL_FOREGROUND_COLOR);
        BotonHora->labelfont(8);
        BotonHora->labelsize(18);
        BotonHora->callback((Fl_Callback*)cb_BotonHora);
        if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} // si ya está definida la hora, desactivar
        else {o->activate();} // y si no, activar
        switch (Idioma) {case ESP:o->label("Añadir Hora");break; case ING:o->label("Add Time");break; case ITA:o->label("Creare Orario");break;}
      } // Fl_Button* BotonHora
      { Fl_Choice* o = ChoiceFormatoHora1 = new Fl_Choice(180, 129, 80, 36, "primero");
        ChoiceFormatoHora1->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoHora1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoHora1->selection_color(FL_YELLOW);
        ChoiceFormatoHora1->labelfont(8);
        ChoiceFormatoHora1->labelsize(15);
        ChoiceFormatoHora1->textfont(8);
        ChoiceFormatoHora1->textsize(15);
        ChoiceFormatoHora1->callback((Fl_Callback*)cb_ChoiceFormatoHora1);
        ChoiceFormatoHora1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización
        o->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial
        if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar
        switch (Idioma) {case ESP:o->label("primero");break; case ING:o->label("first");break; case ITA:o->label("primo");break;}
      } // Fl_Choice* ChoiceFormatoHora1
      { Fl_Choice* o = ChoiceFormatoHora2 = new Fl_Choice(265, 129, 80, 36, "segundo");
        ChoiceFormatoHora2->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoHora2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoHora2->selection_color(FL_YELLOW);
        ChoiceFormatoHora2->labelfont(8);
        ChoiceFormatoHora2->labelsize(15);
        ChoiceFormatoHora2->textfont(8);
        ChoiceFormatoHora2->textsize(15);
        ChoiceFormatoHora2->callback((Fl_Callback*)cb_ChoiceFormatoHora2);
        ChoiceFormatoHora2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización
        o->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial
        if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar
        switch (Idioma) {case ESP:o->label("segundo");break; case ING:o->label("second");break; case ITA:o->label("secondo");break;}
      } // Fl_Choice* ChoiceFormatoHora2
      { Fl_Choice* o = ChoiceFormatoHora3 = new Fl_Choice(350, 129, 80, 36, "tercero");
        ChoiceFormatoHora3->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFormatoHora3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFormatoHora3->selection_color(FL_YELLOW);
        ChoiceFormatoHora3->labelfont(8);
        ChoiceFormatoHora3->labelsize(15);
        ChoiceFormatoHora3->textfont(8);
        ChoiceFormatoHora3->textsize(15);
        ChoiceFormatoHora3->callback((Fl_Callback*)cb_ChoiceFormatoHora3);
        ChoiceFormatoHora3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización
        o->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial
        if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar
        switch (Idioma) {case ESP:o->label("tercero");break; case ING:o->label("third");break; case ITA:o->label("terzo");break;}
      } // Fl_Choice* ChoiceFormatoHora3
      { Fl_Choice* o = ChoiceSeparadorHora = new Fl_Choice(435, 129, 60, 36, "sep.");
        ChoiceSeparadorHora->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceSeparadorHora->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceSeparadorHora->selection_color(FL_YELLOW);
        ChoiceSeparadorHora->labelfont(8);
        ChoiceSeparadorHora->labelsize(15);
        ChoiceSeparadorHora->textfont(8);
        ChoiceSeparadorHora->textsize(15);
        ChoiceSeparadorHora->callback((Fl_Callback*)cb_ChoiceSeparadorHora);
        ChoiceSeparadorHora->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        int i; for (i=0; i<SeparadoresHora; i++) {o->add(SeparadorHora[i]);}//inicialización
        o->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial
        if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar
        switch (Idioma) {case ESP:o->label("sep.");break; case ING:o->label("sep.");break; case ITA:o->label("sep.");break;}
      } // Fl_Choice* ChoiceSeparadorHora
      GrupoHora->end();
    } // Fl_Group* GrupoHora
    { GrupoSerie = new Fl_Group(10, 180, 615, 80);
      GrupoSerie->box(FL_PLASTIC_DOWN_BOX);
      GrupoSerie->color(FL_DARK1);
      { Fl_Button* o = BotonSerie = new Fl_Button(20, 190, 150, 60, "A\361""adir Serie");
        BotonSerie->box(FL_PLASTIC_UP_BOX);
        BotonSerie->down_box(FL_PLASTIC_DOWN_BOX);
        BotonSerie->color(FL_FOREGROUND_COLOR);
        BotonSerie->labelfont(8);
        BotonSerie->labelsize(18);
        BotonSerie->callback((Fl_Callback*)cb_BotonSerie);
        if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar
        switch (Idioma) {case ESP:o->label("Añadir Serie");break; case ING:o->label("Add Series");break; case ITA:o->label("Creare Serie");break;}
      } // Fl_Button* BotonSerie
      { Fl_Output* o = CuadroTextoSerie = new Fl_Output(180, 219, 80, 26, "Inicio");
        CuadroTextoSerie->box(FL_PLASTIC_THIN_DOWN_BOX);
        CuadroTextoSerie->labelfont(8);
        CuadroTextoSerie->labelsize(15);
        CuadroTextoSerie->textfont(8);
        CuadroTextoSerie->textsize(15);
        CuadroTextoSerie->callback((Fl_Callback*)cb_CuadroTextoSerie);
        CuadroTextoSerie->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        //char record[12]; sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1], NumeroSerieInicial[LineaCalcular - 1]);o->value(record); //inicialización
        if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar
        //o->clear_visible_focus(); // Para que no se vea "^" en el widget
        switch (Idioma) {case ESP:o->label("Inicio");break; case ING:o->label("Start");break; case ITA:o->label("Inizio");break;}
      } // Fl_Output* CuadroTextoSerie
      { Fl_Output* o = CuadroTextoSerieFinal = new Fl_Output(265, 219, 80, 26, "Fin");
        CuadroTextoSerieFinal->box(FL_PLASTIC_THIN_DOWN_BOX);
        CuadroTextoSerieFinal->labelfont(8);
        CuadroTextoSerieFinal->labelsize(15);
        CuadroTextoSerieFinal->textfont(8);
        CuadroTextoSerieFinal->textsize(15);
        CuadroTextoSerieFinal->callback((Fl_Callback*)cb_CuadroTextoSerieFinal);
        CuadroTextoSerieFinal->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        char record[12];
        if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record);} else {o->value("");}
        if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar
        //o->clear_visible_focus(); switch (Idioma) {case ESP:o->label("Fin");break; case ING:o->label("End");break; case ITA:o->label("Fine");break;}
      } // Fl_Output* CuadroTextoSerieFinal
      { Fl_Group* o = FrameLote = new Fl_Group(350, 200, 155, 50, "Lote");
        FrameLote->box(FL_BORDER_FRAME);
        FrameLote->labelfont(8);
        FrameLote->labelsize(15);
        { Fl_Output* o = CuadroTextoUnidadesLote = new Fl_Output(355, 219, 70, 26, "unidades");
          CuadroTextoUnidadesLote->box(FL_PLASTIC_THIN_DOWN_BOX);
          CuadroTextoUnidadesLote->labelfont(8);
          CuadroTextoUnidadesLote->labelsize(12);
          CuadroTextoUnidadesLote->textfont(8);
          CuadroTextoUnidadesLote->textsize(15);
          CuadroTextoUnidadesLote->callback((Fl_Callback*)cb_CuadroTextoUnidadesLote);
          CuadroTextoUnidadesLote->align(Fl_Align(133));
          char record[12]; sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record); //inicialización
          if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar
          //o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("unidades");break; case ING:o->label("units");break; case ITA:o->label("unità");break;}
        } // Fl_Output* CuadroTextoUnidadesLote
        { Fl_Output* o = CuadroTextoUnidadesLoteActual = new Fl_Output(430, 219, 70, 26, "actual");
          CuadroTextoUnidadesLoteActual->box(FL_PLASTIC_THIN_DOWN_BOX);
          CuadroTextoUnidadesLoteActual->labelfont(8);
          CuadroTextoUnidadesLoteActual->labelsize(12);
          CuadroTextoUnidadesLoteActual->textfont(8);
          CuadroTextoUnidadesLoteActual->textsize(15);
          CuadroTextoUnidadesLoteActual->callback((Fl_Callback*)cb_CuadroTextoUnidadesLoteActual);
          CuadroTextoUnidadesLoteActual->align(Fl_Align(133));
          char record[12]; sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record); //inicialización
          if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar
          //o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("actual");break; case ING:o->label("current");break; case ITA:o->label("attuale");break;}
        } // Fl_Output* CuadroTextoUnidadesLoteActual
        switch (Idioma) {case ESP:o->label("Lote");break; case ING:o->label("Batch");break; case ITA:o->label("Lotto");break;}
        FrameLote->end();
      } // Fl_Group* FrameLote
      { Fl_Button* o = BotonReiniciarSerie = new Fl_Button(530, 191, 80, 30, "Reiniciar");
        BotonReiniciarSerie->box(FL_PLASTIC_UP_BOX);
        BotonReiniciarSerie->down_box(FL_PLASTIC_DOWN_BOX);
        BotonReiniciarSerie->color(FL_FOREGROUND_COLOR);
        BotonReiniciarSerie->labelfont(8);
        BotonReiniciarSerie->labelsize(15);
        BotonReiniciarSerie->callback((Fl_Callback*)cb_BotonReiniciarSerie);
        if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->activate();} else {o->deactivate();} // si ya está definido el número de serie, activar, y si no, desactivar
        switch (Idioma) {case ESP:o->label("Reiniciar");break; case ING:o->label("Reset");break; case ITA:o->label("Reiniziare");break;}
      } // Fl_Button* BotonReiniciarSerie
      { Fl_Check_Button* o = CheckResetSerieFecha = new Fl_Check_Button(515, 225, 90, 30, "Reset date");
        CheckResetSerieFecha->down_box(FL_DOWN_BOX);
        CheckResetSerieFecha->callback((Fl_Callback*)cb_CheckResetSerieFecha);
        o->value(ResetSerieFecha); //inicialización
      } // Fl_Check_Button* CheckResetSerieFecha
      GrupoSerie->end();
    } // Fl_Group* GrupoSerie
    { Fl_Output* o = CuadroTextoLinea = new Fl_Output(10, 265, 750, 50);
      CuadroTextoLinea->type(12);
      CuadroTextoLinea->box(FL_PLASTIC_THIN_DOWN_BOX);
      CuadroTextoLinea->color((Fl_Color)175);
      CuadroTextoLinea->selection_color(FL_SELECTION_COLOR);
      CuadroTextoLinea->labeltype(FL_NORMAL_LABEL);
      CuadroTextoLinea->labelfont(8);
      CuadroTextoLinea->labelsize(14);
      CuadroTextoLinea->labelcolor(FL_FOREGROUND_COLOR);
      CuadroTextoLinea->textfont(8);
      CuadroTextoLinea->callback((Fl_Callback*)cb_CuadroTextoLinea);
      CuadroTextoLinea->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      CuadroTextoLinea->when(FL_WHEN_RELEASE);
      //o->clear_visible_focus(); // Para que no se vea "^" en el widget
      o->type(FL_MULTILINE_OUTPUT_WRAP);
    } // Fl_Output* CuadroTextoLinea
    { GrupoTeclado = new Fl_Group(10, 320, 750, 270);
      GrupoTeclado->box(FL_PLASTIC_UP_FRAME);
      GrupoTeclado->color(FL_FOREGROUND_COLOR);
      { Boton1 = new Fl_Button(20, 330, 50, 50, "1");
        Boton1->box(FL_PLASTIC_UP_BOX);
        Boton1->down_box(FL_PLASTIC_DOWN_BOX);
        Boton1->color(FL_INACTIVE_COLOR);
        Boton1->labelfont(8);
        Boton1->labelsize(18);
        Boton1->callback((Fl_Callback*)cb_Boton1);
      } // Fl_Button* Boton1
      { Boton2 = new Fl_Button(70, 330, 50, 50, "2");
        Boton2->box(FL_PLASTIC_UP_BOX);
        Boton2->down_box(FL_PLASTIC_DOWN_BOX);
        Boton2->color(FL_INACTIVE_COLOR);
        Boton2->labelfont(8);
        Boton2->labelsize(18);
        Boton2->callback((Fl_Callback*)cb_Boton2);
      } // Fl_Button* Boton2
      { Boton3 = new Fl_Button(120, 330, 50, 50, "3");
        Boton3->box(FL_PLASTIC_UP_BOX);
        Boton3->down_box(FL_PLASTIC_DOWN_BOX);
        Boton3->color(FL_INACTIVE_COLOR);
        Boton3->labelfont(8);
        Boton3->labelsize(18);
        Boton3->callback((Fl_Callback*)cb_Boton3);
      } // Fl_Button* Boton3
      { Boton4 = new Fl_Button(170, 330, 50, 50, "4");
        Boton4->box(FL_PLASTIC_UP_BOX);
        Boton4->down_box(FL_PLASTIC_DOWN_BOX);
        Boton4->color(FL_INACTIVE_COLOR);
        Boton4->labelfont(8);
        Boton4->labelsize(18);
        Boton4->callback((Fl_Callback*)cb_Boton4);
      } // Fl_Button* Boton4
      { Boton5 = new Fl_Button(220, 330, 50, 50, "5");
        Boton5->box(FL_PLASTIC_UP_BOX);
        Boton5->down_box(FL_PLASTIC_DOWN_BOX);
        Boton5->color(FL_INACTIVE_COLOR);
        Boton5->labelfont(8);
        Boton5->labelsize(18);
        Boton5->callback((Fl_Callback*)cb_Boton5);
      } // Fl_Button* Boton5
      { Boton6 = new Fl_Button(270, 330, 50, 50, "6");
        Boton6->box(FL_PLASTIC_UP_BOX);
        Boton6->down_box(FL_PLASTIC_DOWN_BOX);
        Boton6->color(FL_INACTIVE_COLOR);
        Boton6->labelfont(8);
        Boton6->labelsize(18);
        Boton6->callback((Fl_Callback*)cb_Boton6);
      } // Fl_Button* Boton6
      { Boton7 = new Fl_Button(320, 330, 50, 50, "7");
        Boton7->box(FL_PLASTIC_UP_BOX);
        Boton7->down_box(FL_PLASTIC_DOWN_BOX);
        Boton7->color(FL_INACTIVE_COLOR);
        Boton7->labelfont(8);
        Boton7->labelsize(18);
        Boton7->callback((Fl_Callback*)cb_Boton7);
      } // Fl_Button* Boton7
      { Boton8 = new Fl_Button(370, 330, 50, 50, "8");
        Boton8->box(FL_PLASTIC_UP_BOX);
        Boton8->down_box(FL_PLASTIC_DOWN_BOX);
        Boton8->color(FL_INACTIVE_COLOR);
        Boton8->labelfont(8);
        Boton8->labelsize(18);
        Boton8->callback((Fl_Callback*)cb_Boton8);
      } // Fl_Button* Boton8
      { Boton9 = new Fl_Button(420, 330, 50, 50, "9");
        Boton9->box(FL_PLASTIC_UP_BOX);
        Boton9->down_box(FL_PLASTIC_DOWN_BOX);
        Boton9->color(FL_INACTIVE_COLOR);
        Boton9->labelfont(8);
        Boton9->labelsize(18);
        Boton9->callback((Fl_Callback*)cb_Boton9);
      } // Fl_Button* Boton9
      { Boton0 = new Fl_Button(470, 330, 50, 50, "0");
        Boton0->box(FL_PLASTIC_UP_BOX);
        Boton0->down_box(FL_PLASTIC_DOWN_BOX);
        Boton0->color(FL_INACTIVE_COLOR);
        Boton0->labelfont(8);
        Boton0->labelsize(18);
        Boton0->callback((Fl_Callback*)cb_Boton0);
      } // Fl_Button* Boton0
      { Fl_Button* o = BotonBorrar = new Fl_Button(520, 330, 95, 50, "Borrar");
        BotonBorrar->box(FL_PLASTIC_UP_BOX);
        BotonBorrar->down_box(FL_PLASTIC_DOWN_BOX);
        BotonBorrar->color(FL_INACTIVE_COLOR);
        BotonBorrar->labelfont(8);
        BotonBorrar->labelsize(18);
        BotonBorrar->callback((Fl_Callback*)cb_BotonBorrar);
        switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}
      } // Fl_Button* BotonBorrar
      { BotonQ = new Fl_Button(45, 380, 50, 50, "Q");
        BotonQ->box(FL_PLASTIC_UP_BOX);
        BotonQ->down_box(FL_PLASTIC_DOWN_BOX);
        BotonQ->color(FL_INACTIVE_COLOR);
        BotonQ->labelfont(8);
        BotonQ->labelsize(18);
        BotonQ->callback((Fl_Callback*)cb_BotonQ);
      } // Fl_Button* BotonQ
      { BotonW = new Fl_Button(95, 380, 50, 50, "W");
        BotonW->box(FL_PLASTIC_UP_BOX);
        BotonW->down_box(FL_PLASTIC_DOWN_BOX);
        BotonW->color(FL_INACTIVE_COLOR);
        BotonW->labelfont(8);
        BotonW->labelsize(18);
        BotonW->callback((Fl_Callback*)cb_BotonW);
      } // Fl_Button* BotonW
      { BotonE = new Fl_Button(145, 380, 50, 50, "E");
        BotonE->box(FL_PLASTIC_UP_BOX);
        BotonE->down_box(FL_PLASTIC_DOWN_BOX);
        BotonE->color(FL_INACTIVE_COLOR);
        BotonE->labelfont(8);
        BotonE->labelsize(18);
        BotonE->callback((Fl_Callback*)cb_BotonE);
      } // Fl_Button* BotonE
      { BotonR = new Fl_Button(195, 380, 50, 50, "R");
        BotonR->box(FL_PLASTIC_UP_BOX);
        BotonR->down_box(FL_PLASTIC_DOWN_BOX);
        BotonR->color(FL_INACTIVE_COLOR);
        BotonR->labelfont(8);
        BotonR->labelsize(18);
        BotonR->callback((Fl_Callback*)cb_BotonR);
      } // Fl_Button* BotonR
      { BotonT = new Fl_Button(245, 380, 50, 50, "T");
        BotonT->box(FL_PLASTIC_UP_BOX);
        BotonT->down_box(FL_PLASTIC_DOWN_BOX);
        BotonT->color(FL_INACTIVE_COLOR);
        BotonT->labelfont(8);
        BotonT->labelsize(18);
        BotonT->callback((Fl_Callback*)cb_BotonT);
      } // Fl_Button* BotonT
      { BotonY = new Fl_Button(295, 380, 50, 50, "Y");
        BotonY->box(FL_PLASTIC_UP_BOX);
        BotonY->down_box(FL_PLASTIC_DOWN_BOX);
        BotonY->color(FL_INACTIVE_COLOR);
        BotonY->labelfont(8);
        BotonY->labelsize(18);
        BotonY->callback((Fl_Callback*)cb_BotonY);
      } // Fl_Button* BotonY
      { BotonU = new Fl_Button(345, 380, 50, 50, "U");
        BotonU->box(FL_PLASTIC_UP_BOX);
        BotonU->down_box(FL_PLASTIC_DOWN_BOX);
        BotonU->color(FL_INACTIVE_COLOR);
        BotonU->labelfont(8);
        BotonU->labelsize(18);
        BotonU->callback((Fl_Callback*)cb_BotonU);
      } // Fl_Button* BotonU
      { BotonI = new Fl_Button(395, 380, 50, 50, "I");
        BotonI->box(FL_PLASTIC_UP_BOX);
        BotonI->down_box(FL_PLASTIC_DOWN_BOX);
        BotonI->color(FL_INACTIVE_COLOR);
        BotonI->labelfont(8);
        BotonI->labelsize(18);
        BotonI->callback((Fl_Callback*)cb_BotonI);
      } // Fl_Button* BotonI
      { BotonO = new Fl_Button(445, 380, 50, 50, "O");
        BotonO->box(FL_PLASTIC_UP_BOX);
        BotonO->down_box(FL_PLASTIC_DOWN_BOX);
        BotonO->color(FL_INACTIVE_COLOR);
        BotonO->labelfont(8);
        BotonO->labelsize(18);
        BotonO->callback((Fl_Callback*)cb_BotonO);
      } // Fl_Button* BotonO
      { BotonP = new Fl_Button(495, 380, 50, 50, "P");
        BotonP->box(FL_PLASTIC_UP_BOX);
        BotonP->down_box(FL_PLASTIC_DOWN_BOX);
        BotonP->color(FL_INACTIVE_COLOR);
        BotonP->labelfont(8);
        BotonP->labelsize(18);
        BotonP->callback((Fl_Callback*)cb_BotonP);
      } // Fl_Button* BotonP
      { BotonA = new Fl_Button(70, 430, 50, 50, "A");
        BotonA->box(FL_PLASTIC_UP_BOX);
        BotonA->down_box(FL_PLASTIC_DOWN_BOX);
        BotonA->color(FL_INACTIVE_COLOR);
        BotonA->labelfont(8);
        BotonA->labelsize(18);
        BotonA->callback((Fl_Callback*)cb_BotonA);
      } // Fl_Button* BotonA
      { BotonS = new Fl_Button(120, 430, 50, 50, "S");
        BotonS->box(FL_PLASTIC_UP_BOX);
        BotonS->down_box(FL_PLASTIC_DOWN_BOX);
        BotonS->color(FL_INACTIVE_COLOR);
        BotonS->labelfont(8);
        BotonS->labelsize(18);
        BotonS->callback((Fl_Callback*)cb_BotonS);
      } // Fl_Button* BotonS
      { BotonD = new Fl_Button(170, 430, 50, 50, "D");
        BotonD->box(FL_PLASTIC_UP_BOX);
        BotonD->down_box(FL_PLASTIC_DOWN_BOX);
        BotonD->color(FL_INACTIVE_COLOR);
        BotonD->labelfont(8);
        BotonD->labelsize(18);
        BotonD->callback((Fl_Callback*)cb_BotonD);
      } // Fl_Button* BotonD
      { BotonF = new Fl_Button(220, 430, 50, 50, "F");
        BotonF->box(FL_PLASTIC_UP_BOX);
        BotonF->down_box(FL_PLASTIC_DOWN_BOX);
        BotonF->color(FL_INACTIVE_COLOR);
        BotonF->labelfont(8);
        BotonF->labelsize(18);
        BotonF->callback((Fl_Callback*)cb_BotonF);
      } // Fl_Button* BotonF
      { BotonG = new Fl_Button(270, 430, 50, 50, "G");
        BotonG->box(FL_PLASTIC_UP_BOX);
        BotonG->down_box(FL_PLASTIC_DOWN_BOX);
        BotonG->color(FL_INACTIVE_COLOR);
        BotonG->labelfont(8);
        BotonG->labelsize(18);
        BotonG->callback((Fl_Callback*)cb_BotonG);
      } // Fl_Button* BotonG
      { BotonH = new Fl_Button(320, 430, 50, 50, "H");
        BotonH->box(FL_PLASTIC_UP_BOX);
        BotonH->down_box(FL_PLASTIC_DOWN_BOX);
        BotonH->color(FL_INACTIVE_COLOR);
        BotonH->labelfont(8);
        BotonH->labelsize(18);
        BotonH->callback((Fl_Callback*)cb_BotonH);
      } // Fl_Button* BotonH
      { BotonJ = new Fl_Button(370, 430, 50, 50, "J");
        BotonJ->box(FL_PLASTIC_UP_BOX);
        BotonJ->down_box(FL_PLASTIC_DOWN_BOX);
        BotonJ->color(FL_INACTIVE_COLOR);
        BotonJ->labelfont(8);
        BotonJ->labelsize(18);
        BotonJ->callback((Fl_Callback*)cb_BotonJ);
      } // Fl_Button* BotonJ
      { BotonK = new Fl_Button(420, 430, 50, 50, "K");
        BotonK->box(FL_PLASTIC_UP_BOX);
        BotonK->down_box(FL_PLASTIC_DOWN_BOX);
        BotonK->color(FL_INACTIVE_COLOR);
        BotonK->labelfont(8);
        BotonK->labelsize(18);
        BotonK->callback((Fl_Callback*)cb_BotonK);
      } // Fl_Button* BotonK
      { BotonL = new Fl_Button(470, 430, 50, 50, "L");
        BotonL->box(FL_PLASTIC_UP_BOX);
        BotonL->down_box(FL_PLASTIC_DOWN_BOX);
        BotonL->color(FL_INACTIVE_COLOR);
        BotonL->labelfont(8);
        BotonL->labelsize(18);
        BotonL->callback((Fl_Callback*)cb_BotonL);
      } // Fl_Button* BotonL
      { BotonEnhe = new Fl_Button(520, 430, 50, 50, "\321");
        BotonEnhe->box(FL_PLASTIC_UP_BOX);
        BotonEnhe->down_box(FL_PLASTIC_DOWN_BOX);
        BotonEnhe->color(FL_INACTIVE_COLOR);
        BotonEnhe->labelfont(8);
        BotonEnhe->labelsize(18);
        BotonEnhe->callback((Fl_Callback*)cb_BotonEnhe);
      } // Fl_Button* BotonEnhe
      { BotonX = new Fl_Button(145, 480, 50, 50, "X");
        BotonX->box(FL_PLASTIC_UP_BOX);
        BotonX->down_box(FL_PLASTIC_DOWN_BOX);
        BotonX->color(FL_INACTIVE_COLOR);
        BotonX->labelfont(8);
        BotonX->labelsize(18);
        BotonX->callback((Fl_Callback*)cb_BotonX);
      } // Fl_Button* BotonX
      { BotonC = new Fl_Button(195, 480, 50, 50, "C");
        BotonC->box(FL_PLASTIC_UP_BOX);
        BotonC->down_box(FL_PLASTIC_DOWN_BOX);
        BotonC->color(FL_INACTIVE_COLOR);
        BotonC->labelfont(8);
        BotonC->labelsize(18);
        BotonC->callback((Fl_Callback*)cb_BotonC);
      } // Fl_Button* BotonC
      { BotonV = new Fl_Button(245, 480, 50, 50, "V");
        BotonV->box(FL_PLASTIC_UP_BOX);
        BotonV->down_box(FL_PLASTIC_DOWN_BOX);
        BotonV->color(FL_INACTIVE_COLOR);
        BotonV->labelfont(8);
        BotonV->labelsize(18);
        BotonV->callback((Fl_Callback*)cb_BotonV);
      } // Fl_Button* BotonV
      { BotonB = new Fl_Button(295, 480, 50, 50, "B");
        BotonB->box(FL_PLASTIC_UP_BOX);
        BotonB->down_box(FL_PLASTIC_DOWN_BOX);
        BotonB->color(FL_INACTIVE_COLOR);
        BotonB->labelfont(8);
        BotonB->labelsize(18);
        BotonB->callback((Fl_Callback*)cb_BotonB);
      } // Fl_Button* BotonB
      { BotonN = new Fl_Button(345, 480, 50, 50, "N");
        BotonN->box(FL_PLASTIC_UP_BOX);
        BotonN->down_box(FL_PLASTIC_DOWN_BOX);
        BotonN->color(FL_INACTIVE_COLOR);
        BotonN->labelfont(8);
        BotonN->labelsize(18);
        BotonN->callback((Fl_Callback*)cb_BotonN);
      } // Fl_Button* BotonN
      { BotonM = new Fl_Button(395, 480, 50, 50, "M");
        BotonM->box(FL_PLASTIC_UP_BOX);
        BotonM->down_box(FL_PLASTIC_DOWN_BOX);
        BotonM->color(FL_INACTIVE_COLOR);
        BotonM->labelfont(8);
        BotonM->labelsize(18);
        BotonM->callback((Fl_Callback*)cb_BotonM);
      } // Fl_Button* BotonM
      { BotonComa = new Fl_Button(445, 480, 50, 50, ",");
        BotonComa->box(FL_PLASTIC_UP_BOX);
        BotonComa->down_box(FL_PLASTIC_DOWN_BOX);
        BotonComa->color(FL_INACTIVE_COLOR);
        BotonComa->labelfont(8);
        BotonComa->labelsize(18);
        BotonComa->callback((Fl_Callback*)cb_BotonComa);
      } // Fl_Button* BotonComa
      { BotonPunto = new Fl_Button(495, 480, 50, 50, ".");
        BotonPunto->box(FL_PLASTIC_UP_BOX);
        BotonPunto->down_box(FL_PLASTIC_DOWN_BOX);
        BotonPunto->color(FL_INACTIVE_COLOR);
        BotonPunto->labelfont(8);
        BotonPunto->labelsize(18);
        BotonPunto->callback((Fl_Callback*)cb_BotonPunto);
      } // Fl_Button* BotonPunto
      { BotonZ = new Fl_Button(95, 480, 50, 50, "Z");
        BotonZ->box(FL_PLASTIC_UP_BOX);
        BotonZ->down_box(FL_PLASTIC_DOWN_BOX);
        BotonZ->color(FL_INACTIVE_COLOR);
        BotonZ->labelfont(8);
        BotonZ->labelsize(18);
        BotonZ->callback((Fl_Callback*)cb_BotonZ);
      } // Fl_Button* BotonZ
      { BotonEspacio = new Fl_Button(95, 530, 375, 50, " ");
        BotonEspacio->box(FL_PLASTIC_UP_BOX);
        BotonEspacio->down_box(FL_PLASTIC_DOWN_BOX);
        BotonEspacio->color(FL_INACTIVE_COLOR);
        BotonEspacio->labelfont(8);
        BotonEspacio->labelsize(18);
        BotonEspacio->callback((Fl_Callback*)cb_BotonEspacio);
      } // Fl_Button* BotonEspacio
      { BotonBarra = new Fl_Button(470, 530, 50, 50, "/");
        BotonBarra->box(FL_PLASTIC_UP_BOX);
        BotonBarra->down_box(FL_PLASTIC_DOWN_BOX);
        BotonBarra->color(FL_INACTIVE_COLOR);
        BotonBarra->labelfont(8);
        BotonBarra->labelsize(18);
        BotonBarra->callback((Fl_Callback*)cb_BotonBarra);
      } // Fl_Button* BotonBarra
      { BotonDosPuntos = new Fl_Button(520, 530, 50, 50, ":");
        BotonDosPuntos->box(FL_PLASTIC_UP_BOX);
        BotonDosPuntos->down_box(FL_PLASTIC_DOWN_BOX);
        BotonDosPuntos->color(FL_INACTIVE_COLOR);
        BotonDosPuntos->labelfont(8);
        BotonDosPuntos->labelsize(18);
        BotonDosPuntos->callback((Fl_Callback*)cb_BotonDosPuntos);
      } // Fl_Button* BotonDosPuntos
      { BotonMas = new Fl_Button(545, 380, 50, 50, "+");
        BotonMas->box(FL_PLASTIC_UP_BOX);
        BotonMas->down_box(FL_PLASTIC_DOWN_BOX);
        BotonMas->color(FL_INACTIVE_COLOR);
        BotonMas->labelfont(8);
        BotonMas->labelsize(18);
        BotonMas->callback((Fl_Callback*)cb_BotonMas);
      } // Fl_Button* BotonMas
      { BotonMenos = new Fl_Button(545, 480, 50, 50, "-");
        BotonMenos->box(FL_PLASTIC_UP_BOX);
        BotonMenos->down_box(FL_PLASTIC_DOWN_BOX);
        BotonMenos->color(FL_INACTIVE_COLOR);
        BotonMenos->labelfont(8);
        BotonMenos->labelsize(18);
        BotonMenos->callback((Fl_Callback*)cb_BotonMenos);
      } // Fl_Button* BotonMenos
      { Fl_Button* o = BotonRupia = new Fl_Button(20, 480, 75, 50, "Rupee");
        BotonRupia->box(FL_PLASTIC_UP_BOX);
        BotonRupia->down_box(FL_PLASTIC_DOWN_BOX);
        BotonRupia->color(FL_INACTIVE_COLOR);
        BotonRupia->labelfont(8);
        BotonRupia->labelsize(17);
        BotonRupia->callback((Fl_Callback*)cb_BotonRupia);
        if (ValorFuente==9) {o->show();} //sólo fuente "india"
        else {o->hide();}
        switch (Idioma) {case ESP:o->label("Rupia");break; case ING:o->label("Rupee");break; case ITA:o->label("Rupee");break;}
      } // Fl_Button* BotonRupia
      { Fl_Button* o = BotonISI = new Fl_Button(20, 530, 75, 50, "ISI");
        BotonISI->box(FL_PLASTIC_UP_BOX);
        BotonISI->down_box(FL_PLASTIC_DOWN_BOX);
        BotonISI->color(FL_INACTIVE_COLOR);
        BotonISI->labelfont(8);
        BotonISI->labelsize(17);
        BotonISI->callback((Fl_Callback*)cb_BotonISI);
        if (ValorFuente==9) {o->show();} //sólo fuente "india"
        else {o->hide();}
        switch (Idioma) {case ESP:o->label("ISI");break; case ING:o->label("ISI");break; case ITA:o->label("ISI");break;}
      } // Fl_Button* BotonISI
      { Fl_Button* o = BotonDiametro = new Fl_Button(570, 530, 75, 50, "Diam");
        BotonDiametro->box(FL_PLASTIC_UP_BOX);
        BotonDiametro->down_box(FL_PLASTIC_DOWN_BOX);
        BotonDiametro->color(FL_INACTIVE_COLOR);
        BotonDiametro->labelfont(8);
        BotonDiametro->labelsize(17);
        BotonDiametro->callback((Fl_Callback*)cb_BotonDiametro);
        if (ValorFuente==4) {o->show();} //sólo fuente "india"
        else {o->hide();}
        switch (Idioma) {case ESP:o->label("Dia");break; case ING:o->label("Dia");break; case ITA:o->label("Dia");break;}
      } // Fl_Button* BotonDiametro
      GrupoTeclado->end();
    } // Fl_Group* GrupoTeclado
    { Fl_Button* o = Cancelar_VentanaModificarTexto = new Fl_Button(640, 100, 135, 75, "Cancelar");
      Cancelar_VentanaModificarTexto->box(FL_PLASTIC_UP_BOX);
      Cancelar_VentanaModificarTexto->down_box(FL_PLASTIC_DOWN_BOX);
      Cancelar_VentanaModificarTexto->color(FL_FOREGROUND_COLOR);
      Cancelar_VentanaModificarTexto->labelfont(8);
      Cancelar_VentanaModificarTexto->labelsize(20);
      Cancelar_VentanaModificarTexto->callback((Fl_Callback*)cb_Cancelar_VentanaModificarTexto);
      switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
    } // Fl_Button* Cancelar_VentanaModificarTexto
    { Fl_Button* o = Aceptar_VentanaModificarTexto = new Fl_Button(640, 180, 135, 75, "Aceptar");
      Aceptar_VentanaModificarTexto->box(FL_PLASTIC_UP_BOX);
      Aceptar_VentanaModificarTexto->down_box(FL_PLASTIC_DOWN_BOX);
      Aceptar_VentanaModificarTexto->color(FL_FOREGROUND_COLOR);
      Aceptar_VentanaModificarTexto->labelfont(8);
      Aceptar_VentanaModificarTexto->labelsize(20);
      Aceptar_VentanaModificarTexto->callback((Fl_Callback*)cb_Aceptar_VentanaModificarTexto);
      switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
    } // Fl_Button* Aceptar_VentanaModificarTexto
    VentanaModificarTexto->set_modal();
    VentanaModificarTexto->clear_border();
    VentanaModificarTexto->size_range(800, 600, 800, 600);
    VentanaModificarTexto->end();
    VentanaModificarTexto->resizable(VentanaModificarTexto);
  } // Fl_Double_Window* VentanaModificarTexto
  return VentanaModificarTexto;
}

Fl_Double_Window *VentanaDetallesLinea=(Fl_Double_Window *)0;

Fl_Choice *ChoiceTipoLinea=(Fl_Choice *)0;

static void cb_ChoiceTipoLinea(Fl_Choice* o, void*) {
  int error;

// Si no ha habido cambios no hace nada
if (o->value() == ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]) { return;}

// Almacena el valor seleccionado en la variable ValorTipoLinea
ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] = o->value();

// Si el tipo de línea es texto oculta los grupos de barcode y gráfico
if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {

	GrupoTexto->show();
	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();

	// Si había un código de barras borra el objeto
	//if(BarcodeSymbol[LineaCalcular - 1] != NULL) {
		//ZBarcode_Delete(BarcodeSymbol[LineaCalcular - 1]);
	//}

	if (Estrategia < 3) {
		TextoMinX->hide();
		TextoMinY->hide();
	}
	else {
		TextoMinX->show();
		
		TextoMinY->show();	
	}
	// Activa el botón de Aceptar, por si previamente había sido desactivado
	Aceptar_VentanaDetallesLinea->activate();
	
}

// Si el tipo de línea es gráfico, muestra el grupo gráfico y oculta el de barcode
else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {

	GrupoBarcode->hide();
	GrupoGrafico->show();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();

	// Si había un código de barras borra el objeto
	//if(BarcodeSymbol[LineaCalcular - 1] != NULL) {
		//ZBarcode_Delete(BarcodeSymbol[LineaCalcular - 1]);
	//}

	// Activa el botón de Aceptar, por si previamente había sido desactivado
	//Aceptar_VentanaDetallesLinea->activate();
	
	// Deselecciona lo que hubiera
	FileBrowserArchivosPlt->deselect(FileBrowserArchivosPlt->value());
	
	// Desactiva el botón de Aceptar hasta que se haga una seleccion
	Aceptar_VentanaDetallesLinea->deactivate();
	if (Estrategia < 3) {
		GraficoMinX->hide();
		GraficoMinY->hide();
	}
	else {
		GraficoMinX->show();
		
		GraficoMinY->show();	
	}

}

else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {

	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();
	
	if (Estrategia <3){
		switch (Idioma) {		
			case ESP:
			BoxVentanaMensaje->label("Estrategia incorrecta");
			break; 
			case ING:
			BoxVentanaMensaje->label("Invalid marking strategy");
			break; 
			case ITA:
			BoxVentanaMensaje->label("Invalido di estrategia marcatura");
			break;
			}
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		
		VentanaDetallesLinea->deactivate();
		Aceptar_VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	}

	else {
		if (Funcionalidad<1){
		switch (Idioma) {		
			case ESP:
			BoxVentanaMensaje->label("Funcionalidad incorrecta. Bloques no aceptados");
			break; 
			case ING:
			BoxVentanaMensaje->label("Invalid functionality. Blocks not accepted");
			break; 
			case ITA:
			BoxVentanaMensaje->label("Invalido di estrategia marcatura. Bloques no aceptados");
			break;
			}
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		
		VentanaDetallesLinea->deactivate();
		Aceptar_VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		}

	
		else {
		GrupoTextoCircular->show();
		Aceptar_VentanaDetallesLinea->activate();
		}

	}
	

	
	}
// Si es cualquier otro tipo muestra el grupo de barcode y oculta el grupo gráfico
else {

	GrupoBarcode->show();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();

	if (Estrategia < 3) {
		BarcodeMinX->hide();
		BarcodeMinY->hide();
	}
	else {
		BarcodeMinX->show();
		
		BarcodeMinY->show();	
	}

	// Si es un datamatrix ocultar la opción de invertir el código, ya que no tiene sentido
	if ( numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] == 71) {
	
		CheckInvertirBarcode->hide();
	}
	
	else {
		CheckInvertirBarcode->show();
	
	}
	
	// Crea el código de barras
	error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);

	// Comprueba que se ha creado correctamente
        if(error) {
        
        	// Asigna el mensaje de error
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Código de barras inválido");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Invalid barcode");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Invalido di codici a barre");
			break;
			
		}
	
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		
		// Desactiva el botón de Aceptar, para no poder consolidar un cambio erróneo
		Aceptar_VentanaDetallesLinea->deactivate();
	
        }
        
        else {

        	// Activa el botón de Aceptar
		Aceptar_VentanaDetallesLinea->activate();
	
	}
        
};
}

Fl_Group *GrupoBarcode=(Fl_Group *)0;

Fl_Round_Button *CheckInvertirBarcode=(Fl_Round_Button *)0;

static void cb_CheckInvertirBarcode(Fl_Round_Button* o, void*) {
  // Almacena el valor seleccionado en la variable InvertirBarcode
InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] = o->value();

// Invertir
//if (o->value() == ON) {
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->fgcolour, "ffffff");
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->bgcolour, "000000");
//}
        
//else {
//        strcpy(BarcodeSymbol[LineaCalcular - 1]->fgcolour, "000000");
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->bgcolour, "ffffff");
//};
}

Fl_Counter *IndicadorEscalaBarcode=(Fl_Counter *)0;

static void cb_IndicadorEscalaBarcode(Fl_Counter* o, void*) {
  // Cambia la variable de la escala del código de barras
EscalaBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *IndicadorSeparacionBarrasBarcode=(Fl_Counter *)0;

static void cb_IndicadorSeparacionBarrasBarcode(Fl_Counter* o, void*) {
  // Cambia la variable de la anchura del código de barras
SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *BarcodeMinX=(Fl_Counter *)0;

static void cb_BarcodeMinX(Fl_Counter* o, void*) {
  // Cambia la posicion del codigo de barras
MinXBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *BarcodeMinY=(Fl_Counter *)0;

static void cb_BarcodeMinY(Fl_Counter* o, void*) {
  // Cambia la posicion del codigo de barras
MinYBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Group *GrupoGrafico=(Fl_Group *)0;

Fl_File_Browser *FileBrowserArchivosPlt=(Fl_File_Browser *)0;

static void cb_FileBrowserArchivosPlt(Fl_File_Browser* o, void*) {
  if (o->value()){
	
	// guarda el nombre del archivo seleccionado
	strcpy(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], o->text(o->value()));

	if (debug_plt) {
		printf("NombreArchivoPlt:%s\n", NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
	}

	// activa el botón de Aceptar ahora que se ha hecho una selección
	Aceptar_VentanaDetallesLinea->activate();

};
}

Fl_Counter *GraficoMinX=(Fl_Counter *)0;

static void cb_GraficoMinX(Fl_Counter* o, void*) {
  // Cambia la posicion del grafico
MinXGrafico[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *GraficoMinY=(Fl_Counter *)0;

static void cb_GraficoMinY(Fl_Counter* o, void*) {
  // Cambia la posicion del grafico
MinYGrafico[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Button *Cancelar_VentanaDetallesLinea=(Fl_Button *)0;

static void cb_Cancelar_VentanaDetallesLinea(Fl_Button*, void*) {
  //Vuelve a la ventana principal sin hacer nada

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

/*

// Actualiza los campos de la ventana principal
ActualizarFechaHoraSerie();

// Carga el cuadro de texto de la ventana que saldrá con el texto de la línea 1
CargarTexto();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea1->value(LineaTexto1);
	break;

case 2:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea2->value(LineaTexto2);
	break;
	
case 3:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea3->value(LineaTexto3);
	break;

case 4:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea4->value(LineaTexto4);
	break;
				
}

*/

// Oculta la ventana emergente actual
VentanaDetallesLinea->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Aceptar_VentanaDetallesLinea=(Fl_Button *)0;

static void cb_Aceptar_VentanaDetallesLinea(Fl_Button*, void*) {
  // Actualiza el botón del tipo de línea
switch (LineaCalcular) {

case 1:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea1Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea1Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea1Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea1->deactivate();
			CuadroTextoLinea1Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea1->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea1->activate();
			CuadroTextoLinea1Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;

case 2:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea2Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea2Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea2Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea2->deactivate();
			CuadroTextoLinea2Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea2->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea2->activate();
			CuadroTextoLinea2Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;
	
case 3:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea3Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea3Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea3Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea3->deactivate();
			CuadroTextoLinea3Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea3->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea3->activate();
			CuadroTextoLinea3Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;

case 4:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea4->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea4Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea4Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea4Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea4->deactivate();
			CuadroTextoLinea4Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea4->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea4->activate();
			CuadroTextoLinea4Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;
				
}

// Guarda todo
Escribir_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaDetallesLinea->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Group *GrupoTextoCircular=(Fl_Group *)0;

Fl_Counter *Angulo=(Fl_Counter *)0;

static void cb_Angulo(Fl_Counter* o, void*) {
  // Cambia el angulo de inicio del texto circular
AnguloTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *Radio=(Fl_Counter *)0;

static void cb_Radio(Fl_Counter* o, void*) {
  // Cambia el angulo de inicio del texto circular
RadioTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *TextoCircularCentroX=(Fl_Counter *)0;

static void cb_TextoCircularCentroX(Fl_Counter* o, void*) {
  // Cambia la posicion del centro del texto circular
CentroXTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Counter *TextoCircularCentroY=(Fl_Counter *)0;

static void cb_TextoCircularCentroY(Fl_Counter* o, void*) {
  // Cambia el angulo de inicio del texto circular
CentroYTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();
}

Fl_Group *GrupoTexto=(Fl_Group *)0;

Fl_Counter *TextoMinX=(Fl_Counter *)0;

static void cb_TextoMinX(Fl_Counter* o, void*) {
  // Cambia la posicion del texto
MinXTexto[LineaCalcular - 1][BloqueCalcular - 1] = (double)o->value();
}

Fl_Counter *TextoMinY=(Fl_Counter *)0;

static void cb_TextoMinY(Fl_Counter* o, void*) {
  // Cambia el angulo de inicio del texto circular
MinYTexto[LineaCalcular - 1][BloqueCalcular - 1] = (double)o->value();
}

Fl_Double_Window* Make_Window_Detalles_Linea() {
  { VentanaDetallesLinea = new Fl_Double_Window(475, 550);
    VentanaDetallesLinea->box(FL_BORDER_BOX);
    VentanaDetallesLinea->color(FL_BACKGROUND2_COLOR);
    VentanaDetallesLinea->selection_color(FL_BACKGROUND2_COLOR);
    VentanaDetallesLinea->when(FL_WHEN_RELEASE_ALWAYS);
    { Fl_Choice* o = ChoiceTipoLinea = new Fl_Choice(50, 42, 250, 38, "Tipo de l\355nea");
      ChoiceTipoLinea->box(FL_PLASTIC_THIN_UP_BOX);
      ChoiceTipoLinea->down_box(FL_PLASTIC_THIN_DOWN_BOX);
      ChoiceTipoLinea->selection_color(FL_YELLOW);
      ChoiceTipoLinea->labelfont(8);
      ChoiceTipoLinea->labelsize(18);
      ChoiceTipoLinea->textfont(8);
      ChoiceTipoLinea->textsize(18);
      ChoiceTipoLinea->callback((Fl_Callback*)cb_ChoiceTipoLinea);
      ChoiceTipoLinea->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      int i; for (i=0; i<NumeroTiposLinea; i++) {o->add(strTiposLinea[Idioma][i]);}//inicialización
      switch (Idioma) {case ESP:o->label("Tipo de línea");break; case ING:o->label("Line type");break; case ITA:o->label("Tipo di linea");break;}
    } // Fl_Choice* ChoiceTipoLinea
    { GrupoBarcode = new Fl_Group(50, 95, 355, 350);
      GrupoBarcode->box(FL_PLASTIC_DOWN_BOX);
      GrupoBarcode->color((Fl_Color)10);
      { Fl_Round_Button* o = CheckInvertirBarcode = new Fl_Round_Button(100, 120, 180, 25, " Invertir c\363""digo");
        CheckInvertirBarcode->down_box(FL_PLASTIC_DOWN_BOX);
        CheckInvertirBarcode->color(FL_FOREGROUND_COLOR);
        CheckInvertirBarcode->labelfont(8);
        CheckInvertirBarcode->labelsize(18);
        CheckInvertirBarcode->callback((Fl_Callback*)cb_CheckInvertirBarcode);
        switch (Idioma) {case ESP:o->label("Invertir código");break; case ING:o->label("Invert code");break; case ITA:o->label("Invertire codice");break;}
      } // Fl_Round_Button* CheckInvertirBarcode
      { Fl_Counter* o = IndicadorEscalaBarcode = new Fl_Counter(100, 184, 240, 36, "Escala %");
        IndicadorEscalaBarcode->type(1);
        IndicadorEscalaBarcode->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorEscalaBarcode->color(FL_FOREGROUND_COLOR);
        IndicadorEscalaBarcode->labelfont(8);
        IndicadorEscalaBarcode->labelsize(18);
        IndicadorEscalaBarcode->minimum(50);
        IndicadorEscalaBarcode->maximum(200);
        IndicadorEscalaBarcode->step(50);
        IndicadorEscalaBarcode->value(100);
        IndicadorEscalaBarcode->textfont(8);
        IndicadorEscalaBarcode->textsize(18);
        IndicadorEscalaBarcode->callback((Fl_Callback*)cb_IndicadorEscalaBarcode);
        IndicadorEscalaBarcode->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Escala %");break; case ING:o->label("Scale %");break; case ITA:o->label("Scala %");break;}
      } // Fl_Counter* IndicadorEscalaBarcode
      { Fl_Counter* o = IndicadorSeparacionBarrasBarcode = new Fl_Counter(100, 240, 240, 36, "Separaci\363n barras %");
        IndicadorSeparacionBarrasBarcode->type(1);
        IndicadorSeparacionBarrasBarcode->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorSeparacionBarrasBarcode->color(FL_FOREGROUND_COLOR);
        IndicadorSeparacionBarrasBarcode->labelfont(8);
        IndicadorSeparacionBarrasBarcode->labelsize(18);
        IndicadorSeparacionBarrasBarcode->minimum(50);
        IndicadorSeparacionBarrasBarcode->maximum(200);
        IndicadorSeparacionBarrasBarcode->step(10);
        IndicadorSeparacionBarrasBarcode->value(100);
        IndicadorSeparacionBarrasBarcode->textfont(8);
        IndicadorSeparacionBarrasBarcode->textsize(18);
        IndicadorSeparacionBarrasBarcode->callback((Fl_Callback*)cb_IndicadorSeparacionBarrasBarcode);
        IndicadorSeparacionBarrasBarcode->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Separación barras %");break; case ING:o->label("Bar separation %");break; case ITA:o->label("Separazione fra le barre %");break;}
      } // Fl_Counter* IndicadorSeparacionBarrasBarcode
      { Fl_Counter* o = BarcodeMinX = new Fl_Counter(100, 290, 240, 36, "MinX");
        BarcodeMinX->type(1);
        BarcodeMinX->box(FL_PLASTIC_THIN_UP_BOX);
        BarcodeMinX->minimum(-100);
        BarcodeMinX->maximum(100);
        BarcodeMinX->step(1);
        BarcodeMinX->callback((Fl_Callback*)cb_BarcodeMinX);
        BarcodeMinX->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}
      } // Fl_Counter* BarcodeMinX
      { Fl_Counter* o = BarcodeMinY = new Fl_Counter(100, 340, 240, 36, "MinY");
        BarcodeMinY->type(1);
        BarcodeMinY->box(FL_PLASTIC_THIN_UP_BOX);
        BarcodeMinY->minimum(-100);
        BarcodeMinY->maximum(100);
        BarcodeMinY->step(1);
        BarcodeMinY->callback((Fl_Callback*)cb_BarcodeMinY);
        BarcodeMinY->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}
      } // Fl_Counter* BarcodeMinY
      GrupoBarcode->end();
    } // Fl_Group* GrupoBarcode
    { GrupoGrafico = new Fl_Group(50, 95, 355, 350);
      GrupoGrafico->box(FL_PLASTIC_DOWN_BOX);
      GrupoGrafico->color((Fl_Color)11);
      GrupoGrafico->hide();
      { Fl_File_Browser* o = FileBrowserArchivosPlt = new Fl_File_Browser(80, 130, 290, 175, "Archivos de gr\341""ficos (.plt)");
        FileBrowserArchivosPlt->type(2);
        FileBrowserArchivosPlt->labelfont(8);
        FileBrowserArchivosPlt->labelsize(18);
        FileBrowserArchivosPlt->textfont(8);
        FileBrowserArchivosPlt->textsize(18);
        FileBrowserArchivosPlt->callback((Fl_Callback*)cb_FileBrowserArchivosPlt);
        FileBrowserArchivosPlt->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        o->filter("*.plt"); o->load(".");// Inicialización
        o->remove(1); // Para eliminar la entrada con "../"
      } // Fl_File_Browser* FileBrowserArchivosPlt
      { Fl_Counter* o = GraficoMinX = new Fl_Counter(75, 330, 240, 36, "MinX");
        GraficoMinX->minimum(-100);
        GraficoMinX->maximum(100);
        GraficoMinX->step(1);
        GraficoMinX->callback((Fl_Callback*)cb_GraficoMinX);
        GraficoMinX->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}
      } // Fl_Counter* GraficoMinX
      { Fl_Counter* o = GraficoMinY = new Fl_Counter(75, 380, 240, 36, "MinY");
        GraficoMinY->minimum(-100);
        GraficoMinY->maximum(100);
        GraficoMinY->step(1);
        GraficoMinY->callback((Fl_Callback*)cb_GraficoMinY);
        GraficoMinY->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}
      } // Fl_Counter* GraficoMinY
      GrupoGrafico->end();
    } // Fl_Group* GrupoGrafico
    { Fl_Button* o = Cancelar_VentanaDetallesLinea = new Fl_Button(270, 450, 135, 75, "Cancelar");
      Cancelar_VentanaDetallesLinea->box(FL_PLASTIC_UP_BOX);
      Cancelar_VentanaDetallesLinea->down_box(FL_PLASTIC_DOWN_BOX);
      Cancelar_VentanaDetallesLinea->color(FL_FOREGROUND_COLOR);
      Cancelar_VentanaDetallesLinea->labelfont(8);
      Cancelar_VentanaDetallesLinea->labelsize(20);
      Cancelar_VentanaDetallesLinea->callback((Fl_Callback*)cb_Cancelar_VentanaDetallesLinea);
      //o->deactivate();// de momento no se implementa la posibilidad de cancelar los cambios
      switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
    } // Fl_Button* Cancelar_VentanaDetallesLinea
    { Fl_Button* o = Aceptar_VentanaDetallesLinea = new Fl_Button(50, 450, 135, 75, "Aceptar");
      Aceptar_VentanaDetallesLinea->box(FL_PLASTIC_UP_BOX);
      Aceptar_VentanaDetallesLinea->down_box(FL_PLASTIC_DOWN_BOX);
      Aceptar_VentanaDetallesLinea->color(FL_FOREGROUND_COLOR);
      Aceptar_VentanaDetallesLinea->labelfont(8);
      Aceptar_VentanaDetallesLinea->labelsize(20);
      Aceptar_VentanaDetallesLinea->callback((Fl_Callback*)cb_Aceptar_VentanaDetallesLinea);
      switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
    } // Fl_Button* Aceptar_VentanaDetallesLinea
    { GrupoTextoCircular = new Fl_Group(50, 95, 355, 240);
      GrupoTextoCircular->box(FL_PLASTIC_DOWN_BOX);
      GrupoTextoCircular->color((Fl_Color)93);
      { Fl_Counter* o = Angulo = new Fl_Counter(100, 120, 240, 36, "Angulo");
        Angulo->box(FL_THIN_UP_BOX);
        Angulo->labelfont(8);
        Angulo->labelsize(12);
        Angulo->minimum(0);
        Angulo->maximum(359);
        Angulo->step(1);
        Angulo->textfont(8);
        Angulo->textsize(18);
        Angulo->callback((Fl_Callback*)cb_Angulo);
        Angulo->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Angulo");break; case ING:o->label("Angle º");break; case ITA:o->label("Angulo º");break;}
      } // Fl_Counter* Angulo
      { Fl_Counter* o = Radio = new Fl_Counter(100, 170, 240, 36, "Radio");
        Radio->box(FL_THIN_UP_BOX);
        Radio->labelsize(12);
        Radio->minimum(10);
        Radio->maximum(100);
        Radio->step(1);
        Radio->value(10);
        Radio->textsize(18);
        Radio->callback((Fl_Callback*)cb_Radio);
        Radio->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Radio mm");break; case ING:o->label("Radius mm");break; case ITA:o->label("Radio mm");break;}
      } // Fl_Counter* Radio
      { Fl_Counter* o = TextoCircularCentroX = new Fl_Counter(100, 220, 240, 36, "CentroX");
        TextoCircularCentroX->box(FL_THIN_UP_BOX);
        TextoCircularCentroX->labelfont(8);
        TextoCircularCentroX->labelsize(12);
        TextoCircularCentroX->minimum(-100);
        TextoCircularCentroX->maximum(100);
        TextoCircularCentroX->step(1);
        TextoCircularCentroX->textfont(8);
        TextoCircularCentroX->textsize(18);
        TextoCircularCentroX->callback((Fl_Callback*)cb_TextoCircularCentroX);
        TextoCircularCentroX->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Centro X");break; case ING:o->label("Center X");break; case ITA:o->label("Centro X");break;}
      } // Fl_Counter* TextoCircularCentroX
      { Fl_Counter* o = TextoCircularCentroY = new Fl_Counter(100, 270, 240, 36, "Centro Y");
        TextoCircularCentroY->box(FL_THIN_UP_BOX);
        TextoCircularCentroY->labelfont(8);
        TextoCircularCentroY->labelsize(12);
        TextoCircularCentroY->minimum(-100);
        TextoCircularCentroY->maximum(100);
        TextoCircularCentroY->step(1);
        TextoCircularCentroY->textfont(8);
        TextoCircularCentroY->textsize(18);
        TextoCircularCentroY->callback((Fl_Callback*)cb_TextoCircularCentroY);
        TextoCircularCentroY->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Centro Y");break; case ING:o->label("Center Y");break; case ITA:o->label("Centro Y");break;}
      } // Fl_Counter* TextoCircularCentroY
      GrupoTextoCircular->end();
    } // Fl_Group* GrupoTextoCircular
    { GrupoTexto = new Fl_Group(50, 95, 355, 240);
      GrupoTexto->when(FL_WHEN_CHANGED);
      { Fl_Counter* o = TextoMinX = new Fl_Counter(100, 220, 240, 36, "MinX");
        TextoMinX->type(1);
        TextoMinX->minimum(-100);
        TextoMinX->maximum(100);
        TextoMinX->step(1);
        TextoMinX->callback((Fl_Callback*)cb_TextoMinX);
        TextoMinX->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}
      } // Fl_Counter* TextoMinX
      { Fl_Counter* o = TextoMinY = new Fl_Counter(100, 270, 240, 36, "MinY");
        TextoMinY->type(1);
        TextoMinY->minimum(-100);
        TextoMinY->maximum(100);
        TextoMinY->step(1);
        TextoMinY->callback((Fl_Callback*)cb_TextoMinY);
        TextoMinY->align(Fl_Align(133));
        switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}
      } // Fl_Counter* TextoMinY
      GrupoTexto->end();
    } // Fl_Group* GrupoTexto
    VentanaDetallesLinea->set_modal();
    VentanaDetallesLinea->clear_border();
    VentanaDetallesLinea->end();
  } // Fl_Double_Window* VentanaDetallesLinea
  return VentanaDetallesLinea;
}

Fl_Double_Window *VentanaTrabajos=(Fl_Double_Window *)0;

Fl_Box *LogoItacaVentanaTrabajos=(Fl_Box *)0;

Fl_File_Browser *FileBrowserArchivosTrabajos=(Fl_File_Browser *)0;

static void cb_FileBrowserArchivosTrabajos(Fl_File_Browser* o, void*) {
  char str[50];

if (o->value()){
	
	// copia el nombre del archivo seleccionado
	strcpy(str, o->text(o->value()));
	
	// adelanta el carácter de fin de string 4 caracteres, para borrar la extensión
	str[strlen(str) - 4] = '\0';
	
	// Actualiza la línea de texto
	CuadroTextoTrabajo->value(str);

	// activa el botón de Aceptar ahora que se ha hecho una selección
	//Aceptar_VentanaDetallesLinea->activate();

};
}

Fl_Output *CuadroTextoTrabajo=(Fl_Output *)0;

static void cb_CuadroTextoTrabajo(Fl_Output*, void*) {
  // variable que indica donde se ha fijado el foco, para el teclado
indice = 0;
}

Fl_Group *GrupoTecladoTrabajos=(Fl_Group *)0;

Fl_Button *Boton1t=(Fl_Button *)0;

static void cb_Boton1t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton2t=(Fl_Button *)0;

static void cb_Boton2t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton3t=(Fl_Button *)0;

static void cb_Boton3t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton4t=(Fl_Button *)0;

static void cb_Boton4t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton5t=(Fl_Button *)0;

static void cb_Boton5t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton6t=(Fl_Button *)0;

static void cb_Boton6t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton7t=(Fl_Button *)0;

static void cb_Boton7t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton8t=(Fl_Button *)0;

static void cb_Boton8t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton9t=(Fl_Button *)0;

static void cb_Boton9t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Boton0t=(Fl_Button *)0;

static void cb_Boton0t(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonBorrart=(Fl_Button *)0;

static void cb_BotonBorrart(Fl_Button*, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

if (strlen(CuadroTextoTrabajo->value())) {
        		
	// copia el texto actual en una nueva variable
	strcpy(str, CuadroTextoTrabajo->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoTrabajo->value(str);
	
};
}

Fl_Button *BotonQt=(Fl_Button *)0;

static void cb_BotonQt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonWt=(Fl_Button *)0;

static void cb_BotonWt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonEt=(Fl_Button *)0;

static void cb_BotonEt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonRt=(Fl_Button *)0;

static void cb_BotonRt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonTt=(Fl_Button *)0;

static void cb_BotonTt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonYt=(Fl_Button *)0;

static void cb_BotonYt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonUt=(Fl_Button *)0;

static void cb_BotonUt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonIt=(Fl_Button *)0;

static void cb_BotonIt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonOt=(Fl_Button *)0;

static void cb_BotonOt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonPt=(Fl_Button *)0;

static void cb_BotonPt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonAt=(Fl_Button *)0;

static void cb_BotonAt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonSt=(Fl_Button *)0;

static void cb_BotonSt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonDt=(Fl_Button *)0;

static void cb_BotonDt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonFt=(Fl_Button *)0;

static void cb_BotonFt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonGt=(Fl_Button *)0;

static void cb_BotonGt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonHt=(Fl_Button *)0;

static void cb_BotonHt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonJt=(Fl_Button *)0;

static void cb_BotonJt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonKt=(Fl_Button *)0;

static void cb_BotonKt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonLt=(Fl_Button *)0;

static void cb_BotonLt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonEnhet=(Fl_Button *)0;

static void cb_BotonEnhet(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonXt=(Fl_Button *)0;

static void cb_BotonXt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonCt=(Fl_Button *)0;

static void cb_BotonCt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonVt=(Fl_Button *)0;

static void cb_BotonVt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonBt=(Fl_Button *)0;

static void cb_BotonBt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonNt=(Fl_Button *)0;

static void cb_BotonNt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonMt=(Fl_Button *)0;

static void cb_BotonMt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonZt=(Fl_Button *)0;

static void cb_BotonZt(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonEspaciot=(Fl_Button *)0;

static void cb_BotonEspaciot(Fl_Button*, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, " ");
CuadroTextoTrabajo->value(str);
}

Fl_Button *BotonMenost=(Fl_Button *)0;

static void cb_BotonMenost(Fl_Button* o, void*) {
  // string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);
}

Fl_Button *Cargar_VentanaTrabajos=(Fl_Button *)0;

static void cb_Cargar_VentanaTrabajos(Fl_Button*, void*) {
  // Si hay un trabajo lanza la ventana de confirmación
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuación
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar cargar trabajos
	CargarVentanaConfirmarCargarTrabajo();
	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

};
}

Fl_Button *Guardar_VentanaTrabajos=(Fl_Button *)0;

static void cb_Guardar_VentanaTrabajos(Fl_Button*, void*) {
  // Si hay un trabajo lanza la ventana de confirmacion
if (strlen(CuadroTextoTrabajo->value())) {
	
	if (ControlAcceso) {
		VentanaPassword->show();
	}
	
	else {
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar guardar trabajo
	CargarVentanaConfirmarGuardarTrabajo();
	}	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

};
}

Fl_Button *Cancelar_VentanaTrabajos=(Fl_Button *)0;

static void cb_Cancelar_VentanaTrabajos(Fl_Button*, void*) {
  char str[50];

// Si no había trabajo seleccionado limpia todo
if (!ValorTrabajo) {

	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoTrabajo->value("");

	// Refresca el file browser para que no quede ninguna opción seleccionada
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"

}

// si no, restituye los valores correspondientes al trabajo actual
else {

	// Actualiza la selección en el file browser
	FileBrowserArchivosTrabajos->value(ValorTrabajo);
	
	// copia el nombre del archivo seleccionado
	strcpy(str, FileBrowserArchivosTrabajos->text(ValorTrabajo));
	
	// adelanta el carácter de fin de string 4 caracteres, para borrar la extensión
	str[strlen(str) - 4] = '\0';
	
	// Actualiza la línea de texto
	CuadroTextoTrabajo->value(str);

}

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Borrar_VentanaTrabajos=(Fl_Button *)0;

static void cb_Borrar_VentanaTrabajos(Fl_Button*, void*) {
  // Si hay un trabajo lanza la ventana de confirmacion
if (strlen(CuadroTextoTrabajo->value())) {
	
	if (ControlAcceso) {
		VentanaPassword->show();
	}
	
	else {
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar guardar trabajo
	CargarVentanaConfirmarBorrarTrabajo();
	}	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

};
}

Fl_Double_Window* Make_Window_Trabajos() {
  { VentanaTrabajos = new Fl_Double_Window(800, 600);
    VentanaTrabajos->color(FL_BACKGROUND2_COLOR);
    VentanaTrabajos->selection_color(FL_BACKGROUND2_COLOR);
    VentanaTrabajos->when(FL_WHEN_RELEASE_ALWAYS);
    { LogoItacaVentanaTrabajos = new Fl_Box(630, 0, 165, 75);
      LogoItacaVentanaTrabajos->color(FL_BACKGROUND2_COLOR);
      LogoItacaVentanaTrabajos->image(image_fls);
      LogoItacaVentanaTrabajos->labelsize(12);
      LogoItacaVentanaTrabajos->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
    } // Fl_Box* LogoItacaVentanaTrabajos
    { Fl_File_Browser* o = FileBrowserArchivosTrabajos = new Fl_File_Browser(10, 90, 615, 170, "Archivos de trabajos");
      FileBrowserArchivosTrabajos->type(2);
      FileBrowserArchivosTrabajos->box(FL_PLASTIC_THIN_DOWN_BOX);
      FileBrowserArchivosTrabajos->color(FL_DARK3);
      FileBrowserArchivosTrabajos->labelfont(8);
      FileBrowserArchivosTrabajos->labelsize(16);
      FileBrowserArchivosTrabajos->textfont(8);
      FileBrowserArchivosTrabajos->textsize(18);
      FileBrowserArchivosTrabajos->callback((Fl_Callback*)cb_FileBrowserArchivosTrabajos);
      FileBrowserArchivosTrabajos->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      o->filter("*.trb"); o->load(".");// Inicialización
      o->remove(1); // Para eliminar la entrada con "../"
      switch (Idioma) {case ESP:o->label("Archivos de trabajos");break; case ING:o->label("Job files");break; case ITA:o->label("File di lavoro");break;}
    } // Fl_File_Browser* FileBrowserArchivosTrabajos
    { Fl_Output* o = CuadroTextoTrabajo = new Fl_Output(10, 270, 615, 40);
      CuadroTextoTrabajo->box(FL_PLASTIC_THIN_DOWN_BOX);
      CuadroTextoTrabajo->color((Fl_Color)175);
      CuadroTextoTrabajo->labelfont(8);
      CuadroTextoTrabajo->labelsize(20);
      CuadroTextoTrabajo->textfont(8);
      CuadroTextoTrabajo->textsize(20);
      CuadroTextoTrabajo->callback((Fl_Callback*)cb_CuadroTextoTrabajo);
      CuadroTextoTrabajo->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      o->clear_visible_focus(); // Para que no se vea "^" en el widget
    } // Fl_Output* CuadroTextoTrabajo
    { GrupoTecladoTrabajos = new Fl_Group(10, 320, 615, 270);
      GrupoTecladoTrabajos->box(FL_PLASTIC_UP_FRAME);
      GrupoTecladoTrabajos->color(FL_FOREGROUND_COLOR);
      { Boton1t = new Fl_Button(20, 330, 50, 50, "1");
        Boton1t->box(FL_PLASTIC_UP_BOX);
        Boton1t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton1t->color(FL_INACTIVE_COLOR);
        Boton1t->labelfont(8);
        Boton1t->labelsize(20);
        Boton1t->callback((Fl_Callback*)cb_Boton1t);
      } // Fl_Button* Boton1t
      { Boton2t = new Fl_Button(70, 330, 50, 50, "2");
        Boton2t->box(FL_PLASTIC_UP_BOX);
        Boton2t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton2t->color(FL_INACTIVE_COLOR);
        Boton2t->labelfont(8);
        Boton2t->labelsize(20);
        Boton2t->callback((Fl_Callback*)cb_Boton2t);
      } // Fl_Button* Boton2t
      { Boton3t = new Fl_Button(120, 330, 50, 50, "3");
        Boton3t->box(FL_PLASTIC_UP_BOX);
        Boton3t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton3t->color(FL_INACTIVE_COLOR);
        Boton3t->labelfont(8);
        Boton3t->labelsize(20);
        Boton3t->callback((Fl_Callback*)cb_Boton3t);
      } // Fl_Button* Boton3t
      { Boton4t = new Fl_Button(170, 330, 50, 50, "4");
        Boton4t->box(FL_PLASTIC_UP_BOX);
        Boton4t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton4t->color(FL_INACTIVE_COLOR);
        Boton4t->labelfont(8);
        Boton4t->labelsize(20);
        Boton4t->callback((Fl_Callback*)cb_Boton4t);
      } // Fl_Button* Boton4t
      { Boton5t = new Fl_Button(220, 330, 50, 50, "5");
        Boton5t->box(FL_PLASTIC_UP_BOX);
        Boton5t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton5t->color(FL_INACTIVE_COLOR);
        Boton5t->labelfont(8);
        Boton5t->labelsize(20);
        Boton5t->callback((Fl_Callback*)cb_Boton5t);
      } // Fl_Button* Boton5t
      { Boton6t = new Fl_Button(270, 330, 50, 50, "6");
        Boton6t->box(FL_PLASTIC_UP_BOX);
        Boton6t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton6t->color(FL_INACTIVE_COLOR);
        Boton6t->labelfont(8);
        Boton6t->labelsize(20);
        Boton6t->callback((Fl_Callback*)cb_Boton6t);
      } // Fl_Button* Boton6t
      { Boton7t = new Fl_Button(320, 330, 50, 50, "7");
        Boton7t->box(FL_PLASTIC_UP_BOX);
        Boton7t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton7t->color(FL_INACTIVE_COLOR);
        Boton7t->labelfont(8);
        Boton7t->labelsize(20);
        Boton7t->callback((Fl_Callback*)cb_Boton7t);
      } // Fl_Button* Boton7t
      { Boton8t = new Fl_Button(370, 330, 50, 50, "8");
        Boton8t->box(FL_PLASTIC_UP_BOX);
        Boton8t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton8t->color(FL_INACTIVE_COLOR);
        Boton8t->labelfont(8);
        Boton8t->labelsize(20);
        Boton8t->callback((Fl_Callback*)cb_Boton8t);
      } // Fl_Button* Boton8t
      { Boton9t = new Fl_Button(420, 330, 50, 50, "9");
        Boton9t->box(FL_PLASTIC_UP_BOX);
        Boton9t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton9t->color(FL_INACTIVE_COLOR);
        Boton9t->labelfont(8);
        Boton9t->labelsize(20);
        Boton9t->callback((Fl_Callback*)cb_Boton9t);
      } // Fl_Button* Boton9t
      { Boton0t = new Fl_Button(470, 330, 50, 50, "0");
        Boton0t->box(FL_PLASTIC_UP_BOX);
        Boton0t->down_box(FL_PLASTIC_DOWN_BOX);
        Boton0t->color(FL_INACTIVE_COLOR);
        Boton0t->labelfont(8);
        Boton0t->labelsize(20);
        Boton0t->callback((Fl_Callback*)cb_Boton0t);
      } // Fl_Button* Boton0t
      { Fl_Button* o = BotonBorrart = new Fl_Button(520, 330, 95, 50, "Borrar");
        BotonBorrart->box(FL_PLASTIC_UP_BOX);
        BotonBorrart->down_box(FL_PLASTIC_DOWN_BOX);
        BotonBorrart->color(FL_INACTIVE_COLOR);
        BotonBorrart->labelfont(8);
        BotonBorrart->labelsize(17);
        BotonBorrart->callback((Fl_Callback*)cb_BotonBorrart);
        switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}
      } // Fl_Button* BotonBorrart
      { BotonQt = new Fl_Button(45, 380, 50, 50, "Q");
        BotonQt->box(FL_PLASTIC_UP_BOX);
        BotonQt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonQt->color(FL_INACTIVE_COLOR);
        BotonQt->labelfont(8);
        BotonQt->labelsize(20);
        BotonQt->callback((Fl_Callback*)cb_BotonQt);
      } // Fl_Button* BotonQt
      { BotonWt = new Fl_Button(95, 380, 50, 50, "W");
        BotonWt->box(FL_PLASTIC_UP_BOX);
        BotonWt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonWt->color(FL_INACTIVE_COLOR);
        BotonWt->labelfont(8);
        BotonWt->labelsize(20);
        BotonWt->callback((Fl_Callback*)cb_BotonWt);
      } // Fl_Button* BotonWt
      { BotonEt = new Fl_Button(145, 380, 50, 50, "E");
        BotonEt->box(FL_PLASTIC_UP_BOX);
        BotonEt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonEt->color(FL_INACTIVE_COLOR);
        BotonEt->labelfont(8);
        BotonEt->labelsize(20);
        BotonEt->callback((Fl_Callback*)cb_BotonEt);
      } // Fl_Button* BotonEt
      { BotonRt = new Fl_Button(195, 380, 50, 50, "R");
        BotonRt->box(FL_PLASTIC_UP_BOX);
        BotonRt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonRt->color(FL_INACTIVE_COLOR);
        BotonRt->labelfont(8);
        BotonRt->labelsize(20);
        BotonRt->callback((Fl_Callback*)cb_BotonRt);
      } // Fl_Button* BotonRt
      { BotonTt = new Fl_Button(245, 380, 50, 50, "T");
        BotonTt->box(FL_PLASTIC_UP_BOX);
        BotonTt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonTt->color(FL_INACTIVE_COLOR);
        BotonTt->labelfont(8);
        BotonTt->labelsize(20);
        BotonTt->callback((Fl_Callback*)cb_BotonTt);
      } // Fl_Button* BotonTt
      { BotonYt = new Fl_Button(295, 380, 50, 50, "Y");
        BotonYt->box(FL_PLASTIC_UP_BOX);
        BotonYt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonYt->color(FL_INACTIVE_COLOR);
        BotonYt->labelfont(8);
        BotonYt->labelsize(20);
        BotonYt->callback((Fl_Callback*)cb_BotonYt);
      } // Fl_Button* BotonYt
      { BotonUt = new Fl_Button(345, 380, 50, 50, "U");
        BotonUt->box(FL_PLASTIC_UP_BOX);
        BotonUt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonUt->color(FL_INACTIVE_COLOR);
        BotonUt->labelfont(8);
        BotonUt->labelsize(20);
        BotonUt->callback((Fl_Callback*)cb_BotonUt);
      } // Fl_Button* BotonUt
      { BotonIt = new Fl_Button(395, 380, 50, 50, "I");
        BotonIt->box(FL_PLASTIC_UP_BOX);
        BotonIt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonIt->color(FL_INACTIVE_COLOR);
        BotonIt->labelfont(8);
        BotonIt->labelsize(20);
        BotonIt->callback((Fl_Callback*)cb_BotonIt);
      } // Fl_Button* BotonIt
      { BotonOt = new Fl_Button(445, 380, 50, 50, "O");
        BotonOt->box(FL_PLASTIC_UP_BOX);
        BotonOt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonOt->color(FL_INACTIVE_COLOR);
        BotonOt->labelfont(8);
        BotonOt->labelsize(20);
        BotonOt->callback((Fl_Callback*)cb_BotonOt);
      } // Fl_Button* BotonOt
      { BotonPt = new Fl_Button(495, 380, 50, 50, "P");
        BotonPt->box(FL_PLASTIC_UP_BOX);
        BotonPt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonPt->color(FL_INACTIVE_COLOR);
        BotonPt->labelfont(8);
        BotonPt->labelsize(20);
        BotonPt->callback((Fl_Callback*)cb_BotonPt);
      } // Fl_Button* BotonPt
      { BotonAt = new Fl_Button(70, 430, 50, 50, "A");
        BotonAt->box(FL_PLASTIC_UP_BOX);
        BotonAt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonAt->color(FL_INACTIVE_COLOR);
        BotonAt->labelfont(8);
        BotonAt->labelsize(20);
        BotonAt->callback((Fl_Callback*)cb_BotonAt);
      } // Fl_Button* BotonAt
      { BotonSt = new Fl_Button(120, 430, 50, 50, "S");
        BotonSt->box(FL_PLASTIC_UP_BOX);
        BotonSt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonSt->color(FL_INACTIVE_COLOR);
        BotonSt->labelfont(8);
        BotonSt->labelsize(20);
        BotonSt->callback((Fl_Callback*)cb_BotonSt);
      } // Fl_Button* BotonSt
      { BotonDt = new Fl_Button(170, 430, 50, 50, "D");
        BotonDt->box(FL_PLASTIC_UP_BOX);
        BotonDt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonDt->color(FL_INACTIVE_COLOR);
        BotonDt->labelfont(8);
        BotonDt->labelsize(20);
        BotonDt->callback((Fl_Callback*)cb_BotonDt);
      } // Fl_Button* BotonDt
      { BotonFt = new Fl_Button(220, 430, 50, 50, "F");
        BotonFt->box(FL_PLASTIC_UP_BOX);
        BotonFt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonFt->color(FL_INACTIVE_COLOR);
        BotonFt->labelfont(8);
        BotonFt->labelsize(20);
        BotonFt->callback((Fl_Callback*)cb_BotonFt);
      } // Fl_Button* BotonFt
      { BotonGt = new Fl_Button(270, 430, 50, 50, "G");
        BotonGt->box(FL_PLASTIC_UP_BOX);
        BotonGt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonGt->color(FL_INACTIVE_COLOR);
        BotonGt->labelfont(8);
        BotonGt->labelsize(20);
        BotonGt->callback((Fl_Callback*)cb_BotonGt);
      } // Fl_Button* BotonGt
      { BotonHt = new Fl_Button(320, 430, 50, 50, "H");
        BotonHt->box(FL_PLASTIC_UP_BOX);
        BotonHt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonHt->color(FL_INACTIVE_COLOR);
        BotonHt->labelfont(8);
        BotonHt->labelsize(20);
        BotonHt->callback((Fl_Callback*)cb_BotonHt);
      } // Fl_Button* BotonHt
      { BotonJt = new Fl_Button(370, 430, 50, 50, "J");
        BotonJt->box(FL_PLASTIC_UP_BOX);
        BotonJt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonJt->color(FL_INACTIVE_COLOR);
        BotonJt->labelfont(8);
        BotonJt->labelsize(20);
        BotonJt->callback((Fl_Callback*)cb_BotonJt);
      } // Fl_Button* BotonJt
      { BotonKt = new Fl_Button(420, 430, 50, 50, "K");
        BotonKt->box(FL_PLASTIC_UP_BOX);
        BotonKt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonKt->color(FL_INACTIVE_COLOR);
        BotonKt->labelfont(8);
        BotonKt->labelsize(20);
        BotonKt->callback((Fl_Callback*)cb_BotonKt);
      } // Fl_Button* BotonKt
      { BotonLt = new Fl_Button(470, 430, 50, 50, "L");
        BotonLt->box(FL_PLASTIC_UP_BOX);
        BotonLt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonLt->color(FL_INACTIVE_COLOR);
        BotonLt->labelfont(8);
        BotonLt->labelsize(20);
        BotonLt->callback((Fl_Callback*)cb_BotonLt);
      } // Fl_Button* BotonLt
      { Fl_Button* o = BotonEnhet = new Fl_Button(520, 430, 50, 50, "\321");
        BotonEnhet->box(FL_PLASTIC_UP_BOX);
        BotonEnhet->down_box(FL_PLASTIC_DOWN_BOX);
        BotonEnhet->color(FL_INACTIVE_COLOR);
        BotonEnhet->labelfont(8);
        BotonEnhet->labelsize(20);
        BotonEnhet->callback((Fl_Callback*)cb_BotonEnhet);
        o->hide();// no se usa, problemas con el sistema de archivos
      } // Fl_Button* BotonEnhet
      { BotonXt = new Fl_Button(145, 480, 50, 50, "X");
        BotonXt->box(FL_PLASTIC_UP_BOX);
        BotonXt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonXt->color(FL_INACTIVE_COLOR);
        BotonXt->labelfont(8);
        BotonXt->labelsize(20);
        BotonXt->callback((Fl_Callback*)cb_BotonXt);
      } // Fl_Button* BotonXt
      { BotonCt = new Fl_Button(195, 480, 50, 50, "C");
        BotonCt->box(FL_PLASTIC_UP_BOX);
        BotonCt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonCt->color(FL_INACTIVE_COLOR);
        BotonCt->labelfont(8);
        BotonCt->labelsize(20);
        BotonCt->callback((Fl_Callback*)cb_BotonCt);
      } // Fl_Button* BotonCt
      { BotonVt = new Fl_Button(245, 480, 50, 50, "V");
        BotonVt->box(FL_PLASTIC_UP_BOX);
        BotonVt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonVt->color(FL_INACTIVE_COLOR);
        BotonVt->labelfont(8);
        BotonVt->labelsize(20);
        BotonVt->callback((Fl_Callback*)cb_BotonVt);
      } // Fl_Button* BotonVt
      { BotonBt = new Fl_Button(295, 480, 50, 50, "B");
        BotonBt->box(FL_PLASTIC_UP_BOX);
        BotonBt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonBt->color(FL_INACTIVE_COLOR);
        BotonBt->labelfont(8);
        BotonBt->labelsize(20);
        BotonBt->callback((Fl_Callback*)cb_BotonBt);
      } // Fl_Button* BotonBt
      { BotonNt = new Fl_Button(345, 480, 50, 50, "N");
        BotonNt->box(FL_PLASTIC_UP_BOX);
        BotonNt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonNt->color(FL_INACTIVE_COLOR);
        BotonNt->labelfont(8);
        BotonNt->labelsize(20);
        BotonNt->callback((Fl_Callback*)cb_BotonNt);
      } // Fl_Button* BotonNt
      { BotonMt = new Fl_Button(395, 480, 50, 50, "M");
        BotonMt->box(FL_PLASTIC_UP_BOX);
        BotonMt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonMt->color(FL_INACTIVE_COLOR);
        BotonMt->labelfont(8);
        BotonMt->labelsize(20);
        BotonMt->callback((Fl_Callback*)cb_BotonMt);
      } // Fl_Button* BotonMt
      { BotonZt = new Fl_Button(95, 480, 50, 50, "Z");
        BotonZt->box(FL_PLASTIC_UP_BOX);
        BotonZt->down_box(FL_PLASTIC_DOWN_BOX);
        BotonZt->color(FL_INACTIVE_COLOR);
        BotonZt->labelfont(8);
        BotonZt->labelsize(20);
        BotonZt->callback((Fl_Callback*)cb_BotonZt);
      } // Fl_Button* BotonZt
      { BotonEspaciot = new Fl_Button(120, 530, 350, 50, " ");
        BotonEspaciot->box(FL_PLASTIC_UP_BOX);
        BotonEspaciot->down_box(FL_PLASTIC_DOWN_BOX);
        BotonEspaciot->color(FL_INACTIVE_COLOR);
        BotonEspaciot->labelfont(8);
        BotonEspaciot->labelsize(20);
        BotonEspaciot->callback((Fl_Callback*)cb_BotonEspaciot);
      } // Fl_Button* BotonEspaciot
      { BotonMenost = new Fl_Button(445, 480, 50, 50, "-");
        BotonMenost->box(FL_PLASTIC_UP_BOX);
        BotonMenost->down_box(FL_PLASTIC_DOWN_BOX);
        BotonMenost->color(FL_INACTIVE_COLOR);
        BotonMenost->labelfont(8);
        BotonMenost->labelsize(20);
        BotonMenost->callback((Fl_Callback*)cb_BotonMenost);
      } // Fl_Button* BotonMenost
      GrupoTecladoTrabajos->end();
    } // Fl_Group* GrupoTecladoTrabajos
    { Fl_Button* o = Cargar_VentanaTrabajos = new Fl_Button(640, 340, 145, 75, "Cargar");
      Cargar_VentanaTrabajos->box(FL_PLASTIC_UP_BOX);
      Cargar_VentanaTrabajos->down_box(FL_PLASTIC_DOWN_BOX);
      Cargar_VentanaTrabajos->color(FL_FOREGROUND_COLOR);
      Cargar_VentanaTrabajos->labelfont(8);
      Cargar_VentanaTrabajos->labelsize(20);
      Cargar_VentanaTrabajos->callback((Fl_Callback*)cb_Cargar_VentanaTrabajos);
      switch (Idioma) {case ESP:o->label("Cargar");break; case ING:o->label("Load");break; case ITA:o->label("Carico");break;}
    } // Fl_Button* Cargar_VentanaTrabajos
    { Fl_Button* o = Guardar_VentanaTrabajos = new Fl_Button(640, 425, 145, 75, "Guardar");
      Guardar_VentanaTrabajos->box(FL_PLASTIC_UP_BOX);
      Guardar_VentanaTrabajos->down_box(FL_PLASTIC_DOWN_BOX);
      Guardar_VentanaTrabajos->color(FL_FOREGROUND_COLOR);
      Guardar_VentanaTrabajos->labelfont(8);
      Guardar_VentanaTrabajos->labelsize(20);
      Guardar_VentanaTrabajos->callback((Fl_Callback*)cb_Guardar_VentanaTrabajos);
      switch (Idioma) {case ESP:o->label("Guardar");break; case ING:o->label("Save");break; case ITA:o->label("Salvare");break;}
    } // Fl_Button* Guardar_VentanaTrabajos
    { Fl_Button* o = Cancelar_VentanaTrabajos = new Fl_Button(640, 510, 145, 75, "Cancelar");
      Cancelar_VentanaTrabajos->box(FL_PLASTIC_UP_BOX);
      Cancelar_VentanaTrabajos->down_box(FL_PLASTIC_DOWN_BOX);
      Cancelar_VentanaTrabajos->color(FL_FOREGROUND_COLOR);
      Cancelar_VentanaTrabajos->labelfont(8);
      Cancelar_VentanaTrabajos->labelsize(20);
      Cancelar_VentanaTrabajos->callback((Fl_Callback*)cb_Cancelar_VentanaTrabajos);
      switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
    } // Fl_Button* Cancelar_VentanaTrabajos
    { Fl_Button* o = Borrar_VentanaTrabajos = new Fl_Button(640, 200, 145, 75, "Borrar");
      Borrar_VentanaTrabajos->box(FL_PLASTIC_UP_BOX);
      Borrar_VentanaTrabajos->down_box(FL_PLASTIC_DOWN_BOX);
      Borrar_VentanaTrabajos->color(FL_RED);
      Borrar_VentanaTrabajos->labelfont(8);
      Borrar_VentanaTrabajos->labelsize(20);
      Borrar_VentanaTrabajos->callback((Fl_Callback*)cb_Borrar_VentanaTrabajos);
      switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Borrar");break;}
    } // Fl_Button* Borrar_VentanaTrabajos
    VentanaTrabajos->set_modal();
    VentanaTrabajos->clear_border();
    VentanaTrabajos->size_range(800, 600, 800, 600);
    VentanaTrabajos->end();
  } // Fl_Double_Window* VentanaTrabajos
  return VentanaTrabajos;
}

Fl_Double_Window *VentanaMensaje=(Fl_Double_Window *)0;

Fl_Box *BoxVentanaMensaje=(Fl_Box *)0;

Fl_Button *Aceptar_VentanaMensaje=(Fl_Button *)0;

static void cb_Aceptar_VentanaMensaje(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaMensaje->hide();

// Y vuelve a presentar la ventana activa desde donde se invocó el mensaje
switch (VentanaActiva) {

	case VPrincipal:
	VentanaPrincipal->activate();
	break;

	case VModificar:
	VentanaModificarTexto->activate();
	break;
	
	case VDetalles:
	VentanaDetallesLinea->activate();
	break;
	
	case VPassword:
	VentanaPassword->activate();
	break;

};
}

Fl_Double_Window* Make_Window_Mensaje() {
  { VentanaMensaje = new Fl_Double_Window(475, 230);
    VentanaMensaje->box(FL_NO_BOX);
    VentanaMensaje->color((Fl_Color)1);
    VentanaMensaje->selection_color((Fl_Color)1);
    VentanaMensaje->labelfont(8);
    VentanaMensaje->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 475, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)1);
      { BoxVentanaMensaje = new Fl_Box(10, 20, 450, 70);
        BoxVentanaMensaje->labelfont(8);
        BoxVentanaMensaje->labelsize(20);
        BoxVentanaMensaje->align(Fl_Align(FL_ALIGN_WRAP|FL_ALIGN_INSIDE));
      } // Fl_Box* BoxVentanaMensaje
      { Fl_Button* o = Aceptar_VentanaMensaje = new Fl_Button(165, 120, 150, 75, "Aceptar");
        Aceptar_VentanaMensaje->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaMensaje->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaMensaje->labelfont(8);
        Aceptar_VentanaMensaje->labelsize(20);
        Aceptar_VentanaMensaje->callback((Fl_Callback*)cb_Aceptar_VentanaMensaje);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaMensaje
      o->end();
    } // Fl_Group* o
    VentanaMensaje->set_modal();
    VentanaMensaje->clear_border();
    VentanaMensaje->end();
  } // Fl_Double_Window* VentanaMensaje
  return VentanaMensaje;
}

Fl_Double_Window *VentanaPassword=(Fl_Double_Window *)0;

Fl_Output *CuadroTextoPassword=(Fl_Output *)0;

Fl_Group *GrupoTecladop=(Fl_Group *)0;

Fl_Button *Boton1p=(Fl_Button *)0;

static void cb_Boton1p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "1");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton2p=(Fl_Button *)0;

static void cb_Boton2p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "2");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton3p=(Fl_Button *)0;

static void cb_Boton3p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "3");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton4p=(Fl_Button *)0;

static void cb_Boton4p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "4");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton5p=(Fl_Button *)0;

static void cb_Boton5p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "5");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton6p=(Fl_Button *)0;

static void cb_Boton6p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "6");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton7p=(Fl_Button *)0;

static void cb_Boton7p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "7");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton8p=(Fl_Button *)0;

static void cb_Boton8p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "8");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton9p=(Fl_Button *)0;

static void cb_Boton9p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "9");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Boton0p=(Fl_Button *)0;

static void cb_Boton0p(Fl_Button*, void*) {
  char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "0");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *BotonBorrarp=(Fl_Button *)0;

static void cb_BotonBorrarp(Fl_Button*, void*) {
  char txt[25];

// adelanta el carácter de fin de string un carácter, para borrar el último de la password
Password[strlen(Password) - 1] = '\0';

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// adelanta el carácter de fin de string un carácter, para borrar el último
txt[strlen(txt) - 1] = '\0';

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);
}

Fl_Button *Cancelar_VentanaPassword=(Fl_Button *)0;

static void cb_Cancelar_VentanaPassword(Fl_Button*, void*) {
  // Vacía el cuadro de texto, para evitar líos...
CuadroTextoPassword->value("");

// Oculta la ventana emergente actual
VentanaPassword->hide();

// Y vuelve a presentar la ventana principal
//VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Aceptar_VentanaPassword=(Fl_Button *)0;

static void cb_Aceptar_VentanaPassword(Fl_Button*, void*) {
  // Si la contraseña es correcta sale:
if (!strcmp(Password, PasswordUsuario)) {

	// Desactiva el control de acceso
	ControlAcceso = OFF;
 
	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoPassword->value("");

	// Y la password
	strcpy(Password, "");
	
	// Oculta la ventana emergente actual
	VentanaPassword->hide();

	// Y vuelve a presentar la ventana principal
	VentanaActiva = VPrincipal;
	VentanaPrincipal->activate();
	VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
	
	// Y lanza un time out para restaurar el control de acceso
	Fl::add_timeout(TIMEOUT_CONTROLACCESO, ActualizaControlAcceso);
	
}

// Si no, da un mensaje y vacía el cuadro de texto
else {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Contraseña incorrecta");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Wrong password");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Password errata");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaPassword->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoPassword->value("");
	
	// Y la password
	strcpy(Password, "");

};
}

Fl_Double_Window* Make_Window_Password() {
  { VentanaPassword = new Fl_Double_Window(460, 460);
    VentanaPassword->box(FL_BORDER_BOX);
    VentanaPassword->color((Fl_Color)46);
    VentanaPassword->selection_color(FL_BACKGROUND2_COLOR);
    VentanaPassword->when(FL_WHEN_RELEASE_ALWAYS);
    { Fl_Output* o = CuadroTextoPassword = new Fl_Output(50, 42, 355, 40, "Contrase\361""a:");
      CuadroTextoPassword->box(FL_PLASTIC_THIN_DOWN_BOX);
      CuadroTextoPassword->color((Fl_Color)175);
      CuadroTextoPassword->labelfont(8);
      CuadroTextoPassword->labelsize(20);
      CuadroTextoPassword->textsize(20);
      CuadroTextoPassword->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      switch (Idioma) {case ESP:o->label("Contraseña:");break; case ING:o->label("Password:");break; case ITA:o->label("Password:");break;}
    } // Fl_Output* CuadroTextoPassword
    { GrupoTecladop = new Fl_Group(50, 95, 355, 240);
      GrupoTecladop->box(FL_PLASTIC_UP_FRAME);
      GrupoTecladop->color(FL_FOREGROUND_COLOR);
      { Boton1p = new Fl_Button(150, 215, 50, 50, "1");
        Boton1p->box(FL_PLASTIC_UP_BOX);
        Boton1p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton1p->color(FL_INACTIVE_COLOR);
        Boton1p->labelsize(20);
        Boton1p->callback((Fl_Callback*)cb_Boton1p);
      } // Fl_Button* Boton1p
      { Boton2p = new Fl_Button(200, 215, 50, 50, "2");
        Boton2p->box(FL_PLASTIC_UP_BOX);
        Boton2p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton2p->color(FL_INACTIVE_COLOR);
        Boton2p->labelsize(20);
        Boton2p->callback((Fl_Callback*)cb_Boton2p);
      } // Fl_Button* Boton2p
      { Boton3p = new Fl_Button(250, 215, 50, 50, "3");
        Boton3p->box(FL_PLASTIC_UP_BOX);
        Boton3p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton3p->color(FL_INACTIVE_COLOR);
        Boton3p->labelsize(20);
        Boton3p->callback((Fl_Callback*)cb_Boton3p);
      } // Fl_Button* Boton3p
      { Boton4p = new Fl_Button(150, 165, 50, 50, "4");
        Boton4p->box(FL_PLASTIC_UP_BOX);
        Boton4p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton4p->color(FL_INACTIVE_COLOR);
        Boton4p->labelsize(20);
        Boton4p->callback((Fl_Callback*)cb_Boton4p);
      } // Fl_Button* Boton4p
      { Boton5p = new Fl_Button(200, 165, 50, 50, "5");
        Boton5p->box(FL_PLASTIC_UP_BOX);
        Boton5p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton5p->color(FL_INACTIVE_COLOR);
        Boton5p->labelsize(20);
        Boton5p->callback((Fl_Callback*)cb_Boton5p);
      } // Fl_Button* Boton5p
      { Boton6p = new Fl_Button(250, 165, 50, 50, "6");
        Boton6p->box(FL_PLASTIC_UP_BOX);
        Boton6p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton6p->color(FL_INACTIVE_COLOR);
        Boton6p->labelsize(20);
        Boton6p->callback((Fl_Callback*)cb_Boton6p);
      } // Fl_Button* Boton6p
      { Boton7p = new Fl_Button(150, 115, 50, 50, "7");
        Boton7p->box(FL_PLASTIC_UP_BOX);
        Boton7p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton7p->color(FL_INACTIVE_COLOR);
        Boton7p->labelsize(20);
        Boton7p->callback((Fl_Callback*)cb_Boton7p);
      } // Fl_Button* Boton7p
      { Boton8p = new Fl_Button(200, 115, 50, 50, "8");
        Boton8p->box(FL_PLASTIC_UP_BOX);
        Boton8p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton8p->color(FL_INACTIVE_COLOR);
        Boton8p->labelsize(20);
        Boton8p->callback((Fl_Callback*)cb_Boton8p);
      } // Fl_Button* Boton8p
      { Boton9p = new Fl_Button(250, 115, 50, 50, "9");
        Boton9p->box(FL_PLASTIC_UP_BOX);
        Boton9p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton9p->color(FL_INACTIVE_COLOR);
        Boton9p->labelsize(20);
        Boton9p->callback((Fl_Callback*)cb_Boton9p);
      } // Fl_Button* Boton9p
      { Boton0p = new Fl_Button(150, 265, 50, 50, "0");
        Boton0p->box(FL_PLASTIC_UP_BOX);
        Boton0p->down_box(FL_PLASTIC_DOWN_BOX);
        Boton0p->color(FL_INACTIVE_COLOR);
        Boton0p->labelsize(20);
        Boton0p->callback((Fl_Callback*)cb_Boton0p);
      } // Fl_Button* Boton0p
      { Fl_Button* o = BotonBorrarp = new Fl_Button(200, 265, 100, 50, "Borrar");
        BotonBorrarp->box(FL_PLASTIC_UP_BOX);
        BotonBorrarp->down_box(FL_PLASTIC_DOWN_BOX);
        BotonBorrarp->color(FL_INACTIVE_COLOR);
        BotonBorrarp->labelsize(17);
        BotonBorrarp->callback((Fl_Callback*)cb_BotonBorrarp);
        switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}
      } // Fl_Button* BotonBorrarp
      GrupoTecladop->end();
    } // Fl_Group* GrupoTecladop
    { Fl_Button* o = Cancelar_VentanaPassword = new Fl_Button(270, 360, 135, 75, "Cancelar");
      Cancelar_VentanaPassword->box(FL_PLASTIC_UP_BOX);
      Cancelar_VentanaPassword->down_box(FL_PLASTIC_DOWN_BOX);
      Cancelar_VentanaPassword->color(FL_FOREGROUND_COLOR);
      Cancelar_VentanaPassword->labelfont(8);
      Cancelar_VentanaPassword->labelsize(20);
      Cancelar_VentanaPassword->callback((Fl_Callback*)cb_Cancelar_VentanaPassword);
      switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
    } // Fl_Button* Cancelar_VentanaPassword
    { Fl_Button* o = Aceptar_VentanaPassword = new Fl_Button(50, 360, 135, 75, "Aceptar");
      Aceptar_VentanaPassword->box(FL_PLASTIC_UP_BOX);
      Aceptar_VentanaPassword->down_box(FL_PLASTIC_DOWN_BOX);
      Aceptar_VentanaPassword->color(FL_FOREGROUND_COLOR);
      Aceptar_VentanaPassword->labelfont(8);
      Aceptar_VentanaPassword->labelsize(20);
      Aceptar_VentanaPassword->callback((Fl_Callback*)cb_Aceptar_VentanaPassword);
      switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
    } // Fl_Button* Aceptar_VentanaPassword
    VentanaPassword->set_modal();
    VentanaPassword->clear_border();
    VentanaPassword->size_range(460, 460, 460, 460);
    VentanaPassword->end();
    VentanaPassword->resizable(VentanaPassword);
  } // Fl_Double_Window* VentanaPassword
  return VentanaPassword;
}

Fl_Double_Window *VentanaConfirmarCargarTrabajo=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaConfirmarCargarTrabajo=(Fl_Button *)0;

static void cb_Aceptar_VentanaConfirmarCargarTrabajo(Fl_Button*, void*) {
  char str[50];

// Carga los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el índice del trabajo seleccionado
	ValorTrabajo = FileBrowserArchivosTrabajos->value();
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	Leer_DAT(str);
	
	// Inicializa los widgets con los nuevos valores
	Inicializar_Widgets();
	
	// Y los parámetros de marcaje
	Inicializar_Marcaje();
	
}

// Oculta la ventana emergente actual
VentanaConfirmarCargarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Cancelar_VentanaConfirmarCargarTrabajo=(Fl_Button *)0;

static void cb_Cancelar_VentanaConfirmarCargarTrabajo(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaConfirmarCargarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();
}

Fl_Double_Window* Make_Window_Confirmar_CargarTrabajo() {
  { VentanaConfirmarCargarTrabajo = new Fl_Double_Window(460, 230);
    VentanaConfirmarCargarTrabajo->box(FL_BORDER_FRAME);
    VentanaConfirmarCargarTrabajo->color((Fl_Color)1);
    VentanaConfirmarCargarTrabajo->selection_color((Fl_Color)1);
    VentanaConfirmarCargarTrabajo->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)1);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277""Cargar el trabajo?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Cargar el trabajo?");break; case ING:o->label("Load the job file?");break; case ITA:o->label("Caricare file di lavoro?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaConfirmarCargarTrabajo = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaConfirmarCargarTrabajo->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaConfirmarCargarTrabajo->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaConfirmarCargarTrabajo->labelfont(8);
        Aceptar_VentanaConfirmarCargarTrabajo->labelsize(20);
        Aceptar_VentanaConfirmarCargarTrabajo->callback((Fl_Callback*)cb_Aceptar_VentanaConfirmarCargarTrabajo);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaConfirmarCargarTrabajo
      { Fl_Button* o = Cancelar_VentanaConfirmarCargarTrabajo = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaConfirmarCargarTrabajo->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaConfirmarCargarTrabajo->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaConfirmarCargarTrabajo->labelfont(8);
        Cancelar_VentanaConfirmarCargarTrabajo->labelsize(20);
        Cancelar_VentanaConfirmarCargarTrabajo->callback((Fl_Callback*)cb_Cancelar_VentanaConfirmarCargarTrabajo);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaConfirmarCargarTrabajo
      o->end();
    } // Fl_Group* o
    VentanaConfirmarCargarTrabajo->set_modal();
    VentanaConfirmarCargarTrabajo->clear_border();
    VentanaConfirmarCargarTrabajo->end();
  } // Fl_Double_Window* VentanaConfirmarCargarTrabajo
  return VentanaConfirmarCargarTrabajo;
}

Fl_Double_Window *VentanaConfirmarGuardarTrabajo=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaConfirmarGuardarTrabajo=(Fl_Button *)0;

static void cb_Aceptar_VentanaConfirmarGuardarTrabajo(Fl_Button* o, void*) {
  char str[50];
char str2[100];
int i;

// Guarda los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	Escribir_DAT(str);
	sprintf(str2,"cp %s %s", str, "/rootFLS/itaca/");
	system("mount / -o rw,remount");
	system(str2);
	system("mount / -o ro,remount");
	
	// Refresca el file browser
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"
	
	// Y deja seleccionada la opción correspondiente al trabajo que se acaba de guardar
	for (i=1; i<=FileBrowserArchivosTrabajos->size(); i++) {
			
		// si son iguales los nombres, hay que seleccionar esa entrada
		if (strcmp(str, FileBrowserArchivosTrabajos->text(i)) == 0) {
			FileBrowserArchivosTrabajos->select(i);	
			ValorTrabajo = i;
		}
		
	}
	
}

// Oculta la ventana emergente actual
VentanaConfirmarGuardarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Cancelar_VentanaConfirmarGuardarTrabajo=(Fl_Button *)0;

static void cb_Cancelar_VentanaConfirmarGuardarTrabajo(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaConfirmarGuardarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();
}

Fl_Double_Window* Make_Window_Confirmar_GuardarTrabajo() {
  { VentanaConfirmarGuardarTrabajo = new Fl_Double_Window(460, 230);
    VentanaConfirmarGuardarTrabajo->box(FL_BORDER_FRAME);
    VentanaConfirmarGuardarTrabajo->color((Fl_Color)1);
    VentanaConfirmarGuardarTrabajo->selection_color((Fl_Color)1);
    VentanaConfirmarGuardarTrabajo->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)1);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277Guardar el trabajo?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Guardar el trabajo?");break; case ING:o->label("Save the job file?");break; case ITA:o->label("Salvare file di lavoro?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaConfirmarGuardarTrabajo = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaConfirmarGuardarTrabajo->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaConfirmarGuardarTrabajo->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaConfirmarGuardarTrabajo->labelfont(8);
        Aceptar_VentanaConfirmarGuardarTrabajo->labelsize(20);
        Aceptar_VentanaConfirmarGuardarTrabajo->callback((Fl_Callback*)cb_Aceptar_VentanaConfirmarGuardarTrabajo);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaConfirmarGuardarTrabajo
      { Fl_Button* o = Cancelar_VentanaConfirmarGuardarTrabajo = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaConfirmarGuardarTrabajo->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaConfirmarGuardarTrabajo->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaConfirmarGuardarTrabajo->labelfont(8);
        Cancelar_VentanaConfirmarGuardarTrabajo->labelsize(20);
        Cancelar_VentanaConfirmarGuardarTrabajo->callback((Fl_Callback*)cb_Cancelar_VentanaConfirmarGuardarTrabajo);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaConfirmarGuardarTrabajo
      o->end();
    } // Fl_Group* o
    VentanaConfirmarGuardarTrabajo->set_modal();
    VentanaConfirmarGuardarTrabajo->clear_border();
    VentanaConfirmarGuardarTrabajo->end();
  } // Fl_Double_Window* VentanaConfirmarGuardarTrabajo
  return VentanaConfirmarGuardarTrabajo;
}

Fl_Double_Window *VentanaConfirmarBorrarTrabajo=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaConfirmarBorrarTrabajo=(Fl_Button *)0;

static void cb_Aceptar_VentanaConfirmarBorrarTrabajo(Fl_Button* o, void*) {
  char str[50];
char stra[50];
char str2[100];
char stra2[100];
int i;

// Guarda los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, "/root/itaca/");
	strcat(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	strcpy(stra, "/rootFLS/itaca/");
	strcat(stra, CuadroTextoTrabajo->value());
	strcat(stra, ".trb");
	//Escribir_DAT(str);
	sprintf(str2,"rm %s", str);
	sprintf(stra2, "rm %s",stra);
	system ("mount / -o rw,remount");
	system(str2);
	system(stra2);
	system("mount / -o ro,remount");
	
	// Refresca el file browser
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"
	
	// Y deja seleccionada la opción correspondiente al trabajo que se acaba de guardar
	for (i=1; i<=FileBrowserArchivosTrabajos->size(); i++) {
			
		// si son iguales los nombres, hay que seleccionar esa entrada
		if (strcmp(str, FileBrowserArchivosTrabajos->text(i)) == 0) {
			FileBrowserArchivosTrabajos->select(i);	
			ValorTrabajo = i;
		}
		
	}
	
}

// Oculta la ventana emergente actual
VentanaConfirmarBorrarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Cada vez que se carga la ventana se debe borrar el texto del cuadro
CuadroTextoTrabajo->value("");

// Oculta la ventana emergente actual
//VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
//VentanaActiva = VPrincipal;
//VentanaPrincipal->activate();
//VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Cancelar_VentanaConfirmarBorrarTrabajo=(Fl_Button *)0;

static void cb_Cancelar_VentanaConfirmarBorrarTrabajo(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaConfirmarBorrarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();
}

Fl_Double_Window* Make_Window_Confirmar_BorrarTrabajo() {
  { VentanaConfirmarBorrarTrabajo = new Fl_Double_Window(460, 230);
    VentanaConfirmarBorrarTrabajo->box(FL_BORDER_FRAME);
    VentanaConfirmarBorrarTrabajo->color((Fl_Color)1);
    VentanaConfirmarBorrarTrabajo->selection_color((Fl_Color)1);
    VentanaConfirmarBorrarTrabajo->labelcolor(FL_BACKGROUND2_COLOR);
    { Fl_Group* o = new Fl_Group(0, 0, 460, 230);
      o->box(FL_PLASTIC_THIN_DOWN_BOX);
      o->color((Fl_Color)1);
      { Fl_Box* o = new Fl_Box(55, 28, 345, 42, "\277""Cargar el trabajo?");
        o->color((Fl_Color)175);
        o->labelfont(9);
        o->labelsize(22);
        switch (Idioma) {case ESP:o->label("¿Borrar el trabajo?");break; case ING:o->label("Delete the job file?");break; case ITA:o->label("Borrare file di lavoro?");break;}
      } // Fl_Box* o
      { Fl_Button* o = Aceptar_VentanaConfirmarBorrarTrabajo = new Fl_Button(55, 99, 150, 75, "Aceptar");
        Aceptar_VentanaConfirmarBorrarTrabajo->box(FL_PLASTIC_UP_BOX);
        Aceptar_VentanaConfirmarBorrarTrabajo->color(FL_FOREGROUND_COLOR);
        Aceptar_VentanaConfirmarBorrarTrabajo->labelfont(8);
        Aceptar_VentanaConfirmarBorrarTrabajo->labelsize(20);
        Aceptar_VentanaConfirmarBorrarTrabajo->callback((Fl_Callback*)cb_Aceptar_VentanaConfirmarBorrarTrabajo);
        switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
      } // Fl_Button* Aceptar_VentanaConfirmarBorrarTrabajo
      { Fl_Button* o = Cancelar_VentanaConfirmarBorrarTrabajo = new Fl_Button(250, 99, 150, 75, "Cancelar");
        Cancelar_VentanaConfirmarBorrarTrabajo->box(FL_PLASTIC_UP_BOX);
        Cancelar_VentanaConfirmarBorrarTrabajo->color(FL_FOREGROUND_COLOR);
        Cancelar_VentanaConfirmarBorrarTrabajo->labelfont(8);
        Cancelar_VentanaConfirmarBorrarTrabajo->labelsize(20);
        Cancelar_VentanaConfirmarBorrarTrabajo->callback((Fl_Callback*)cb_Cancelar_VentanaConfirmarBorrarTrabajo);
        switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
      } // Fl_Button* Cancelar_VentanaConfirmarBorrarTrabajo
      o->end();
    } // Fl_Group* o
    VentanaConfirmarBorrarTrabajo->set_modal();
    VentanaConfirmarBorrarTrabajo->clear_border();
    VentanaConfirmarBorrarTrabajo->end();
  } // Fl_Double_Window* VentanaConfirmarBorrarTrabajo
  return VentanaConfirmarBorrarTrabajo;
}

Fl_Double_Window *VentanaFPGA=(Fl_Double_Window *)0;

Fl_Button *Aceptar_VentanaFPGA=(Fl_Button *)0;

static void cb_Aceptar_VentanaFPGA(Fl_Button*, void*) {
  // Oculta la ventana emergente actual
VentanaFPGA->hide();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->show();
}

Fl_Button *LaserOn=(Fl_Button *)0;

static void cb_LaserOn(Fl_Button*, void*) {
  outb((COMANDO_LASER|0x01), REGISTRO_ADDR);
}

Fl_Button *LaserOff=(Fl_Button *)0;

static void cb_LaserOff(Fl_Button*, void*) {
  outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
}

Fl_Button *TicksUp=(Fl_Button *)0;

static void cb_TicksUp(Fl_Button*, void*) {
  // Primero paramos el láser, para que no se líe la cuenta en la FPGA
//outb(COMANDO_LASER_OFF, REGISTRO_ADDR);

// Ticks Laser Up:

// Byte menos significativo (LSB)
outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);

//printf("Laser_Up_Ticks=%d	Laser_Up_Ticks & 0x00FF=%d\n", Laser_Up_Ticks, Laser_Up_Ticks & 0x00FF);

// comando LSB
outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);

// Byte más significativo (MSB)
outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

//printf("Laser_Up_Ticks>>8=%d	(Laser_Up_Ticks >> 8) & 0x00FF=%d\n", Laser_Up_Ticks >> 8, (Laser_Up_Ticks >> 8) & 0x00FF);

// comando MSB
outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);
}

Fl_Button *TicksDown=(Fl_Button *)0;

static void cb_TicksDown(Fl_Button*, void*) {
  // Primero paramos el láser, para que no se líe la cuenta en la FPGA
//outb(COMANDO_LASER_OFF, REGISTRO_ADDR);

// Ticks Laser Down:

// Byte menos significativo (LSB)
outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);

//printf("Laser_Down_Ticks=%d	Laser_Down_Ticks & 0x00FF=%d\n", Laser_Down_Ticks, Laser_Down_Ticks & 0x00FF);

// comando LSB
outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);

// Byte más significativo (MSB)
outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

//printf("Laser_Down_Ticks>>8=%d	(Laser_Down_Ticks >> 8) & 0x00FF=%d\n", Laser_Down_Ticks >> 8, (Laser_Down_Ticks >> 8) & 0x00FF);

// comando MSB
outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);
}

Fl_Button *GalvosOn=(Fl_Button *)0;

static void cb_GalvosOn(Fl_Button*, void*) {
  outb((COMANDO_GALVOS|0x01), REGISTRO_ADDR);
}

Fl_Button *GalvosOff=(Fl_Button *)0;

static void cb_GalvosOff(Fl_Button*, void*) {
  outb((COMANDO_GALVOS|0x00), REGISTRO_ADDR);
}

Fl_Button *ControlOn=(Fl_Button *)0;

static void cb_ControlOn(Fl_Button*, void*) {
  outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);
}

Fl_Button *ControlOff=(Fl_Button *)0;

static void cb_ControlOff(Fl_Button*, void*) {
  outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);
}

Fl_Button *LaserEnableOn=(Fl_Button *)0;

static void cb_LaserEnableOn(Fl_Button*, void*) {
  outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);
}

Fl_Button *LaserEnableOff=(Fl_Button *)0;

static void cb_LaserEnableOff(Fl_Button*, void*) {
  outb((COMANDO_LASER_ENABLE|0x00), REGISTRO_ADDR);
}

Fl_Button *ExtractorOn=(Fl_Button *)0;

static void cb_ExtractorOn(Fl_Button*, void*) {
  outb((COMANDO_EXTRACTOR|0x01), REGISTRO_ADDR);
}

Fl_Button *ExtractorOff=(Fl_Button *)0;

static void cb_ExtractorOff(Fl_Button*, void*) {
  outb((COMANDO_EXTRACTOR|0x00), REGISTRO_ADDR);
}

Fl_Button *MarkInProgressOn=(Fl_Button *)0;

static void cb_MarkInProgressOn(Fl_Button*, void*) {
  outb((COMANDO_MARK_IN_PROGRESS|0x01), REGISTRO_ADDR);
}

Fl_Button *MarkInProgressOff=(Fl_Button *)0;

static void cb_MarkInProgressOff(Fl_Button*, void*) {
  outb((COMANDO_MARK_IN_PROGRESS|0x00), REGISTRO_ADDR);
}

Fl_Button *Unconfigure=(Fl_Button *)0;

static void cb_Unconfigure(Fl_Button*, void*) {
  outb((COMANDO_ADMIN_FPGA|ARG_UNCONFIGURE_FPGA), REGISTRO_ADDR);
}

Fl_Button *Reset=(Fl_Button *)0;

static void cb_Reset(Fl_Button*, void*) {
  outb((COMANDO_ADMIN_FPGA|ARG_RESET_IO), REGISTRO_ADDR);
}

Fl_Button *EncoderOn=(Fl_Button *)0;

static void cb_EncoderOn(Fl_Button*, void*) {
  outb((COMANDO_ENCODER|0x01), REGISTRO_ADDR);
}

Fl_Button *EncoderOff=(Fl_Button *)0;

static void cb_EncoderOff(Fl_Button*, void*) {
  outb((COMANDO_ENCODER|0x00), REGISTRO_ADDR);
}

Fl_Value_Output *CuentasEncoder=(Fl_Value_Output *)0;

Fl_Button *LeerEncoder=(Fl_Button *)0;

static void cb_LeerEncoder(Fl_Button*, void*) {
  // Lee las cuentas del encoder
unsigned short cuentas;
//RTIME t0, t1;

// Manda el comando a la FPGA
// Con este comando se copia el valor de las cuentas del encoder en la FPGA (8 bits)

//t0=rt_get_cpu_time_ns();
outb(COMANDO_LEER_CUENTAS_ENCODER, REGISTRO_ADDR);
//t1=rt_get_cpu_time_ns();
//rt_printk("Encoder outb:%f ", float(t1-t0)/1000.0);

// Lee el byteo
//t0=rt_get_cpu_time_ns();
cuentas = inb(REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("inb:%f\n", float(t1-t0)/1000.0);

// Y lo presenta:
CuentasEncoder->value(cuentas);
}

Fl_Value_Output *Fotocelula=(Fl_Value_Output *)0;

Fl_Button *LeerFotocelula=(Fl_Button *)0;

static void cb_LeerFotocelula(Fl_Button*, void*) {
  BYTE inbyte, valor;

inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\n", inbyte);

// En la fotocélula se lee -con la máscara- 32 cuando está conectada a tierra, y 0 cuando está
// conectada a 5V

if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {valor = 0;}
else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {valor = 1;}
else valor = -1; // error

// Lee la señal de la fotocélula
//Fotocelula->value(inb(REGISTRO_STATUS) & MASCARA_ENTRADA_FOTOCELULA);

Fotocelula->value(valor);
}

Fl_Value_Output *LaserOk=(Fl_Value_Output *)0;

Fl_Button *LeerLaserOk=(Fl_Button *)0;

static void cb_LeerLaserOk(Fl_Button*, void*) {
  BYTE inbyte, valor;

// Redirige la entrada de Laser Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_LASER_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

LaserOk->value(valor);
}

Fl_Value_Output *TemperaturaOk=(Fl_Value_Output *)0;

Fl_Button *LeerTemperaturaOk=(Fl_Button *)0;

static void cb_LeerTemperaturaOk(Fl_Button*, void*) {
  BYTE inbyte, valor;

// Redirige la entrada de Temperatura Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_TEMPERATURA_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

TemperaturaOk->value(valor);
}

Fl_Value_Output *ExtractorOk=(Fl_Value_Output *)0;

Fl_Button *LeerExtractorOk=(Fl_Button *)0;

static void cb_LeerExtractorOk(Fl_Button*, void*) {
  BYTE inbyte, valor;

// Redirige la entrada de Extractor Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_EXTRACTOR_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

ExtractorOk->value(valor);
}

Fl_Button *LeeGalvoX=(Fl_Button *)0;

static void cb_LeeGalvoX(Fl_Button*, void*) {
  /*
unsigned short posicion;
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;

// Y lo presenta:
GalvoX->value(posicion);
*/;
}

Fl_Value_Output *GalvoX=(Fl_Value_Output *)0;

Fl_Button *LeeGalvoY=(Fl_Button *)0;

static void cb_LeeGalvoY(Fl_Button*, void*) {
  /*
unsigned short posicion;
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;

// Y lo presenta:
GalvoY->value(posicion);
*/;
}

Fl_Value_Output *GalvoY=(Fl_Value_Output *)0;

Fl_Counter *FPGAEscribirGalvoX=(Fl_Counter *)0;

static void cb_FPGAEscribirGalvoX(Fl_Counter*, void*) {
  BYTE LSB_byte, comando;
short valor;
RTIME t0, t1;

valor = FPGA_from_phys(FPGAEscribirGalvoX->value());

rt_printk("X: valor=%d ", valor);

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_X | ((valor >> 8) & 0x000F));

t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
t1=rt_get_cpu_time_ns();
rt_printk("t=%f\n", float(t1-t0)/1000.0);
}

Fl_Counter *FPGAEscribirGalvoY=(Fl_Counter *)0;

static void cb_FPGAEscribirGalvoY(Fl_Counter*, void*) {
  BYTE LSB_byte, comando;
short valor;
RTIME t0, t1;

valor = FPGA_from_phys(FPGAEscribirGalvoY->value());

rt_printk("Y: valor=%d ", valor);

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_Y | ((valor >> 8) & 0x000F));

t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
t1=rt_get_cpu_time_ns();
rt_printk("t=%f\n", float(t1-t0)/1000.0);
}

Fl_Double_Window* Make_Window_FPGA() {
  { VentanaFPGA = new Fl_Double_Window(800, 600);
    VentanaFPGA->color((Fl_Color)5);
    VentanaFPGA->selection_color(FL_BACKGROUND2_COLOR);
    VentanaFPGA->when(FL_WHEN_RELEASE_ALWAYS);
    { Aceptar_VentanaFPGA = new Fl_Button(640, 510, 145, 75, "Aceptar");
      Aceptar_VentanaFPGA->box(FL_PLASTIC_UP_BOX);
      Aceptar_VentanaFPGA->down_box(FL_PLASTIC_DOWN_BOX);
      Aceptar_VentanaFPGA->color(FL_FOREGROUND_COLOR);
      Aceptar_VentanaFPGA->labelfont(8);
      Aceptar_VentanaFPGA->labelsize(20);
      Aceptar_VentanaFPGA->callback((Fl_Callback*)cb_Aceptar_VentanaFPGA);
    } // Fl_Button* Aceptar_VentanaFPGA
    { LaserOn = new Fl_Button(20, 120, 150, 25, "Laser On");
      LaserOn->color((Fl_Color)31);
      LaserOn->callback((Fl_Callback*)cb_LaserOn);
    } // Fl_Button* LaserOn
    { LaserOff = new Fl_Button(175, 120, 150, 25, "Laser Off");
      LaserOff->color((Fl_Color)31);
      LaserOff->callback((Fl_Callback*)cb_LaserOff);
    } // Fl_Button* LaserOff
    { TicksUp = new Fl_Button(20, 90, 150, 25, "Ticks Up");
      TicksUp->color((Fl_Color)31);
      TicksUp->callback((Fl_Callback*)cb_TicksUp);
    } // Fl_Button* TicksUp
    { TicksDown = new Fl_Button(175, 90, 150, 25, "Ticks Down");
      TicksDown->color((Fl_Color)31);
      TicksDown->callback((Fl_Callback*)cb_TicksDown);
    } // Fl_Button* TicksDown
    { GalvosOn = new Fl_Button(20, 170, 150, 25, "Galvos On");
      GalvosOn->color((Fl_Color)31);
      GalvosOn->callback((Fl_Callback*)cb_GalvosOn);
    } // Fl_Button* GalvosOn
    { GalvosOff = new Fl_Button(175, 170, 150, 25, "Galvos Off");
      GalvosOff->color((Fl_Color)31);
      GalvosOff->callback((Fl_Callback*)cb_GalvosOff);
    } // Fl_Button* GalvosOff
    { ControlOn = new Fl_Button(20, 205, 150, 25, "Control On");
      ControlOn->color((Fl_Color)31);
      ControlOn->callback((Fl_Callback*)cb_ControlOn);
    } // Fl_Button* ControlOn
    { ControlOff = new Fl_Button(175, 205, 150, 25, "Control Off");
      ControlOff->color((Fl_Color)31);
      ControlOff->callback((Fl_Callback*)cb_ControlOff);
    } // Fl_Button* ControlOff
    { LaserEnableOn = new Fl_Button(20, 60, 150, 25, "Laser Enable On");
      LaserEnableOn->color((Fl_Color)31);
      LaserEnableOn->labelsize(12);
      LaserEnableOn->callback((Fl_Callback*)cb_LaserEnableOn);
    } // Fl_Button* LaserEnableOn
    { LaserEnableOff = new Fl_Button(175, 60, 150, 25, "Laser Enable Off");
      LaserEnableOff->color((Fl_Color)31);
      LaserEnableOff->labelsize(12);
      LaserEnableOff->callback((Fl_Callback*)cb_LaserEnableOff);
    } // Fl_Button* LaserEnableOff
    { ExtractorOn = new Fl_Button(20, 240, 150, 25, "Extractor On");
      ExtractorOn->color((Fl_Color)31);
      ExtractorOn->callback((Fl_Callback*)cb_ExtractorOn);
    } // Fl_Button* ExtractorOn
    { ExtractorOff = new Fl_Button(175, 240, 150, 25, "Extractor Off");
      ExtractorOff->color((Fl_Color)31);
      ExtractorOff->callback((Fl_Callback*)cb_ExtractorOff);
    } // Fl_Button* ExtractorOff
    { MarkInProgressOn = new Fl_Button(20, 275, 150, 25, "Mark In Progress On");
      MarkInProgressOn->color((Fl_Color)31);
      MarkInProgressOn->labelsize(12);
      MarkInProgressOn->callback((Fl_Callback*)cb_MarkInProgressOn);
    } // Fl_Button* MarkInProgressOn
    { MarkInProgressOff = new Fl_Button(175, 275, 150, 25, "Mark In Progress Off");
      MarkInProgressOff->color((Fl_Color)31);
      MarkInProgressOff->labelsize(12);
      MarkInProgressOff->callback((Fl_Callback*)cb_MarkInProgressOff);
    } // Fl_Button* MarkInProgressOff
    { Unconfigure = new Fl_Button(20, 15, 150, 25, "Unconfigure FPGA");
      Unconfigure->color((Fl_Color)31);
      Unconfigure->callback((Fl_Callback*)cb_Unconfigure);
    } // Fl_Button* Unconfigure
    { Reset = new Fl_Button(175, 15, 150, 25, "Reset FPGA");
      Reset->color((Fl_Color)31);
      Reset->callback((Fl_Callback*)cb_Reset);
    } // Fl_Button* Reset
    { EncoderOn = new Fl_Button(20, 345, 150, 25, "Encoder On");
      EncoderOn->color((Fl_Color)31);
      EncoderOn->callback((Fl_Callback*)cb_EncoderOn);
    } // Fl_Button* EncoderOn
    { EncoderOff = new Fl_Button(175, 345, 150, 25, "Encoder Off");
      EncoderOff->color((Fl_Color)31);
      EncoderOff->callback((Fl_Callback*)cb_EncoderOff);
    } // Fl_Button* EncoderOff
    { CuentasEncoder = new Fl_Value_Output(175, 375, 150, 25);
      CuentasEncoder->color((Fl_Color)31);
    } // Fl_Value_Output* CuentasEncoder
    { LeerEncoder = new Fl_Button(20, 375, 150, 25, "Leer Encoder:");
      LeerEncoder->color((Fl_Color)31);
      LeerEncoder->callback((Fl_Callback*)cb_LeerEncoder);
    } // Fl_Button* LeerEncoder
    { Fotocelula = new Fl_Value_Output(175, 425, 150, 25);
      Fotocelula->color((Fl_Color)31);
    } // Fl_Value_Output* Fotocelula
    { LeerFotocelula = new Fl_Button(20, 425, 150, 25, "Leer Fotocelula:");
      LeerFotocelula->color((Fl_Color)31);
      LeerFotocelula->callback((Fl_Callback*)cb_LeerFotocelula);
    } // Fl_Button* LeerFotocelula
    { LaserOk = new Fl_Value_Output(175, 455, 150, 25);
      LaserOk->color((Fl_Color)31);
    } // Fl_Value_Output* LaserOk
    { LeerLaserOk = new Fl_Button(20, 455, 150, 25, "Leer Laser Ok:");
      LeerLaserOk->color((Fl_Color)31);
      LeerLaserOk->callback((Fl_Callback*)cb_LeerLaserOk);
    } // Fl_Button* LeerLaserOk
    { TemperaturaOk = new Fl_Value_Output(175, 485, 150, 25);
      TemperaturaOk->color((Fl_Color)31);
    } // Fl_Value_Output* TemperaturaOk
    { LeerTemperaturaOk = new Fl_Button(20, 485, 150, 25, "Leer Temp. Ok:");
      LeerTemperaturaOk->color((Fl_Color)31);
      LeerTemperaturaOk->callback((Fl_Callback*)cb_LeerTemperaturaOk);
    } // Fl_Button* LeerTemperaturaOk
    { ExtractorOk = new Fl_Value_Output(175, 515, 150, 25);
      ExtractorOk->color((Fl_Color)31);
    } // Fl_Value_Output* ExtractorOk
    { LeerExtractorOk = new Fl_Button(20, 515, 150, 25, "Leer Extractor Ok:");
      LeerExtractorOk->color((Fl_Color)31);
      LeerExtractorOk->callback((Fl_Callback*)cb_LeerExtractorOk);
    } // Fl_Button* LeerExtractorOk
    { LeeGalvoX = new Fl_Button(455, 115, 150, 25, "Leer Galvo X:");
      LeeGalvoX->callback((Fl_Callback*)cb_LeeGalvoX);
    } // Fl_Button* LeeGalvoX
    { GalvoX = new Fl_Value_Output(610, 115, 150, 25);
    } // Fl_Value_Output* GalvoX
    { LeeGalvoY = new Fl_Button(455, 240, 150, 25, "Leer Galvo Y:");
      LeeGalvoY->callback((Fl_Callback*)cb_LeeGalvoY);
    } // Fl_Button* LeeGalvoY
    { GalvoY = new Fl_Value_Output(610, 240, 150, 25);
    } // Fl_Value_Output* GalvoY
    { Fl_Counter* o = FPGAEscribirGalvoX = new Fl_Counter(520, 70, 240, 35, "Galvo X:");
      FPGAEscribirGalvoX->minimum(-10);
      FPGAEscribirGalvoX->maximum(10);
      FPGAEscribirGalvoX->callback((Fl_Callback*)cb_FPGAEscribirGalvoX);
      FPGAEscribirGalvoX->align(Fl_Align(FL_ALIGN_LEFT));
      o->value(-10.0);
    } // Fl_Counter* FPGAEscribirGalvoX
    { Fl_Counter* o = FPGAEscribirGalvoY = new Fl_Counter(520, 195, 240, 35, "Galvo Y:");
      FPGAEscribirGalvoY->minimum(-10);
      FPGAEscribirGalvoY->maximum(10);
      FPGAEscribirGalvoY->callback((Fl_Callback*)cb_FPGAEscribirGalvoY);
      FPGAEscribirGalvoY->align(Fl_Align(FL_ALIGN_LEFT));
      o->value(-10.0);
    } // Fl_Counter* FPGAEscribirGalvoY
    VentanaFPGA->set_modal();
    VentanaFPGA->clear_border();
    VentanaFPGA->size_range(800, 600, 800, 600);
    VentanaFPGA->end();
  } // Fl_Double_Window* VentanaFPGA
  return VentanaFPGA;
}

Fl_Double_Window *VentanaRepeticiones=(Fl_Double_Window *)0;

Fl_Group *GrupoFilas=(Fl_Group *)0;

Fl_Counter *IndicadorFilas=(Fl_Counter *)0;

static void cb_IndicadorFilas(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el número de filas
	NumeroFilas = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(NumeroFilas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorSeparacionFilas=(Fl_Counter *)0;

static void cb_IndicadorSeparacionFilas(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	SeparacionFilas = (float)o->value();
	ySeparacionFilas = (int)(SeparacionFilas * CalibracionCorreccion);	// en bits
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionFilas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoColumnas=(Fl_Group *)0;

Fl_Counter *IndicadorColumnas=(Fl_Counter *)0;

static void cb_IndicadorColumnas(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el número de columnas
	NumeroColumnas = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(NumeroColumnas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorSeparacionColumnas=(Fl_Counter *)0;

static void cb_IndicadorSeparacionColumnas(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	SeparacionColumnas = (float)o->value();
	xSeparacionColumnas = (int)(SeparacionColumnas * CalibracionCorreccion);	// en bits

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionColumnas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoPrecorte=(Fl_Group *)0;

Fl_Round_Button *CheckPrecorte=(Fl_Round_Button *)0;

static void cb_CheckPrecorte(Fl_Round_Button* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	Precorte = (int) o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Precorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorLongitudPrecorte=(Fl_Counter *)0;

static void cb_IndicadorLongitudPrecorte(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	LongitudPrecorte = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(LongitudPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorSeparacionPrecorte=(Fl_Counter *)0;

static void cb_IndicadorSeparacionPrecorte(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	SeparacionPrecorte = (float)o->value();
	SeparacionPrecorteBits = (int)(SeparacionPrecorte * CalibracionCorreccion);	// en bits

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorVelocidadPrecorte=(Fl_Counter *)0;

static void cb_IndicadorVelocidadPrecorte(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el valor
	VelocidadPrecorte = (int) o->value();

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(VelocidadPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *Cancelar_VentanaRepeticiones=(Fl_Button *)0;

static void cb_Cancelar_VentanaRepeticiones(Fl_Button*, void*) {
  //Vuelve a la ventana principal sin hacer nada

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaRepeticiones->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Button *Aceptar_VentanaRepeticiones=(Fl_Button *)0;

static void cb_Aceptar_VentanaRepeticiones(Fl_Button*, void*) {
  // Guarda todo
Escribir_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaRepeticiones->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
}

Fl_Double_Window* Make_Window_Repeticiones() {
  { VentanaRepeticiones = new Fl_Double_Window(460, 460);
    VentanaRepeticiones->box(FL_BORDER_BOX);
    VentanaRepeticiones->color(FL_BACKGROUND2_COLOR);
    VentanaRepeticiones->selection_color(FL_BACKGROUND2_COLOR);
    VentanaRepeticiones->when(FL_WHEN_RELEASE_ALWAYS);
    { GrupoFilas = new Fl_Group(50, 15, 355, 75);
      GrupoFilas->box(FL_PLASTIC_DOWN_BOX);
      GrupoFilas->color((Fl_Color)48);
      { Fl_Counter* o = IndicadorFilas = new Fl_Counter(65, 45, 150, 35, "Filas");
        IndicadorFilas->type(1);
        IndicadorFilas->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorFilas->color(FL_INACTIVE_COLOR);
        IndicadorFilas->labelfont(8);
        IndicadorFilas->labelsize(15);
        IndicadorFilas->minimum(1);
        IndicadorFilas->maximum(20);
        IndicadorFilas->step(1);
        IndicadorFilas->value(1);
        IndicadorFilas->textfont(8);
        IndicadorFilas->textsize(15);
        IndicadorFilas->callback((Fl_Callback*)cb_IndicadorFilas);
        IndicadorFilas->align(Fl_Align(133));
        IndicadorFilas->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(NumeroFilas); //inicialización
        if (o->value() == 0) {NumeroFilas=1; o->value(NumeroFilas);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Filas");break; case ING:o->label("Rows");break; case ITA:o->label("Righe");break;}
      } // Fl_Counter* IndicadorFilas
      { Fl_Counter* o = IndicadorSeparacionFilas = new Fl_Counter(240, 45, 150, 35, "Separaci\363n (mm)");
        IndicadorSeparacionFilas->type(1);
        IndicadorSeparacionFilas->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorSeparacionFilas->color(FL_INACTIVE_COLOR);
        IndicadorSeparacionFilas->labelfont(8);
        IndicadorSeparacionFilas->labelsize(15);
        IndicadorSeparacionFilas->minimum(-100);
        IndicadorSeparacionFilas->maximum(100);
        IndicadorSeparacionFilas->textfont(8);
        IndicadorSeparacionFilas->textsize(15);
        IndicadorSeparacionFilas->callback((Fl_Callback*)cb_IndicadorSeparacionFilas);
        IndicadorSeparacionFilas->align(Fl_Align(133));
        IndicadorSeparacionFilas->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(SeparacionFilas); //inicialización
        switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}
      } // Fl_Counter* IndicadorSeparacionFilas
      GrupoFilas->end();
    } // Fl_Group* GrupoFilas
    { GrupoColumnas = new Fl_Group(50, 100, 355, 75);
      GrupoColumnas->box(FL_PLASTIC_DOWN_BOX);
      GrupoColumnas->color((Fl_Color)48);
      { Fl_Counter* o = IndicadorColumnas = new Fl_Counter(65, 130, 150, 35, "Columnas");
        IndicadorColumnas->type(1);
        IndicadorColumnas->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorColumnas->color(FL_INACTIVE_COLOR);
        IndicadorColumnas->labelfont(8);
        IndicadorColumnas->labelsize(15);
        IndicadorColumnas->minimum(1);
        IndicadorColumnas->maximum(20);
        IndicadorColumnas->step(1);
        IndicadorColumnas->value(1);
        IndicadorColumnas->textfont(8);
        IndicadorColumnas->textsize(15);
        IndicadorColumnas->callback((Fl_Callback*)cb_IndicadorColumnas);
        IndicadorColumnas->align(Fl_Align(133));
        IndicadorColumnas->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(NumeroColumnas); //inicialización
        if (o->value() == 0) {NumeroColumnas=1; o->value(NumeroColumnas);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Columnas");break; case ING:o->label("Columns");break; case ITA:o->label("Colonne");break;}
      } // Fl_Counter* IndicadorColumnas
      { Fl_Counter* o = IndicadorSeparacionColumnas = new Fl_Counter(240, 130, 150, 35, "Separaci\363n (mm)");
        IndicadorSeparacionColumnas->type(1);
        IndicadorSeparacionColumnas->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorSeparacionColumnas->color(FL_INACTIVE_COLOR);
        IndicadorSeparacionColumnas->labelfont(8);
        IndicadorSeparacionColumnas->labelsize(15);
        IndicadorSeparacionColumnas->minimum(-100);
        IndicadorSeparacionColumnas->maximum(100);
        IndicadorSeparacionColumnas->textfont(8);
        IndicadorSeparacionColumnas->textsize(15);
        IndicadorSeparacionColumnas->callback((Fl_Callback*)cb_IndicadorSeparacionColumnas);
        IndicadorSeparacionColumnas->align(Fl_Align(133));
        IndicadorSeparacionColumnas->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(SeparacionColumnas); //inicialización
        switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}
      } // Fl_Counter* IndicadorSeparacionColumnas
      GrupoColumnas->end();
    } // Fl_Group* GrupoColumnas
    { GrupoPrecorte = new Fl_Group(50, 185, 355, 150);
      GrupoPrecorte->box(FL_PLASTIC_DOWN_BOX);
      GrupoPrecorte->color((Fl_Color)48);
      { Fl_Round_Button* o = CheckPrecorte = new Fl_Round_Button(65, 205, 145, 35, " Precorte");
        CheckPrecorte->down_box(FL_PLASTIC_DOWN_BOX);
        CheckPrecorte->color(FL_FOREGROUND_COLOR);
        CheckPrecorte->labelfont(8);
        CheckPrecorte->labelsize(16);
        CheckPrecorte->callback((Fl_Callback*)cb_CheckPrecorte);
        CheckPrecorte->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(Precorte); //inicialización
        switch (Idioma) {case ESP:o->label("Precorte");break; case ING:o->label("Slitting");break; case ITA:o->label("Pretagliato");break;}
      } // Fl_Round_Button* CheckPrecorte
      { Fl_Counter* o = IndicadorLongitudPrecorte = new Fl_Counter(245, 215, 150, 35, "Longitud (%)");
        IndicadorLongitudPrecorte->type(1);
        IndicadorLongitudPrecorte->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorLongitudPrecorte->color(FL_INACTIVE_COLOR);
        IndicadorLongitudPrecorte->labelfont(8);
        IndicadorLongitudPrecorte->labelsize(15);
        IndicadorLongitudPrecorte->minimum(1);
        IndicadorLongitudPrecorte->maximum(100);
        IndicadorLongitudPrecorte->step(1);
        IndicadorLongitudPrecorte->value(100);
        IndicadorLongitudPrecorte->textfont(8);
        IndicadorLongitudPrecorte->textsize(15);
        IndicadorLongitudPrecorte->callback((Fl_Callback*)cb_IndicadorLongitudPrecorte);
        IndicadorLongitudPrecorte->align(Fl_Align(133));
        IndicadorLongitudPrecorte->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(LongitudPrecorte); //inicialización
        if (o->value() == 0) {LongitudPrecorte=100; o->value(LongitudPrecorte);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Longitud (%)");break; case ING:o->label("Length (%)");break; case ITA:o->label("Longitude (%)");break;}
      } // Fl_Counter* IndicadorLongitudPrecorte
      { Fl_Counter* o = IndicadorSeparacionPrecorte = new Fl_Counter(65, 280, 150, 35, "Separaci\363n (mm)");
        IndicadorSeparacionPrecorte->type(1);
        IndicadorSeparacionPrecorte->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorSeparacionPrecorte->color(FL_INACTIVE_COLOR);
        IndicadorSeparacionPrecorte->labelfont(8);
        IndicadorSeparacionPrecorte->labelsize(15);
        IndicadorSeparacionPrecorte->minimum(-100);
        IndicadorSeparacionPrecorte->maximum(100);
        IndicadorSeparacionPrecorte->textfont(8);
        IndicadorSeparacionPrecorte->textsize(15);
        IndicadorSeparacionPrecorte->callback((Fl_Callback*)cb_IndicadorSeparacionPrecorte);
        IndicadorSeparacionPrecorte->align(Fl_Align(133));
        IndicadorSeparacionPrecorte->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(SeparacionPrecorte); //inicialización
        switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}
      } // Fl_Counter* IndicadorSeparacionPrecorte
      { Fl_Counter* o = IndicadorVelocidadPrecorte = new Fl_Counter(245, 280, 150, 35, "Velocidad (%)");
        IndicadorVelocidadPrecorte->type(1);
        IndicadorVelocidadPrecorte->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorVelocidadPrecorte->color(FL_INACTIVE_COLOR);
        IndicadorVelocidadPrecorte->labelfont(8);
        IndicadorVelocidadPrecorte->labelsize(15);
        IndicadorVelocidadPrecorte->minimum(10);
        IndicadorVelocidadPrecorte->maximum(1000);
        IndicadorVelocidadPrecorte->step(10);
        IndicadorVelocidadPrecorte->value(100);
        IndicadorVelocidadPrecorte->textfont(8);
        IndicadorVelocidadPrecorte->textsize(15);
        IndicadorVelocidadPrecorte->callback((Fl_Callback*)cb_IndicadorVelocidadPrecorte);
        IndicadorVelocidadPrecorte->align(Fl_Align(133));
        IndicadorVelocidadPrecorte->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(VelocidadPrecorte); //inicialización
        switch (Idioma) {case ESP:o->label("Velocidad (%)");break; case ING:o->label("Speed (%)");break; case ITA:o->label("Velocità (%)");break;}
      } // Fl_Counter* IndicadorVelocidadPrecorte
      GrupoPrecorte->end();
    } // Fl_Group* GrupoPrecorte
    { Fl_Button* o = Cancelar_VentanaRepeticiones = new Fl_Button(270, 355, 135, 75, "Cancelar");
      Cancelar_VentanaRepeticiones->box(FL_PLASTIC_UP_BOX);
      Cancelar_VentanaRepeticiones->down_box(FL_PLASTIC_DOWN_BOX);
      Cancelar_VentanaRepeticiones->color(FL_FOREGROUND_COLOR);
      Cancelar_VentanaRepeticiones->labelfont(8);
      Cancelar_VentanaRepeticiones->labelsize(20);
      Cancelar_VentanaRepeticiones->callback((Fl_Callback*)cb_Cancelar_VentanaRepeticiones);
      //o->deactivate();// de momento no se implementa la posibilidad de cancelar los cambios
      switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}
    } // Fl_Button* Cancelar_VentanaRepeticiones
    { Fl_Button* o = Aceptar_VentanaRepeticiones = new Fl_Button(50, 355, 135, 75, "Aceptar");
      Aceptar_VentanaRepeticiones->box(FL_PLASTIC_UP_BOX);
      Aceptar_VentanaRepeticiones->down_box(FL_PLASTIC_DOWN_BOX);
      Aceptar_VentanaRepeticiones->color(FL_FOREGROUND_COLOR);
      Aceptar_VentanaRepeticiones->labelfont(8);
      Aceptar_VentanaRepeticiones->labelsize(20);
      Aceptar_VentanaRepeticiones->callback((Fl_Callback*)cb_Aceptar_VentanaRepeticiones);
      switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}
    } // Fl_Button* Aceptar_VentanaRepeticiones
    VentanaRepeticiones->set_modal();
    VentanaRepeticiones->clear_border();
    VentanaRepeticiones->end();
  } // Fl_Double_Window* VentanaRepeticiones
  return VentanaRepeticiones;
}

void CargarVentanaModificarTexto() {
  char record[12];
  
  ////////////////////////////////////////////////////////////7
  // Estado de los widgets de la ventana de modificar texto
  
    if (ValorFuente==9) {
  	BotonRupia->show();
  	BotonISI->show();
  }
  
  else {
  	BotonRupia->hide();
  	BotonISI->hide();
  }
   
  // Fecha
  ChoiceFormatoFecha1->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceFormatoFecha2->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceFormatoFecha3->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceSeparadorFecha->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  IndicadorCaducidad->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]);
  
  if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
  	BotonFecha->deactivate();
  	ChoiceFormatoFecha1->deactivate();
  	ChoiceFormatoFecha2->deactivate();
  	ChoiceFormatoFecha3->deactivate();
  	ChoiceSeparadorFecha->deactivate();
  	IndicadorCaducidad->deactivate();
  }
  
  else {
  	BotonFecha->activate();
  	ChoiceFormatoFecha1->activate();
  	ChoiceFormatoFecha2->activate();
  	ChoiceFormatoFecha3->activate();
  	ChoiceSeparadorFecha->activate();
  	IndicadorCaducidad->activate();
  }
  
  // Hora
  ChoiceFormatoHora1->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceFormatoHora2->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceFormatoHora3->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);
  ChoiceSeparadorHora->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);
  
  if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {
  	BotonHora->deactivate();
  	ChoiceFormatoHora1->deactivate();
  	ChoiceFormatoHora2->deactivate();
  	ChoiceFormatoHora3->deactivate();
  	ChoiceSeparadorHora->deactivate();
  }
  
  else {
  	BotonHora->activate();
  	ChoiceFormatoHora1->activate();
  	ChoiceFormatoHora2->activate();
  	ChoiceFormatoHora3->activate();
  	ChoiceSeparadorHora->activate();
  }
  
  // Serie
  sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1]);
  CuadroTextoSerie->value(record);
  
  if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
  	sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);
  	CuadroTextoSerieFinal->value(record);
  }
  else {
  	CuadroTextoSerieFinal->value("");
  }
  
  sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);
  CuadroTextoUnidadesLote->value(record);
  
  sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
  CuadroTextoUnidadesLoteActual->value(record);
  
      if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
  	
  	BotonSerie->deactivate();
  	CuadroTextoSerie->deactivate();
  	CuadroTextoSerieFinal->deactivate();
  	FrameLote->deactivate();
  	CuadroTextoUnidadesLote->deactivate();
  	CuadroTextoUnidadesLoteActual->deactivate();
  	BotonReiniciarSerie->activate();
  	
  }
  
  else {
  	
  	BotonSerie->activate();
  	CuadroTextoSerie->activate();
  	CuadroTextoSerieFinal->activate();
  	FrameLote->activate();
  	CuadroTextoUnidadesLote->activate();
  	CuadroTextoUnidadesLoteActual->activate();
  	BotonReiniciarSerie->deactivate();
  	
  }
  
    CargarTexto();
  
    if (NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] > 0) {	//si no es mayor que 0 el campo no tiene significado
  	sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
  	CuadroTextoUnidadesLoteActual->value(record);
  }
  
  // Muestra la nueva ventana		
  VentanaActiva = VModificar;
  VentanaModificarTexto->show();
}

void CargarVentanaDetallesLinea() {
    int i;
  
    ChoiceTipoLinea->value(ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]);
  
    if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
  
  	GrupoTexto->show();
  	GrupoBarcode->hide();
  	GrupoGrafico->hide();
  	GrupoTextoCircular->hide();
  	
  	if (Estrategia < 3) {
  		TextoMinX->hide();
  		TextoMinY->hide();
  	}
  	else {
  		TextoMinX->show();
  		TextoMinX->value(MinXTexto[LineaCalcular-1][BloqueCalcular-1]);
  		TextoMinY->show();
  		TextoMinY->value(MinYTexto[LineaCalcular-1][BloqueCalcular-1]);	
  	}
  }
  
    else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
  
  	GrupoTexto->hide();
  	GrupoBarcode->hide();
  	GrupoGrafico->show();
  	GrupoTextoCircular->hide();
  	
  	if (Estrategia < 3) {
  		GraficoMinX->hide();
  		GraficoMinY->hide();
  	}
  	else {
  		GraficoMinX->show();
  		GraficoMinX->value(MinXGrafico[LineaCalcular-1][BloqueCalcular-1]);
  		GraficoMinY->show();
  		GraficoMinY->value(MinYGrafico[LineaCalcular-1][BloqueCalcular-1]);	
  	}
  
  	
    	Aceptar_VentanaDetallesLinea->deactivate();
  
  	// Selecciona el archivo que corresponda
  	if (strlen(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]) > 0) {
  	
  		if (debug_plt) {
  			printf("NombreArchivoPlt[%d,%d]:%s\n", LineaCalcular-1, BloqueCalcular - 1, NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
  		}
  			
  		for (i=1; i<=FileBrowserArchivosPlt->size(); i++) {
  		
  			if (debug_plt) {
  				printf("FileBrowserArchivosPlt->text(%d):%s\n", i, FileBrowserArchivosPlt->text(i));
  			}
  			
  			// si son iguales los nombres, hay que seleccionar esa entrada
  			if (strcmp(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], FileBrowserArchivosPlt->text(i)) == 0) {
  				FileBrowserArchivosPlt->select(i);	
  			}
  		
  		}
  	
  	}
  
  	
    	else {
  	
  		if (debug_plt) {
    		}
  	
  		FileBrowserArchivosPlt->deselect(FileBrowserArchivosPlt->value());
  			
  	}
  
  }
  else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {
  
  	GrupoTexto->hide();
  	GrupoBarcode->hide();
  	GrupoGrafico->hide();
  	GrupoTextoCircular->show();
  	
  	if (Estrategia < 3) {
  		TextoCircularCentroX->hide();
  		TextoCircularCentroY->hide();
  		Angulo->hide();
  		Radio->hide();
  	}
  	else {
  		TextoCircularCentroX->show();
  		TextoCircularCentroX->value(CentroXTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
  		TextoCircularCentroY->show();
  		TextoCircularCentroY->value(CentroYTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
  		Angulo->show();
  		Angulo->value(AnguloTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
  		Radio->show();
  		Radio->value(RadioTextoCircular[LineaCalcular-1][BloqueCalcular-1]);	
  	}
  		Aceptar_VentanaDetallesLinea->activate();
  
  	
  }
    else {
  
  	GrupoTexto->hide();	
  	GrupoBarcode->show();
  	GrupoGrafico->hide();
  	GrupoTextoCircular->hide();
  
    	if ( numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] == 71) {
  	
  		CheckInvertirBarcode->hide();
  	}
  	
  	else {
  		CheckInvertirBarcode->show();
  	
  	}
  	
  	// Invertir
  	CheckInvertirBarcode->value(InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1]);
  
  	// Escala Barcode
  	IndicadorEscalaBarcode->value(EscalaBarcode[LineaCalcular - 1][BloqueCalcular - 1]);
  
    	IndicadorSeparacionBarrasBarcode->value(SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1]);
  
  	if (Estrategia < 3) {
  		BarcodeMinX->hide();
  		BarcodeMinY->hide();
  	}
  	else {
  		BarcodeMinX->show();
  		BarcodeMinX->value(MinXBarcode[LineaCalcular-1][BloqueCalcular-1]);
  		BarcodeMinY->show();
  		BarcodeMinY->value(MinYBarcode[LineaCalcular-1][BloqueCalcular-1]);	
  	}
  
  	Aceptar_VentanaDetallesLinea->activate();
  
  }
  
  // Muestra la nueva ventana		
  VentanaActiva = VDetalles;
  VentanaDetallesLinea->show();
}

void CargarVentanaTrabajos() {
  // Cada vez que se carga la ventana se debe borrar el texto del cuadro
  CuadroTextoTrabajo->value("");
  
  
  // Muestra la nueva ventana		
  VentanaActiva = VTrabajos;
  VentanaTrabajos->show();
}

void CargarVentanaPassword() {
  // Muestra la nueva ventana		
  VentanaActiva = VPassword;
  VentanaPassword->show();
}

void CargarVentanaConfirmarCargarTrabajo() {
  // Muestra la nueva ventana		
  VentanaActiva = VConfirmarCargarTrabajo;
  VentanaConfirmarCargarTrabajo->show();
}

void CargarVentanaConfirmarGuardarTrabajo() {
  // Muestra la nueva ventana		
  VentanaActiva = VConfirmarGuardarTrabajo;
  VentanaConfirmarGuardarTrabajo->show();
}

void CargarVentanaConfirmarBorrarTrabajo() {
  // Muestra la nueva ventana		
  VentanaActiva = VConfirmarCargarTrabajo;
  VentanaConfirmarBorrarTrabajo->show();
}

void CargarVentanaRepeticiones() {
    IndicadorFilas->value(NumeroFilas);
  IndicadorSeparacionFilas->value(SeparacionFilas);
  
  IndicadorColumnas->value(NumeroColumnas);
  IndicadorSeparacionColumnas->value(SeparacionColumnas);
  
  CheckPrecorte->value(Precorte);
  IndicadorLongitudPrecorte->value(LongitudPrecorte);
  IndicadorSeparacionPrecorte->value(SeparacionPrecorte);
  
  // Muestra la nueva ventana
  VentanaActiva = VRepeticiones;
  VentanaRepeticiones->show();
}

int CrearBarcode(int linea, int bloque) {
  int error;
  //float alturalineatexto;
  int datamsize;
  int qrsize;
  char datamsquare;
    
    if(BarcodeSymbol[linea][bloque] != NULL) {
  
  	ZBarcode_Delete(BarcodeSymbol[linea][bloque]);
  
  }
  
  // Crea el objeto barcode
  BarcodeSymbol[linea][bloque] = ZBarcode_Create();
  
  // Comprueba si se ha creado correctamente
  if(BarcodeSymbol[linea][bloque] == NULL) {	// No se ha creado correctamente
          
          return -1;
                 
  }
          
            
          // Tipo
          BarcodeSymbol[linea][bloque]->symbology = numTiposLinea[ValorTipoLinea[linea][bloque]];
          
          
            if(numTiposLinea[ValorTipoLinea[linea][bloque]]==71){
          datamsize = 8;
          datamsquare = char(DM_SQUARE);
          	//BarcodeSymbol[linea][bloque]->option_2 = datamsize; //numTiposLinea[ValorTipoLinea[linea][bloque]];
          	BarcodeSymbol[linea][bloque]->option_3 = datamsquare; //numTiposLinea[ValorTipoLinea[linea][bloque]];
              	
          }
  
  
          if(numTiposLinea[ValorTipoLinea[linea][bloque]]==58){
          qrsize = 8;
          	//BarcodeSymbol[linea][bloque]->option_2 = qrsize; //numTiposLinea[ValorTipoLinea[linea][bloque]];
          	//BarcodeSymbol[linea][bloque]->option_3 = datamsquare; //numTiposLinea[ValorTipoLinea[linea][bloque]];
              	
          }        
          // Invertir
          //if (InvertirBarcode[linea] == ON) {
          //	strcpy(BarcodeSymbol[linea]->fgcolour, "ffffff");
  	//	strcpy(BarcodeSymbol[linea]->bgcolour, "000000");
          //}
          
          //else {
          //	strcpy(BarcodeSymbol[linea]->fgcolour, "000000");
  	//	strcpy(BarcodeSymbol[linea]->bgcolour, "ffffff");
          //}
          
    	//switch (linea) {
  
  	//	case 0:
  	//	alturalineatexto = AlturaLineaTexto1;
  	//	break;
  
  	//	case 1:
  	//	alturalineatexto = AlturaLineaTexto2;
  	//	break;
      
  	//	case 2:
  	//    	alturalineatexto = AlturaLineaTexto3;
  	//	break;
     	
     	//	case 3:
  	//    	alturalineatexto = AlturaLineaTexto4;
  	//
  	
  	//}
          
          // factor de escala
          BarcodeSymbol[linea][bloque]->scale = EscalaBarcode[linea][bloque]/100.0;
          
          // barras laterales
          //BarcodeSymbol[linea]->border_width = 10;
          
            //height = (int)((alturalineatexto/(double)Spot*1000.0*50.0/(double)EscalaBarcode[linea]));
  	//BarcodeSymbol[linea]->height = height;
          
            //strcpy(BarcodeSymbol[LineaCalcular - 1]->outfile, "barcode.svg");  
          
          // Codifica  	
          switch (linea) {
  
  		case 0:
  		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto1[bloque], 0);
  		break;
          
  	        case 1:
  		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto2[bloque], 0);
  		break;
  		
  		case 2:
  		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto3[bloque], 0);
  		break;
  		
  		case 3:
  		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto4[bloque], 0);
  		break;
  		
  	}
  	
  	// Chequea posibles errores
  	if(error != 0) {
               
          	// some error occurred
  	        rt_printk("CrearBarcode %s\n", BarcodeSymbol[linea][bloque]->errtxt);
          
  	}
          
  	if(error > WARN_INVALID_OPTION) {
                  
          	// stop now
  	        //ZBarcode_Delete(my_symbol);
          	return 1;
          
  	}
  	
  	// Elimina el human readable text
  	strcpy((char *)BarcodeSymbol[linea][bloque]->text, "");
  	
    	ZBarcode_Buffer(BarcodeSymbol[linea][bloque], 0);
  	
  }
  
    // para evitar stacked symbols
          
  return 0;
}

void CargarTexto() {
  // string de texto auxiliar
  char str[NumeroMaximoCaracteresLinea];
  
    //OrdenFecha = OrdenFechaLinea[LineaCalcular - 1];
  //OrdenHora = OrdenHoraLinea[LineaCalcular - 1];
  //OrdenNumeroSerie = OrdenNumeroSerieLinea[LineaCalcular - 1];
  
    	
  // Procesa el texto
  switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
      	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 0: //0
          
  	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      
  	case 0: //0,0
          
  	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
  	       	case 0: //0,0,0
   			
                  	switch(LineaCalcular) {	
                  	
                  	case 1:
                  		strcpy(str, LineaTexto1[BloqueCalcular - 1]);
                  		break;
                  	
                  	case 2:
                  		strcpy(str, LineaTexto2[BloqueCalcular - 1]);
                  		break;
                  		
                  	case 3:
                  		strcpy(str, LineaTexto3[BloqueCalcular - 1]);
                  		break;
                  		
                  	case 4:
                  		strcpy(str, LineaTexto4[BloqueCalcular - 1]);
                  		break;
                  	
                  	}
                  	
              		CuadroTextoLinea->value(str);
              		
              		if (debug_texto) {
  	            		printf("Cargar 0.0.0 %s\n", str);
  	            	} 
              		
             		break; //0,0,0
              		
  		case 1: //0,0,1
  		        
  		       	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	        	
  
  			if (debug_texto) {
  	            		printf("Cargar 0.0.1 %s\n", str);
  	            	} 
  	            			        	
  		        break; //0,0,1
  	           	
          	}
  	
  		break; //0,0
  		
  	case 1: //0,1
      
  		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   		case 0: //0,1,0
  	      
  	        	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	        			        	
              		
              		if (debug_texto) {
  	            		printf("Cargar 0.1.0 %s\n", str);
  	            	} 
  	            	
              		break;//0,1,0
          	
          	case 2: //0,1,2
          		
  		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	       
  			
  			if (debug_texto) {
  	            		printf("Cargar 0.1.2 %s\n", str);
  	            	} 
  	            	
          		break; //0,1,0
          		
          	}
          	
          	break; //0,1
          	
  	case 2: //0,2
      	
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         		case 1: //0,2,1
         	
  	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	        
  	            	
  	            	if (debug_texto) {
  	            		printf("Cargar 0.2.1 %s\n", str);
  	            	} 
  	            	
          		break; //0,2,1
          		
          	}
          		
          	break; //0,2
          		
          }
         	
  	break; //0
  		
  //////////////////////////////////////////////////////////////////////////////////////	    	
  case 1: //1
  
  	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      
  	case 0: //1,0
          
  	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
  	       	case 0: //1,0,0
  
  			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			CuadroTextoLinea->value(str);
  	            	
  	            	if (debug_texto) {
  	            		printf("Cargar 1.0.0 %s\n", str);
  	            	} 
  	            	
              		break;//1,0,0
              		
  		case 2: //1,0,2
  
  		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	       
  		        
  		        if (debug_texto) {
  	            		printf("Cargar 1.0.2 %s\n", str);
  	            	} 
  	            		
  		        break; //1,0,2
  	           	
          	}
  	
  		break; //1,0
  		
  	case 2: //1,2
      
  		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   		case 0: //1,2,0
                    	      
  	        	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	        
  	            	
              		if (debug_texto) {
  	            		printf("Cargar 1.2.0 %s\n", str);
  	            	} 
  	            	
              		break; //1,2,0
          	
          	case 3: //1,2,3
     	
  		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	    
  			
  			if (debug_texto) {
  	            		printf("Cargar 1.2.3 %s\n", str);
  	            	} 
  	            	
          		break; //1,2,3
          		
          	}
          	
          	break; //1,2
          	
  	case 3: //1,3
      	
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         		case 2: //1,3,2
   			
  		        strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	   
              			
              		if (debug_texto) {
  	            		printf("Cargar 1.3.2 %s\n", str);
  	            	} 
  	            	
          		break; //1,3,2
          		
          	} 
          		
          	break; //1,3
          		        	
          } 
          	
          break; //1
          
  //////////////////////////////////////////////////////////////////////////////////////	
  case 2: //2
          	
         	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
         	case 0: //2,0
          		
         		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
         		case 1: //2,0,1
         			
  			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			CuadroTextoLinea->value(str);
  		        
  		        if (debug_texto) {
  	            		printf("Cargar 2.0.1 %s\n", str);
  	            	} 
  	            		
          		break; //2,0,1
          		
          	}
          		
          	break; //2,0
          	
          case 1: //2,1
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 0: //2,1,0       	
            			
   			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			CuadroTextoLinea->value(str);
  		        
  		        if (debug_texto) {
  	            		printf("Cargar 2.1.0 %s\n", str);
  	            	} 
  	            	
          		break; //2,1,0
          		
          	case 3: //2,1,3
             			
  		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
                  	CuadroTextoLinea->value(str);
                  	
                  	if (debug_texto) {
  	            		printf("Cargar 2.1.3 %s\n", str);
  	            	} 
  	            	
          		break; //2,1,3
          		
          	}
          		
          	break; //2,1
          	
          case 3: //2,3
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 1: //2,3,1
     				
  	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		CuadroTextoLinea->value(str);	   
              		
              		if (debug_texto) {
  	            		printf("Cargar 2.3.1 %s\n", str);
  	            	} 
  	            			
          		break; //2,3,1
          		
          	}
          		
          	break; //2,3
          	
          }
          	
  	break; //2
  	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 3: //3
          	
         	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
         	case 1: //3,1 
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 2: //3,1,2
            		
   			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			CuadroTextoLinea->value(str);
  		        
  		        if (debug_texto) {
  	            		printf("Cargar 3.1.2 %s\n", str);
  	            	} 
  	            		        		
          		break; //3,1,2
          		
          	}
          		
          	break; //3,1
          	
          case 2: //3,2
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 1: //3,2,1
  	
   			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			CuadroTextoLinea->value(str);
  		        
  		        if (debug_texto) {
  	            		printf("Cargar 3.2.1 %s\n", str);
  	            	} 
  	            		        		
          		break; //3,2,1
          		
          	}
          		
          	break; //3,2
          	
          }
          	
  	break; //3
  		
  } // de switch (OrdenFecha) inicial
}

void ProcesarCaracter(const char *caracter) {
  // string de texto auxiliar
  char str[NumeroMaximoCaracteresLinea];
  
    	
  // Procesa el texto
  switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
      	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 0: //0
          
  	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      
  	case 0: //0,0
          
  	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
  	       	case 0: //0,0,0
   			
   			strcpy(str, CuadroTextoLinea->value());
  			
  			strcat(str, caracter);
              		
              		CuadroTextoLinea->value(str);
              		
             		break; //0,0,0
              		
  		case 1: //0,0,1
  		        
  		       	strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		       	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	        	
  		        	
  		        break; //0,0,1
  	           	
          	}
  	
  		break; //0,0
  		
  	case 1: //0,1
      
  		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   		case 0: //0,1,0
       	
  	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  	        	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	        			        	
              		
              		break;//0,1,0
          	
          	case 2: //0,1,2
  
          		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	       
  			
          		break; //0,1,0
          		
          	}
          	
          	break; //0,1
          	
  	case 2: //0,2
      	
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         		case 1: //0,2,1
  	
         			strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	        
  	            	
          		break; //0,2,1
          		
          	}
          		
          	break; //0,2
          		
          }
         	
  	break; //0
  		
  //////////////////////////////////////////////////////////////////////////////////////	    	
  case 1: //1
  
  	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      
  	case 0: //1,0
          
  	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
  	       	case 0: //1,0,0
  
  			strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
   				
  			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			
  			CuadroTextoLinea->value(str);
  	            	
              		break;//1,0,0
              		
  		case 2: //1,0,2
  
  		       	strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	       
  		        	
  		        break; //1,0,2
  	           	
          	}
  	
  		break; //1,0
  		
  	case 2: //1,2
      
  		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   		case 0: //1,2,0
                      
  	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  	        	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	        
  	            	
              		
              		break; //1,2,0
          	
          	case 3: //1,2,3
     
           		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	    
  			
          		break; //1,2,3
          		
          	}
          	
          	break; //1,2
          	
  	case 3: //1,3
      	
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         		case 2: //1,3,2
   		
  	           	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		        strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	   
              			
          		break; //1,3,2
          		
          	} 
          		
          	break; //1,3
          		        	
          } 
          	
          break; //1
          
  //////////////////////////////////////////////////////////////////////////////////////	
  case 2: //2
          	
         	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
         	case 0: //2,0
          		
         		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
         		case 1: //2,0,1
         		
         			strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
   				
  			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			
  			CuadroTextoLinea->value(str);
  		        	
          		break; //2,0,1
          		
          	}
          		
          	break; //2,0
          	
          case 1: //2,1
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 0: //2,1,0       	
            		
                  	strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
   				
   			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			
  			CuadroTextoLinea->value(str);
  		        	
          		break; //2,1,0
          		
          	case 3: //2,1,3
             		
                 		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
                  	
                  	CuadroTextoLinea->value(str);
                  		
          		break; //2,1,3
          		
          	}
          		
          	break; //2,1
          	
          case 3: //2,3
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 1: //2,3,1
     			        	
  	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
  		        	
  	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		
              		CuadroTextoLinea->value(str);	   
              				
          		break; //2,3,1
          		
          	}
          		
          	break; //2,3
          	
          }
          	
  	break; //2
  	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 3: //3
          	
         	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
         	case 1: //3,1 
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 2: //3,1,2
            		
                 		strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
   			
   			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
             		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			
  			CuadroTextoLinea->value(str);
  		        	        		
          		break; //3,1,2
          		
          	}
          		
          	break; //3,1
          	
          case 2: //3,2
          		
          	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          	case 1: //3,2,1
  
  	             	strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
   				
   			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
  			
  			CuadroTextoLinea->value(str);
  		        	        		
          		break; //3,2,1
          		
          	}
          		
          	break; //3,2
          	
          }
          	
  	break; //3
  		
  } // de switch (OrdenFecha) inicial
}

void ProcesarTexto() {
  // Si hay texto introducido:
  //if (strlen(CuadroTextoLinea->value())) {
  
    	//OrdenFechaLinea[LineaCalcular - 1] = OrdenFecha;
  	//OrdenHoraLinea[LineaCalcular - 1] = OrdenHora;
  	//OrdenNumeroSerieLinea[LineaCalcular - 1] = OrdenNumeroSerie;
     
  	// Calcula la fecha/hora si es necesario
  	if ((StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) || (StatusHora[LineaCalcular - 1][BloqueCalcular - 1] > 0)){
  		
  		//LineaFecha = LineaCalcular;
  		
  		//Actualiza la fecha
  		//ActualizarFechaHora();
  		ActualizarFechaHoraSerie();
  		
  	}
  
  	
  	//if (OrdenNumeroSerie[LineaCalcular - 1] > 0) {
  		
  		//LineaSerie = LineaCalcular;
  	
  	//}
  
    	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
      	
  		//////////////////////////////////////////////////////////////////////////////////////	
  		case 0: //0
          
  		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      	
  			case 0: //0,0
  			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
  	       			case 1: //0,0,1      	
  				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);    
              			if (debug_texto) {
  	            			printf("Procesar 0.0.1\n");
  	            		}     		
  		        	break; //0,0,1
  	           	
          		}
  	
  			break; //0,0
  		
  			case 1: //0,1
  			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   				case 0: //0,1,0
       				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			if (debug_texto) {
  	            			printf("Procesar 0.1.0\n");
  	            		}   
              			break;//0,1,0
          	
  		        	case 2: //0,1,2
  				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);       				
          			if (debug_texto) {
  	            			printf("Procesar 0.1.2\n");
  	            		}   
          			break; //0,1,2
          		
          		}
          	
  		        break; //0,1
          	
  			case 2: //0,2
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
      		   		case 1: //0,2,1
  				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);		
          			if (debug_texto) {
  	            			printf("Procesar 0.2.1\n");
  	            		}   
          			break; //0,2,1
          		
        			}
          		
          		break; //0,2
          		
    		}
         	
  		break; //0
  		
  		//////////////////////////////////////////////////////////////////////////////////////	    	
  		case 1: //1
  
  		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
      
  			case 0: //1,0
  	 	    	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
  	  		    	case 0: //1,0,0
  	       			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			if (debug_texto) {
  	            			printf("Procesar 1.0.0\n");
  	            		}   
              			break;//1,0,0
              		
  				case 2: //1,0,2
  		 		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
  				if (debug_texto) {
  	            			printf("Procesar 1.0.2\n");
  	            		}   
  				break; //1,0,2
  	           	
          		}
  	
  			break; //1,0
  		
  			case 2: //1,2
  			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
   				case 0: //1,2,0
  				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);          				
              			if (debug_texto) {
  	            			printf("Procesar 1.2.0\n");
  	            		}   
              			break; //1,2,0
          	
          			case 3: //1,2,3
          			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 1.2.3\n");
  	            		}   
          			break; //1,2,3
          		
          		}
          	
  		        break; //1,2
          	
  			case 3: //1,3
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         				case 2: //1,3,2
  		        	strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 1.3.2\n");
  	            		}   
          			break; //1,3,2
          		
          		} 
          		
          		break; //1,3
          		        	
          	} 
          	
          	break; //1
          
  		//////////////////////////////////////////////////////////////////////////////////////	
  		case 2: //2
          	
         		switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
         		
         			case 0: //2,0	
         			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
         				case 1: //2,0,1      				
         				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 2.0.1\n");
  	            		}   
          			break; //2,0,1
          		
          		}
          		
          		break; //2,0
          	
          		case 1: //2,1
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          			case 0: //2,1,0       	
                  		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 2.1.0\n");
  	            		}   
          			break; //2,1,0
          		
          			case 3: //2,1,3
             			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 2.1.3\n");
  	            		}   
          			break; //2,1,3
          		
          		}
          		
          		break; //2,1
          	
          		case 3: //2,3
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          			case 1: //2,3,1	
  	        		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 2.3.1\n");
  	            		}   
          			break; //2,3,1
          		
          		}
          		
          		break; //2,3
          	
          	}
          	
  		break; //2
  	
  		//////////////////////////////////////////////////////////////////////////////////////	
  		case 3: //3
          	
        		switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
          	
         			case 1: //3,1 		
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
          			case 2: //3,1,2
                 			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);		
          			if (debug_texto) {
  	            			printf("Procesar 3.1.2\n");
  	            		}   
          			break; //3,1,2
          		
          		}
          		
  		        break; //3,1
          	
  		        case 2: //3,2
          		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
          		
  		        	case 1: //3,2,1
  	        		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
              			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
          			if (debug_texto) {
  	            			printf("Procesar 3.2.1\n");
  	            		}   
          			break; //3,2,1
          		
          		}
          		
          		break; //3,2
          	
          	}
          	
  		break; //3
  		
  	} // de switch (OrdenFecha) inicial
  			
    LineaTexto_calcular(LineaCalcular, BloqueCalcular);
}

void LineaTexto_calcular(int linea, int bloque) {
  char lineatexto[NumeroMaximoCaracteresLinea];
  
    if (debug_texto) {
    } 
  	
  // Procesa el texto
  switch (OrdenFecha[linea - 1][bloque - 1]) {
      	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 0: //0
          
  	switch (OrdenHora[linea - 1][bloque - 1]) {
      
  	case 0: //0,0
          
  	       	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          	
  	       	case 0: //0,0,0
   			
   			strcpy(lineatexto, CuadroTextoLinea->value());
              		
             		break; //0,0,0
              		
  		case 1: //0,0,1
  		        
  		       	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
              		strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  	            	
  		        break; //0,0,1
  	           	
          	}
  	
  		break; //0,0
  		
  	case 1: //0,1
      
  		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          	
   		case 0: //0,1,0
       			
       			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
              		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
              		
              		break;//0,1,0
          	
          	case 2: //0,1,2
  
  			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
              		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
              		strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  			
          		break; //0,1,2
          		
          	}
          	
          	break; //0,1
          	
  	case 2: //0,2
      	
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
         		
         		case 1: //0,2,1
  	
  			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
  			strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
              		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  			
          		break; //0,2,1
          		
          	}
          		
          	break; //0,2
          		
          }
         	
  	break; //0
  		
  //////////////////////////////////////////////////////////////////////////////////////	    	
  case 1: //1
  
  	switch (OrdenHora[linea - 1][bloque - 1]) {
      
  	case 0: //1,0
          
  	       	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          	
  	       	case 0: //1,0,0
  						
  			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
              		strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
              		break;//1,0,0
              		
  		case 2: //1,0,2
  
  		       	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  		        	
  		        break; //1,0,2
  	           	
          	}
  	
  		break; //1,0
  		
  	case 2: //1,2
      
  		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          	
   		case 0: //1,2,0
  
  			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  	        	
              		break; //1,2,0
          	
          	case 3: //1,2,3
                  
           		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Hora[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  			
          		break; //1,2,3
          		
          	}
          	
          	break; //1,2
          	
  	case 3: //1,3
      	
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
         		
         		case 2: //1,3,2
   		
  	           	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
              			
          		break; //1,3,2
          		
          	} 
          		
          	break; //1,3
          		        	
          } 
          	
          break; //1
          
  //////////////////////////////////////////////////////////////////////////////////////	
  case 2: //2
          	
         	switch(OrdenHora[linea - 1][bloque - 1]) {
          	
         	case 0: //2,0
          		
         		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          		
         		case 1: //2,0,1
         			
  	           	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);    		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  		        	
          		break; //2,0,1
          		
          	}
          		
          	break; //2,0
          	
          case 1: //2,1
          		
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          		
          	case 0: //2,1,0       	
            		
                  	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);    		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  		        	
          		break; //2,1,0
          		
          	case 3: //2,1,3
  
             		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
                  		
          		break; //2,1,3
          		
          	}
          		
          	break; //2,1
          	
          case 3: //2,3
          		
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          		
          	case 1: //2,3,1
     			        	
  	        	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
              				
          		break; //2,3,1
          		
          	}
          		
          	break; //2,3
          	
          }
          	
  	break; //2
  	
  //////////////////////////////////////////////////////////////////////////////////////	
  case 3: //3
          	
         	switch(OrdenHora[linea - 1][bloque - 1]) {
          	
         	case 1: //3,1 
          		
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          		
          	case 2: //3,1,2
            		
                 		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  		       	        		
          		break; //3,1,2
          		
          	}
          		
          	break; //3,1
          	
          case 2: //3,2
          		
          	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
          		
          	case 1: //3,2,1
  
  	             	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
  		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
  			strcat(lineatexto, Hora[linea - 1][bloque - 1]);  
  			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
  			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);           		
              		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
  		        	        		
          		break; //3,2,1
          		
          	}
          		
          	break; //3,2
          	
          }
          	
  	break; //3
  		
  } // de switch (OrdenFecha) inicial
  
    switch (linea) {
  
  	case 1:
  	strcpy(LineaTexto1[bloque - 1], lineatexto);
  	//CuadroTextoLinea1->value(lineatexto);
  	break;
  	
  	case 2:
  	strcpy(LineaTexto2[bloque - 1], lineatexto);
  	//CuadroTextoLinea2->value(lineatexto);
  	break;
  	
  	case 3:
  	strcpy(LineaTexto3[bloque - 1], lineatexto);
  	//CuadroTextoLinea3->value(lineatexto);
  	break;
  	
  	case 4:
  	strcpy(LineaTexto4[bloque - 1], lineatexto);
  	//CuadroTextoLinea4->value(lineatexto);
  	break;
  	
  }
  
  if (debug_texto) {
  	printf("lineatexto: %s\n", lineatexto);
  }
}

int Leer_Configuracion() {
    char record[255], *dato;	/* array to hold each "record" */ 
  FILE *fichero;                  /* pointer to input file */
  int caracter, i;
  
  /* open the file to read */
  fichero = fopen("itaca.conf", "r");		
  
  if (fichero == NULL) {
  	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  	rt_printk("Error al abrir el fichero itaca.conf\n");
    	system("cp /rootFLS/itaca/itaca.conf.ok itaca.conf");
    	exit(0);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  PeriodoTrenPulsos = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s PeriodoTrenPulsos %d\n", dato, PeriodoTrenPulsos);
  }
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoLaserOn = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s RetardoLaserOn %d\n", dato, RetardoLaserOn);
  }
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoLaserOff = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s RetardoLaserOff %d\n", dato, RetardoLaserOff);
  }
  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de la velocidad de salto */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  VelocidadSalto = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s VelocidadSalto %d\n", dato, VelocidadSalto);
  }
  
  /* Lee el valor del retardo de salto */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoSalto = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s RetardoSalto %d\n", dato, RetardoSalto);
  }
  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoPoligono = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s RetardoPoligono %d\n", dato, RetardoPoligono);
  }
  
  /* Lee el valor del Retardo de marcaje */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoMarcaje = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s RetardoMarcaje %d\n", dato, RetardoMarcaje);
  }
  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  CalibracionCorreccion = atof(dato);
  
  if (debug_resto){
  	printf("Dato %s CalibracionCorreccion %f\n", dato, CalibracionCorreccion);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Orientacion = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s Orientacion %d\n", dato, Orientacion);
  }
  
  /* Lee el valor del Avance */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Avance = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s Avance %d\n", dato, Avance);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    // 0 indica no activado, 1 indica activado con velocidad variable (usa encoder) y 2 es activado con 
  // CheckCentrado->activate();	velocidad constante
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  MarcajeDinamicoActivo = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s MarcajeDinamicoActivo %d\n", dato, MarcajeDinamicoActivo);
  }
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  CalibracionEncoder = atof(dato);
  
  if (debug_resto){
  	printf("Dato %s CalibracionEncoder %f\n", dato, CalibracionEncoder);
  }
  
  /* Lee el valor de la velocidad de la lÂ´inea */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  VelocidadLinea = atof(dato);
  
  if (debug_resto){
  	printf("Dato %s VelocidadLinea %f\n", dato, VelocidadLinea);
  }
  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  VGalvoRef_MaximoBits = atof(dato);
  
  VGalvoMax = VGalvoRef_MaximoBits * 1.001; // Para controlar el error de campo
  
  if (debug_resto){
  	printf("Dato %s VGalvoRef_MaximoBits %f\n", dato, VGalvoRef_MaximoBits);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ExtractorActivado = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (desactivado)
  if ((ExtractorActivado != 0) && (ExtractorActivado != 1)) {ExtractorActivado = 0;}
  
  if (debug_resto){
  	printf("Dato %s ExtractorActivado %d\n", dato, ExtractorActivado);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ValorDisparo = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0
  if ((ValorDisparo != 0) && (ValorDisparo != 1)) {ValorDisparo = 0;}
  
  if (debug_resto){
  	printf("Dato %s ValorDisparo %d\n", dato, ValorDisparo);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor del periodo en microsegundos */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  PERIODO_MICROSEGUNDOS = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s PERIODO_MICROSEGUNDOS %d\n", dato, PERIODO_MICROSEGUNDOS);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ServicioTecnico = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (desactivado)
  if ((ServicioTecnico != 0) && (ServicioTecnico != 1)) {ServicioTecnico = 0;}
  
  if (debug_resto){
  	printf("Dato %s ServicioTecnico %d\n", dato, ServicioTecnico);
  }
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor del idioma para el GUI */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Idioma = atoi(dato);
  
    if ((Idioma < 0) || (Idioma > 2)) {Idioma = 0;}
  
  if (debug_resto){
  	printf("Dato %s Idioma %d\n", dato, Idioma);
  }
  
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Spot = atoi(dato);
  
  // si es 0 o un valor negativo se asigna a 250 micras por defecto
  if (Spot <= 0) {Spot = 250;}
  
  if (debug_resto){
  	printf("Dato %s Spot %d\n", dato, Spot);
  }
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor que hay que escribir para activar los galvos */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ValorActivacionGalvos = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0
  if ((ValorActivacionGalvos != 0) && (ValorActivacionGalvos != 1)) {ValorActivacionGalvos = 0;}
  
  if (debug_resto){
  	printf("Dato %s ValorActivacionGalvos %d\n", dato, ValorActivacionGalvos);
  }
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor que hay que escribir para saber si hay control por puerto serie */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  PuertoSerieActivo = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (desactivado)
  if ((PuertoSerieActivo != 0) && (PuertoSerieActivo != 1)) {PuertoSerieActivo = 0;}
  
  if (debug_resto){
  	printf("Dato %s PuertoSerieActivo %d\n", dato, PuertoSerieActivo);
  }
  
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Centrado = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (no centrado)
  if ((Centrado != 0) && (Centrado != 1)) {Centrado = 0;}
  
  if (debug_resto){
  	printf("Dato %s Centrado %d\n", dato, Centrado);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor del tipo de disparo, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  TipoDisparo = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (externo) por defecto
  if ((TipoDisparo != 0) && (TipoDisparo != 1)) {TipoDisparo = 0;}
  
  if (debug_resto){
  	printf("Dato %s TipoDisparo %d\n", dato, TipoDisparo);
  }  
  
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  RetardoDisparo_mm = atoi(dato);
  
  // tiene que ser mayor que 0, si no se hace 0 por defecto
  if (RetardoDisparo_mm < 0) {RetardoDisparo_mm = 0;}
  
  if (debug_resto){
  	printf("Dato %s RetardoDisparo_mm %d\n", dato, RetardoDisparo_mm);
  }  
  
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  MinimoLecturasConsecutivasDisparo = atoi(dato);
  
  // tiene que ser mayor que 1, si no se hace 1 por defecto
  if (MinimoLecturasConsecutivasDisparo < 1) {MinimoLecturasConsecutivasDisparo = 1;}
  
  if (debug_resto){
  	printf("Dato %s MinimoLecturasConsecutivasDisparo %d\n", dato, MinimoLecturasConsecutivasDisparo);
  }  
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de la Separacion Entre Disparos */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  SeparacionEntreDisparos_mm = atoi(dato);
  
  // tiene que ser mayor que 1, si no se hace 1 por defecto
  if (SeparacionEntreDisparos_mm < 1) {SeparacionEntreDisparos_mm = 1;}
  
  if (debug_resto){
  	printf("Dato %s SeparacionEntreDisparos_mm %d\n", dato, SeparacionEntreDisparos_mm);
  }    
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor que hay que escribir para saber si se imprime en el reverso (en espejo) */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Reverso = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0
  if ((Reverso != 0)&&(Reverso != 1)) {Reverso = 0;}
  
  if (debug_resto){
  	printf("Dato %s Reverso %d\n", dato, Reverso);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor que hay que escribir para saber que estrategia de marcaje se sigue */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Estrategia = atoi(dato);
  
    if ((Estrategia != 0)&&(Estrategia != 1)&&(Estrategia != 2)&&(Estrategia!=3)) {Estrategia = 0;}
  
  if (debug_resto){
  	printf("Dato %s Estrategia %d\n", dato, Estrategia);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor que hay que escribir para saber que estrategia de marcaje se sigue */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  Control = atoi(dato);
  
  // tiene que ser 0 (DAQ) o 1 (FPGA), si no se hace 0
  if ((Control != 0)&&(Control != 1)) {Control = 0;}
  
  if (debug_resto){
  	printf("Dato %s Control %d\n", dato, Estrategia);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ControlarErrorCampo = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 1 (activado)
  if ((ControlarErrorCampo != 0) && (ControlarErrorCampo != 1)) {ControlarErrorCampo = 1;}
  
  if (debug_resto){
  	printf("Dato %s ControlarErrorCampo %d\n", dato, ControlarErrorCampo);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
    fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ControlarErrorGalvos = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 1 (activado)
  if ((ControlarErrorGalvos != 0) && (ControlarErrorGalvos != 1)) {ControlarErrorGalvos = 1;}
  
  if (debug_resto){
  	printf("Dato %s ControlarErrorGalvos %d\n", dato, ControlarErrorGalvos);
  }
  
  //////////////////////////////////////////////////////////////////////////////
      
  	// Lee los valores de los turnos separados por tabuladores
  	for (i=0; i<NumeroTurnos; i++) {
  		
  		//printf("i=%d\n", i);
  
    		fgets(record, sizeof(record), fichero);
  		dato = strtok(record, "\t"); HoraInicioTurno[i] = atoi(dato);
  		//printf("HoraInicioTurno[%d]:%d\n", i, HoraInicioTurno[i]);
  		dato = strtok(NULL, "\t"); MinutoInicioTurno[i] = atoi(dato);
  		//printf("MinutoInicioTurno[%d]:%d\n", i, MinutoInicioTurno[i]);		
  		dato = strtok(NULL, "\t"); HoraFinTurno[i] = atoi(dato);
  		//printf("HoraFinTurno[%d]:%d\n", i, HoraFinTurno[i]);		
  		dato = strtok(NULL, "\t"); MinutoFinTurno[i] = atoi(dato);
  		//printf("MinutoFinTurno[%d]:%d\n", i, MinutoFinTurno[i]);		
  		dato = strtok(NULL, "\t\n"); 
  		//printf("TextoTurno[%d]:%s\n", i, dato);		
  		
  		if (dato!=NULL) {
  			//printf("dato:%s\n", dato);
  			strcpy(TextoTurno[i], dato);
  		}
  		else {
  			strcpy (TextoTurno[i], "");
  		}
  		
    		MinutoDiaInicioTurno[i] = (HoraInicioTurno[i]*60) + MinutoInicioTurno[i];
  		MinutoDiaFinTurno[i] = (HoraFinTurno[i]*60) + MinutoFinTurno[i];
  		
  		if (debug_resto){
  			printf("Turno %d - %d\t%d\t%d\t%d\%s\n", i, HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
  		}
  
  	}
  
  }
  
  else {
  
  	// Lee los valores de los turnos separados por tabuladores
  	for (i=0; i<NumeroTurnos; i++) {
  
  		HoraInicioTurno[i] = 0;
  		MinutoInicioTurno[i] = 0;
  		HoraFinTurno[i] = 0;
  		MinutoFinTurno[i] = 0;
  		strcpy (TextoTurno[i], "");
  		
    		MinutoDiaInicioTurno[i] = (HoraInicioTurno[i]*60) + MinutoInicioTurno[i];
  		MinutoDiaFinTurno[i] = (HoraFinTurno[i]*60) + MinutoFinTurno[i];
  		
  		if (debug_resto){
  			printf("Turno %d - %d\t%d\t%d\t%d\%s\n", i, HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
  		}	
  	
  	}
  	
  }
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de Tipo de Laser */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  TipoLaser = atoi(dato);
  
  // tiene que ser 0 o , si no se hace 1 (CO2)
  if ((TipoLaser != 0) && (TipoLaser != 1)) {TipoLaser = 0;}
  
  if (debug_resto){
  	printf("Dato %s TipoLaser %d\n", dato, TipoLaser);
  }
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de activacion del fichero de correccion */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  FicheroCorreccionActivo = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (desactivado)
  if ((FicheroCorreccionActivo != 0) && (FicheroCorreccionActivo != 1)) {FicheroCorreccionActivo = 0;}
  
  if (debug_resto){
  	printf("Dato %s FicheroCorreccionActivo %d\n", dato, FicheroCorreccionActivo);
  }
  
  
  
  /* cierra el archivo */
  fclose(fichero);	
  
  ////////////////////////////////////////////////////////////////////////////////
  // Abre ahora el fichero de la funcionalidad, que es binario
  ////////////////////////////////////////////////////////////////////////////////
  
  fichero = fopen("funcionalidad.bin", "rb");		
  
  if (fichero == NULL) {
  	
    	Funcionalidad = SOLOTEXTO;
  }
  
  else {
  
    	caracter = fgetc(fichero);
  	
    	if (caracter == 1) {	
  		Funcionalidad = COMPLETA;
  	}
  
  	else if (caracter == 2) {	
  		Funcionalidad = BLOQUES;
  	}
  
  	else {
  		Funcionalidad = SOLOTEXTO;
  	}
  	
  	// cierra el archivo
  	fclose(fichero);
  	
    	// de esta forma aunque haya datos definidos en itaca.dat para el resto de los bloques
    	// los datos de nuevo
  	
  	if (Funcionalidad != BLOQUES) {
  		NumeroBloques = 1;
  	}
  	
  	else {
  		NumeroBloques = 3;
  	}
  
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  // Abre ahora el fichero de control de acceso, que es binario
  ////////////////////////////////////////////////////////////////////////////////
  
  fichero = fopen("acceso.bin", "rb");		
  
  if (fichero == NULL) {
  	
    	ControlAcceso = ON;
  }
  
  else {
  
    	caracter = fgetc(fichero);
  	
    	if (caracter == 1) {	
  		ControlAcceso = OFF;
  	}
  	else {
  		ControlAcceso = ON;
  	}
  	
  	// cierra el archivo
  	fclose(fichero);
  
  }
  
  ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////
  
  fichero = fopen("usuario.bin", "rb");		
  
  if (fichero == NULL) {
  	
    	strcpy(PasswordUsuario, PASSWORD);
  }
  
  else {
  
    	fgets(PasswordUsuario, sizeof(PasswordUsuario), fichero);
  	
  	// cierra el archivo
  	fclose(fichero);
  
  }
  
  ////////////////////////////////////////////////////////////////////////////////
  // Abre ahora el fichero de control tablas y precorte, que es binario
  ////////////////////////////////////////////////////////////////////////////////
  
  fichero = fopen("tablaprecorte.bin", "rb");		
  
  if (fichero == NULL) {
  	
    	ControlTablaPrecorte = OFF;
  }
  
  else {
  
    	caracter = fgetc(fichero);
  	
    	if (caracter == 1) {	
  		ControlTablaPrecorte = ON;
  	}
  	else {
  		ControlTablaPrecorte = OFF;
  	}
  	
  	// cierra el archivo
  	fclose(fichero);
  
  }
  
  return 0;
}

int Escribir_Configuracion() {
    
  char record[256];		/* array to hold each "record" */ 
  FILE *fichero;                  /* pointer to file */
  int i;
  
  /* open the file to write */
  fichero = fopen("itaca.conf", "w");			
  
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor del Periodo tren de pulsos */
  sprintf(record, "%d		Periodo tren de pulsos	(1 - 100.000 microsegundos)\n", PeriodoTrenPulsos);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor del Retardo Laser On */
  sprintf(record, "%d		Retardo Laser On .	(0 - 100.000 microsegundos)\n", RetardoLaserOn);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  /* Escribe el valor del Retardo Laser Off */
  sprintf(record, "%d		Retardo Laser Off 	(0 - 100.000 microsegundos)\n", RetardoLaserOff);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL DE SALTO\n", fichero);
  
  /* Escribe el valor de la Velocidad de salto */
  sprintf(record, "%d		Velocidad de salto	(100 - 50.000 mm/s)\n", VelocidadSalto);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor del Retardo Salto */
  sprintf(record, "%d		Retardo Salto 		(0 - 100.000 microsegundos)\n", RetardoSalto);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  //////////////////////////////////////////////////////////////////////////////
      
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor del Retardo de Marcaje */
  sprintf(record, "%d		Retardo Marcaje 	(0 - 100.000 microsegundos)\n", RetardoMarcaje);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  //////////////////////////////////////////////////////////////////////////////
      
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor de la Orientacion */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor del Avance */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor del Marcaje Dinamico Activo */
  sprintf(record, "%d		Activado		(0: desactivado 1:activado 2:velocidad constante)\n", MarcajeDinamicoActivo);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor de la Calibracion del Encoder */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  /* Escribe el valor de la Velocidad de Linea */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }
  	
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL GALVOS\n", fichero);
  
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  	
  	
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL EXTRACTOR\n", fichero);
  
  /* Escribe el valor del Extractor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
      
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	PERIODO\n", fichero);
  
  /* Escribe el valor del PERIODO_MICROSEGUNDOS */
  sprintf(record, "%d		Periodo Microsegundos	(10 - 1000) Periodo RT en microsegundos\n", PERIODO_MICROSEGUNDOS);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor del ServicioTecnico */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	IDIOMA\n", fichero);
  
  /* Escribe el valor del Idioma */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	SPOT\n", fichero);
  
  /* Escribe el valor del Spot */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor */
  sprintf(record, "%d		ValorActivacionGalvos	Valor digital (0/1) que hay que escribir para activar los galvos\n", ValorActivacionGalvos);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL PUERTO SERIE\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		PuertoSerieActivo	(0 - 1) Activa o no el control por el puerto serie\n", PuertoSerieActivo);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CENTRADO\n", fichero);
  
  /* Escribe el valor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	TIPO DE DISPARO\n", fichero);
  
  /* Escribe el valor del tipo de disparo */
  sprintf(record, "%d		TipoDisparo		(0 - 1) Disparo externo o interno\n", TipoDisparo);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	RETARDO DE DISPARO\n", fichero);
  
  /* Escribe el valor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
   	
  //////////////////////////////////////////////////////////////////////////////
      
  /* Escribe el valor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
      
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	REVERSO\n", fichero);
  
  /* Escribe el valor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	ESTRATEGIA DE MARCAJE\n", fichero);
  
  /* Escribe el valor */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	SISTEMA DE CONTROL\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		Sistema de control	0-DAQ, 1-FPGA\n", Control);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL ERROR DE CAMPO\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		ControlarErrorCampo\n", ControlarErrorCampo);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	CONTROL ERROR DE GALVOS\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		ControlarErrorGalvos\n", ControlarErrorGalvos);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	TURNOS\n", fichero);
  
  // Escribe los valores de los turnos separados por tabuladores
  for (i=0; i<NumeroTurnos; i++) {
  
  	sprintf(record, "%d\t%d\t%d\t%d\t%s\n", HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
  	fputs(record, fichero);
  	
  	if (debug_resto){
  		printf("Escribiendo: %s", record);
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	TIPO DE LASER\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		Tipo de Laser	0-CO2, 1-Fibra,\n", TipoLaser);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	FICHERO CORRECCION ACTIVO\n", fichero);
  
  /* Escribe el valor */
  sprintf(record, "%d		Fichero Correccion Activo	0-No Activo, 1-Activo\n", FicheroCorreccionActivo);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
   	 
  //////////////////////////////////////////////////////////////////////////////
  /* cierra el archivo */
  fclose(fichero);	
  
  return 0;
}

int Leer_DAT(char ArchivoDat[50]) {
    
  char record[256], *dato;		/* array to hold each "record" */ 
  FILE *fichero;                          /* pointer to input file */
  int i, j;
  
  
  /* open the file to read */
  //fichero = fopen("itaca.dat", "r");
  fichero = fopen(ArchivoDat, "r");		
  
  if (fichero == NULL) {
  	rt_printk("Error al abrir el fichero %s para lectura\n", ArchivoDat);
    	//system("cp /rootFLS/itaca/itaca.dat.ok itaca.dat");
    	//exit(0);
  	return 1;
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de la Potencia Laser inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  PotenciaLaser = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s PotenciaLaser %d\n", dato, PotenciaLaser);
  }  
  
  /* Lee el valor de la Velocidad de Marcaje inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  VelocidadMarcaje = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s VelocidadMarcaje %d\n", dato, VelocidadMarcaje);
  }  
    
  /* Lee el valor del offset vertical inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  Vertical = atoi(dato);
  
  yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits
  
  if (debug_resto){
  	printf("Dato %s Vertical %d\n", dato, Vertical);
  }    
    
  /* Lee el valor del offset horizontal inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  Horizontal = atoi(dato);
  
  xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion);	// en bits
  
  if (debug_resto){
  	printf("Dato %s Horizontal %d\n", dato, Horizontal);
  }      
  
  /* Lee el valor de la fuente seleccionada, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  ValorFuente = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s ValorFuente %d\n", dato, ValorFuente);
  }  
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  JustificacionIzquierda = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s JustificacionIzquierda %d\n", dato, JustificacionIzquierda);
  }     
    
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  JustificacionCentro = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s JustificacionCentro %d\n", dato, JustificacionCentro);
  }    
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  JustificacionDerecha = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s JustificacionDerecha %d\n", dato, JustificacionDerecha);
  }      
    
  /* Lee el valor de la anchura inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  Anchura = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s Anchura %d\n", dato, Anchura);
  }     
  
  /* Lee el valor del espaciado inicial, para cargar en el GUI */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  Espaciado = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s Espaciado %d\n", dato, Espaciado);
  }    
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  SeparacionLineas = atof(dato);
  
  if (debug_resto){
  	printf("Dato %s SeparacionLineas %f\n", dato, SeparacionLineas);
  }   
  
    
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (j=0; j<NumeroBloquesLinea; j++) {
  
        
  	// Copia el texto a la variable
  	if (dato) {
  		strcpy(LineaTexto1[j], dato);
  	}
  	else {	
  		strcpy(LineaTexto1[j], "");
  	}
  
  	if (debug_resto){
  		printf("LineaTexto1[%d]: %s\n", j, LineaTexto1[j]);
  	}
  
      	dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  	AlturaLineaTexto1[j] = atof(dato);
  
  	if (debug_resto){
  		printf("Dato %s AlturaLineaTexto1[%d] %2.1f\n", dato, j, AlturaLineaTexto1[j]);
  	}
  	
  }	     
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (j=0; j<NumeroBloquesLinea; j++) {
  
        
  	// Copia el texto a la variable
  	if (dato) {
  		strcpy(LineaTexto2[j], dato);
  	}
  	else {	
  		strcpy(LineaTexto2[j], "");
  	}
  
  	if (debug_resto){
  		printf("LineaTexto2[%d]: %s\n", j, LineaTexto2[j]);
  	}
  
      	dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  	AlturaLineaTexto2[j] = atof(dato);
  
  	if (debug_resto){
  		printf("Dato %s AlturaLineaTexto2[%d] %2.1f\n", dato, j, AlturaLineaTexto2[j]);
  	}
  
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (j=0; j<NumeroBloquesLinea; j++) {
  
        
  	// Copia el texto a la variable
  	if (dato) {
  		strcpy(LineaTexto3[j], dato);
  	}
  	else {	
  		strcpy(LineaTexto3[j], "");
  	}
  
  	if (debug_resto){
  		printf("LineaTexto3[%d]: %s\n", j, LineaTexto3[j]);
  	}
  
      	dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  	AlturaLineaTexto3[j] = atof(dato);
  
  	if (debug_resto){
  		printf("Dato %s AlturaLineaTexto3[%d] %2.1f\n", dato, j, AlturaLineaTexto3[j]);
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (j=0; j<NumeroBloquesLinea; j++) {
  
        
  	// Copia el texto a la variable
  	if (dato) {
  		strcpy(LineaTexto4[j], dato);
  	}
  	else {	
  		strcpy(LineaTexto4[j], "");
  	}
  
  	if (debug_resto){
  		printf("LineaTexto4[%d]: %s\n", j, LineaTexto4[j]);
  	}
  
      	dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  	AlturaLineaTexto4[j] = atof(dato);
  
  	if (debug_resto){
  		printf("Dato %s AlturaLineaTexto4[%d] %2.1f\n", dato, j, AlturaLineaTexto4[j]);
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		/* Lee el valor del status de fecha */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		StatusFecha[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s StatusFecha[%d][%d] %d\n", dato, i, j, StatusFecha[i][j]);
  		}  
  
  		/* Lee el orden de la fecha */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		OrdenFecha[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s OrdenFecha[%d][%d] %d\n", dato, i, j, OrdenFecha[i][j]);
  		}  
  
  		/* Lee el formato completo de la fecha */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(FormatoCompletoFecha[i][j], dato);
  		}	
  		else {		
  			strcpy(FormatoCompletoFecha[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("FormatoCompletoFecha[%d][%d]: %s\n", i, j, FormatoCompletoFecha[i][j]);
  		}
  
  		/* Lee el texto anterior a la fecha */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoanteriorfecha[i][j], dato);
  		}	
  		else {		
  			strcpy(textoanteriorfecha[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoanteriorfecha[%d][%d]: %s\n", i, j, textoanteriorfecha[i][j]);
  		}
  
  		/* Lee el texto posterior a la fecha */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoposteriorfecha[i][j], dato);
  		}
  		else {	
  			strcpy(textoposteriorfecha[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoposteriorfecha[%d][%d]: %s\n", i, j, textoposteriorfecha[i][j]);
  		}
  
  		/* Lee el valor del formato de fecha 1 */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoFecha1[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoFecha1[%d][%d] %d\n", dato, i, j, ValorFormatoFecha1[i][j]);
  		}
  	
  		/* Lee el valor del formato de fecha 2 */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoFecha2[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoFecha2[%d][%d] %d\n", dato, i, j, ValorFormatoFecha2[i][j]);
  		}
  	
  		/* Lee el valor del formato de fecha 3 */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoFecha3[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoFecha3[%d][%d] %d\n", dato, i, j, ValorFormatoFecha3[i][j]);
  		}
  	
  		/* Lee el valor del separador de fecha */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorSeparadorFecha[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorSeparadorFecha[%d][%d] %d\n", dato, i, j, ValorSeparadorFecha[i][j]);
  		}
  
  		/* Lee el valor de la caducidad, para cargar en el GUI */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		Caducidad[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s Caducidad[%d][%d] %d\n", dato, i, j, Caducidad[i][j]);
  		}  
  
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
  		/* Lee el valor del status de la hora */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		StatusHora[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s StatusHora[%d][%d] %d\n", dato, i, j, StatusHora[i][j]);
  		}  
  
  		/* Lee el orden de la hora */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		OrdenHora[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s OrdenHora[%d][%d] %d\n", dato, i, j, OrdenHora[i][j]);
  		}    
  
  		/* Lee el formato completo de la hora */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(FormatoCompletoHora[i][j], dato);
  		}	
  		else {		
  			strcpy(FormatoCompletoHora[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("FormatoCompletoHora[%d][%d]: %s\n", i, j, FormatoCompletoHora[i][j]);
  		}
  	
  		/* Lee el texto anterior a la hora */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoanteriorhora[i][j], dato);
  		}
  		else {	
  			strcpy(textoanteriorhora[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoanteriorhora[%d][%d]: %s\n", i, j, textoanteriorhora[i][j]);
  		}
  
  		/* Lee el texto posterior a la hora */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoposteriorhora[i][j], dato);
  		}
  		else {	
  			strcpy(textoposteriorhora[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoposteriorhora[%d][%d]: %s\n", i, j, textoposteriorhora[i][j]);
  		}
  	
  		/* Lee el valor del formato de hora 1, para cargar en el GUI */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoHora1[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoHora1[%d][%d] %d\n", dato, i, j, ValorFormatoHora1[i][j]);
  		}  
  	
  		/* Lee el valor del formato de hora 2, para cargar en el GUI */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoHora2[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoHora2[%d][%d] %d\n", dato, i, j, ValorFormatoHora2[i][j]);
  		}  
  	
  		/* Lee el valor del formato de hora 3, para cargar en el GUI */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorFormatoHora3[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorFormatoHora3[%d][%d] %d\n", dato, i, j, ValorFormatoHora3[i][j]);
  		}  
  	
  		/* Lee el valor del separador de hora, para cargar en el GUI */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorSeparadorHora[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorSeparadorHora[%d][%d] %d\n", dato, i, j, ValorSeparadorHora[i][j]);
  		}  
  
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
   		/* Lee el valor del status de serie */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		StatusNumeroSerie[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s StatusNumeroSerie[%d][%d] %d\n", dato, i, j, StatusNumeroSerie[i][j]);
  		}
  	
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		OrdenNumeroSerie[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s OrdenNumeroSerie[%d][%d] %d\n", dato, i, j, OrdenNumeroSerie[i][j]);
  		} 
  	
        
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(strNumeroSerie[i][j], dato);
  		}
  		else {	
  			strcpy(strNumeroSerie[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("strNumeroSerie[%d][%d]: %s\n", i, j, strNumeroSerie[i][j]);
  		}
  	
        
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoanteriorserie[i][j], dato);
  		}
  		else {	
  			strcpy(textoanteriorserie[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoanteriorserie[%d][%d]: %s\n", i, j, textoanteriorserie[i][j]);
  		}
  
        
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(textoposteriorserie[i][j], dato);
  		}
  		else {	
  			strcpy(textoposteriorserie[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("textoposteriorserie[%d][%d]: %s\n", i, j, textoposteriorserie[i][j]);
  		}	
  	
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroSerie[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s NumeroSerie[%d][%d] %ld\n", dato, i, j, NumeroSerie[i][j]);
  		}  
  
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroDigitosNumeroSerie[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s NumeroDigitosNumeroSerie[%d][%d] %d\n", dato, i, j, NumeroDigitosNumeroSerie[i][j]);
  		}  	
  
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroSerieInicial[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s NumeroSerieInicial[%d][%d] %ld\n", dato, i, j, NumeroSerieInicial[i][j]);
  		}  
  
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroSerieFinal[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s NumeroSerieFinal[%d][%d] %ld\n", dato, i, j, NumeroSerieFinal[i][j]);
  		}  
  
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroUnidadesLote[i][j] = atoi(dato);
  	
    		if (NumeroUnidadesLote[i][j] == 0) {
  			NumeroUnidadesLote[i][j] = 1;
  		}
  
  		if (debug_resto){
  			printf("Dato %s NumeroUnidadesLote[%d][%d] %ld\n", dato, i, j, NumeroUnidadesLote[i][j]);
  		}  
  
      		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		NumeroUnidadesLoteActual[i][j] = atoi(dato);
  
    		if (NumeroUnidadesLoteActual[i][j] == 0) {
  			NumeroUnidadesLoteActual[i][j] = 1;
  		}
  	
  		if (debug_resto){
  			printf("Dato %s NumeroUnidadesLoteActual[%d][%d] %ld\n", dato, i, j, NumeroUnidadesLoteActual[i][j]);
  		} 
  
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		/* Lee lineaanterior */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(lineaanterior[i][j], dato);
  		}
  		else {
  			strcpy(lineaanterior[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("lineaanterior[%d][%d]: %s\n", i, j, lineaanterior[i][j]);
  		}
  
  		/* Lee lineamedio */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(lineamedio[i][j], dato);
  		}
  		else {	
  			strcpy(lineamedio[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("lineamedio[%d][%d]: %s\n", i, j, lineamedio[i][j]);
  		}
  
  		/* Lee lineamedio2 */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(lineamedio2[i][j], dato);
  		}
  		else {	
  			strcpy(lineamedio2[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("lineamedio2[%d][%d]: %s\n", i, j, lineamedio2[i][j]);
  		}
  
  		/* Lee lineafinal */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(lineafinal[i][j], dato);
  		}
  		else {	
  			strcpy(lineafinal[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("lineafinal[%d][%d]: %s\n", i, j, lineafinal[i][j]);
  		}
  	
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
          
          for (j=0; j<NumeroBloquesLinea; j++) {
          
  		/* Lee el valor de ValorTipoLinea */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		ValorTipoLinea[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s ValorTipoLinea[%d][%d] %d\n", dato, i, j, ValorTipoLinea[i][j]);
  		}
  	
  		/* Lee el valor de InvertirBarcode */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		InvertirBarcode[i][j] = atoi(dato);
  
  		if (debug_resto){
  			printf("Dato %s InvertirBarcode[%d][%d] %d\n", dato, i, j, InvertirBarcode[i][j]);
  		}
  	
  		/* Lee el valor de EscalaBarcode */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		EscalaBarcode[i][j] = atoi(dato);
  	
  		if (EscalaBarcode[i][j] == 0) {EscalaBarcode[i][j]=100;}
  	
  		if (debug_resto){
  			printf("Dato %s EscalaBarcode[%d][%d] %d\n", dato, i, j, EscalaBarcode[i][j]);
  		}   
  	
  		/* Lee el valor de SeparacionBarrasBarcode */
    		dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  		SeparacionBarrasBarcode[i][j] = atoi(dato);
  	
  		if (SeparacionBarrasBarcode[i][j] == 0) {SeparacionBarrasBarcode[i][j]=100;}
  
  		if (debug_resto){
  			printf("Dato %s SeparacionBarrasBarcode[%d][%d] %d\n", dato, i, j, SeparacionBarrasBarcode[i][j]);
  		}
  	
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		/* Lee el nombre del archivo plt */
      
  		// Copia el texto a la variable
  		if (dato) {
  			strcpy(NombreArchivoPlt[i][j], dato);
  		}
  		else {	
  			strcpy(NombreArchivoPlt[i][j], "");
  		}
  
  		if (debug_resto){
  			printf("NombreArchivoPlt[%d][%d]: %s\n", i, j, NombreArchivoPlt[i][j]);
  		}
        
  	}
  	
  }
  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
          
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  NumeroFilas = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s NumeroFilas %d\n", dato, NumeroFilas);
  }  
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  SeparacionFilas = atof(dato);
  ySeparacionFilas = (int)(SeparacionFilas * CalibracionCorreccion);	// en bits
  
  if (debug_resto){
  	printf("Dato %s SeparacionFilas %f\n", dato, SeparacionFilas);
  }   
          
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  NumeroColumnas = atoi(dato);
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  SeparacionColumnas = atof(dato);
  xSeparacionColumnas = (int)(SeparacionColumnas * CalibracionCorreccion);	// en bits
  
  if (debug_resto){
  	printf("Dato %s SeparacionColumnas %f\n", dato, SeparacionColumnas);
  }   
  
  if (debug_resto){
  	printf("Dato %s NumeroColumnas %d\n", dato, NumeroColumnas);
  }  
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
          
  /* Lee el valor del Precorte */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  Precorte = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s Precorte %d\n", dato, Precorte);
  }  
  
  /* Lee el valor de la longitud del Precorte (%) */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  LongitudPrecorte = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s LongitudPrecorte %d\n", dato, LongitudPrecorte);
  }  
  
      dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  SeparacionPrecorte = atof(dato);
  SeparacionPrecorteBits = (int)(SeparacionPrecorte * CalibracionCorreccion);	// en bits
  
  if (debug_resto){
  	printf("Dato %s SeparacionPrecorte %f\n", dato, SeparacionPrecorte);
  }   
  
  /* Lee el valor de la velocidad del Precorte */
    dato = strtok(record, "\t"); 		/* lee hasta el primer tabulador */
  VelocidadPrecorte = atoi(dato);
  
  if (debug_resto){
  	printf("Dato %s VelocidadPrecorte %d\n", dato, VelocidadPrecorte);
  }   
  
    fgets(record, sizeof(record), fichero);
  
  /* Lee el valor de ResetSerieFecha */
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t");
  ResetSerieFecha = atoi(dato);
  
  // tiene que ser 0 o 1, si no se hace 0 (Desactivado)
  if ((ResetSerieFecha != 0) && (ResetSerieFecha != 1)) {ResetSerieFecha = 0;}
  
  if (debug_resto){
  	printf("Dato %s ResetSerieFecha %d\n", dato, ResetSerieFecha);
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fgets(record, sizeof(record), fichero);
  
  
  for (i=0; i<NumeroLineasTexto; i++) {
  	for (j=0; j<NumeroBloquesLinea;j++){
  		/* Lee el valortipolinea*/ 
  		fgets(record, sizeof(record),fichero);	
  		dato = strtok(record, "\t");
  		ValorTipoLinea[i][j] =atoi(dato);
  		//rt_printk("Valor Tipo Linea = %d \n",ValorTipoLinea[i][j]);
  
  		
  		if (ValorTipoLinea[i][j] == TEXTO) {
  			/* Lee el valor XMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinXTexto[i][j] =atof(dato);
  			//rt_printk("MinXTexto = %f \n",MinXTexto[i][j]);
  
  			/* Lee el valor YMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinYTexto[i][j] =atof(dato);
  		}
  		else if (ValorTipoLinea[i][j] == GRAFICO) {
  			/* Lee el valor XMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinXGrafico[i][j] =atof(dato);
  			/* Lee el valor YMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinYGrafico[i][j] =atof(dato);
  		}
  		else if (ValorTipoLinea[i][j] == TEXTOCIRCULAR) {
  			/* Lee el valor CentroX*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			CentroXTextoCircular[i][j] =atof(dato);
  			/* Lee el valor CentroY*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			CentroYTextoCircular[i][j] =atof(dato);
  			/* Lee el angulo*/
  			fgets(record, sizeof(record),fichero);
  			dato = strtok(record, "\t");
  			AnguloTextoCircular[i][j]=atof(dato);
  			/* Lee el radio*/
  			fgets(record, sizeof(record),fichero);
  			dato = strtok(record, "\t");
  			RadioTextoCircular[i][j]=atof(dato);			
  		}
  		else {
  			/* Lee el valor XMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinXBarcode[i][j] =atof(dato);
  			/* Lee el valor YMin*/ 
  			fgets(record, sizeof(record),fichero);	
  			dato = strtok(record, "\t");
  			MinYBarcode[i][j] =atof(dato);
  		}
  
  				
  	}
  }
          
  //////////////////////////////////////////////////////////////////////////////
  /* cierra el archivo */
  fclose(fichero);	
  
  return 0;
}

int Escribir_DAT(char ArchivoDat[50]) {
    
  char record[256];		/* array to hold each "record" */ 
  FILE *fichero;                          /* pointer to file */
  int i, j;
  
  //rt_printk("Escribir DAT: %s\n", ArchivoDat);
  
  /* open the file to write */
  fichero = fopen(ArchivoDat, "w");		
  
  if (fichero == NULL) {
  	rt_printk("Error al abrir el fichero %s para escritura\n", ArchivoDat);
    	//system("cp /rootFLS/itaca/itaca.dat.ok itaca.dat");
    	//exit(0);
  	return 1;
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Global\n", fichero);
  
  /* Escribe el valor de la Potencia Laser */
    fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }  
  
  /* Escribe el valor de la Velocidad de Marcaje */
  sprintf(record, "%d		Velocidad Marcaje	(100 - 20.000 mm/s)\n", VelocidadMarcaje);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  /* Escribe el valor del Offset Vertical */
  sprintf(record, "%d		Vertical		(-semicampo mm a +semicampo mm)\n", Vertical);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  /* Escribe el valor del Offset Horizontal */
  sprintf(record, "%d		Horizontal		(-semicampo mm a +semicampo mm)\n", Horizontal);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }   
  
  /* Escribe el valor de la fuente */
  sprintf(record, "%d		Valor Fuente\n", ValorFuente);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo Valor Fuente: %s", record);
  } 
  
    sprintf(record, "%d		JustificacionIzquierda	(0 - 1)\n", JustificacionIzquierda);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }      
  
    sprintf(record, "%d		JustificacionCentro	(0 - 1)\n", JustificacionCentro);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }      
  
    sprintf(record, "%d		JustificacionDerecha	(0 - 1)\n", JustificacionDerecha);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }      
  
  /* Escribe el valor de la Anchura */
  sprintf(record, "%d		Anchura			(10 - 200)\n", Anchura);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  }      
  
  /* Escribe el valor del Espaciado */
  sprintf(record, "%d		Espaciado		(10 - 200)\n", Espaciado);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
   
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
   
  //////////////////////////////////////////////////////////////////////////////
      
  for (j=0; j<NumeroBloquesLinea; j++) {
   
    	sprintf(record, "%s\n", LineaTexto1[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
    	} 
  
    	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\n", AlturaLineaTexto1[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
  		printf("Escribiendo: %s", record);
  	}
  	
  } 
     
  //////////////////////////////////////////////////////////////////////////////
       
  for (j=0; j<NumeroBloquesLinea; j++) {
   
    	sprintf(record, "%s\n", LineaTexto2[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
    	} 
  
    	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\n", AlturaLineaTexto2[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
  		printf("Escribiendo: %s", record);
  	}
  	
  } 
     
  //////////////////////////////////////////////////////////////////////////////
      
  for (j=0; j<NumeroBloquesLinea; j++) {
   
    	sprintf(record, "%s\n", LineaTexto3[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
    	} 
  
    	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\n", AlturaLineaTexto3[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
  		printf("Escribiendo: %s", record);
  	}
  	
  } 
  
  //////////////////////////////////////////////////////////////////////////////
      
  for (j=0; j<NumeroBloquesLinea; j++) {
   
    	sprintf(record, "%s\n", LineaTexto4[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
    	} 
  
    	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\n", AlturaLineaTexto4[j]);
  	fputs(record, fichero);
  
  	if (debug_resto){
  		printf("Escribiendo: %s", record);
  	}
  	
  } 
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Campos variables: Fecha \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		/* Escribe el status de la fecha */
  		sprintf(record, "%d		StatusFecha[%d][%d]\n", StatusFecha[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo StatusFecha[%d][%d]: %s", i, j, record);
  		} 
   
  	 	/* Escribe el orden de la fecha */
  		sprintf(record, "%d		OrdenFecha[%d][%d]\n", OrdenFecha[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo OrdenFecha[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe el valor del formato completo de la fecha */
  		sprintf(record, "%s\n", FormatoCompletoFecha[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo FormatoCompletoFecha[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el texto anterior a la fecha */
  		sprintf(record, "%s\n", textoanteriorfecha[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoanteriorfecha[%d][%d]: %s", i, j, record);
  		} 
   
  		/* Escribe el texto posterior a la fecha */
  		sprintf(record, "%s\n", textoposteriorfecha[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoposteriorfecha[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe el valor del formato de la fecha 1 */
  		sprintf(record, "%d		ValorFormatoFecha1[%d][%d]\n", ValorFormatoFecha1[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoFecha1[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del formato de la fecha 2 */
  		sprintf(record, "%d		ValorFormatoFecha2[%d][%d]\n", ValorFormatoFecha2[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoFecha2[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del formato de la fecha 3 */
  		sprintf(record, "%d		ValorFormatoFecha3[%d][%d]\n", ValorFormatoFecha3[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoFecha3[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del separador de la fecha */
  		sprintf(record, "%d		ValorSeparadorFecha[%d][%d]\n", ValorSeparadorFecha[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorSeparadorFecha[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe el valor de la caducidad */
  		sprintf(record, "%d		Caducidad[%d][%d]\n", Caducidad[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo Caducidad[%d][%d]: %s", i, j, record);
  		} 
  
  	}
  
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Campos variables: Hora \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
  		/* Escribe el status de la hora */
  		sprintf(record, "%d		StatusHora[%d][%d]\n", StatusHora[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo StatusHora[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe el orden de la hora */
  		sprintf(record, "%d		OrdenHora[%d][%d]\n", OrdenHora[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo OrdenHora[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe el valor del formato completo de la hora */
  		sprintf(record, "%s\n", FormatoCompletoHora[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo FormatoCompletoHora[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el texto anterior a la hora */
  		sprintf(record, "%s\n", textoanteriorhora[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoanteriorhora[%d][%d]: %s", i, j, record);
  		} 
   
  		/* Escribe el texto posterior a la hora */
  		sprintf(record, "%s\n", textoposteriorhora[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoposteriorhora[%d][%d]: %s", i, j, record);
  		} 
  		
  		/* Escribe el valor del formato de la hora 1 */
  		sprintf(record, "%d		ValorFormatoHora1[%d][%d]\n", ValorFormatoHora1[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoHora1[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del formato de la hora 2 */
  		sprintf(record, "%d		ValorFormatoHora2[%d][%d]\n", ValorFormatoHora2[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoHora2[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del formato de la hora 3 */
  		sprintf(record, "%d		ValorFormatoHora3[%d][%d]\n", ValorFormatoHora3[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorFormatoHora3[%d][%d]: %s", i, j, record);
  		} 
  	
  		/* Escribe el valor del separador de la hora */
  		sprintf(record, "%d		ValorSeparadorHora[%d][%d]\n", ValorSeparadorHora[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorSeparadorHora[%d][%d]: %s", i, j, record);
  		} 
  
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Campos variables: Serie \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
    		sprintf(record, "%d		OrdenNumeroSerie[%d][%d]\n", OrdenNumeroSerie[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo OrdenNumeroSerie[%d][%d]: %s", i, j, record);
  		} 
  	
    		sprintf(record, "%s\n", strNumeroSerie[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo strNumeroSerie[%d][%d]: %s", i, j, record);
  		} 
  
    		sprintf(record, "%s\n", textoanteriorserie[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoanteriorserie[%d][%d]: %s", i, j, record);
  		} 
   
    		sprintf(record, "%s\n", textoposteriorserie[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo textoposteriorserie[%d][%d]: %s", i, j, record);
  		} 
  		
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
      		fputs(record, fichero);
  
  		if (debug_resto){
    		} 
  
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Campos variables: textos \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		/* Escribe lineaanterior */
  		sprintf(record, "%s\n", lineaanterior[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo lineaanterior[%d][%d]: %s", i, j, record);
  		} 
   
  		/* Escribe lineamedio */
  		sprintf(record, "%s\n", lineamedio[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo lineamedio[%d][%d]: %s", i, j, record);
  		}
  
  		/* Escribe lineamedio2 */
  		sprintf(record, "%s\n", lineamedio2[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo lineamedio2[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe lineafinal */
  		sprintf(record, "%s\n", lineafinal[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo lineafinal[%d][%d]: %s", i, j, record);
  		} 
  
  	}
  	
  } 
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Barcode \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   	
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
  	 	/* Escribe ValorTipoBarcode */
  		sprintf(record, "%d		ValorTipoLinea[%d][%d]\n", ValorTipoLinea[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorTipoLinea[%d][%d]: %s", i, j, record);
  		} 
   
  		/* Escribe InvertirBarcode */
  		sprintf(record, "%d		InvertirBarcode[%d][%d]\n", InvertirBarcode[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo InvertirBarcode[%d][%d]: %s", i, j, record);
  		} 
  
  		/* Escribe EscalaBarcode */
  		sprintf(record, "%d		EscalaBarcode[%d][%d]\n", EscalaBarcode[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo DensidadBarcode[%d][%d]: %s", i, j, record);
  		}
  	
  		/* Escribe SeparacionBarrasBarcode */
  		sprintf(record, "%d		SeparacionBarrasBarcode[%d][%d]\n", SeparacionBarrasBarcode[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo SeparacionBarrasBarcode[%d][%d]: %s", i, j, record);
  		} 
  	
  	}
  	
  } 
  
  //////////////////////////////////////////////////////////////////////////////
      
  for (i=0; i<NumeroLineasTexto; i++) {
   	
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
   		/* Escribe el nombre del archivo plt */
  		sprintf(record, "%s\n", NombreArchivoPlt[i][j]);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo NombreArchivoPlt[%d][%d]: %s", i, j, record);
  		} 
  	
  	}
  	
  }
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Repeticiones\n", fichero);
  
    sprintf(record, "%d		Numero de Filas		(1 - 20)\n", NumeroFilas);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
    sprintf(record, "%d		Numero de Columnas	(1 - 20)\n", NumeroColumnas);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Precorte\n", fichero);
  
  /* Escribe el valor del Precorte */
  sprintf(record, "%d		Precorte		(0 - 1)\n", Precorte);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
  /* Escribe el valor de la longitud del Precorte (en %) */
  sprintf(record, "%d		Longitud Precorte	(10 - 200)\n", LongitudPrecorte);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
      fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
  /* Escribe el valor de la velocidad del Precorte (en %) */
  sprintf(record, "%d		Velocidad Precorte	(10 - 1000)\n", VelocidadPrecorte);
  fputs(record, fichero);
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
    fputs("#	ResetSerieFecha\n", fichero);
  
  /* Escribe el valor del ResetSerieFecha */
  sprintf(record, "%d		ResetSerieFecha		(0 - 1)\n", ResetSerieFecha);
  fputs(record, fichero);
  
  //////////////////////////////////////////////////////////////////////////////
    fputs("#	Valores tipo linea de X Y \n", fichero);
  
  for (i=0; i<NumeroLineasTexto; i++) {
   	
   	for (j=0; j<NumeroBloquesLinea; j++) {
   	
  	 	/* Escribe ValorTipoBarcode */
  		sprintf(record, "%d		ValorTipoLinea[%d][%d]\n", ValorTipoLinea[i][j], i, j);
  		fputs(record, fichero);
  
  		if (debug_resto){
  			printf("Escribiendo ValorTipoLinea[%d][%d]: %s", i, j, record);
  		} 
   
  		/* Escribe Valores Tipo Texto */
  		if (ValorTipoLinea[i][j]==TEXTO){
  			sprintf(record, "%f		MinXTexto[%d][%d]\n", MinXTexto[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		MinYTexto[%d][%d]\n", MinYTexto[i][j], i, j);
  			fputs(record, fichero);
  			}
  		/* Escribe Valores Tipo Grafico */
  		else if (ValorTipoLinea[i][j]==GRAFICO){
  			sprintf(record, "%f		MinXGrafico[%d][%d]\n", MinXGrafico[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		MinYGrafico[%d][%d]\n", MinYGrafico[i][j], i, j);
  			fputs(record, fichero);
  			}
  		/* Escribe Valores Tipo Texto Circular */
  		else if (ValorTipoLinea[i][j]==TEXTOCIRCULAR){
  			sprintf(record, "%f		CentroXTextoCircular[%d][%d]\n", CentroXTextoCircular[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		CentroYTextoCircular[%d][%d]\n", CentroYTextoCircular[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		AnguloTextoCircular[%d][%d]\n", AnguloTextoCircular[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		RadioTextoCircular[%d][%d]\n", RadioTextoCircular[i][j], i, j);
  			fputs(record, fichero);
  			}
  		else {
  			sprintf(record, "%f		MinXBarcode[%d][%d]\n", MinXBarcode[i][j], i, j);
  			fputs(record, fichero);
  			sprintf(record, "%f		MinYBarcode[%d][%d]\n", MinYBarcode[i][j], i, j);
  			fputs(record, fichero);
  		}
  
  	
  	}
  	
  } 
  
  
  
  if (debug_resto){
  	printf("Escribiendo: %s", record);
  } 
  
  
   	 
  //////////////////////////////////////////////////////////////////////////////
  /* cierra el archivo */
  fclose(fichero);
  
  //system("mount / -o rw,remount");
  //system("cp itaca.dat /rootFLS/itaca/itaca.dat");
  //system("mount / -o ro,remount");
  
  return 0;
}

void Inicializar_Marcaje() {
  //////////////////////////////////////////////////////////////////////////////
    
    
  if (!EnEjecucion) {
  
  	// Semicampo en mm
  	Semicampo = (float) (MaximoBits/CalibracionCorreccion);
  
  	// Inicializa lista 0
  	Lista0_Open = false;
  	Lista0_Exe = false;
  	Lista0_NumeroMicroVectores = 0;
  
  	// Inicializa lista 1
  	Lista1_Open = false;
  	Lista1_Exe = false;
  	Lista1_NumeroMicroVectores = 0;
  
  	// Inicializa lista 2
  	Lista2_Open = false;
  	Lista2_Exe = false;
  	Lista2_NumeroMicroVectores = 0;
  
  	//////////////////////////////////////////////////////////////////////////////
  
  	// Calcula el Mark Step Size
  	CalcularMarkStepSize();
  
  	// Calcula el Jump Step Size
  	CalcularJumpStepSize();
  
    	PeriodosRetardoLaserOn = (unsigned int) floor((float)RetardoLaserOn/(float)PERIODO_MICROSEGUNDOS);
  
    	PeriodosRetardoLaserOff = (unsigned int) floor((float)RetardoLaserOff/(float)PERIODO_MICROSEGUNDOS);
  
    	PeriodosRetardoMarcaje = (unsigned int) floor((float)RetardoMarcaje/(float)PERIODO_MICROSEGUNDOS);
  
    	PeriodosRetardoPoligono = (unsigned int) floor((float)RetardoPoligono/(float)PERIODO_MICROSEGUNDOS);
  
    	PeriodosRetardoSalto = (unsigned int) floor((float)RetardoSalto/(float)PERIODO_MICROSEGUNDOS);
  
  	if (debug_resto) {
  
  		rt_printk("PeriodosRetardoLaserOn: %d\n", PeriodosRetardoLaserOn);
  		rt_printk("PeriodosRetardoLaserOff: %d\n", PeriodosRetardoLaserOff);
  		rt_printk("PeriodosRetardoMarcaje: %d\n", PeriodosRetardoMarcaje);
  		rt_printk("PeriodosRetardoPoligono: %d\n", PeriodosRetardoPoligono);
  		rt_printk("PeriodosRetardoSalto: %d\n", PeriodosRetardoSalto);
  
  	}
  
  	//////////////////////////////////////////////////////////////////////////////
  
    	AnchuraLineaTexto1 = 0;
  
    	AnchuraLineaTexto2 = 0;
  
    	AnchuraLineaTexto3 = 0;
  	
    	AnchuraLineaTexto4 = 0;
  
  	// Estado
  	EstadoLaser = OFF;
  	Actualizar = false;
  	//Contador = 0;
  	EnEjecucion = false;
  	MarcajeOk = true;
  
  	// Fuentes
  	ArchivoFuentesAbierto = false;
  	AnchuraCaracterAnterior = 0;
  	xMaxFont = 0;
  	yMaxFont = 0;
  
      	Ky_Bits_a_Voltios = (double)(VGalvoRef_MaximoBits)/(double)(MaximoBits);
  	
  	if (debug_resto){
  		rt_printk("Kx_Bits_a_Voltios:%f   Ky_Bits_a_Voltios:%f \n", Kx_Bits_a_Voltios, Ky_Bits_a_Voltios);
  	}
  	
  }
  
  
      
  switch (Avance) {
                  
  case 0:
  	
    		Kx_Cuentas_a_Bits = (double)CalibracionCorreccion/(double)CalibracionEncoder;
  	}
  	
  	else {	//velocidad constante
  		Kx_Cuentas_a_Bits = (double)CalibracionCorreccion/25.0;
  	}
  	
  	Ky_Cuentas_a_Bits = 0;
  	
    	Ku_Cuentas_a_Bits = Kx_Cuentas_a_Bits;
  	
  	break;
          
  case 90:
  	
  	Kx_Cuentas_a_Bits = 0;
  	
    		Ky_Cuentas_a_Bits = (double)CalibracionCorreccion/(double)CalibracionEncoder;
  	}
  	
  	else {	//velocidad constante
  		Ky_Cuentas_a_Bits = (double)CalibracionCorreccion/25.0;
  	}
  	
    	Ku_Cuentas_a_Bits = Ky_Cuentas_a_Bits;
  	
  	break;
              
  case 180:
  		
    		Kx_Cuentas_a_Bits = -(double)CalibracionCorreccion/(double)CalibracionEncoder;
  	}
  	
  	else {	//velocidad constante
  		Kx_Cuentas_a_Bits = -(double)CalibracionCorreccion/25.0;
  	}
  	
  	Ky_Cuentas_a_Bits = 0;
  	
    	Ku_Cuentas_a_Bits = Kx_Cuentas_a_Bits;
  	
  	break;
  	
  case 270:
  	
  	Kx_Cuentas_a_Bits = 0;
  	
    		Ky_Cuentas_a_Bits = -(double)CalibracionCorreccion/(double)CalibracionEncoder;
  	}
  	
  	else {	//velocidad constante
  		Ky_Cuentas_a_Bits = -(double)CalibracionCorreccion/25.0;
  	}
  	
    	Ku_Cuentas_a_Bits = Ky_Cuentas_a_Bits;
  	
  	break;
  
  }
  
  if (debug_resto){
  	rt_printk("Kx_Cuentas_a_Bits:%f   Ky_Cuentas_a_Bits:%f \n", Kx_Cuentas_a_Bits, Ky_Cuentas_a_Bits);
  }
  
    if (MarcajeDinamicoActivo == 2) {
  
    	//IncrementoCuentasPeriodo = (float) (VelocidadLinea * CalibracionEncoder * PERIODO_MICROSEGUNDOS / 60000.0);
  	IncrementoCuentasPeriodo = (float) (VelocidadLinea * 25.0 * PERIODO_MICROSEGUNDOS / 60000.0);
  	
  	if (debug_resto){
  		rt_printk("IncrementoCuentasPeriodo:%f \n", IncrementoCuentasPeriodo);
  	}
  	
  }
  
    if (RetardoDisparo_mm == 0) {
  
  	RetardoDisparo_cuentas = 0;
  }
  
  else {
  
    	if (MarcajeDinamicoActivo == 0) {
  	
  		RetardoDisparo_cuentas = 0;
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 1) {
  	
  		RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * CalibracionEncoder);
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 2) {
  	
  		//RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * CalibracionEncoder);
  		RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * 25.0);
  		
  	}
  	
  }
  
  if (debug_resto) {
  	rt_printk("RetardoDisparo_mm: %d, RetardoDisparo_cuentas: %d\n", RetardoDisparo_mm, RetardoDisparo_cuentas);
  }
  
    SpotBits = (int) ( (double)CalibracionCorreccion * ((double)Spot/1000.0) ) ;
  
    //SpotBits = (int) ((double)Spot_bits *  100.0 / (double)DensidadBarcode[LineaCalcular - 1] ) ;
  
  // Disparo interno
  if (TipoDisparo == DISPAROINTERNO) {
  
    	if (MarcajeDinamicoActivo == 0) {
  	
  		SeparacionEntreDisparos_cuentas = 0;
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 1) {
  	
  		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 2) {
  	
  		//SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
  		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * 25.0);
  		
  	}
  	
  	//printf("SeparacionEntreDisparos_mm:%d SeparacionEntreDisparos_cuentas:%ld\n", SeparacionEntreDisparos_mm, SeparacionEntreDisparos_cuentas);
  
  }
  
  if (debug_resto) {
  	rt_printk("SpotBits: %d\n", SpotBits);
  }
}

int Inicializar_Control() {
  // inicializa el sistema de control
  switch (Control) {
  
  case DAQ:
  	
  	Clock_Period_ns = 50;	// 20MHz NI 6221 clock
  	Inicializar_DAQ_comedi();
  	break;
  
  case FPGA:
  
  	Clock_Period_ns = 25;	// 40MHz FPGA clock
  	Inicializar_FPGA();	
  	break;
  	
  } 
  	   	
  return 0;
}

int Inicializar_DAQ_comedi() {
  // inicializa la DAQ y configura los canales para la tarjeta NI pci 6221
  // si el conector es de 37 pines o de 68 se gestiona con #ifdef 68pines
  
  int error = 0;
  
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_DAQ_comedi\n");
  }
  
  // Cargar el driver
  system("modprobe ni_pcimio");
  
  //=============================================================================================
  // Abre el dispositivo
  //=============================================================================================
  
  comedi_device = comedi_open("/dev/comedi16");
  
  if(comedi_device == NULL) {
  	rt_printk("ERROR comedi_open\n");
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
  
  //=============================================================================================
    //=============================================================================================
  
    error = comedi_dio_config(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, COMEDI_INPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config INPUT canal %d\n", comedi_canalDI_Fotocelula);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
  //=============================================================================================
  // ENTRADAS DIGITALES NORMALES: 
  //=============================================================================================
  
  // Laser Ok
  error = comedi_dio_config(comedi_device, comedi_subdevice_LaserOk, comedi_canalDI_LaserOk, COMEDI_INPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config INPUT canal %d\n", comedi_canalDI_LaserOk);
  	ErrorDAQ = ON;
  	ProcesarError();
  }
  
  // Extractor Ok
  error = comedi_dio_config(comedi_device, comedi_subdevice_ExtractorOk, comedi_canalDI_ExtractorOk, COMEDI_INPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config INPUT canal %d\n", comedi_canalDI_ExtractorOk);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
  
  //=============================================================================================
  // SALIDAS DIGITALES: 
  //=============================================================================================
  
  // Laser Enable
  
  // Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
  #ifndef _68pines
  
  	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, NI_PFI_OUTPUT_PFI_DO);
  	if (error < 0){
  		rt_printk("ERROR %d comedi_set_routing\n", error);
  		ErrorDAQ = ON;
  		return ErrorDAQ;
  	}
  
  #endif
  
  // Configurar el puerto como salida
  error = comedi_dio_config(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, COMEDI_OUTPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\n", comedi_canalDO_LaserEnable);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
    
  // No hace falta enrutar la salida porque no es un puerto PFI
  error = comedi_dio_config(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, COMEDI_OUTPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\n", comedi_canalDO_ControlEnable);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
  // Mark in Progress
  
  // Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
  #ifndef _68pines
  
  	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, NI_PFI_OUTPUT_PFI_DO);
  	if (error < 0){
  		rt_printk("ERROR %d comedi_set_routing\n", error);
  		ErrorDAQ = ON;
  		return ErrorDAQ;
  	}
  	
  #endif
  
  // Configurar el puerto como salida
  error = comedi_dio_config(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, COMEDI_OUTPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\n", comedi_canalDO_MarkInProgress);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
    
  // Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
  #ifndef _68pines
  
  	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, NI_PFI_OUTPUT_PFI_DO);
  	if (error < 0){
  		rt_printk("ERROR %d comedi_set_routing\n", error);
  		ErrorDAQ = ON;
  		return ErrorDAQ;
  	}
  
  #endif
  
  // Configurar el puerto como salida
  error = comedi_dio_config(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, COMEDI_OUTPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\n", comedi_canalDO_ExtractorEnable);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
    
  // Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
  #ifndef _68pines
  
  	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, NI_PFI_OUTPUT_PFI_DO);
  	if (error < 0){
  		rt_printk("ERROR %d comedi_set_routing\n", error);
  		ErrorDAQ = ON;
  		return ErrorDAQ;
  	}
  
  #endif
  
  // Configurar el puerto como salida
  error = comedi_dio_config(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, COMEDI_OUTPUT);
  if(error < 0){
  	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\n", comedi_canalDO_ActivacionGalvos);
  	ErrorDAQ = ON;
  	return ErrorDAQ;
  }
  
  //=============================================================================================
  // ENTRADAS ANALOGICAS 
  //=============================================================================================
    
    MaxdataAI = comedi_get_maxdata(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionX);
  
  // Obtiene el rango
  //RangoAI = comedi_get_range(comedi_device, comedi_subdevice_AI, comedi_PosicionX_canalAI, 0);
  
  //=============================================================================================
  // SALIDAS ANALOGICAS
  //=============================================================================================
    
    MaxdataAO = comedi_get_maxdata(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX);
  
  // Calcula la constante para pasar los valores de voltios a enteros que se escriban en la tarjeta
  kFromPhysAO = (double) MaxdataAO / 2.0;
  
  // Obtiene el rango
  //RangoAO = comedi_get_range(comedi_device, comedi_subdevice_AO, comedi_GalvoX_canalAO, 0);
  
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_DAQ_comedi\n");
  }
  	   	
  return 0;
}

int Desactivar_DAQ_comedi() {
  //=============================================================================================
  // Cierra el dispositivo
  //=============================================================================================
  
  int error = 0;
  
    //if (MarcajeDinamicoActivo == 1) {
  //	Desactivar_Encoder();
  //}
  
    error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);	
  if(error < 0){
  	rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos OFF \n",error);
  	ErrorDAQ = ON;
  	ProcesarError();
  }
  
  // Cierra el dispositivo comedi
  error = comedi_close(comedi_device);
  if (error < 0) {
  	rt_printk("ERROR comedi_close\n");
  	ErrorDAQ = ON;
  	ProcesarError();
  }
  
  //system("/usr/local/sbin/comedi_config -r /dev/comedi0 ni_pcimio");
  
  return 0;
}

int Inicializar_FPGA() {
  // Inicializa la FPGA
  
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_FPGA\n");
  }
  
  // Otorga permisos de acceso a los puertos
  if (iopl(3)) {
  
  	rt_printk("Error al conseguir permisos de acceso a los puertos\n");
  	ErrorFPGA = ON;
  	//ProcesarError();
  	
  }
  
  // Descarga el firmware en la FPGA
  if (DescargarFirmwareFPGA()) {
  
  	rt_printk("Error al cargar el firmware en la FPGA\n");
  	ErrorFPGA = ON;
  	//ProcesarError();
  	
  }
  
  // Calcula la constante para pasar los valores de voltios a enteros que se escriban en la tarjeta
    //kFromPhysFPGA = (double) (4095.0 / (2.0*VGalvoRef_MaximoBits));
  
  // Hay que usar +/-10V de rango; luego en FPGAfromPhys, si se ha usado un rango menor en los galvos
    kFromPhysFPGA = (double) (4095.0 / (2.0*10.0));
  
  
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_FPGA\n");
  }
  	   	
  return 0;
}

int DescargarFirmwareFPGA() {
  const int SZ=19895; // Pluto-P (EP1K10) .rbf size
  FILE *f;
  unsigned char buf[SZ];
  int byte, bit;
  
  // Primero se manda un comando de unconfigure, para poder cargar la FPGA de nuevo en caso de que se
  // hubiera cargado antes y se haya salido de forma irregular
  outb((COMANDO_ADMIN_FPGA|ARG_UNCONFIGURE_FPGA), REGISTRO_ADDR);
  byte = inb(REGISTRO_STATUS);
  
  rt_printk("Status: %d\n", byte);
  
  if (byte & MASCARA_EPP_TIME_OUT) {
  
  	rt_printk("Error: no hay FPGA\n");
  	return 1;
  
  }
  
  // Abre el archivo del firmware
  f = fopen("firmwareFPGA_0_8_1.rbf", "rb");
  
  if(!f) { 
  	rt_printk("Error: no se ha podido cargar el firmware de la FPGA\n");
  	return 1;
  }
  
  fread(buf, SZ, 1, f);
  
  if(iopl(3) < 0) { 
  	rt_printk("Error: no se ha podido obtener privilegios para acceder al puerto paralelo\n");
  	return 1;
  }
  
  for(byte = 0; byte < SZ; byte++) {
  	
  	for(bit = 0; bit < 8; bit++) {
  		
  		int v = buf[byte] & (1<<bit);
  	    	
  	    	if(v) outb(0xff, BASE_ADDRESS_PUERTO_PARALELO); else outb(0, BASE_ADDRESS_PUERTO_PARALELO);
  	    	
  	    	outb(1, BASE_ADDRESS_PUERTO_PARALELO+2);
  	    	outb(0, BASE_ADDRESS_PUERTO_PARALELO+2);
  	
  	}
      
  }
  
  
  rt_printk("Cargado el firmware en la FPGA\n");
  
  return 0;
}

int Desactivar_FPGA() {
  // Pone a 0 todas las salidas de la FPGA
  outb((COMANDO_ADMIN_FPGA|ARG_RESET_IO), REGISTRO_ADDR);
  
  return 0;
}

int Inicializar_Galvos() {
  // inicializa los galvos en el origen
  int error = 0;
  
  //////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_Galvos\n");
  }
  
  
  // inicializa el sistema de control
  switch (Control) {
  
  case DAQ:
  	switch(TipoLaser){
  	
    	
    	error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, ValorActivacionGalvos);	
  	if(error < 0){
  		rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \n",error);
  		ErrorDAQ = ON;
  		ProcesarError();
  	}
  	
  	}
  
  	break;
  
  case FPGA:
  
    	outb((COMANDO_GALVOS|0x01), REGISTRO_ADDR);
  	
  	break;
  	
  } 
  
    sleep(1);
  	
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_Galvos\n");
  }
  
  return error;
}

int Inicializar_RTAI() {
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Inicializar RTAI\n");
  }
  
  // Crea la tarea "buddy" en el espacio del kernel
  if (!(maint = rt_task_init(nam2num("MAIN"), 1, 0, 0))) {
  	rt_printk("CANNOT INIT TASK > MAIN <\n");
  	ErrorRTAI = ON;
  	ProcesarError();
  	exit (-1);
  }
  
  // se pone a OFF tras entrar en RT (ejecutar rt_make_hard_real_time en timer_handler)
  endthread = ON;
  endhandler = ON;
  
  // Crea el thread del timer
  if (!(timerthread = rt_thread_create((void *)timer_handler, NULL, 10000))) {  // create thread
  	rt_printk("CANNOT INIT TIMERTHREAD\n");
  	ErrorRTAI = ON;
  	ProcesarError();
  	exit (-1);
  }
  	
  // espera hasta que se haya destruido el handler para proseguir
  while (!endhandler) {   	
  	usleep(10000);
  }	
  
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar RTAI\n");
  }
  
  return 0;
}

void Desactivar_RTAI() {
  // termina el bucle de RTAI:
  endthread = ON;
  	
  // espera hasta que se haya destruido el handler para proseguir
  while (!endhandler) {   	
  	usleep(10000);
  }	
  
  // destruye el thread
  rt_thread_join(timerthread);
  
  // elimina la tarea principal
  rt_task_delete(maint);
}

int Inicializar_thread_estado() {
  // Crea el thread del timer de estado
  if (pthread_create(&id_thread_timer_estado, NULL, timer_estado, NULL) != 0) {  // create pthread
  	rt_printk("CANNOT INIT THREAD ESTADO\n");
  	ErrorTimerEstado = ON;
  	ProcesarError();
  	return -1;
  }
  
  return 0;
}

void *timer_estado(void *) {
      int error = false;
  int dummy;
  unsigned long long contadorantiguo = 0; // va guardando los valores del contador de disparos 
  int incrementodisparos = 0;	// cuenta el incremento de disparos
  
  // Variables para la lectura de las cuentas del encoder
  //static lsampl_t ValorCuentasActual_Estado, ValorCuentasAnterior_Estado;
  //static float IncrementoCuentas_Estado;
  
    static RTIME tAnterior;
  
    static RTIME tActual; 
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Thread estado\n");
  }
  
  ///////////////////////////////////////////////////////////////////////////////
    
  // abre el archivo de watchdog
  fd_watchdog = open("/dev/watchdog", O_WRONLY);
  	
  if (fd_watchdog == -1) {
  	rt_printk("Error opening /dev/watchdog \n");
  	ErrorWatchdog = ON;
  	ProcesarError();
  }
  
    Apagar = false;
  
  tAnterior = rt_get_time_ns();
  
    while (Apagar == false) {
  
  	if (debug_testado) {
  		printf("\n--------TIMER--------\n");
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// WATCHDOG
  	
  	// Patea el watchdog
  	ioctl(fd_watchdog, WDIOC_KEEPALIVE, &dummy);
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// LASER OK
  	
    	switch (Control) {
  
  	case DAQ:
  	
  		error = comedi_dio_read(comedi_device, comedi_subdevice_LaserOk, comedi_canalDI_LaserOk, &LaserOkDIValue);	
  		if (error < 0) {
  			rt_printk("comedi_dio_read LaserOk error = %d\n",error);
  			//ErrorDAQ = ON;
  			//ProcesarError();
  		}
  		
  		break;
  
  	case FPGA:
  
  		outb((COMANDO_LEER_DI|ARG_LEER_LASER_OK), REGISTRO_ADDR);
  		LaserOkDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;	
  		
  		break;
  	
  	} 
  	
  	//printf("LaserOkDIValue:%d\n", LaserOkDIValue);
  	//debug: luego quitar
  	LaserOkDIValue = HIGH;
  		
    	if (LaserOkDIValue == LOW) {
  		ErroresConsecutivosLaserOk++;
  	}
  	else {
  		ErroresConsecutivosLaserOk = 0;
  	}	
  	
  	if (ErroresConsecutivosLaserOk >= MaximoErroresConsecutivosLaserOk) {
  		ErrorLaserOk = true;
  	}
  	else {
  		ErrorLaserOk = false;
  	}
  	
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// TEMPERATURA 
  	
  	/*
  	
    	switch (Control) {
  
  	case DAQ:
  	
  		error = comedi_dio_read(comedi_device, comedi_subdevice_DI, comedi_Temperatura_canalDI, &TemperaturaDIValue);	
  		if (error < 0) {
  			printf("comedi_dio_read Temperatura error = %d\n",error);
  			ErrorDAQ = ON;
  			ProcesarError();
  		}
  		
  		break;
  
  	case FPGA:
  
  		outb((COMANDO_LEER_DI|ARG_LEER_TEMPERATURA_OK), REGISTRO_ADDR);
  		TemperaturaDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;	
  		
  		break;
  	
  	} 
  	
  	//printf("TemperaturaDIValue:%d\n", TemperaturaDIValue);
  	
    	if (TemperaturaDIValue == LOW) {
  		ErroresConsecutivosTemperatura++;
  	}
  	else {
  		ErroresConsecutivosTemperatura = 0;
  	}	
  	
  	if (ErroresConsecutivosTemperatura >= MaximoErroresConsecutivosTemperatura) {
  		ErrorTemperatura = true;
  	}
  	else {
  		ErrorTemperatura = false;
  	}
  	
  	*/
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// EXTRACTOR
  	
    	if (ExtractorActivado == true) {
  	
    		switch (Control) {
  
  		case DAQ:
  	
  			error = comedi_dio_read(comedi_device, comedi_subdevice_ExtractorOk, comedi_canalDI_ExtractorOk, &ExtractorDIValue);	
  			if (error < 0) {
  				rt_printk("comedi_dio_read Extractor error = %d\n",error);
  				//ErrorDAQ = ON;
  				//ProcesarError();
  			}
  		
  			break;
  
  		case FPGA:
  
  			outb((COMANDO_LEER_DI|ARG_LEER_EXTRACTOR_OK), REGISTRO_ADDR);
  			ExtractorDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;
  	
  			break;
  	
  		} 
  		
  		
  
    		if ((ExtractorDIValue == LOW) && (EnEjecucion == true)) {
  			ErroresConsecutivosExtractor++;
  		}
  		else {
  			ErroresConsecutivosExtractor = 0;
  		}	
  	
  		if (ErroresConsecutivosExtractor >= MaximoErroresConsecutivosExtractor) {
  			ErrorExtractor = true;
  		}
  		else {
  			ErrorExtractor = false;
  		}	
  	
  	}
  	
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// SISTEMA OK
  	
  	if ( (ErrorLaserOk) || (ErrorTemperatura) || ((ExtractorActivado) && (ErrorExtractor)) || (ErrorEncoder) || (ErrorCampo)) {
  	
    		SistemaOk = false;
  		ProcesarError();
  		
    		if ((EnEjecucion == true) || (EstadoLaser == ON)) {
  
  			StopEjecucion();
    			
  		}
  		
  	}
  	
  	else {	
  		
    		if (SistemaOk == false) {
  		
  			// Vuelve a poner el Led en verde
  			LedEstado->color((Fl_Color)2); 	// Led verde
  			LedEstado->redraw();		// Marca el Led para redraw
  	
  			// Actualiza el mensaje
  			// Actualiza el mensaje
  			switch (Idioma) {
  			
  				case ESP:
  				LedEstado->label("Sistema OK");
  				break; 
  			
  				case ING:
  				LedEstado->label("System OK");
  				break;
  			
  				case ITA:
  				LedEstado->label("Sistema OK");
  				break;
  			
  			}
  	  
  			// Vuelve a activar los botones
  			BotonMarcar->activate();
  			BotonPrueba->activate();
  			
  			if (ServicioTecnico) {
  				BotonCampo->activate();
  				BotonLaser->activate();
  			}	
  	
  		}
  		
  		// No hay errores de estado
  		SistemaOk = true;
  	
  	}
  
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// Espera el periodo de estado antes de continuar
  	usleep(PERIODO_ESTADO);
  	
  	
  	//////////////////////////////////////////////////////////////////////////////
    	
  	if (MarcajeDinamicoActivo == 1) {
  	
  		tActual = rt_get_time_ns();
  		
    		//if (!EnEjecucion) {
  		
  			// Leer las cuentas del encoder
  			//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual_Estado);
  			//if (error < 0) {
  			//	rt_printk("ESTADO: LEER ENCODER comedi_data_read = %d\n",error);
  			//	ErrorDAQ = ON;
  			//	ProcesarError();
  			//}
  			
  		//}
  		
    		//else {
  		
  			ValorCuentasActual_Estado = ValorCuentasActual;
  		//}
  		
  		// Calcular el incremento de cuentas
  		if (ValorCuentasActual_Estado >= ValorCuentasAnterior_Estado) {
  			IncrementoCuentas_Estado = (float)(ValorCuentasActual_Estado - ValorCuentasAnterior_Estado);
  		}
    			IncrementoCuentas_Estado = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Estado) + ValorCuentasActual_Estado);
  			//StopEjecucion();
  			//LedEstado->label("Encoder overflow");
  			//rt_printk("ESTADO: OVERFLOW MV %ld Actual:%d INCR:%f\n", MicroVector, ValorCuentasActual_Estado, IncrementoCuentas_Estado);
  		}
  	
    		ValorCuentasAnterior_Estado = ValorCuentasActual_Estado;
  		
  		// Calcula la velocidad 
  		VelocidadLinea = (IncrementoCuentas_Estado * 6E7) / (float)((tActual - tAnterior) * CalibracionEncoder);
  		
  		// Presenta el resultado en el interfaz
  		CuadroTextoVLinea->value(VelocidadLinea);
  		
  		tAnterior = tActual;
  		
  		//printf("Actual:%d Anterior:%d Velocidad:%f\n", ValorCuentasActual_Estado, ValorCuentasAnterior_Estado, VelocidadLinea);	
  		
    		incrementodisparos = Contador - contadorantiguo;
  		contadorantiguo = Contador;
  		
  		if (IncrementoCuentas_Estado == 0) { // encoder parado
  			
  			ContadorDisparosParado += incrementodisparos;
  		}
  		
  		else {
  		
  			ContadorDisparosParado = 0;
  		}
  		
  		if (ContadorDisparosParado >= MaximoDisparosParado) {
  	
    	
  		}
  		
  	}
  	
  }
  
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Thread estado\n");
  }
  
  return 0;
}

int Desactivar_thread_estado() {
  // Crea el thread del timer de estado
  if (pthread_join(id_thread_timer_estado, NULL) != 0) {  // create pthread
  	rt_printk("CANNOT JOIN THREAD ESTADO\n");
  	ErrorTimerEstado = ON;
  	ProcesarError();
  	return -1;
  }
  
  return 0;
}

int Inicializar_PuertoSerie() {
  struct termios options;
  
  // debug
  if (debug_resto) {
  	printf("Entrando-----------------Thread puerto serie\n");
  }
  
  ///////////////////////////////////////////////////////////////////////////////
    ErrorPuertoSerie = OFF;
  
  // Hay que poner el puerto serie en modo raw, para no requerir CR para leer el puerto
  //system("stty -F /dev/ttyS1 raw");
  
  // Abrir el puerto
  fd_puertoserie = open("/dev/ttyS1", O_RDWR | O_NOCTTY | O_NDELAY);
  
  if (fd_puertoserie == -1) {
  	
  	rt_printk("Puerto Serie: open_port: Unable to open /dev/ttyS1 - ");
  	ErrorPuertoSerie = ON;
  	//return -1;
  	
  } 
  
  else {
  	fcntl(fd_puertoserie, F_SETFL, 0);
  }
  
  // Get the current options for the port...
  tcgetattr(fd_puertoserie, &options);
  
  // Set the baud rates to 9600
  cfsetispeed(&options, B9600);
  cfsetospeed(&options, B9600);
  
  // Enable the receiver and set local mode...
  // c_cflag describe el hardware control del terminal
    options.c_cflag &= ~PARENB;		// sin paridad
    options.c_cflag &= ~CSIZE;		
  options.c_cflag |= CS8;			// 8 bits de datos
  
  options.c_oflag = 0;			// salida en bruto		
  
  options.c_iflag = ~IGNCR;		// evita el mapeo de CR a NL		
  options.c_iflag &= ICRNL;
  options.c_iflag &= INLCR;
  
    
  options.c_cc[VTIME] = 0;		// no usa el temporizador
  options.c_cc[VMIN] = 3; 		// espera hasta tener al menos 3 caracteres
  
  // Set the new options for the port...
  tcsetattr(fd_puertoserie, TCSANOW, &options);
  
  // don't block serial read
  fcntl(fd_puertoserie, F_SETFL, FNDELAY); 
  
  return 0;
}

void ControlPuertoSerie(void *) {
    int error = false;
  int i,j;
  int numbytes=0;
  char str_result[NumeroMaximoCaracteresLinea];
  char caracter;
  		
      // al inicializar el segundo elemento a 0x01 ya hay que mandar los 3 caracteres de forma correcta
  str_result[1]=0x01;
  
  //////////////////////////////////////////////////////////////////////////////
  // Lee el puerto
  numbytes = read(fd_puertoserie, str_result, NumeroMaximoCaracteresLinea);
  
    //tcflush(fd_puertoserie, TCIOFLUSH);
  	
    if (numbytes > 0) {
  	
  	if (debug_puertoserie) {
  			
    			
  		// imprime los caracteres en hexadecimal
  		for (i=0;i<numbytes;i++) {
  			rt_printk("%x", str_result[i]);
  		}
  			
  		rt_printk("\n");
  		
  	}
  	
    	if (strlen(StrParcial) > 0) {
  	
  		//if (debug_puertoserie) {
    			rt_printk("- Periodo anterior:%s\n", StrParcial);
  			rt_printk("- Periodo actual:%s\n", str_result);
  
  		//}
  		
  		j=strlen(StrParcial);
  		for (i=0;i<numbytes;i++) {
  			StrParcial[j+i]=str_result[i];
  		}
  		
  		for (i=0;i<j+numbytes;i++) {
  			str_result[i]=StrParcial[i];
  		}
  		
  		//strcat(StrParcial, str_result);
  		//strcpy(str_result, StrParcial);
  		
  		
  		//if (debug_puertoserie) {
  			rt_printk("- Mensaje compuesto:%s\n", str_result);
  			
  			// imprime los caracteres en hexadecimal
  			for (i=0;i<j+numbytes;i++) {
  				rt_printk("%x", str_result[i]);
  			}
  		
  			rt_printk("\n");
  		//}
  		
  		strcpy(StrParcial,"");
  		numbytes = numbytes + j;
  		
  	}
  		
  	//////////////////////////////////////////////////////////////////////////////
  	// Print On: 1Bh 01h 09h = 27 1 9
  	if ( (str_result[0]==27) && (str_result[1]==1) && (str_result[2]==9) ) {
  					
    		// en la ventana emergente
  		if (EnEjecucion == false) {
  			
  			// Pone el flag para evitar ventanas emergentes al calcular la matriz
  			ModoImpresionSerie = true;
  					
  			// Arranca si no hay error de algo en el sistema
  			if (!((ErrorGalvos)||(ErrorDAQ)||(ErrorFPGA)||(ErrorRTAI)||(ErrorLaserOk)||(ErrorTemperatura)||(ErrorExtractor)||(ErrorVectores)||(ErrorWatchdog)||(ErrorCampo))) {
  				
  				// Calcula la matriz para comprobar que no hay problemas
  				if (CalcularMatriz() != NoError) {
  					
  					rt_printk("ControlPuertoSerie: problema al CalcularMatriz\n");
  					ErrorEjecucionListas = true;	
  					
  				}
  				
  				else {
  					ErrorEjecucionListas = false;
  					StartEjecucion();	
  			
  				}
  				
  			}
  			
  			else {
  			
  				ErrorEjecucionListas = true;
  			}
  		
  		}
  						
  		if (ErrorEjecucionListas == false) {
  							
  			write(fd_puertoserie, Str_Modoimpresion, 4);
  				
  			if (debug_puertoserie) {
    			}
  			
  		}
  			
  		else {
  			
  			write(fd_puertoserie, Str_Modoreposo, 4);
  		
  			if (debug_puertoserie) {
  				rt_printk("Inicio NOK - Modo de Reposo\n");
  			}
  				
  		}
  			
  	}
  	
  
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// Print Off: 1Bh 01h 0Ah = 27 1 10
  	else if ( (str_result[0]==27) && (str_result[1]==1) && (str_result[2]==10) ) {
  		
  		if (debug_puertoserie) {
  			rt_printk("Stop OK - Modo de Reposo\n");
  		}
  		
    		error = StopEjecucion();
  					
  		write(fd_puertoserie, Str_Modoreposo, 4);
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
  	// Print Status: 1Bh 00h 00h = 27 0 0
  	else if ( (str_result[0]==27) && (str_result[1]==0) && (str_result[2]==0) ) {
  		
    		if (EnEjecucion == true) {
  							
  			write(fd_puertoserie, Str_Modoimpresion, 4);
  			
  			if (debug_puertoserie) {
    			}
  			
  		}
  			
  		else {
  								
  			write(fd_puertoserie, Str_Modoreposo, 4);
  			
  			if (debug_puertoserie) {
  				rt_printk("Status OK - Modo de Reposo\n");
  			}	
  		}
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
    	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==1)) {
  							
    		LineaCalcular = 1;
  		BloqueCalcular = 1;
  		
    		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
  		
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  		else {
  			
  			// Carga el formulario
  			CargarVentanaModificarTexto();
  	
    			for (i=0; i<(int)strlen(LineaTexto1[BloqueCalcular - 1]); i++) {
  		
    				cb_BotonBorrar(BotonBorrar, NULL);
  			
  			}
  		
    			str_result[numbytes-2]=0x00;
  				
  			// Procesa los caracteres
  			for (i=0; i<(int)strlen(str_result); i++) {
  		
  				caracter = str_result[i];
  				
    				if (CaracterValido(caracter)) {
  				
  					ProcesarCaracter(&caracter);
  					
  				}
  				
  			}
  			
    			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
  				
    			if (ModoImpresionSerie == true) {
  				
  				ActualizarPuertoSerie = true;
  			
  			}
  			
  			//escribimos secuencia recibida
  			
  			write(fd_puertoserie, Str_Linea1recibida, 4);
  			
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  	
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
    	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==2)) {
  					
    		LineaCalcular = 2;
  		BloqueCalcular = 1;
  		
    		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
  		
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  		else {
  			
  			// Carga el formulario
  			CargarVentanaModificarTexto();
  
    			for (i=0; i<(int)strlen(LineaTexto2[BloqueCalcular - 1]); i++) {
  		
    				cb_BotonBorrar(BotonBorrar, NULL);
  			
  			}
  		
    			str_result[numbytes-2]=0x00;
  				
  			// Procesa los caracteres
  			for (i=0; i<(int)strlen(str_result); i++) {
  		
  				caracter = str_result[i];
  				
    				if (CaracterValido(caracter)) {
  				
  					ProcesarCaracter(&caracter);
  					
  				}
  				
  			}
  			
    			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
  				
    			if (ModoImpresionSerie == true) {
  				
  				ActualizarPuertoSerie = true;
  			
  			}
  			
  			//escribimos secuencia recibida
  			
  			write(fd_puertoserie, Str_Linea2recibida, 4);
  			
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
    	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==3)) {
  					
    		LineaCalcular = 3;
  		BloqueCalcular = 1;
  		
    		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
  		
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  		else {
  			
  			// Carga el formulario
  			CargarVentanaModificarTexto();
  
    			for (i=0; i<(int)strlen(LineaTexto3[BloqueCalcular - 1]); i++) {
  		
    				cb_BotonBorrar(BotonBorrar, NULL);
  			
  			}
  		
    			str_result[numbytes-2]=0x00;
  				
  			// Procesa los caracteres
  			for (i=0; i<(int)strlen(str_result); i++) {
  		
  				caracter = str_result[i];
  				
    				if (CaracterValido(caracter)) {
  				
  					ProcesarCaracter(&caracter);
  					
  				}
  				
  			}
  			
    			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
  				
    			if (ModoImpresionSerie == true) {
  				
  				ActualizarPuertoSerie = true;
  			
  			}
  			
  			//escribimos secuencia recibida
  			
  			write(fd_puertoserie, Str_Linea3recibida, 4);
  			
  			//debug
  			if (debug_puertoserie) {
    			}
  		
  		}
  			
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////
    	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==4)) {
  					
    		LineaCalcular = 4;
  		BloqueCalcular = 1;
  		
    		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
  		
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  		else {
  			
  			// Carga el formulario
  			CargarVentanaModificarTexto();
  
    			for (i=0; i<(int)strlen(LineaTexto4[BloqueCalcular - 1]); i++) {
  		
    				cb_BotonBorrar(BotonBorrar, NULL);
  			
  			}
  		
    			str_result[numbytes-2]=0x00;
  				
  			// Procesa los caracteres
  			for (i=0; i<(int)strlen(str_result); i++) {
  		
  				caracter = str_result[i];
  				
    				if (CaracterValido(caracter)) {
  				
  					ProcesarCaracter(&caracter);
  					
  				}
  				
  			}
  			
    			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
  				
    			if (ModoImpresionSerie == true) {
  				
  				ActualizarPuertoSerie = true;
  			
  			}
  			//escribimos secuencia recibida
  			
  			write(fd_puertoserie, Str_Linea4recibida, 4);
  			
  			//debug
  			if (debug_puertoserie) {
    			}
  			
  		}
  		
  	}
  	
    	else {
  			
  		strcpy (StrParcial, str_result);
  		
  		if (debug_puertoserie) {
  			rt_printk("Lectura del puerto serie incompleta:%s\n", StrParcial);
  		}
  		
  	
  	}
  		
  }
  	
  //////////////////////////////////////////////////////////////////////////////
    Fl::repeat_timeout(PERIODO_PUERTOSERIE, ControlPuertoSerie);
  
  return;
}

bool CaracterValido(int num) {
      // False cuando no es as
  
  //printf("caracter: %d\n", num);
  
  // 0-9
  if ((num >=48) && (num<=57)) {return true;}
  
  // A-Z
  else if ((num >= 65) && (num <= 90)) {return true;}
  
  // + , .- . /
  else if ((num >= 43) && (num <= 47)) {return true;}
  
  // espacio
  else if (num == 32) {return true;}
  
  // :
  else if (num == 58) {return true;}
  
    else return false;
}

int Desactivar_PuertoSerie() {
  // cierra el puerto y sale
  close(fd_puertoserie);
  
  // debug
  if (debug_resto){
  	
  	printf("Saliendo-----------------Thread puerto serie\n");
  
  }
  
  return 0;
}

void ProcesarError() {
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  if ((ErrorGalvos)
  ||(ErrorDAQ)
  ||(ErrorFPGA)
  ||(ErrorRTAI)
  ||(ErrorLaserOk)
  ||(ErrorTemperatura)
  ||(ErrorExtractor)
  ||(ErrorVectores)
  ||(ErrorWatchdog)
  ||(ErrorCampo)
  ||(ErrorEncoder)) {
  
    	if ((EnEjecucion) && (ErrorGalvos == false)) {
  		
  		StopEjecucion();
  	
  	}
  	
  	//Actualiza el Led de estado
  	LedEstado->color((Fl_Color)1); 	// Led rojo
  	LedEstado->redraw();		// Marca el Led para redraw
  
    	//if (!ENDESARROLLO) {
  		
  		BotonMarcar->deactivate();
  		BotonPrueba->deactivate();
  		
  		if (ServicioTecnico) {
  			BotonCampo->deactivate();
  			BotonLaser->deactivate();
  		}
  			
  	//}
  	
  	// Mensaje
  	if (ErrorGalvos == ON) {
  	
  		switch (Idioma) {
  			
  		case ESP:
    			break; 
  			
  		case ING:
  			LedEstado->label("Scanner");
  			break;
  			
  		case ITA:
  			LedEstado->label("Scanner");
  			break;
  			
  		}
  		
  		// resetea el error
  		ErrorGalvos = OFF;
  	
  	}	
  		
  	else if (ErrorDAQ == ON) {
  	
  		LedEstado->label("DAQ");
  		//LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de DAQ
  		
  		// resetea el error
  		ErrorDAQ = OFF;
  	}	
  	
  	else if (ErrorFPGA == ON) {
  	
  		LedEstado->label("FPGA");
  		//LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de DAQ
  		
  		// resetea el error
  		ErrorFPGA = OFF;
  	}
  		
  	else if (ErrorRTAI == ON) {
  	
  		LedEstado->label("RTAI");
  		LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de RTAI
  		
  		// resetea el error
  		ErrorRTAI = OFF;	
  	}
  		
  	else if (ErrorLaserOk == ON) {
  		
  		switch (Idioma) {
  			
  		case ESP:
    			break; 
  			
  		case ING:
  			LedEstado->label("Laser");
  			break;
  			
  		case ITA:
  			LedEstado->label("Laser");
  			break;
  			
  		}
  		
  		// resetea el error
  		ErrorLaserOk = OFF;
  	}
  		
  	else if (ErrorTemperatura == ON) {
  		
  		switch (Idioma) {
  			
  		case ESP:
  			LedEstado->label("Temperatura");
  			break; 
  			
  		case ING:
  			LedEstado->label("Temperature");
  			break;
  			
  		case ITA:
  			LedEstado->label("Temperatura");
  			break;
  			
  		}
  		
  		// resetea el error
  		ErrorTemperatura = OFF;
  	}
  		
  	else if (ErrorExtractor == ON) {
  		
  		switch (Idioma) {
  			
  		case ESP:
  			LedEstado->label("Extractor");
  			break; 
  			
  		case ING:
  			LedEstado->label("Extractor");
  			break;
  			
  		case ITA:
  			LedEstado->label("Estrattore");
  			break;
  			
  		}
  		
  		// resetea el error
  		ErrorExtractor = OFF;
  	}	
  
  	else if (ErrorVectores == ON) {
  		
  		switch (Idioma) {
  			
  		case ESP:
  			LedEstado->label("Vectores");
  			break; 
  			
  		case ING:
  			LedEstado->label("Vectors");
  			break;
  			
  		case ITA:
  			LedEstado->label("Vettori");
  			break;
  			
  		}
  		
  		// resetea el error
  		ErrorVectores = OFF;
  	}
  
  	else if (ErrorWatchdog == ON) {
  		
  		LedEstado->label("Watchdog");
  		
  		// resetea el error
  		ErrorWatchdog = OFF;
  	}	
  
  	else if (ErrorCampo == ON) {
  		
  		switch (Idioma) {
  			
  		case ESP:
  			LedEstado->label("Campo");
  			break; 
  			
  		case ING:
  			LedEstado->label("Field");
  			break;
  			
  		case ITA:
  			LedEstado->label("Campo");
  			break;
  			
  		}
  		
  		// resetea el error
  		//ErrorCampo = OFF;
  	}
  
  	else if (ErrorEncoder == ON) {
  	
  		LedEstado->label("Encoder");
  		
  		// resetea el error
  		//ErrorEncoder = OFF;
  	}
  	
  	// Redraw all
  	//Fl::flush		
  
  }
  
  else if (ErrorValidacion) {
  
  	//Actualiza el Led de estado
  	LedEstado->color(FL_YELLOW); 	// Led amarillo
  	LedEstado->redraw();		// Marca el Led para redraw
  
    	if (!ENDESARROLLO) {
  		
  		BotonMarcar->deactivate();
  			
  	}
  	
  	//Actualiza el Led de estado
  	switch (Idioma) {
  	
  	case ESP:
    		break; 
  			
  	case ING:
  		LedEstado->label("Validation");
  		break; 
  			
  	case ITA:
  		LedEstado->label("Convalida");
  		break;
  	
  	}
  	
  }
}

void *timer_handler(void *args) {
  //==============================================================================
  // TIMER EN TIEMPO REAL (RTAI)
  // Crea el timer y mantiene el bucle de control del programa, llamando al algoritmo
  // de control de la DAQ o a las rutinas de error de obturador/galvos cuando es necesario
  //==============================================================================
  
  int error = false;
  
  // contador de ciclos
  static long long ContadorCiclos = 0;
  
  // Contador de ciclos que "llegaron tarde"
  static long overrun = 0;
  static long ov_RTE_UNBLKD = 0;
  static long ov_RTE_TMROVRN = 0;
  		
    static RTIME tAnterior;
  
    static RTIME tProceso;
  
    static RTIME tActual; 
  
    static double duracionCiclo = 0;
  static double duracionCicloMax = 0;
  static double duracionCicloMin = 1000000000;
  static double duracionCicloPromedio = 0;
  
    static long long duracionCiclo_hist[7];
  static float umbral_duracionCiclo[6];	//hay 6 umbrales para 7 rangos
  
  // Variables para almacenar los valores de tiempo de proceso de ciclos
  static double duracionProceso = 0;
  static double duracionProcesoMax = 0;
  static double duracionProcesoMin = 1000000000;
  static double duracionProcesoPromedio = 0;
  
    static long long duracionProceso_hist[7];
  static float umbral_duracionProceso[6];	//hay 6 umbrales para 7 rangos
  
  // Variables para almacenar los valores de tiempo de espera desde que termina el proceso hasta que empieza el siguiente ciclo
  static double duracionEspera = 0;
  static double duracionEsperaMax = 0;
  static double duracionEsperaMin = 1000000000;
  static double duracionEsperaPromedio = 0;
  
    static long long duracionEspera_hist[7];
  static float umbral_duracionEspera[6];	//hay 6 umbrales para 7 rangos
  
  // Para leer el registro de status del puerto paralelo
  static BYTE inbyte; 
  
  // Control de tipos de bucles
  static signed int result_wait;
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Thread RTAI\n");
  }
  
  //rt_printk("EWOULDBLOCK=%d EINTR=%d ETIMEDOUT=%d EPERM=%d\n",EWOULDBLOCK, EINTR, ETIMEDOUT, EPERM);
  
  //rt_printk("RTE_UNBLKD=%d RTE_TMROVRN=%d\n",RTE_UNBLKD, RTE_TMROVRN);
  
    if (debug_ciclos) {
  
  	umbral_duracionCiclo[0] = 0.5 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
  	umbral_duracionCiclo[1] = 1.0 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
  	umbral_duracionCiclo[2] = 1.5 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
  	umbral_duracionCiclo[3] = 2.0 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
  	umbral_duracionCiclo[4] = 2.5 * PERIODO_MICROSEGUNDOS * 1000; //250% del periodo en ns
  	umbral_duracionCiclo[5] = 3.0 * PERIODO_MICROSEGUNDOS * 1000; //300% del periodo en ns
  	
  	umbral_duracionProceso[0] = 0.25 * PERIODO_MICROSEGUNDOS * 1000; //25% del periodo en ns
  	umbral_duracionProceso[1] = 0.50 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
  	umbral_duracionProceso[2] = 0.75 * PERIODO_MICROSEGUNDOS * 1000; //75% del periodo en ns
  	umbral_duracionProceso[3] = 1.00 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
  	umbral_duracionProceso[4] = 1.50 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
  	umbral_duracionProceso[5] = 2.00 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
  	
  	umbral_duracionEspera[0] = 0.25 * PERIODO_MICROSEGUNDOS * 1000; //25% del periodo en ns
  	umbral_duracionEspera[1] = 0.50 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
  	umbral_duracionEspera[2] = 0.75 * PERIODO_MICROSEGUNDOS * 1000; //75% del periodo en ns
  	umbral_duracionEspera[3] = 1.00 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
  	umbral_duracionEspera[4] = 1.50 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
  	umbral_duracionEspera[5] = 2.00 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
  		
  }
  		
  //static RT_TASK *timer_task_handler;
  //static RTIME period;
  
  if (!(timer_task_handler = rt_task_init(nam2num("TIMER"), 1, 0, 0))) {
  	rt_printk("CANNOT INIT TASK > TIMER <\n");
  	ErrorRTAI = ON;
  	ProcesarError();
  }
  	
  // permite acceso a los recursos io
  rt_allow_nonroot_hrt();
  	
  // se fija en memoria para evitar swap
  mlockall(MCL_CURRENT | MCL_FUTURE);
  
  // Modo periodico:
  rt_set_periodic_mode();
  //rt_set_oneshot_mode();
  
  // Inicia el timer
  Periodo = start_rt_timer(nano2count(PERIODO_MICROSEGUNDOS*1000));
   	
  // HARD RT /////////////////////////////////////////////////////////////
  rt_make_hard_real_time();
  
  // Control del bucle while y sincronismo
  endthread = OFF;
  endhandler = OFF;
  		
  // Fija el inicio y el periodo de la tarea
  rt_task_make_periodic(timer_task_handler, rt_get_time() + Periodo, Periodo);
  
  //////////////////////////////////////////////////////////////////////////////////////////////////
  // BUCLE DE CONTROL DEL PROGRAMA: ESTA ACTIVO DURANTE TODA LA VIDA DEL MISMO, MANTENIENDO EL TIMER
  //////////////////////////////////////////////////////////////////////////////////////////////////
  
  tAnterior = rt_get_cpu_time_ns();
  
  while ( !endthread ) {
  	
  	// Lee las cuentas del encoder
  	// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  	// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  	
  	if (MarcajeDinamicoActivo == 1) {
  
  		switch (Control) {
  
  		case DAQ:
  	
  			// Leer las cuentas del encoder
  			error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual);
  			if (error < 0) {
  				rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  				ErrorDAQ = ON;
  				//ProcesarError();
  			}
  		
  			break;
  
  		case FPGA:
  
  			// Leer las cuentas del encoder
  			ValorCuentasActual = LeerCuentasEncoder_FPGA();
  		
  			break;	
  	
  		} 
  		
  	}
  	
  	///////////////////////////////////////////////////////////////////
    	///////////////////////////////////////////////////////////////////
  	
    	if ( (Lista1_Exe == true) && (Lista2_Exe == true) && (SistemaOk == true) ) {
    	}
  	
    	else if ((Lista0_Exe == true) && (SistemaOk == true)) {
  	
  		//rt_printk("L0:%d L1:%d L2:%d\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
  		
  		MarcajeOk = EjecutarMicrovector(0); // lista 0
  	
  	}
  	
    	else if ((Lista1_Exe == true) && (SistemaOk == true) && (MarcajeOk == true)) {
  		
  		//rt_printk("L0:%d L1:%d L2:%d\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
  		
    		if ((TipoDisparo == DISPAROEXTERNO) && (EsperaFotocelula == true) && (PruebaMarcaje == false)) {
  		
    			switch (Control) {
  
  			case DAQ:
  	
  				error = comedi_dio_read(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, &FotocelulaDIValue);	
  				if (error < 0) {
  					rt_printk("comedi_dio_read Fotocelula error=%d Valor=%d\n", error, FotocelulaDIValue);
  					ErrorDAQ = ON;
  					//StopEjecucion();
  				}
  		
  				break;
  
  			case FPGA:
  
    				inbyte = inb(REGISTRO_STATUS);
  			
      				if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {FotocelulaDIValue = 0;}
  				else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {FotocelulaDIValue = 1;}
  				else FotocelulaDIValue = -1; // error
  		
  				break;	
  	
  			} 
  			
  			// DEBUG
  			if (debug_fotocelula) {
  				rt_printk("FotoCelula:%d\n",FotocelulaDIValue);
  			}
  			
  			// Si tiene el valor de disparo 
  			if (FotocelulaDIValue == ValorDisparo) {
  				LecturasConsecutivasDisparo++;
  				//printf("%d\n", LecturasConsecutivasDisparo);
  			}
  			else {
  				LecturasConsecutivasDisparo=0;
  			}
  					
  			// Si tiene el valor de disparo 
  			if ((LecturasConsecutivasDisparo>=MinimoLecturasConsecutivasDisparo) && (FotocelulaDIValue == ValorDisparo)) {
  			
  				// Si ha cambiado antes de valor, es que ya se ha disparado
  				if (CambioFotocelula == true) {
  			
  					EsperaFotocelula = false;
  					CambioFotocelula = false;
  					
    					if (MarcajeDinamicoActivo == 1) {
  						
  						// Leer las cuentas del encoder en la variable "Anterior"
  						//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
  						//if (error < 0) {
  						//	rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  						//	ErrorDAQ = ON;
  						//	StopEjecucion();
  						//}
  					
  						IncrementoAcumulado = 0;
  						ValorCuentasAnterior = ValorCuentasActual;
  					}
  					
    					ControlMarkInProgress(ON);
  					
  				}
  	
  			}
  			
    			else {
  			
  				// Resetea el flag
  				CambioFotocelula = true;
  				
  			}	
  	
  		}
  		
  		// Disparo interno: comprueba si hay que seguir esperando
  		else if ((TipoDisparo == DISPAROINTERNO) && (EsperaSeparacionEntreDisparos) && (PruebaMarcaje == false)) {
  		
  			// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  			// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  			if (MarcajeDinamicoActivo == 1) {
  		
  				ValorCuentasActual_Espera = ValorCuentasActual;
  				
  				// Calcular el incremento de cuentas
  				if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
  					IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
  				}
    					IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
  					//StopEjecucion();
  					//LedEstado->label("Encoder: overflow");
  					rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  					return false;
  				}
  	
  				// debug excesos del encoder
  				if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
  			
  					//StopEjecucion();
  			
  					LedEstado->label("Encoder: incremento");
  					rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  					return false;
  		
  				}
  	
    				ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
  	
  			}
  	
  			// Acumula las cuentas del periodo
  			IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
  	
  			// Mira a ver si se ha sobrepasado ya las cuentas de espera
  			if (IncrementoAcumulado_Espera >= SeparacionEntreDisparos_cuentas) {
  			
    				EsperaSeparacionEntreDisparos = false;
  				
  				// y vuelve a empezar a contar para la siguiente marca
  				IncrementoAcumulado_Espera = 0;
  				
    				if (MarcajeDinamicoActivo == 1) {
  						
  					// Leer las cuentas del encoder en la variable "Anterior"
  					//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
  					//if (error < 0) {
  					//	rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  					//	ErrorDAQ = ON;
  					//	StopEjecucion();
  					//}
  					
  					IncrementoAcumulado = 0;
  					ValorCuentasAnterior = ValorCuentasActual;
  				}
  				
    				ControlMarkInProgress(ON);
  				
  			}
  			
  			//DEBUG
  			if (debug_espera == true) {
  				rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  			}
  	
  		}
  		
    		else {
  			
  			MarcajeOk = EjecutarMicrovector(1); // lista 1
  			
  			// Si hay disparo interno hay que seguir leyendo las cuentas
  			if (TipoDisparo == DISPAROINTERNO) {
  		
  				// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  				// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  				if (MarcajeDinamicoActivo == 1) {
  		
  					ValorCuentasActual_Espera = ValorCuentasActual;
  				
  					// Calcular el incremento de cuentas
  					if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
  						IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
  					}
  					
    						IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
  						//StopEjecucion();
  						//LedEstado->label("Encoder: overflow");
  						rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  						return false;
  					}
  	
  					// debug excesos del encoder
  					if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
  			
  						//StopEjecucion();
  			
  						LedEstado->label("Encoder: incremento");
  						rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  						return false;
  		
  					}
  	
    					ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
  	
  				}
  	
  				// Acumula las cuentas del periodo
  				IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
  			
  			}
  			
  			//DEBUG
  			if (debug_espera == true) {
  				rt_printk("MV - Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  			}
  			
  		}
  		
  	}
  	
    	else if ((Lista2_Exe == true) && (SistemaOk == true) && (MarcajeOk == true)) {
  		
  		//rt_printk("L0:%d L1:%d L2:%d\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
  		
    		if ((TipoDisparo == DISPAROEXTERNO) && (EsperaFotocelula == true) && (PruebaMarcaje == false)) {
  		
    			switch (Control) {
  
  			case DAQ:
  	
  				error = comedi_dio_read(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, &FotocelulaDIValue);	
  				if (error < 0) {
  					rt_printk("comedi_dio_read Fotocelula error=%d Valor=%d\n", error, FotocelulaDIValue);
  					ErrorDAQ = ON;
  					//StopEjecucion();
  				}
  		
  				break;
  
  			case FPGA:
  
    				inbyte = inb(REGISTRO_STATUS);
  			
      				if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {FotocelulaDIValue = 0;}
  				else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {FotocelulaDIValue = 1;}
  				else FotocelulaDIValue = -1; // error
  		
  				break;	
  	
  			} 
  			
  			// DEBUG
  			if (debug_fotocelula) {
  				rt_printk("FotoCelula:%d\n",FotocelulaDIValue);
  			}
  			
  			// Si tiene el valor de disparo 
  			if (FotocelulaDIValue == ValorDisparo) {
  				LecturasConsecutivasDisparo++;
  				//printf("%d\n", LecturasConsecutivasDisparo);
  			}
  			else {
  				LecturasConsecutivasDisparo=0;
  			}
  					
  			// Si tiene el valor de disparo 
  			if ((LecturasConsecutivasDisparo>=MinimoLecturasConsecutivasDisparo) && (FotocelulaDIValue == ValorDisparo)) {
  			
  				// Si ha cambiado antes de valor, es que ya se ha disparado
  				if (CambioFotocelula == true) {
  					
  					EsperaFotocelula = false;
  					CambioFotocelula = false;
  			
    					if (MarcajeDinamicoActivo == 1) {
  						
  						// Leer las cuentas del encoder en la variable "Anterior"
  						//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
  						//if (error < 0) {
  						//	rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  						//	ErrorDAQ = ON;
  						//	StopEjecucion();
  						//}
  						
  						IncrementoAcumulado = 0;
  						ValorCuentasAnterior = ValorCuentasActual;
  					}
  					
    					ControlMarkInProgress(ON);
  					
  				}
  	
  			}
  			
    			else {
  			
  				// Resetea el flag
  				CambioFotocelula = true;
  				
  			}	
  	
  		}
  		
  		// Disparo interno: comprueba si hay que seguir esperando
  		else if ((TipoDisparo == DISPAROINTERNO) && (EsperaSeparacionEntreDisparos) && (PruebaMarcaje == false)) {
  		
  			// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  			// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  			if (MarcajeDinamicoActivo == 1) {
  		
  				ValorCuentasActual_Espera = ValorCuentasActual;
  				
  				// Calcular el incremento de cuentas
  				if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
  					IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
  				}
    					IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
  					//StopEjecucion();
  					//LedEstado->label("Encoder: overflow");
  					rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  					return false;
  				}
  	
  				// debug excesos del encoder
  				if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
  			
  					//StopEjecucion();
  			
  					LedEstado->label("Encoder: incremento");
  					rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  					return false;
  		
  				}
  	
    				ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
  	
  			}
  	
  			// Acumula las cuentas del periodo
  			IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
  	
  			// Mira a ver si se ha sobrepasado ya las cuentas de espera
  			if (IncrementoAcumulado_Espera >= SeparacionEntreDisparos_cuentas) {
  			
    				EsperaSeparacionEntreDisparos = false;
  				
  				// y vuelve a empezar a contar para la siguiente marca
  				IncrementoAcumulado_Espera = 0;
  				
    				if (MarcajeDinamicoActivo == 1) {
  						
  					// Leer las cuentas del encoder en la variable "Anterior"
  					//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
  					//if (error < 0) {
  					//	rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  					//	ErrorDAQ = ON;
  					//	StopEjecucion();
  					//}
  					
  					IncrementoAcumulado = 0;
  					ValorCuentasAnterior = ValorCuentasActual;
  				}
  				
    				ControlMarkInProgress(ON);
  							
  			}
  			
  			//DEBUG
  			if (debug_espera == true) {
  				rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  			}
  	
  		}
  		
    		else {
  			
  			MarcajeOk = EjecutarMicrovector(2); // lista 2	
  			
  			// Si hay disparo interno hay que seguir leyendo las cuentas
  			if (TipoDisparo == DISPAROINTERNO) {
  		
  				// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  				// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  				if (MarcajeDinamicoActivo == 1) {
  		
  					ValorCuentasActual_Espera = ValorCuentasActual;
  				
  					// Calcular el incremento de cuentas
  					if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
  						IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
  					}
  					
    						IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
  						//StopEjecucion();
  						//LedEstado->label("Encoder: overflow");
  						rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  						return false;
  					}
  	
  					// debug excesos del encoder
  					if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
  			
  						//StopEjecucion();
  			
  						LedEstado->label("Encoder: incremento");
  						rt_printk("Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  						return false;
  		
  					}
  	
    					ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
  	
  				}
  	
  				// Acumula las cuentas del periodo
  				IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
  			
  			}
  			
  			//DEBUG
  			if (debug_espera == true) {
  				rt_printk("MV - Actual:%d INCR:%f ACUM:%f\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
  			}
  					
  		}
  		
  	}
  	
  	// Si se ha salido por algun problema de estado detener el proceso
  	//if ( (SistemaOk == false) && ((EnEjecucion) || (PruebaMarcaje)) ) {
  		
  	//	rt_printk("SistemaOk: %d\n", SistemaOk);
  		//StopEjecucion();
  
  	//}
  
  	//if ((MarcajeOk == false) && ((EnEjecucion) || (PruebaMarcaje)) ){
  	//	rt_printk("MarcajeOk: %d\n", MarcajeOk);
  		
    	//	tFinMarca = rt_get_time_ns();
  	
  	//	StopEjecucion();
  		//ProcesarError();
  		//error = false;
  	//}
  		
  	//ESTADISTICAS del tiempo de los ciclos
  	if (debug_ciclos) {
  		
    		tProceso = rt_get_cpu_time_ns();
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////
  	//ESPERA EL TIEMPO CORRESPONDIENTE A UN PERIODO
  	result_wait = rt_task_wait_period();
  	  
  	if (result_wait && debug_ciclos) {
  		
  		overrun++;
  		
  		//rt_printk("overrun=%ld result_wait=%ld\n",overrun,result_wait);
  		
  		if (result_wait == RTE_UNBLKD) {ov_RTE_UNBLKD++;}
  		else if (result_wait == RTE_TMROVRN) {ov_RTE_TMROVRN++;}
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////		
  	//ESTADISTICAS del tiempo de los ciclos
  	if (debug_ciclos) {
  		
    		tActual = rt_get_cpu_time_ns();
  		
  		// Actualiza el contador de iteraciones
  		ContadorCiclos++;
  		
  		// Duraciones
  		duracionCiclo = (double)(tActual - tAnterior);
  		duracionProceso = (double)(tProceso - tAnterior);
  		duracionEspera = (double)(tActual - tProceso);
  		
    		duracionCicloPromedio += duracionCiclo;
  		duracionProcesoPromedio += duracionProceso;
  		duracionEsperaPromedio += duracionEspera;
  			
    		if (duracionCiclo > duracionCicloMax) duracionCicloMax = duracionCiclo;
  		if (duracionCiclo < duracionCicloMin) duracionCicloMin = duracionCiclo;
  		
  		if (duracionProceso > duracionProcesoMax) duracionProcesoMax = duracionProceso;
  		if (duracionProceso < duracionProcesoMin) duracionProcesoMin = duracionProceso;
  		
  		if (duracionEspera > duracionEsperaMax) duracionEsperaMax = duracionEspera;
  		if (duracionEspera < duracionEsperaMin) duracionEsperaMin = duracionEspera;
  		
  		// Histogramas
    		if (duracionCiclo <= umbral_duracionCiclo[0]) {duracionCiclo_hist[0]++;}
  		else if (duracionCiclo <= umbral_duracionCiclo[1]) {duracionCiclo_hist[1]++;}
  		else if (duracionCiclo <= umbral_duracionCiclo[2]) {duracionCiclo_hist[2]++;}
  		else if (duracionCiclo <= umbral_duracionCiclo[3]) {duracionCiclo_hist[3]++;}
  		else if (duracionCiclo <= umbral_duracionCiclo[4]) {duracionCiclo_hist[4]++;}
  		else if (duracionCiclo <= umbral_duracionCiclo[5]) {duracionCiclo_hist[5]++;}
  		else {duracionCiclo_hist[6]++;}
  		
    		if (duracionProceso <= umbral_duracionProceso[0]) {duracionProceso_hist[0]++;}
  		else if (duracionProceso <= umbral_duracionProceso[1]) {duracionProceso_hist[1]++;}
  		else if (duracionProceso <= umbral_duracionProceso[2]) {duracionProceso_hist[2]++;}
  		else if (duracionProceso <= umbral_duracionProceso[3]) {duracionProceso_hist[3]++;}
  		else if (duracionProceso <= umbral_duracionProceso[4]) {duracionProceso_hist[4]++;}
  		else if (duracionProceso <= umbral_duracionProceso[5]) {duracionProceso_hist[5]++;}
  		else {duracionProceso_hist[6]++;}
  
    		if (duracionEspera <= umbral_duracionCiclo[0]) {duracionEspera_hist[0]++;}
  		else if (duracionEspera <= umbral_duracionEspera[1]) {duracionEspera_hist[1]++;}
  		else if (duracionEspera <= umbral_duracionEspera[2]) {duracionEspera_hist[2]++;}
  		else if (duracionEspera <= umbral_duracionEspera[3]) {duracionEspera_hist[3]++;}
  		else if (duracionEspera <= umbral_duracionEspera[4]) {duracionEspera_hist[4]++;}
  		else if (duracionEspera <= umbral_duracionEspera[5]) {duracionEspera_hist[5]++;}
  		else {duracionEspera_hist[6]++;}
  							
  		// Guarda el tiempo de inicio del siguiente ciclo			
  		tAnterior = tActual;
  		//tAnterior = rt_get_cpu_time_ns();
  		
  	}
  		
  }
  
  // Detiene el timer
  stop_rt_timer();
  	
  // SOFT RT /////////////////////////////////////////////////////////////
  rt_make_soft_real_time();
  rt_task_delete(timer_task_handler);
  endhandler = ON;
  	
  //ESTADISTICAS del tiempo de los ciclos
  if (debug_ciclos) {
  	rt_printk("############################################################################\n");
  	rt_printk("Ciclos:%lld Overrun:%ld(%.2f) RTE_UNBLKD:%ld RTE_TMROVRN:%ld\n", ContadorCiclos, overrun, (float)overrun/(float)ContadorCiclos, ov_RTE_UNBLKD, ov_RTE_TMROVRN);
  	
      	rt_printk("<50:%lld(%.2f) <100:%lld(%.2f) <150:%lld(%.2f) <200:%lld(%.2f) \n<250:%lld(%.2f) <300:%lld(%.2f) >300:%lld(%.2f)\n", duracionCiclo_hist[0], (float)duracionCiclo_hist[0]/ContadorCiclos, duracionCiclo_hist[1], (float)duracionCiclo_hist[1]/ContadorCiclos, duracionCiclo_hist[2], (float)duracionCiclo_hist[2]/ContadorCiclos, duracionCiclo_hist[3], (float)duracionCiclo_hist[3]/ContadorCiclos, duracionCiclo_hist[4], (float)duracionCiclo_hist[4]/ContadorCiclos, duracionCiclo_hist[5], (float)duracionCiclo_hist[5]/ContadorCiclos, duracionCiclo_hist[6], (float)duracionCiclo_hist[6]/ContadorCiclos);
  	
      	rt_printk("<25:%lld(%.2f) <50:%lld(%.2f) <75:%lld(%.2f) <100:%lld(%.2f) \n<150:%lld(%.2f) <200:%lld(%.2f) >200:%lld(%.2f)\n", duracionProceso_hist[0], (float)duracionProceso_hist[0]/ContadorCiclos, duracionProceso_hist[1], (float)duracionProceso_hist[1]/ContadorCiclos, duracionProceso_hist[2], (float)duracionProceso_hist[2]/ContadorCiclos, duracionProceso_hist[3], (float)duracionProceso_hist[3]/ContadorCiclos, duracionProceso_hist[4], (float)duracionProceso_hist[4]/ContadorCiclos, duracionProceso_hist[5], (float)duracionProceso_hist[5]/ContadorCiclos, duracionProceso_hist[6], (float)duracionProceso_hist[6]/ContadorCiclos);
  	
      	rt_printk("<25:%lld(%.2f) <50:%lld(%.2f) <75:%lld(%.2f) <100:%lld(%.2f) \n<150:%lld(%.2f) <200:%lld(%.2f) >200:%lld(%.2f)\n", duracionEspera_hist[0], (float)duracionEspera_hist[0]/ContadorCiclos, duracionEspera_hist[1], (float)duracionEspera_hist[1]/ContadorCiclos, duracionEspera_hist[2], (float)duracionEspera_hist[2]/ContadorCiclos, duracionEspera_hist[3], (float)duracionEspera_hist[3]/ContadorCiclos, duracionEspera_hist[4], (float)duracionEspera_hist[4]/ContadorCiclos, duracionEspera_hist[5], (float)duracionEspera_hist[5]/ContadorCiclos, duracionEspera_hist[6], (float)duracionEspera_hist[6]/ContadorCiclos);
  	
  	rt_printk("############################################################################\n");
  }	
  
  return 0;
}

int Inicializar_Laser() {
  int error = false;
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_laser\n");
  }
  
    // ha definido al inicializar el control
  Laser_Up_Ticks = (unsigned short int)((PeriodoTrenPulsos*10*PotenciaLaser) + Clock_Period_ns / 2) / Clock_Period_ns;
  Laser_Down_Ticks = (unsigned short int)((PeriodoTrenPulsos*1000) + Clock_Period_ns / 2) / Clock_Period_ns - Laser_Up_Ticks;
  
  switch (Control) {
  
  case DAQ:
  	
    	error = comedi_dio_write(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, ON);	
  	if (error < 0) {
  		rt_printk("comedi_dio_write error = %d - Laser Enable ON\n",error);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// Resetea el contador
  	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  	if (error < 0){
  		rt_printk("ERROR comedi_reset comedi_subdevice_ContadorLaser\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	/*
  	
    	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_gate_source 0\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  	*/
  
    	Counter_Mode = NI_GPCT_COUNTING_MODE_NORMAL_BITS;
  
  	// toggle output on terminal count
  	Counter_Mode |= NI_GPCT_OUTPUT_TC_TOGGLE_BITS;
  
  	// load on terminal count
  	Counter_Mode |= NI_GPCT_LOADING_ON_TC_BIT;
  
  	// alternate the reload source between the load a and load b registers
  	Counter_Mode |= NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS;
  
  	// count down
  	Counter_Mode |= NI_GPCT_COUNTING_DIRECTION_DOWN_BITS;
  
  	// initialize load source as load b register
  	Counter_Mode |= NI_GPCT_LOAD_B_SELECT_BIT;
  
  	// don't stop on terminal count
  	Counter_Mode |= NI_GPCT_STOP_ON_GATE_BITS;
  
  	// don't disarm on terminal count or gate signal
  	Counter_Mode |= NI_GPCT_NO_HARDWARE_DISARM_BITS;
  
  
  	/*
  
  	// configura el modo del contador
  	error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_counter_mode\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	*/
  
  	// Hay que enrutar la salida del contador
  	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ContadorLaser_DO, comedi_canalDO_ContadorLaser, comedi_ContadorLaser_Routing);
  	if (error < 0){
  		rt_printk("ERROR %d comedi_set_routing\n", error);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// y configurar el canal digital de salida
  	error = comedi_dio_config(comedi_device, comedi_subdevice_ContadorLaser_DO, comedi_canalDO_ContadorLaser, COMEDI_OUTPUT);
  	if(error < 0){
  		rt_printk("ERROR comedi_dio_config OUTPUT canal contador %d\n", comedi_canalDO_ContadorLaser);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	/*
  
  	// asigna el reloj: 20MHz clock
  	error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_clock_source\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
  	if (Laser_Down_Ticks == 0) {Laser_Down_Ticks=1;}
  
  	printf("=========Laser counter: up_ticks=%d	down_ticks=%d\n", laser_up_ticks, laser_down_ticks);
  
  	// set initial counter value by writing to channel 0
  	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, laser_down_ticks);
  	if (error < 0){
  		rt_printk("ERROR comedi_data_write down_ticks inicial\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// set "load a" register to the number of clock ticks the counter output should remain low
  	// by writing to channel 1.
  	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, laser_down_ticks);
  	if (error < 0){
  		rt_printk("ERROR comedi_data_write down_ticks load a\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// set "load b" register to the number of clock ticks the counter output should remain high
  	//by writing to channel 2
  	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, laser_up_ticks);
  	if (error < 0){
  		rt_printk("ERROR comedi_data_write up_ticks load b\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
  	if (error < 0){
  		printf("ERROR comedi_arm\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
      
  	//if (TipoLaser==2){ //laser de fibra
  
  		error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, LOW);//ValorActivacionGalvos);	
  		sleep(1);
  	
  		error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);//ValorActivacionGalvos);	
  	
  		if(error < 0){
  			rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \n",error);
  			ErrorDAQ = ON;
  			ProcesarError();
  		return -1;
  		}
  	*/	
  	break;
  
  case FPGA:
  
    	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
  
    	outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);
  
  	//rt_printk("Laser_Up_Ticks=%d	Laser_Down_Ticks=%d\n", Laser_Up_Ticks, Laser_Down_Ticks);
  
  	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
  	// if (laser_down_ticks == 0) {laser_down_ticks=1;}
  
    
  	// Ticks Laser Up:
  
  	// Byte menos significativo (LSB)
  	outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);
  
  	// comando LSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);
  
    	outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);
  
  	// comando MSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);
  
  	// Ticks Laser Down:
  
  	// Byte menos significativo (LSB)
  	outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);
  
  	// comando LSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);
  
    	outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);
  
  	// comando MSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);
  	
  	break;
  	
  } 
  
  
  
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_laser\n");
  }
  
  return error;
}

int Desactivar_Laser() {
  int error = false;
  
  switch (Control) {
  
  case DAQ:
  	
    	error = comedi_dio_write(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, OFF);	
  	if (error < 0) {
  		rt_printk("comedi_dio_write error = %d\n - Laser Enable OFF",error);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  	if (error < 0){
  		rt_printk("ERROR comedi_reset laser\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	break;
  
  case FPGA:
  
    	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
  
    	outb((COMANDO_LASER_ENABLE|0x00), REGISTRO_ADDR);
  	
  	break;
  	
  } 
  
  return error;
}

int Control_Laser(int OnOff) {
  int error = false;
  
    
  switch (Control) {
  
  case DAQ:
  	
  	switch (OnOff) {
  
  	case ON: 
  		
  		switch(TipoLaser){
  		
  		case 0: 
    			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_gate_source 0 laser\n");
  				error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);		
  				if (error<0){
  					rt_printk("ERROR comedi_set_gate_source 0 laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  	
  			// configura el modo del contador
  			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_counter_mode laser\n");
  				error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);				
  				if (error<0){
  					rt_printk("ERROR comedi_set_counter_mode laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  
  			// asigna el reloj: 20MHz clock
  			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_clock_source laser\n");
  				error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
  				if (error<0){
  					rt_printk("ERROR comedi_set_clock_source laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  
  			// set initial counter value by writing to channel 0
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks inicial laser\n");
  				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
  				ErrorDAQ = ON;
  				if (error<0){
  					rt_printk("ERROR comedi_data_write down_ticks inicial laser consecutivo\n");
  					ErrorDAQ=ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  
  			// set "load a" register to the number of clock ticks the counter output should remain low
  			// by writing to channel 1.
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks load a laser\n");
  				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
  				if (error<0){
  					rt_printk("ERROR comedi_data_write down_ticks load a laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  
  			// set "load b" register to the number of clock ticks the counter output should remain high
  			//by writing to channel 2
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write up_ticks load b laser\n");
  				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
  				if (error<0){
  					rt_printk("ERROR comedi_data_write up_ticks load b laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  	
  			// arma el contador
  			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
  			if (error < 0){
  				rt_printk("ERROR comedi_arm laser\n");
  				error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
  				if (error<0){
  					rt_printk("ERROR comedi_arm laser consecutivo\n");
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  			break;
  				
  			case 1:
  			
  		
    			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - Mark In Progress On\n",error);
  			// Volvemos a intentarlo si hay error
  				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
  				if (error < 0) {
  					rt_printk("comedi_dio_write error = %d - Mark In Progress On consecutivo\n",error);	
  			// Y todavia una tercera vez
  					error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);
  					if (error<0){
  						ErrorDAQ = ON;
  						ProcesarError();
  						//return -1;
  					}
  				}
  			}
  
    			//LedLaser->color(FL_RED);	// Led rojo
  		
  		
  			break;
  		
  		}
  	
  		break;	
  	
  	case OFF:
  		
  		switch(TipoLaser){
  			case 0:
  			
  			// Resetea el contador
  			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  			if (error < 0){
  				rt_printk("ERROR comedi_reset laser %d\n", error);
  				error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  				if (error<0){
  					rt_printk("ERROR comedi_reset laser consecutivo %d\n", error);
  					ErrorDAQ = ON;
  					ProcesarError();
  					return -1;
  				}
  			}
  			break;
  			
  			case 1:
  		
  			
    			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - Mark In Progress Off\n",error);
  				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
  				if (error < 0) {
  					rt_printk("comedi_dio_write error = %d - Mark In Progress Off\n",error);
  					error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);
  					if (error<0){
  						rt_printk("comedi_dio_write error = %d - Mark In Progress Off\n",error);
  						ErrorDAQ = ON;
  						ProcesarError();
  						//return -1;
  					}
  				}
  			}
  		
    			//LedLaser->color(FL_GREEN);	// Led verde
  		
  		
  			break;
  		}
  	
  		break;
  	}
  	
  	break;
  
  case FPGA:
  
  	switch (OnOff) {
  
  	case ON: 
  
    		outb((COMANDO_LASER|0x01), REGISTRO_ADDR);
  		break;
  	
  	case OFF:
  	
    		outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
  		break;
  	
  	}
  
  	break;
  	
  } 	
  
  // DEBUG
  if (debug_Mvectores) {
  	rt_printk("Control_Laser::MV %ld OnOff:%d EstadoLaser:%d \n", MicroVector, OnOff, EstadoLaser);
  }
  
  // Actualiza el estado
  EstadoLaser = OnOff;
  	
  return error;
}

int Inicializar_Encoder() {
  int error = false;
  lsampl_t counter_mode;
  static const unsigned initial_count = 0;
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_Encoder\n");
  }
  
  // Inicializa las variables para la lectura de las cuentas del encoder
  ValorCuentasActual = 0;
  ValorCuentasAnterior = 0;
  IncrementoAcumulado = 0;
  	
  switch (Control) {
  
  case DAQ:
  	
  	// Resetea el contador
  	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorEncoder);
  	if (error < 0){
  		rt_printk("ERROR comedi_reset inicializar encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
    	MaxdataContadorEncoder = comedi_get_maxdata(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal);
  
    	error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorEncoder, NI_GPCT_PFI_CLOCK_SRC_BITS(SOURCE_PFI_CHANNEL), 0);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_clock_source encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	// Y configurar el canal de entrada
  	error = comedi_dio_config(comedi_device, comedi_subdevice_ContadorEncoder_DI, comedi_canalDI_ContadorEncoder, COMEDI_INPUT);
  	if(error < 0){
  		rt_printk("ERROR comedi_dio_config INPUT canal encoder %d\n", comedi_canalDI_ContadorEncoder);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	//error = comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, NI_GPCT_GATE_PIN_GATE_SELECT(0) /* NI_GPCT_GATE_PIN_i_GATE_SELECT *//*| CR_EDGE*/);
  	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_gate_source 0 encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  		
  	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 1, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_gate_source 1 encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
    	counter_mode = NI_GPCT_COUNTING_MODE_NORMAL_BITS;
  
  	// output pulse on terminal count (doesn't really matter for this application)
  	counter_mode |= NI_GPCT_OUTPUT_TC_PULSE_BITS;
  
  	// Don't alternate the reload source between the load a and load b registers.
  
  	// Doesn't really matter here, since we aren't going to be reloading the counter.
  	counter_mode |= NI_GPCT_RELOAD_SOURCE_FIXED_BITS;
  
  	// count up
  	counter_mode |= NI_GPCT_COUNTING_DIRECTION_UP_BITS;
  
  	// don't stop on terminal count
  	counter_mode |= NI_GPCT_STOP_ON_GATE_BITS;
  
  	// don't disarm on terminal count or gate signal
  	counter_mode |= NI_GPCT_NO_HARDWARE_DISARM_BITS;
  
  	error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorEncoder, 0, counter_mode);
  	if (error < 0){
  		rt_printk("ERROR comedi_set_counter_mode encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	/* set initial counter value by writing to channel 0.  The "load a" and "load b" registers can be
  	set by writing to channels 1 and 2 respectively. */
  	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, 0, initial_count);
  
  	error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorEncoder, NI_GPCT_ARM_IMMEDIATE);
  	if (error < 0){
   		rt_printk("ERROR itaca_comedi_arm encoder\n");
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  	break;
  
  case FPGA:
  
  	// Inicializa el encoder
  	outb((COMANDO_ENCODER|0x01), REGISTRO_ADDR);
  
  	break;
  	
  } 
  
  
  
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_Encoder\n");
  }
  
  return error;
}

int Desactivar_Encoder() {
  int error = false;
  
  switch (Control) {
  
  case DAQ:
  	
  	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorEncoder);
  	if (error < 0){
  		rt_printk("ERROR comedi_reset desactivar encoder %d\n", error);
  		ErrorDAQ = ON;
  		ProcesarError();
  		return -1;
  	}
  
  	break;
  
  case FPGA:
  
  	// Inicializa el encoder
  	outb((COMANDO_ENCODER|0x00), REGISTRO_ADDR);
  	
  	break;
  	
  } 
  
  
  return error;
}

int CalcularMatriz() {
    int retval;
  
    if (ArchivoFuentesAbierto == false) {
      
      // Se rellenan el array ArchivoFuentes y las variables xMaxFont e yMaxFont
      LeerArchivoFuentes();
      ArchivoFuentesAbierto = true;
  
  }
  
  switch (Estrategia) {
          
            	
          	retval = CalcularMatrizCaracter();
          	break;
          	
            	
          	retval = CalcularMatrizAtomos();
          	break;
          	
            	
          	retval = CalcularMatrizFueraCampo();
          	break;	
          	
          case 3:	// Componer        	
          	retval = CalcularMatrizComponer();
          	break;		
  }
  
  // Si ha habido un error calculando la matriz detiene llama a Stop
  if (retval) {
  
  	StopEjecucion();
  
  }
  
  return retval;
}

int CalcularMatrizCaracter() {
    
        char caracter;				// variables de proceso
  float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
  float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
  int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
  double orientacion_radianes, seno, coseno, x, y;
    int fila, columna, offsetvectores;
  unsigned int NumeroVectoresCelda;
  int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;
  
    NumeroVectores = 0;
  AnchuraLineaTexto = 0;
  AnchuraLineaTextoMaxima = 0;
  AlturaLineaTexto = 0;
  AlturaLineaTextoMaxima = 0;
  AlturaTotalMarca = 0;
  AlturaTextoAcumulada = 0;
  FueraLimites = false;
  tempValuesLinea1 = 0;
  tempValuesLinea2 = 0;
  tempValuesLinea3 = 0;
  tempValuesLinea4 = 0;
  tempvalueslinea_inicio = 0;
  tempvalueslinea_fin = 0;
  xoffset = 0;
  yoffset = 0;
  pltDemasiadoGrande = false;
  pltIncorrecto = false;
  
    for (i=1; i<=NumeroLineasTexto; i++) {
  	           
    	AnchuraCaracterAnterior = 0;
          
            LineaCalcular = i;
       
       	// Proceso de cada bloque
  	for (b=1; b<=NumeroBloques; b++) {
  	                  
            	BloqueCalcular = b;
          	
          	if (debug_vectores) {
            	}
          	
  	        ///////////////////////////////////////////////////////////////////////////////////
    	        ///////////////////////////////////////////////////////////////////////////////////
          	switch (LineaCalcular) {
          
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
          	
          		break;	
          		
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
          	
          		break;	
          	
  	        } //del switch que asigna variables de proceso
                  
            
  	       	if (debug_vectores) {
         			printf("LineaTexto:%s  AlturaLineaTexto:%f \n", LineaTexto, AlturaLineaTexto);
         		}
          	
           		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
          	
         			if (strlen(LineaTexto) > 0) {
          		
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  			
         				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
    	        	        	caracter = LineaTexto[j];
         		        		EncontrarParametros (caracter);
          	        		
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              	
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          		
          		}
          		
          		else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
  	        		AlturaLineaTexto = 0;
          		}
          		
  	        }
          	
    	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
          	
            		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  			}
  			
          		EncontrarParametrosPlt();
          		AnchuraLineaTexto = AnchuraCaracterAnterior;
          		
  	        }
          	
           		else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {
          	
         			if (strlen(LineaTexto) > 0) {
          		
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  			
         				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
    	        	        	caracter = LineaTexto[j];
         		        		EncontrarParametros (caracter);
          	        		
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              	
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          		
          		}
          		
          		else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
  	        		AlturaLineaTexto = 0;
          		}
          		
  	        }
  
          		
    	        else {
          		
          		if (strlen(LineaTexto) > 0) {
          		
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
          			EncontrarParametrosBarcode();
                			AnchuraLineaTexto = AnchuraCaracterAnterior; 
         			
  	      		}
         			
         			else {
         			
         				//AnchuraLineaTexto = AnchuraLineaTexto;
        				AlturaLineaTexto = 0;
         			}
         				
          	}
         
  	       	
          
          } // Siguiente bloque
          
            
            switch (LineaCalcular) {
          
            	
    	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
  	   
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                  }
                  else {
                  	alturalineatexto1 = AlturaLineaTexto1[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto1;
  
                	if (NumeroVectores > 0) {
  		       	tempValuesLinea1 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea1 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto2 = AnchuraLineaTexto;
              	
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                  }
                  else {
                  	alturalineatexto2 = AlturaLineaTexto2[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto2;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea2 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea2 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto3 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                  }
                  else {
                  	alturalineatexto3 = AlturaLineaTexto3[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto3;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea3 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea3 = -1;
          	}
          	    	            	
  	        break;
  	        
            	
    	        AnchuraLineaTexto4 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                  }
                  else {
                  	alturalineatexto4 = AlturaLineaTexto4[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto4;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea4 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea4 = -1;
          	}
          	    	            	
  	        break;
              
          }
          
          // Guarda la altura total de la marca hasta ahora
    	if (AnchuraLineaTexto) {
         		
         		if (LineaCalcular > 1) {
  			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
  		}
  	
    			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
  		}
  		
  	}
  	
    	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
          	
          	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
          
  	}
          
    	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
          
          	AlturaLineaTextoMaxima = AlturaLineaTexto;
          
          }
          
    
  // Guardamos los valores de la celda
  XMaxCelda = (int)AnchuraLineaTextoMaxima;
  YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
  //printf("XMaxCelda:%d YMaxCelda:%d\n", XMaxCelda, YMaxCelda);
    
  // Si no hay vectores y no es un plt incorrecto devuelve un valor y presenta mensajes de error:
  if ((NumeroVectores == 0) && (!pltIncorrecto)){
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
  			BoxVentanaMensaje->label("No hay datos para marcar");
  			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("There is no data to mark");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Nessun dato per stampare");
  			break;
  			
  		}
  
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  for (i=1; i<=NumeroLineasTexto; i++) {
  
    	switch (i) {
          
          case 1:
              
                AnchuraLineaTexto = AnchuraLineaTexto1;
              
                if (AnchuraLineaTexto > 0) {
              	
    	    	AlturaLineaTexto = alturalineatexto1;
  	    	
              }
              
              else {
             
              	AlturaLineaTexto = 0;
             
              }
                  
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
              }
              
                tempvalueslinea_inicio = 0;
              tempvalueslinea_fin = tempValuesLinea1;
                          
              break;
          
          case 2:
              
                AnchuraLineaTexto = AnchuraLineaTexto2;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto2;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea1 + 1;
              tempvalueslinea_fin = tempValuesLinea2;
                          
              break;
          
          case 3:
              
                AnchuraLineaTexto = AnchuraLineaTexto3;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto3;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea2 + 1;
              tempvalueslinea_fin = tempValuesLinea3;
                          
              break;
          
          case 4:
              
                AnchuraLineaTexto = AnchuraLineaTexto4;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto4;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea3 + 1;
              tempvalueslinea_fin = tempValuesLinea4;
                          
              break;
                  
          }
          
            
          //Centrado = true;
          
  	// Calcula el offset x e y
    	if (Centrado) {
  		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
  		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
  		
  		if (Reverso) {
  		
  			xoffset = -xoffset;
  			//yoffset = -yoffset;
  			
  		}
  		
  		//printf("------ xoffset:%d yoffset:%d\n", xoffset,yoffset);
  	}
  	
  	
    	else {
  
  		switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
  		case -180:
  		case 180:
  		
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la izquierda
              		if (xOffsetPantalla < 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                   		
        			break;
         
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		case 0:
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la derecha
              		if (xOffsetPantalla > 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
              		
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
  		case -270:
  		case 90:
  			if (JustificacionIzquierda == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
              		
              		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
              		 
              		// Se pueden desplazar verticalmente hacia abajo
              		if (yOffsetPantalla < 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
  		case -90:
  		case 270:
  			if (JustificacionIzquierda == true) {				  
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
               		
               		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);
  
  			// Se pueden desplazar verticalmente hacia arriba
              		if (yOffsetPantalla > 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  
          	}
          
  	}
      	    	
      	if (debug_vectores) {	
  		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \n", Orientacion, Avance, xoffset, yoffset);
  	}
  	
    	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
  		
      		if (Reverso) {
  		
  			xValues[j] = -xValues[j] + xoffset;
  		
  		}
  		
  		else {
  		
  			xValues[j] = xValues[j] + xoffset;
  		
  		}
  		
  		// La coordenada Y no depende del efecto reverso
  		yValues[j] = yValues[j] + yoffset;
  		
  		// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          		FueraLimites = true;
          		
    
  		}
  
  	}
      
  } // Fin del bucle For, para cada linea de texto
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
    if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {
  
  	// primero copia la celda original
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
    	NumeroVectoresCelda = NumeroVectores;
  
    	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);
  
    
    	for (fila = 1; fila <= NumeroFilas; fila++) {
  
  		for (columna = 1; columna <= NumeroColumnas; columna++) {
  
  			// La primera celda no hay que repetirla
  			if ((fila == 1) && (columna == 1)) {continue;}
  		
    			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  		
  			for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
  				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
  				xValues[i+offsetvectores] = xValues[i];	
  				yValues[i+offsetvectores] = yValues[i];
  	
  			}
  
  		}
  
  	}
  
    	xMinTabla = MaximoBits;
  	xMaxTabla = -MaximoBits;
  	yMinTabla = MaximoBits;
  	yMaxTabla = -MaximoBits;
  
      	if ((Orientacion - Avance) == 0) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
  				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  			
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
  				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  	
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    
    if ((ControlTablaPrecorte) && (Precorte)) {
  
    	if ((Orientacion - Avance) == 0) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		
  	}
  	
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  	
  	}
  	
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
  		
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
  			
  		}
  	
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
  }
  
  
  ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
  switch (Orientacion) {
  
  case 0:
  	orientacion_radianes = 0;
  	break;
  
  case 90:
  	orientacion_radianes = M_PI / 2.0;
  	break;
  
  case 180:
  	orientacion_radianes = M_PI;
  	break;
  
  case 270:
  	orientacion_radianes = M_PI / 2.0 * 3.0;
  	break;
  
  }
  
  seno = sin(orientacion_radianes);
  coseno = cos(orientacion_radianes);
  
  if (debug_vectores) {	
  	printf("Orientacion radianes:%f seno:%f coseno:%f\n", orientacion_radianes, seno, coseno);
  }
  
    for (i=0; i<NumeroVectores; i++) {
  	
  	x = xValues[i];
  	y = yValues[i];
  	
  	xValues[i] = (int)((x * coseno) + (-y * seno));
  	yValues[i] = (int)((x * seno) + (y * coseno));
  		
  	// Si alguna coordenada se sale del campo levanta el flag correspondiente
     	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
          		
          	FueraLimites = true;
          	
    		
  	}
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
        // para empezar a marcar por el final de la matriz
  
  if ( (((Orientacion - Avance) == 0) && (!Reverso)) 
     || (((Orientacion - Avance) == 180) && (Reverso))
     || (((Orientacion - Avance) == -180) && (Reverso))
     || ((Orientacion - Avance) == -270) 
     || ((Orientacion - Avance) == 90) ) {
  
  	// primero copia la matriz
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
  	// y luego copia los valores de forma invertida
  	for (j=NumeroVectores-1; j>=0; j--) {
  	
  		//printf("j:%d NumeroVectores:%ld\n",j, NumeroVectores);
  		
  		primero_polilinea = false;
  		ultimo_polilinea = false;
  		
    		k = NumeroVectores - j - 1;
  		
  		// las coordenadas no hay que modificarlas
  		xValues[k] = xValues_tmp[j];	
  		yValues[k] = yValues_tmp[j];
  		
    		if (j==0) {
  			primero_polilinea = false;
  			ultimo_polilinea = true;
  		}
  		
  		else if (j==((int)NumeroVectores - 1)) {
  			primero_polilinea = true;
  			ultimo_polilinea = false;
  		}
  		
  		else if ( (j>0) && (j<((int)NumeroVectores-1)) ) {
  			
  			if (strstr(TipoMarcaje_tmp[j],"PU")) {
  				primero_polilinea = false;
  				ultimo_polilinea = true;
  			}
  						
  			if ((strstr(TipoMarcaje_tmp[j],"PD")) && (strstr(TipoMarcaje_tmp[j+1],"PU"))) {
  				primero_polilinea = true;
  				ultimo_polilinea = false;
  			}
  						
  		}
  				
  		if (primero_polilinea) {
  			strcpy(TipoMarcaje[k], "PU");
  		}
  		
  		else if (ultimo_polilinea) {
  			strcpy(TipoMarcaje[k], "PD");
  		}
  		
  		else {
  			strcpy(TipoMarcaje[k], TipoMarcaje_tmp[j]);
  		}
  				
  	}
  	
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Variables de estado:
  ///////////////////////////////////////////////////////////////////////////////////
  
  ActualizarPuertoSerie = false;
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Debug y Control
  ///////////////////////////////////////////////////////////////////////////////////
      
  /*if (debug_vectores) {	
  	printf("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  	for (i=0; i<NumeroVectores; i++) {	
  		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
  	}
  }
  */
  // Devuelve un valor y presenta mensajes de error:
  if (FueraLimites == true) {
  	
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Mark is out of bounds");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Stampa fuori dai limiti");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltDemasiadoGrande == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Graphic file too big");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine troppo grande");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltIncorrecto == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Bad graphic file");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine sbagliato");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else {
  	// Todo OK
  	return 0;
  }
}

int CalcularMatrizAtomos() {
    
        char caracter;				// variables de proceso
  float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
  float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
  int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
  double orientacion_radianes, seno, coseno, x, y;
    int fila, columna, offsetvectores;
  unsigned int NumeroVectoresCelda;
  int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;
  
    NumeroVectores = 0;
  AnchuraLineaTexto = 0;
  AnchuraLineaTextoMaxima = 0;
  AlturaLineaTexto = 0;
  AlturaLineaTextoMaxima = 0;
  AlturaTotalMarca = 0;
  AlturaTextoAcumulada = 0;
  FueraLimites = false;
  tempValuesLinea1 = 0;
  tempValuesLinea2 = 0;
  tempValuesLinea3 = 0;
  tempValuesLinea4 = 0;
  tempvalueslinea_inicio = 0;
  tempvalueslinea_fin = 0;
  xoffset = 0;
  yoffset = 0;
  pltDemasiadoGrande = false;
  pltIncorrecto = false;
  NumeroAtomos = -1;
  
    for (i=1; i<=NumeroLineasTexto; i++) {
                            
    	AnchuraCaracterAnterior = 0;
          
            LineaCalcular = i;
       
       	// Proceso de cada bloque
  	for (b=1; b<=NumeroBloques; b++) {
  	                  
            	BloqueCalcular = b;
          	
          	if (debug_vectores) {
            	}
          
  	        ///////////////////////////////////////////////////////////////////////////////////
    	        ///////////////////////////////////////////////////////////////////////////////////
          	switch (LineaCalcular) {
          
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
          	
          		break;
          		
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
          	
          		break;	
          	
  	        } //del switch que asigna variables de proceso
                  
            
  	       	if (debug_vectores) {
         			printf("LineaTexto:%s  AlturaLineaTexto:%f \n", LineaTexto, AlturaLineaTexto);
         		}
                          
           		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
          	
         			if (strlen(LineaTexto) > 0) {
          		
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
         				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
    	        	        	caracter = LineaTexto[j];
         		        		EncontrarParametros (caracter);
          	        		
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              	
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          		
  	        	}
          		
          		else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
          			AlturaLineaTexto = 0;
          		}
          			
  	        }
          	
    	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
          	
            		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  			}
  				
          		EncontrarParametrosPlt();
          		AnchuraLineaTexto = AnchuraCaracterAnterior;
          		
          	}
          		
            	else {
          		
          		if (strlen(LineaTexto) > 0) {
          		
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
          			EncontrarParametrosBarcode();
  	              		AnchuraLineaTexto = AnchuraCaracterAnterior; 
         			
        			}
         			
         			else {
         			
         				//AnchuraLineaTexto = AnchuraLineaTexto;
  	      			AlturaLineaTexto = 0;
         			}
         				
  	        }
          
          } // Siguiente bloque
          
            
            switch (LineaCalcular) {
          
            	
    	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
  	   
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                  }
                  else {
                  	alturalineatexto1 = AlturaLineaTexto1[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto1;
                          	
                	if (NumeroVectores > 0) {
  		       	tempValuesLinea1 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea1 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto2 = AnchuraLineaTexto;
              	
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                  }
                  else {
                  	alturalineatexto2 = AlturaLineaTexto2[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto2;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea2 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea2 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto3 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                  }
                  else {
                  	alturalineatexto3 = AlturaLineaTexto3[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto3;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea3 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea3 = -1;
          	}
          	    	            	
  	        break;
  	        
            	
    	        AnchuraLineaTexto4 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                  }
                  else {
                  	alturalineatexto4 = AlturaLineaTexto4[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto4;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea4 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea4 = -1;
          	}
          	    	            	
  	        break;
              
          }
          
          // Guarda la altura total de la marca hasta ahora
    	if (AnchuraLineaTexto) {
         		
         		if (LineaCalcular > 1) {
  			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
  		}
  	
    			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
  		}
  		
  	}
  	
    	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
          	
          	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
          
  	}
          
    	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
          
          	AlturaLineaTextoMaxima = AlturaLineaTexto;
          
          }
          
        
  // Guardamos los valores de la celda
  XMaxCelda = (int)AnchuraLineaTextoMaxima;
  YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
  //printf("XMaxCelda:%d YMaxCelda:%d\n", XMaxCelda, YMaxCelda);
  
  // Si no hay vectores y no hay un plt incorrecto no seguir    
  if ((NumeroVectores == 0) && (!pltIncorrecto)){
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
  			BoxVentanaMensaje->label("No hay datos para marcar");
  			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("There is no data to mark");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Nessun dato per stampare");
  			break;
  			
  		}
  
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  for (i=1; i<=NumeroLineasTexto; i++) {
  
    	switch (i) {
          
          case 1:
                AnchuraLineaTexto = AnchuraLineaTexto1;
              
                if (AnchuraLineaTexto > 0) {
              	
    	    	AlturaLineaTexto = alturalineatexto1;
  	    	
              }
              
              else {
             
              	AlturaLineaTexto = 0;
             
              }
                  
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
              }
              
                tempvalueslinea_inicio = 0;
              tempvalueslinea_fin = tempValuesLinea1;
                          
              break;
          
          case 2:
                AnchuraLineaTexto = AnchuraLineaTexto2;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto2;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea1 + 1;
              tempvalueslinea_fin = tempValuesLinea2;
                          
              break;
          
          case 3:
                AnchuraLineaTexto = AnchuraLineaTexto3;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto3;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea2 + 1;
              tempvalueslinea_fin = tempValuesLinea3;
                          
              break;
              
          case 4:
                AnchuraLineaTexto = AnchuraLineaTexto4;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto4;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea3 + 1;
              tempvalueslinea_fin = tempValuesLinea4;
                          
              break;
              
          }
          
          //Centrado = true;
          
  	// Calcula el offset x e y
    	if (Centrado) {
  		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
  		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
  		
  		if (Reverso) {
  		
  			xoffset = -xoffset;
  			//yoffset = -yoffset;
  			
  		}
  		
  		//printf("------ xoffset:%d yoffset:%d\n", xoffset,yoffset);
  	}
  	
  	
    	else {
  
  		switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
  		case -180:
  		case 180:
  		
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la izquierda
              		if (xOffsetPantalla < 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                   		
        			break;
         
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		case 0:
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la derecha
              		if (xOffsetPantalla > 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
              		
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
  		case -270:
  		case 90:
  			if (JustificacionIzquierda == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
              		
              		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
              		 
              		// Se pueden desplazar verticalmente hacia abajo
              		if (yOffsetPantalla < 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
  		case -90:
  		case 270:
  			if (JustificacionIzquierda == true) {				  
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
               		
               		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);
  
  			// Se pueden desplazar verticalmente hacia arriba
              		if (yOffsetPantalla > 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  
          	}
          
  	}
      	    	
      	if (debug_vectores) {	
  		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \n", Orientacion, Avance, xoffset, yoffset);
  	}
  	
    	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
  		
      		if (Reverso) {
  		
  			xValues[j] = -xValues[j] + xoffset;
  		
  		}
  		
  		else {
  		
  			xValues[j] = xValues[j] + xoffset;
  		
  		}
  		
  		// La coordenada Y no depende del efecto reverso
  		yValues[j] = yValues[j] + yoffset;
  		
  		// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          		FueraLimites = true;
          		
    
  		}
  
  	}
      
  } // Fin del bucle For, para cada linea de texto
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
    if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {
  
  	// primero copia la celda original
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
    	NumeroVectoresCelda = NumeroVectores;
  
    	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);
  
    
    	for (fila = 1; fila <= NumeroFilas; fila++) {
  
  		for (columna = 1; columna <= NumeroColumnas; columna++) {
  
  			// La primera celda no hay que repetirla
  			if ((fila == 1) && (columna == 1)) {continue;}
  		
    			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  		
  			for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
  				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
  				xValues[i+offsetvectores] = xValues[i];	
  				yValues[i+offsetvectores] = yValues[i];
  	
  			}
  
  		}
  
  	}
  
    	xMinTabla = MaximoBits;
  	xMaxTabla = -MaximoBits;
  	yMinTabla = MaximoBits;
  	yMaxTabla = -MaximoBits;
  
      	if ((Orientacion - Avance) == 0) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
  				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  			
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
  				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  	
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    
    if ((ControlTablaPrecorte) && (Precorte)) {
  
    	if ((Orientacion - Avance) == 0) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		
  	}
  	
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  	
  	}
  	
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
  		
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
  			
  		}
  	
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
  // Crea los atomos
  for (i=0; i<NumeroVectores; i++) {
  	
  	//printf("Vector:%ld Tipo:%s X:%d Y:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i]);
  	
    	if ((strstr(TipoMarcaje[i], "PU")) && (!SaltoDentroAtomo[i])) {
  	
    		NumeroAtomos++;
  		Atomos[NumeroAtomos].Inicio = i;
  		Atomos[NumeroAtomos].Longitud = 0;
  		Atomos[NumeroAtomos].Xmax = xValues[i];	
  		Atomos[NumeroAtomos].Xmin = xValues[i];	
  		Atomos[NumeroAtomos].Ymax = yValues[i];	
  		Atomos[NumeroAtomos].Ymin = yValues[i];	
  		
  	}
  	
  	else {
  	
  		// Incrementa la longitud
  		Atomos[NumeroAtomos].Longitud++;
  		
    		if (xValues[i] > Atomos[NumeroAtomos].Xmax) {Atomos[NumeroAtomos].Xmax = xValues[i];}
  		if (xValues[i] < Atomos[NumeroAtomos].Xmin) {Atomos[NumeroAtomos].Xmin = xValues[i];}
  		if (yValues[i] > Atomos[NumeroAtomos].Ymax) {Atomos[NumeroAtomos].Ymax = yValues[i];}
  		if (yValues[i] < Atomos[NumeroAtomos].Ymin) {Atomos[NumeroAtomos].Ymin = yValues[i];}
  		
  	}
  
  }
  
      if ((Orientacion - Avance) == 0) {
  
  	OrdenarAtomos(Atomos, XMAX, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Xmax para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Xmax=%d\n", i, Atomos[i].Xmax);
  		
  		if (Atomos[i].Xmax == Atomos[i+1].Xmax) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomos(Atomos, YMAX, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomos(Atomos, YMAX, i-numatomos+1, i);
  	}
  	
  }
  
      else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
  	OrdenarAtomos(Atomos, XMIN, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Xmin para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Xmin=%d\n", i, Atomos[i].Xmin);
  		
  		if (Atomos[i].Xmin == Atomos[i+1].Xmin) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomos(Atomos, YMIN, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomos(Atomos, YMIN, i-numatomos+1, i);
  	}
  	
  }
  
      else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
  	OrdenarAtomos(Atomos, YMAX, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Ymax para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Ymax=%d\n", i, Atomos[i].Ymax);
  		
  		if (Atomos[i].Ymax == Atomos[i+1].Ymax) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomos(Atomos, XMAX, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomos(Atomos, XMAX, i-numatomos+1, i);
  	}
  	
  }
  
      else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
  	OrdenarAtomos(Atomos, YMIN, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Ymin para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Ymin=%d\n", i, Atomos[i].Ymin);
  		
  		if (Atomos[i].Ymin == Atomos[i+1].Ymin) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomos(Atomos, XMIN, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomos(Atomos, XMIN, i-numatomos+1, i);
  	}
  	
  }
  
    // primero copia la matriz
  for (i=0; i<NumeroVectores; i++) {
  	
  	strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  	xValues_tmp[i] = xValues[i];	
  	yValues_tmp[i] = yValues[i];
  	
  }
  
    vector=0;
  for (i=0; i<=NumeroAtomos; i++) {
  
  	//printf("Atomo:%ld	Inicio:%d Longitud:%d\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
  	
  	for (k=0; k<=Atomos[i].Longitud; k++) {
  	
    		j = Atomos[i].Inicio + k;
  		
  		// rellena los datos
  		strcpy(TipoMarcaje[vector], TipoMarcaje_tmp[j]);
  		xValues[vector] = xValues_tmp[j];
  		yValues[vector] = yValues_tmp[j];
  		
  		//printf("Vector:%ld Tipo:%s X:%d Y:%d\n", i+k, TipoMarcaje[i+k], xValues[i+k], yValues[i+k]);
  	
  		vector++;
  		
  	}
  
  }
  
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
  switch (Orientacion) {
  
  case 0:
  	orientacion_radianes = 0;
  	break;
  
  case 90:
  	orientacion_radianes = M_PI / 2.0;
  	break;
  
  case 180:
  	orientacion_radianes = M_PI;
  	break;
  
  case 270:
  	orientacion_radianes = M_PI / 2.0 * 3.0;
  	break;
  
  }
  
  seno = sin(orientacion_radianes);
  coseno = cos(orientacion_radianes);
  
  if (debug_vectores) {	
  	printf("Orientacion radianes:%f seno:%f coseno:%f\n", orientacion_radianes, seno, coseno);
  }
  
    for (i=0; i<NumeroVectores; i++) {
  	
  	x = xValues[i];
  	y = yValues[i];
  	
  	xValues[i] = (int)((x * coseno) + (-y * seno));
  	yValues[i] = (int)((x * seno) + (y * coseno));
  		
  	// Si alguna coordenada se sale del campo levanta el flag correspondiente
     	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
          		
          	FueraLimites = true;
          	
    		
  	}
  
  }
  
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Variables de estado:
  ///////////////////////////////////////////////////////////////////////////////////
  Actualizar=false;
  ActualizarPuertoSerie=false;
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Debug y Control
  ///////////////////////////////////////////////////////////////////////////////////
      
  if (debug_vectores) {	
  	printf("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  	for (i=0; i<NumeroVectores; i++) {	
  		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
  	}
  }
  
  // Devuelve un valor y presenta mensajes de error:
  if (FueraLimites == true) {
  	
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Mark is out of bounds");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Stampa fuori dai limiti");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltDemasiadoGrande == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Graphic file too big");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine troppo grande");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltIncorrecto == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Bad graphic file");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine sbagliato");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else {
  	// Todo OK
  	return 0;
  }
}

int CalcularMatrizFueraCampo() {
    
        char caracter;				// variables de proceso
  float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
  float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
  int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
  double orientacion_radianes, seno, coseno, x, y, u;
  int factorUmbral;
    int fila, columna, offsetvectores;
  unsigned int NumeroVectoresCelda;
  int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;
  
    NumeroVectores = 0;
  AnchuraLineaTexto = 0;
  AnchuraLineaTextoMaxima = 0;
  AlturaLineaTexto = 0;
  AlturaLineaTextoMaxima = 0;
  AlturaTotalMarca = 0;
  AlturaTextoAcumulada = 0;
  FueraLimites = false;
  tempValuesLinea1 = 0;
  tempValuesLinea2 = 0;
  tempValuesLinea3 = 0;
  tempValuesLinea4 = 0;
  tempvalueslinea_inicio = 0;
  tempvalueslinea_fin = 0;
  xoffset = 0;
  yoffset = 0;
  pltDemasiadoGrande = false;
  pltIncorrecto = false;
  NumeroAtomos = -1;
  
  xValuesMax = -3276800;
  xValuesMin = 3276800;
  yValuesMax = -3276800;
  yValuesMin = 3276800;
  
  RetardoDisparo_cuentas_adicional = 0;
  
    for (i=1; i<=NumeroLineasTexto; i++) {
          
    	AnchuraCaracterAnterior = 0;
          
            LineaCalcular = i;
       
       	// Proceso de cada bloque
  	for (b=1; b<=NumeroBloques; b++) {
  	                  
            	BloqueCalcular = b;
          	
          	if (debug_vectores) {
            	}
          
  	        ///////////////////////////////////////////////////////////////////////////////////
    	        ///////////////////////////////////////////////////////////////////////////////////
          	switch (LineaCalcular) {
          
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
          	
          		break;
          		
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
          	
          		break;	
          	
  	        } //del switch que asigna variables de proceso
                  
            
         		if (debug_vectores) {
         			printf("LineaTexto: %s  AlturaLineaTexto: %f \n", LineaTexto, AlturaLineaTexto);
         		}
          	
           		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
          	
         			if (strlen(LineaTexto) > 0) {
          			
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
  	       			for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
            		        	caracter = LineaTexto[j];
         	        			EncontrarParametros (caracter);
          	        		
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              	
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          		
          		}
          		
  	        	else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
          			AlturaLineaTexto = 0;
          		}
          			
  	        }
          	
    	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
          	
            		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  			}
  				
          		EncontrarParametrosPlt();
          		AnchuraLineaTexto = AnchuraCaracterAnterior;
          		
  	        }
          		
    	        else {
          		
          		if (strlen(LineaTexto) > 0) {
          			
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
          			EncontrarParametrosBarcode();
                			AnchuraLineaTexto = AnchuraCaracterAnterior; 
         			
  	      		}
         			
         			else {
         			
         				//AnchuraLineaTexto = AnchuraLineaTexto;
        				AlturaLineaTexto = 0;
         			}
         				
  	        }
          
          } // Siguiente bloque
          
            
            switch (LineaCalcular) {
          
            	
    	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
  	   
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                  }
                  else {
                  	alturalineatexto1 = AlturaLineaTexto1[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto1;
  
                	if (NumeroVectores > 0) {
  		       	tempValuesLinea1 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea1 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto2 = AnchuraLineaTexto;
              	
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                  }
                  else {
                  	alturalineatexto2 = AlturaLineaTexto2[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto2;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea2 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea2 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto3 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                  }
                  else {
                  	alturalineatexto3 = AlturaLineaTexto3[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto3;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea3 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea3 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto4 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                  }
                  else {
                  	alturalineatexto4 = AlturaLineaTexto4[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto4;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea4 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea4 = -1;
          	}
          	    	            	
  	        break;
              
          }
          
          // Guarda la altura total de la marca hasta ahora
    	if (AnchuraLineaTexto) {
         		
         		if (LineaCalcular > 1) {
  			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
  		}
  	
    			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
  		}
  		
  	}
  	
    	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
          	
          	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
          
  	}
          
    	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
          
          	AlturaLineaTextoMaxima = AlturaLineaTexto;
          
          }
          
    
  // Guardamos los valores de la celda
  XMaxCelda = (int)AnchuraLineaTextoMaxima;
  YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
      
  // Si no hay vectores y no hay un plt incorrecto no seguir    
  if ((NumeroVectores == 0) && (!pltIncorrecto)){
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
  			BoxVentanaMensaje->label("No hay datos para marcar");
  			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("There is no data to mark");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Nessun dato per stampare");
  			break;
  			
  		}
  
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  for (i=1; i<=NumeroLineasTexto; i++) {
  
    	switch (i) {
          
          case 1:
              
                AnchuraLineaTexto = AnchuraLineaTexto1;
              
                if (AnchuraLineaTexto > 0) {
              	
    	    	AlturaLineaTexto = alturalineatexto1;
  	    	
              }
              
              else {
             
              	AlturaLineaTexto = 0;
             
              }
                  
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
              }
              
                tempvalueslinea_inicio = 0;
              tempvalueslinea_fin = tempValuesLinea1;
                          
              break;
          
          case 2:
              
                AnchuraLineaTexto = AnchuraLineaTexto2;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto2;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea1 + 1;
              tempvalueslinea_fin = tempValuesLinea2;
                          
              break;
          
          case 3:
          
                AnchuraLineaTexto = AnchuraLineaTexto3;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto3;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea2 + 1;
              tempvalueslinea_fin = tempValuesLinea3;
                          
              break;
          
          case 4:
          
                AnchuraLineaTexto = AnchuraLineaTexto4;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto4;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea3 + 1;
              tempvalueslinea_fin = tempValuesLinea4;
                          
              break;
                  
          }
          
          //Centrado = true;
          
  	// Calcula el offset x e y
    	if (Centrado) {
  		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
  		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
  		
  		if (Reverso) {
  		
  			xoffset = -xoffset;
  			//yoffset = -yoffset;
  			
  		}
  		
  		//printf("------ xoffset:%d yoffset:%d\n", xoffset,yoffset);
  	}
  	
  	
    	else {
  
  		switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
  		case -180:
  		case 180:
  		
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
              		
              		}
              		
    			if ((MarcajeDinamicoActivo == 0) || (PruebaMarcaje)) {
  			
              			if (xOffsetPantalla < 0){
              				xoffset = xoffset + xOffsetPantalla;
              			}
              		
              		}
              		
      			else if (MarcajeDinamicoActivo == 1) {
  	
  				RetardoDisparo_cuentas_adicional = (int)((double)xOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
  		
  			}
  	
    			else if (MarcajeDinamicoActivo == 2) {
  	
  				RetardoDisparo_cuentas_adicional = (int)((double)xOffsetPantalla / CalibracionCorreccion * 25.0);
  		
  			}
              		            		
              		// el offset vertical se suma siempre
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                   		
        			break;
         
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		case 0:
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
              		
              		}
              		
    			if (MarcajeDinamicoActivo == 0) {
  			
              			if (xOffsetPantalla > 0){
              				xoffset = xoffset + xOffsetPantalla;
              			}
              		
              		}
              		
      			else if (MarcajeDinamicoActivo == 1) {
  	
  				RetardoDisparo_cuentas_adicional = -(int)((double)xOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
  		
  			}
  	
    			else if (MarcajeDinamicoActivo == 2) {
  	
  				RetardoDisparo_cuentas_adicional = -(int)((double)xOffsetPantalla / CalibracionCorreccion * 25.0);
  		
  			}
              		
              		// el offset vertical se suma siempre
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
              		
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
  		case -270:
  		case 90:
  			if (JustificacionIzquierda == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
              		
              		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
              		 
    			if (MarcajeDinamicoActivo == 0) {
  			
              			// Se pueden desplazar verticalmente hacia abajo
              			if (yOffsetPantalla < 0){
              				yoffset = yoffset + yOffsetPantalla;
              			}
              		
              		}
              		
      			else if (MarcajeDinamicoActivo == 1) {
  	
  				RetardoDisparo_cuentas_adicional = (int)((double)yOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
  		
  			}
  	
    			else if (MarcajeDinamicoActivo == 2) {
  	
  				RetardoDisparo_cuentas_adicional = (int)((double)yOffsetPantalla / CalibracionCorreccion * 25.0);
  		
  			}
  			
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
  		case -90:
  		case 270:
  			if (JustificacionIzquierda == true) {				  
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
               		
               		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);
              		
    			if (MarcajeDinamicoActivo == 0) {
  			
              			// Se pueden desplazar verticalmente hacia arriba
              			if (yOffsetPantalla > 0){
              				yoffset = yoffset + yOffsetPantalla;
              			}
              		
              		}
              		
      			else if (MarcajeDinamicoActivo == 1) {
  	
  				RetardoDisparo_cuentas_adicional = -(int)((double)yOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
  		
  			}
  	
    			else if (MarcajeDinamicoActivo == 2) {
  	
  				RetardoDisparo_cuentas_adicional = -(int)((double)yOffsetPantalla / CalibracionCorreccion * 25.0);
  		
  			}
  			
  			break;
  
          	}
          
  	}
      	    	
      	if (debug_vectores) {	
  		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \n", Orientacion, Avance, xoffset, yoffset);
  	}
  	
      	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
  		
      		if (Reverso) {
  		
  			xValues[j] = -xValues[j] + xoffset;
  		
  		}
  		
  		else {
  		
  			xValues[j] = xValues[j] + xoffset;
  		
  		}
  		
  		// La coordenada Y no depende del efecto reverso
  		yValues[j] = yValues[j] + yoffset;
  		
      		
  			// Si alguna coordenada se sale del campo levanta el flag correspondiente
  	   		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          			FueraLimites = true;
          		
    
  			}
  		
  		}
  		
    		
    			if ((Orientacion - Avance) == 0) {
  	
    				if (fabs(yValues[j]) > MaximoBits) {
          		
          				FueraLimites = true;
          		
    
  				}
  		
  			}
  
    			else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  	
    				if (fabs(yValues[j]) > MaximoBits) {
          		
          				FueraLimites = true;
          		
    
  				}
  	
  			}
  
    			else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
    				if (fabs(xValues[j]) > MaximoBits) {
          		
          				FueraLimites = true;
          		
    
  				}
  				
  			}
  
    			else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
    				if (fabs(xValues[j]) > MaximoBits) {
          		
          				FueraLimites = true;
          		
    
  				}
  	
  			}
  		
  		}
  
  	}
      
  } // Fin del bucle For, para cada linea de texto
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
    if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {
  
  	// primero copia la celda original
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
    	NumeroVectoresCelda = NumeroVectores;
  
    	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);
  
    
    	for (fila = 1; fila <= NumeroFilas; fila++) {
  
  		for (columna = 1; columna <= NumeroColumnas; columna++) {
  
  			// La primera celda no hay que repetirla
  			if ((fila == 1) && (columna == 1)) {continue;}
  		
    			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  		
  			for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
  				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
  				xValues[i+offsetvectores] = xValues[i];	
  				yValues[i+offsetvectores] = yValues[i];
  	
  			}
  
  		}
  
  	}
  
    	xMinTabla = MaximoBits;
  	xMaxTabla = -MaximoBits;
  	yMinTabla = MaximoBits;
  	yMaxTabla = -MaximoBits;
  
      	if ((Orientacion - Avance) == 0) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
  				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  			
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  					
      		
  						// Si alguna coordenada se sale del campo levanta el flag correspondiente
  	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
          		
          						FueraLimites = true;
    	
  						}
  		
  					}
  		
    		
      						if (fabs(yValues[i+offsetvectores]) > MaximoBits) {
          				
          						FueraLimites = true;
    
  						}
  		
  					}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
  				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  					
      		
  						// Si alguna coordenada se sale del campo levanta el flag correspondiente
  	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
          		
          						FueraLimites = true;
    	
  						}
  		
  					}
  		
    		
      						if (fabs(yValues[i+offsetvectores]) > MaximoBits) {
          		
          						FueraLimites = true;
    
  						}
  		
  					}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  					
      		
  						// Si alguna coordenada se sale del campo levanta el flag correspondiente
  	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
          		
          						FueraLimites = true;
    		
  						}
  		
  					}
  		
    		
      						if (fabs(xValues[i+offsetvectores]) > MaximoBits) {
          		
          						FueraLimites = true;
    
  						}
  		
  					}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  	
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  					
      		
  						// Si alguna coordenada se sale del campo levanta el flag correspondiente
  	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
          		
          						FueraLimites = true;
    	
  						}
  		
  					}
  		
    		
      						if (fabs(xValues[i+offsetvectores]) > MaximoBits) {
          		
          						FueraLimites = true;
    
  						}
  		
  					}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    
    if ((ControlTablaPrecorte) && (Precorte)) {
  
    	if ((Orientacion - Avance) == 0) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		
  	}
  	
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  	
  	}
  	
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
  		
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
  			
  		}
  	
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
  }
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
    for (i=0; i<NumeroVectores; i++) {
  	
  	//printf("Vector:%ld Tipo:%s X:%d Y:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i]);
  	
    	if ((strstr(TipoMarcaje[i], "PU")) && (!SaltoDentroAtomo[i])) {
  	
    		NumeroAtomos++;
  		Atomos[NumeroAtomos].Inicio = i;
  		Atomos[NumeroAtomos].Longitud = 0;
  		Atomos[NumeroAtomos].Xmax = xValues[i];	
  		Atomos[NumeroAtomos].Xmin = xValues[i];	
  		Atomos[NumeroAtomos].Ymax = yValues[i];	
  		Atomos[NumeroAtomos].Ymin = yValues[i];	
  		
  	}
  	
  	else {
  	
  		// Incrementa la longitud
  		Atomos[NumeroAtomos].Longitud++;
  		
    		if (xValues[i] > Atomos[NumeroAtomos].Xmax) {Atomos[NumeroAtomos].Xmax = xValues[i];}
  		if (xValues[i] < Atomos[NumeroAtomos].Xmin) {Atomos[NumeroAtomos].Xmin = xValues[i];}
  		if (yValues[i] > Atomos[NumeroAtomos].Ymax) {Atomos[NumeroAtomos].Ymax = yValues[i];}
  		if (yValues[i] < Atomos[NumeroAtomos].Ymin) {Atomos[NumeroAtomos].Ymin = yValues[i];}
  		
  	}
  	
    	if (xValues[i] > xValuesMax) {xValuesMax = xValues[i];}
  	if (xValues[i] < xValuesMin) {xValuesMin = xValues[i];}
  	if (yValues[i] > yValuesMax) {yValuesMax = yValues[i];}
  	if (yValues[i] < yValuesMin) {yValuesMin = yValues[i];}
  
  }
  
  //printf("xValuesMax:%ld xValuesMin:%ld yValuesMax:%ld yValuesMin:%ld\n",xValuesMax, xValuesMin, yValuesMax, yValuesMin);
  
    if ((Orientacion - Avance) == 0) {
  	
    	OrdenarAtomosFueraCampo(Atomos, XMIN, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Xmin para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Xmin=%d\n", i, Atomos[i].Xmin);
  		
  		if (Atomos[i].Xmin == Atomos[i+1].Xmin) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
  	}
  	
    	xOffsetDinamico = -(xValuesMax + MaximoBits);
  	yOffsetDinamico = 0;
  	
  }
  
    else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  	
    	OrdenarAtomosFueraCampo(Atomos, XMAX, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Xmax para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Xmax=%d\n", i, Atomos[i].Xmax);
  		
  		if (Atomos[i].Xmax == Atomos[i+1].Xmax) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
  	}
  	
    	xOffsetDinamico = -xValuesMin + MaximoBits;
  	yOffsetDinamico = 0;
  	
  }
  
    else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
    	OrdenarAtomosFueraCampo(Atomos, YMIN, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Ymin para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Ymin=%d\n", i, Atomos[i].Ymin);
  		
  		if (Atomos[i].Ymin == Atomos[i+1].Ymin) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomosFueraCampo(Atomos, XMAX, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomosFueraCampo(Atomos, XMAX, i-numatomos+1, i);
  	}
  	
    	xOffsetDinamico = 0;
  	yOffsetDinamico = -(yValuesMax + MaximoBits);
  	
  }
  
    else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
    	OrdenarAtomosFueraCampo(Atomos, YMAX, 0, NumeroAtomos);
  	
  	// Ahora hay que ordenar los que tienen la misma Ymax para minimizar saltos
  	numatomos=1;
  	for (i=0; i<NumeroAtomos; i++) {
  	
  		//rt_printk("i=%d Atomos[i].Ymax=%d\n", i, Atomos[i].Ymax);
  		
  		if (Atomos[i].Ymax == Atomos[i+1].Ymax) {
  			numatomos++;
  		}
  		
  		else {
  			if (numatomos > 1) {
  				OrdenarAtomosFueraCampo(Atomos, XMIN, i-numatomos+1, i);
  			}
  			
  			numatomos = 1;
  		}
  	}
  	
  	if (numatomos > 1) {
  		OrdenarAtomosFueraCampo(Atomos, XMIN, i-numatomos+1, i);
  	}
  	
    	xOffsetDinamico = 0;
  	yOffsetDinamico = -yValuesMin + MaximoBits;
  	
  }
  
    // primero copia la matriz
  for (i=0; i<NumeroVectores; i++) {
  	
  	strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  	xValues_tmp[i] = xValues[i];	
  	yValues_tmp[i] = yValues[i];
  	
  }
  
    vector=0;
  for (i=0; i<=NumeroAtomos; i++) {
  
  	//rt_printk("Atomo:%ld	Inicio:%d Longitud:%d\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
  	
    	if (PruebaMarcaje) {
  	
    	   	if (  (abs(Atomos[i].Xmin) > MaximoBits) 
  	   	   || (abs(Atomos[i].Xmax) > MaximoBits) 
  	   	   || (abs(Atomos[i].Ymin) > MaximoBits)
  	   	   || (abs(Atomos[i].Ymax) > MaximoBits) ){
          		
          		//rt_printk("Atomo Saltado:%ld	Inicio:%d Longitud:%d\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
          		
          		continue;
          		
  		}
  		
  	}
  	
    
    	if ((Orientacion - Avance) == 0) {
  	
    		Atomos[i].Umbral = Atomos[i].Xmin;
  	
  	}
  
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  	
    		Atomos[i].Umbral = Atomos[i].Xmax;
  	
  	}
  
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
    		Atomos[i].Umbral = Atomos[i].Ymin;
  
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
    		Atomos[i].Umbral = Atomos[i].Ymax;
  	
  	}
  	
  	// Recompone la matriz
  	for (k=0; k<=Atomos[i].Longitud; k++) {
  		
    		j = Atomos[i].Inicio + k;
  		
  		// rellena los datos
  		strcpy(TipoMarcaje[vector], TipoMarcaje_tmp[j]);
  		xValues[vector] = xValues_tmp[j];
  		yValues[vector] = yValues_tmp[j];
    		
  		//printf("Vector:%ld Tipo:%s X:%d Y:%d\n", i+k, TipoMarcaje[i+k], xValues[i+k], yValues[i+k]);
  	
  		vector++;
  		
  	}
  	
  	//rt_printk("Atomo:%ld	Inicio:%d Longitud:%d Umbral:%d\n", i, Atomos[i].Inicio, Atomos[i].Longitud, Atomos[i].Umbral);
  
  }
  
    if (PruebaMarcaje) {
  
  	NumeroVectores = vector;
  
  }
  	
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
  switch (Orientacion) {
  
  case 0:
  	orientacion_radianes = 0;
  	break;
  
  case 90:
  	orientacion_radianes = M_PI / 2.0;
  	break;
  
  case 180:
  	orientacion_radianes = M_PI;
  	break;
  
  case 270:
  	orientacion_radianes = M_PI / 2.0 * 3.0;
  	break;
  
  }
  
  seno = sin(orientacion_radianes);
  coseno = cos(orientacion_radianes);
  
  if (debug_vectores) {	
  	printf("Orientacion radianes:%f seno:%f coseno:%f\n", orientacion_radianes, seno, coseno);
  }
  
    if ((Orientacion - Avance) == 0) {
  			
  	// ajusta el umbral en x
  	factorUmbral = ((int)coseno + (int)seno);
  			
  }
  
    else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  	
  	// ajusta el umbral en x
  	factorUmbral = ((int)coseno + (int)seno);
  			
  }
  
    else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  			
  	// ajusta el umbral en y
  	factorUmbral = ((int)coseno - (int)seno);
  										
  }
  
    else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  			
  	// ajusta el umbral en y
  	factorUmbral = ((int)coseno - (int)seno);
  			
  }
  			
    for (i=0; i<NumeroVectores; i++) {
  	
  	x = (double)xValues[i];
  	y = (double)yValues[i];
  	u = (double)uValues[i];
  	
  	xValues[i] = (int)((x * coseno) + (-y * seno));
  	yValues[i] = (int)((x * seno) + (y * coseno));
  	uValues[i] = (int)(factorUmbral * u);
  
  }
  
    x = (double)xOffsetDinamico;
  y = (double)yOffsetDinamico;
  
  xOffsetDinamico = (long)((x * coseno) + (-y * seno));
  yOffsetDinamico = (long)((x * seno) + (y * coseno));
  
  if (xOffsetDinamico) {
  	uOffsetDinamico = xOffsetDinamico;
  }
  
  else {
  	uOffsetDinamico = yOffsetDinamico;
  }
  
  //rt_printk("xOffsetDinamico:%ld yOffsetDinamico:%ld uOffsetDinamico:%ld\n", xOffsetDinamico, yOffsetDinamico, uOffsetDinamico);
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Variables de estado:
  ///////////////////////////////////////////////////////////////////////////////////
  Actualizar=false;
  ActualizarPuertoSerie=false;
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Debug y Control
  ///////////////////////////////////////////////////////////////////////////////////
      
  if (debug_vectores) {	
  	rt_printk("# CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  	for (i=0; i<NumeroVectores; i++) {	
  		rt_printk(" Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
  	}
  }
  
  // Devuelve un valor y presenta mensajes de error:
  if (FueraLimites == true) {
  	
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Mark is out of bounds");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Stampa fuori dai limiti");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltDemasiadoGrande == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Graphic file too big");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine troppo grande");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltIncorrecto == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Bad graphic file");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine sbagliato");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else {
  	// Todo OK
  	return 0;
  }
}

int CalcularMatrizComponer() {
    
        //int c;					// variable para indexar los vectores que se calculan
  char caracter;				// variables de proceso
  float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
  float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
  int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
  int xoffsetbloque, yoffsetbloque, tempValuesBloque;
  double AnguloInicialTextoCircular;
  double AnguloFinalTextoCircular;
  double ModuloVectorPolar;
  int AnchuraInicialBloque;
  double orientacion_radianes, seno, coseno, x, y;
    int fila, columna, offsetvectores;
  unsigned int NumeroVectoresCelda;
  int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;
  
  // Inicializacion
  NumeroVectores = 0;
  AnchuraLineaTexto = 0;
  AnchuraLineaTextoMaxima = 0;
  AlturaLineaTexto = 0;
  AlturaLineaTextoMaxima = 0;
  AlturaTotalMarca = 0;
  AlturaTextoAcumulada = 0;
  FueraLimites = false;
  tempValuesLinea1 = 0;
  tempValuesLinea2 = 0;
  tempValuesLinea3 = 0;
  tempValuesLinea4 = 0;
  tempvalueslinea_inicio = 0;
  tempvalueslinea_fin = 0;
  xoffset = 0;
  yoffset = 0;
  xoffsetbloque=0;
  yoffsetbloque=0;
  tempValuesBloque=0;
  pltDemasiadoGrande = false;
  pltIncorrecto = false;
  
    for (i=1; i<=NumeroLineasTexto; i++) {
  	           
  	// Inicializacion
  	AnchuraCaracterAnterior = 0;
          
            LineaCalcular = i;
       
       	// Proceso de cada bloque
  	for (b=1; b<=NumeroBloques; b++) {
  	                  
            	BloqueCalcular = b;
          	
          	if (debug_vectores) {
            	}
          	
  	        ///////////////////////////////////////////////////////////////////////////////////
    	        ///////////////////////////////////////////////////////////////////////////////////
          	switch (LineaCalcular) {
          
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
          	
          		break;
          	
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
          	
          		break;	
          		
            	
          		// Asigna las variables de proceso
          		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
  	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
          	
          		break;	
          	
  	        } //del switch que asigna variables de proceso
                  
            
  	       	if (debug_vectores) {
         			printf("LineaTexto:%s  AlturaLineaTexto:%f \n", LineaTexto, AlturaLineaTexto);
         		}
          	
           		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
          	
         			if (strlen(LineaTexto) > 0) {
          			//Guardamos el vector inicial
          			tempValuesBloque=NumeroVectores;
          			AnchuraInicialBloque=AnchuraCaracterAnterior;
  
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  			
         				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
    	        	        	caracter = LineaTexto[j];
         		        		EncontrarParametros (caracter);
          	        		
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              	
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          		
              			
          			xoffsetbloque= int(MinXTexto [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			//El offset en el eje Y es el radio + el offset de la posicion del centro
          			
          			yoffsetbloque= int(MinYTexto[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			//Ahora recalculamos la matrix con estos offsets
          	
          			for (j = tempValuesBloque; j <= NumeroVectores; j++) {
  
  				xValues[j] = xValues[j] + xoffsetbloque;
  		
  				yValues[j] = yValues[j] + yoffsetbloque;
  				
  				}
  				// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          			FueraLimites = true;
          		
    		
          			}
  
          		}
          		
          		else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
  	        		AlturaLineaTexto = 0;
          		}
          		
  	        }
          	
    	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
          	
          			//Guardamos el vector inicial
          			tempValuesBloque=NumeroVectores;
          			AnchuraInicialBloque=AnchuraCaracterAnterior;
  
          		
            		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  			}
  			
          		EncontrarParametrosPlt();
          		AnchuraLineaTexto = AnchuraCaracterAnterior;
          		
              			
          		xoffsetbloque= int(MinXGrafico [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          		//El offset en el eje Y es el radio + el offset de la posicion del centro
          			
          		yoffsetbloque= int(MinYGrafico[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
  			//Ahora recalculamos la matrix con estos offsets
          	
          		for (j=tempValuesBloque; j<=NumeroVectores; j++) {
  			xValues[j] = xValues[j] + xoffsetbloque;
  		
  			yValues[j] = yValues[j] + yoffsetbloque;
  				
  			}
  			// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     			if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          		FueraLimites = true;
          		
    		
          		}
  
  
  	        }
          	
           		else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {
          	
         			if (strlen(LineaTexto) > 0) {
          		
          			//Guardamos el vector inicial
          			tempValuesBloque=NumeroVectores;
          			AnchuraInicialBloque=AnchuraCaracterAnterior;
          			
          			
          			//Esto ya no tiene sentido
          			/*
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				*/
  			
         				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
          	        
    	        	        	caracter = LineaTexto[j];
         		        		EncontrarParametros (caracter);
          	        			
         	        			//printf("j:%d total:%d\n", j, strlen(LineaTexto));
          	        
            			}
              			
              			//Esto ya no tiene sentido AnchuraCaracterAnterior es la anchura del bloque de texto
              			/*
    		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
          			*/
          			AnchuraLineaTexto = (AnchuraCaracterAnterior-AnchuraInicialBloque);
          			
            			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
          			
              			
          			xoffsetbloque= int(CentroXTextoCircular [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			//El offset en el eje Y es el radio + el offset de la posicion del centro
          			
          			yoffsetbloque= int(CentroYTextoCircular[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			//Angulo Inicial Texto Circular para que quede centrado en radianes
          			AnguloInicialTextoCircular = (AnchuraLineaTexto/2/(RadioTextoCircular[LineaCalcular-1][BloqueCalcular-1]*CalibracionCorreccion));
          			
          			//Ahora recalculamos la matrix con estos offsets
          	
          			for (j=tempValuesBloque; j<=NumeroVectores; j++) {
  
  				AnguloFinalTextoCircular = ((3.14159/2)-(xValues[j]/RadioTextoCircular [LineaCalcular-1][BloqueCalcular-1]/CalibracionCorreccion)+AnguloInicialTextoCircular+(AnguloTextoCircular[LineaCalcular-1][BloqueCalcular-1]*2*3.14159/(360)));
  				ModuloVectorPolar= RadioTextoCircular [LineaCalcular-1][BloqueCalcular-1]*CalibracionCorreccion+ double(yValues[j]);
  
  				xValues[j] = int(ModuloVectorPolar)*cos(AnguloFinalTextoCircular);
  				yValues[j] = int(ModuloVectorPolar)*sin(AnguloFinalTextoCircular);				
  
  		
  				xValues[j] = xValues[j] + xoffsetbloque;
  		
  				yValues[j] = yValues[j] + yoffsetbloque;
  				
  				}
  				// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          			FueraLimites = true;
          		
    		
          			}
          		}
          		
          		else {
          		
          			//AnchuraLineaTexto = AnchuraLineaTexto;
  	        		AlturaLineaTexto = 0;
          		}
          		
  	        }
  
          		
    	        else {
          		
          		if (strlen(LineaTexto) > 0) {
          		
          			//Guardamos el vector inicial
          			tempValuesBloque=NumeroVectores;
          			AnchuraInicialBloque=AnchuraCaracterAnterior;
  
            			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
  	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
  				}
  				
          			EncontrarParametrosBarcode();
                			AnchuraLineaTexto = AnchuraCaracterAnterior; 
                			
              			
          			xoffsetbloque= int(MinXBarcode [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			//El offset en el eje Y es el radio + el offset de la posicion del centro
          			
          			yoffsetbloque= int(MinYBarcode[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
          			
          			
          			//Ahora recalculamos la matrix con estos offsets
          	
          			for (j=tempValuesBloque; j<=NumeroVectores; j++) {
  
  					
  				xValues[j] = xValues[j] + xoffsetbloque;
  		
  				yValues[j] = yValues[j] + yoffsetbloque;
  				
  				}
  				// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          			FueraLimites = true;
          		
    		
          			}
  
         			
  	      		}
         			
         			else {
         			
         				//AnchuraLineaTexto = AnchuraLineaTexto;
        				AlturaLineaTexto = 0;
         			}
         				
          	}
         
  	       	
          
          } // Siguiente bloque
          
          
  /*        
            
            switch (LineaCalcular) {
          
            	
    	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
  	   
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                  }
                  else {
                  	alturalineatexto1 = AlturaLineaTexto1[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto1;
  
                	if (NumeroVectores > 0) {
  		       	tempValuesLinea1 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea1 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto2 = AnchuraLineaTexto;
              	
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                  }
                  else {
                  	alturalineatexto2 = AlturaLineaTexto2[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto2;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea2 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea2 = -1;
          	}
          	    	            	
  	        break;
          
            	
    	        AnchuraLineaTexto3 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                  }
                  else {
                  	alturalineatexto3 = AlturaLineaTexto3[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto3;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea3 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea3 = -1;
          	}
          	    	            	
  	        break;
  	        
            	
    	        AnchuraLineaTexto4 = AnchuraLineaTexto;
          
    	        if (NumeroBloques > 1) {
  	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                  }
                  else {
                  	alturalineatexto4 = AlturaLineaTexto4[0];
                  }
                  
                  AlturaLineaTexto = alturalineatexto4;
  
    	        if (NumeroVectores > 0) {
  		        tempValuesLinea4 = NumeroVectores -1;
          	}
  	        else {
          		tempValuesLinea4 = -1;
          	}
          	    	            	
  	        break;
              
          }
          
          // Guarda la altura total de la marca hasta ahora
    	if (AnchuraLineaTexto) {
         		
         		if (LineaCalcular > 1) {
  			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
  		}
  	
    			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
  		}
  		
  	}
  	
    	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
          	
          	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
          
  	}
          
    	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
          
          	AlturaLineaTextoMaxima = AlturaLineaTexto;
          
          }
  */        
    
  
  /*
  // Guardamos los valores de la celda
  XMaxCelda = (int)AnchuraLineaTextoMaxima;
  YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
  //printf("XMaxCelda:%d YMaxCelda:%d\n", XMaxCelda, YMaxCelda);
  
  */
  
  
  
  
  
    
  // Si no hay vectores y no es un plt incorrecto devuelve un valor y presenta mensajes de error:
  if ((NumeroVectores == 0) && (!pltIncorrecto)){
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
  			BoxVentanaMensaje->label("No hay datos para marcar");
  			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("There is no data to mark");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Nessun dato per stampare");
  			break;
  			
  		}
  
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  
  //Cancelamos este calculo de offsets
  /*
  
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  for (i=1; i<=NumeroLineasTexto; i++) {
  
    	switch (i) {
          
          case 1:
              
                AnchuraLineaTexto = AnchuraLineaTexto1;
              
                if (AnchuraLineaTexto > 0) {
              	
    	    	AlturaLineaTexto = alturalineatexto1;
  	    	
              }
              
              else {
             
              	AlturaLineaTexto = 0;
             
              }
                  
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
              }
              
                tempvalueslinea_inicio = 0;
              tempvalueslinea_fin = tempValuesLinea1;
                          
              break;
          
          case 2:
              
                AnchuraLineaTexto = AnchuraLineaTexto2;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto2;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea1 + 1;
              tempvalueslinea_fin = tempValuesLinea2;
                          
              break;
          
          case 3:
              
                AnchuraLineaTexto = AnchuraLineaTexto3;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto3;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea2 + 1;
              tempvalueslinea_fin = tempValuesLinea3;
                          
              break;
          
          case 4:
              
                AnchuraLineaTexto = AnchuraLineaTexto4;
              
                if (AnchuraLineaTexto > 0) {
  	    	
    	    	AlturaLineaTexto = alturalineatexto4;
  	    	
              }
             
              else {
             
              	AlturaLineaTexto = 0;
             
              }
              
              // Altura acumulada del texto
              if (AlturaLineaTexto > 0) {
              	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
              }
              
                tempvalueslinea_inicio = tempValuesLinea3 + 1;
              tempvalueslinea_fin = tempValuesLinea4;
                          
              break;
                  
          }
          
            
          //Centrado = true;
          
  	// Calcula el offset x e y
    	if (Centrado) {
  		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
  		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
  		
  		if (Reverso) {
  		
  			xoffset = -xoffset;
  			//yoffset = -yoffset;
  			
  		}
  		
  		//printf("------ xoffset:%d yoffset:%d\n", xoffset,yoffset);
  	}
  	
  	
    	else {
  
  		switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
  		case -180:
  		case 180:
  		
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la izquierda
              		if (xOffsetPantalla < 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                   		
        			break;
         
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		case 0:
  			// Con reverso:
  			if (Reverso) {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
  				}
  			
  				xoffset = -xoffset;
  				
  			}
  			
  			// Sin reverso:
  			else {
  			
  				if (JustificacionIzquierda == true) {
  					xoffset = (int)-MaximoBits;
  				}
  				else if (JustificacionDerecha == true) {
  					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
  				}
  				else if (JustificacionCentro == true) {
  					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
              			}
              		
              		}
              		
              		// Se pueden desplazar horizontalmente a la derecha
              		if (xOffsetPantalla > 0){
              			xoffset = xoffset + xOffsetPantalla;
              		}
              		
  			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
              		
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
  		case -270:
  		case 90:
  			if (JustificacionIzquierda == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
              		
              		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
              		 
              		// Se pueden desplazar verticalmente hacia abajo
              		if (yOffsetPantalla < 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
  		case -90:
  		case 270:
  			if (JustificacionIzquierda == true) {				  
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
  			}
  			else if (JustificacionDerecha == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
  			}
  			else if (JustificacionCentro == true) {
  				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
  			}
               		
               		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
              		if (Reverso) {xoffset = -xoffset;}
              		
  			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);
  
  			// Se pueden desplazar verticalmente hacia arriba
              		if (yOffsetPantalla > 0){
              			yoffset = yoffset + yOffsetPantalla;
              		}
              		
  			break;
  
          	}
          
  	}
      	    	
      	if (debug_vectores) {	
  		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \n", Orientacion, Avance, xoffset, yoffset);
  	}
  	
    	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
  		
      		if (Reverso) {
  		
  			xValues[j] = -xValues[j] + xoffset;
  		
  		}
  		
  		else {
  		
  			xValues[j] = xValues[j] + xoffset;
  		
  		}
  		
  		// La coordenada Y no depende del efecto reverso
  		yValues[j] = yValues[j] + yoffset;
  		
  		// Si alguna coordenada se sale del campo levanta el flag correspondiente
     		
     		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
          		
          		FueraLimites = true;
          		
    
  		}
  
  	}
      
  } // Fin del bucle For, para cada linea de texto
  
  */
  
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
    if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {
  
  	// primero copia la celda original
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
    	NumeroVectoresCelda = NumeroVectores;
  
    	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);
  
    
    	for (fila = 1; fila <= NumeroFilas; fila++) {
  
  		for (columna = 1; columna <= NumeroColumnas; columna++) {
  
  			// La primera celda no hay que repetirla
  			if ((fila == 1) && (columna == 1)) {continue;}
  		
    			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  		
  			for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
  				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
  				xValues[i+offsetvectores] = xValues[i];	
  				yValues[i+offsetvectores] = yValues[i];
  	
  			}
  
  		}
  
  	}
  
    	xMinTabla = MaximoBits;
  	xMaxTabla = -MaximoBits;
  	yMinTabla = MaximoBits;
  	yMaxTabla = -MaximoBits;
  
      	if ((Orientacion - Avance) == 0) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
  				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  			
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
  				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
  				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
  		for (fila = 1; fila <= NumeroFilas; fila++) {
  	
  			for (columna = 1; columna <= NumeroColumnas; columna++) {
  		
    				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
  			
  				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
  				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
  				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha
  
  				for (i = 0; i < NumeroVectoresCelda; i++) {
  	
  					// Copia las coordenadas x e y de la primera celda
  					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
  					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
  				
    					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
  					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
  					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
  				
  				}
  
  			}
  
  		}
  	
  	}
  
    
    if ((ControlTablaPrecorte) && (Precorte)) {
  
    	if ((Orientacion - Avance) == 0) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		
  	}
  	
    	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  	
  			// en la coordenada x
  			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
  				
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = 0;	
  		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
  		NumeroVectores++;
  	
  	}
  	
    	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
  		
  		}
  		
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
    	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
  
      		for (i = 0; i < NumeroVectores; i++) {
  
  			// en la coordenada y
  			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
  			
  		}
  	
    		strcpy(TipoMarcaje[NumeroVectores], "PU");
  		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
  		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
  		yValues[NumeroVectores] = 0;
  		NumeroVectores++;
  	
  	}
  
  }
  
  
  ////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
  switch (Orientacion) {
  
  case 0:
  	orientacion_radianes = 0;
  	break;
  
  case 90:
  	orientacion_radianes = M_PI / 2.0;
  	break;
  
  case 180:
  	orientacion_radianes = M_PI;
  	break;
  
  case 270:
  	orientacion_radianes = M_PI / 2.0 * 3.0;
  	break;
  
  }
  
  seno = sin(orientacion_radianes);
  coseno = cos(orientacion_radianes);
  
  if (debug_vectores) {	
  	printf("Orientacion radianes:%f seno:%f coseno:%f\n", orientacion_radianes, seno, coseno);
  }
  
    for (i=0; i<NumeroVectores; i++) {
  	
  	x = xValues[i];
  	y = yValues[i];
  	
  	xValues[i] = (int)((x * coseno) + (-y * seno));
  	yValues[i] = (int)((x * seno) + (y * coseno));
  		
  	// Si alguna coordenada se sale del campo levanta el flag correspondiente
     	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
          		
          	FueraLimites = true;
          	
    		
  	}
  
  }
  
  //Cancelamos la ordenacion
  /*
  
  ///////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////
  
        // para empezar a marcar por el final de la matriz
  
  if ( (((Orientacion - Avance) == 0) && (!Reverso)) 
     || (((Orientacion - Avance) == 180) && (Reverso))
     || (((Orientacion - Avance) == -180) && (Reverso))
     || ((Orientacion - Avance) == -270) 
     || ((Orientacion - Avance) == 90) ) {
  
  	// primero copia la matriz
  	for (i=0; i<NumeroVectores; i++) {
  	
  		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
  		xValues_tmp[i] = xValues[i];	
  		yValues_tmp[i] = yValues[i];
  	
  	}
  	
  	// y luego copia los valores de forma invertida
  	for (j=NumeroVectores-1; j>=0; j--) {
  	
  		//printf("j:%d NumeroVectores:%ld\n",j, NumeroVectores);
  		
  		primero_polilinea = false;
  		ultimo_polilinea = false;
  		
    		k = NumeroVectores - j - 1;
  		
  		// las coordenadas no hay que modificarlas
  		xValues[k] = xValues_tmp[j];	
  		yValues[k] = yValues_tmp[j];
  		
    		if (j==0) {
  			primero_polilinea = false;
  			ultimo_polilinea = true;
  		}
  		
  		else if (j==((int)NumeroVectores - 1)) {
  			primero_polilinea = true;
  			ultimo_polilinea = false;
  		}
  		
  		else if ( (j>0) && (j<((int)NumeroVectores-1)) ) {
  			
  			if (strstr(TipoMarcaje_tmp[j],"PU")) {
  				primero_polilinea = false;
  				ultimo_polilinea = true;
  			}
  						
  			if ((strstr(TipoMarcaje_tmp[j],"PD")) && (strstr(TipoMarcaje_tmp[j+1],"PU"))) {
  				primero_polilinea = true;
  				ultimo_polilinea = false;
  			}
  						
  		}
  				
  		if (primero_polilinea) {
  			strcpy(TipoMarcaje[k], "PU");
  		}
  		
  		else if (ultimo_polilinea) {
  			strcpy(TipoMarcaje[k], "PD");
  		}
  		
  		else {
  			strcpy(TipoMarcaje[k], TipoMarcaje_tmp[j]);
  		}
  				
  	}
  	
  }
  
  */
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Variables de estado:
  ///////////////////////////////////////////////////////////////////////////////////
  
  ActualizarPuertoSerie = false;
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Debug y Control
  ///////////////////////////////////////////////////////////////////////////////////
      
  /*if (debug_vectores) {	
  	printf("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  	for (i=0; i<NumeroVectores; i++) {	
  		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
  	}
  }
  */
  // Devuelve un valor y presenta mensajes de error:
  if (FueraLimites == true) {
  	
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Mark is out of bounds");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("Stampa fuori dai limiti");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltDemasiadoGrande == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Graphic file too big");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine troppo grande");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else if (pltIncorrecto == true) {
  
    	if (ModoImpresionSerie == false) {
  	
  		// Asigna el mensaje
  		switch (Idioma) {
  			
  			case ESP:
    			break; 
  			
  			case ING:
  			BoxVentanaMensaje->label("Bad graphic file");
  			break; 
  			
  			case ITA:
  			BoxVentanaMensaje->label("File di immagine sbagliato");
  			break;
  			
  		}
  	
    		VentanaPrincipal->deactivate();
  	
  		// Presenta la ventana con el mensaje emergente
  		VentanaMensaje->show();
  	
  	}
  	
  	return -1;
  
  }
  
  else {
  	// Todo OK
  	return 0;
  }
}

void OrdenarAtomos(tipo_atomo atomos[], int tipo, int inicio, int fin) {
      
  tipo_atomo pivote, tmp;
  
  int l,r,p;
  
  if (debug_vectores) {
  	rt_printk("atomos:%ld tipo:%d inicio:%d fin:%d\n", NumeroAtomos, tipo, inicio, fin);
  }
          	
  while (inicio < fin) {
  
  	l=inicio;
  	p=(inicio+fin)/2;
  	r=fin;
  	
  	pivote = atomos[p];
  	
  	while (1) {
  	
  		switch (tipo) {
  		
  			case XMAX:
  			while ( (l<=r) && (atomos[l].Xmax >= pivote.Xmax) ) l++;
  			while ( (l<=r) && (atomos[r].Xmax < pivote.Xmax) ) r--;
  			break;
  			
  			case XMIN:
  			while ( (l<=r) && (atomos[l].Xmin <= pivote.Xmin) ) l++;
  			while ( (l<=r) && (atomos[r].Xmin > pivote.Xmin) ) r--;
  			break;
  			
  			case YMAX:
  			while ( (l<=r) && (atomos[l].Ymax >= pivote.Ymax) ) l++;
  			while ( (l<=r) && (atomos[r].Ymax < pivote.Ymax) ) r--;
  			break;
  			
  			case YMIN:
  			while ( (l<=r) && (atomos[l].Ymin <= pivote.Ymin) ) l++;
  			while ( (l<=r) && (atomos[r].Ymin > pivote.Ymin) ) r--;
  			break;
  			
  		}
  		
  		if (l>r) break;
  		
  		tmp = atomos[l];
  		atomos[l] = atomos[r];
  		atomos[r] = tmp;
  	
  		if (p==r) p=l;
  			
  		l++; 
  		r--;
  	
  	}
  
  	atomos[p] = atomos[r];
  	atomos[r] = pivote;
  	r--;
  	
    	if ((r-inicio) < (fin-l)) {
  	
  		OrdenarAtomos(atomos, tipo, inicio, r);
  		inicio = l;
  	
  	}
  	
  	else {
  	
  		OrdenarAtomos(atomos, tipo, l, fin);
  		fin = r;
  	
  	}
  	
  }
}

void OrdenarAtomosFueraCampo(tipo_atomo atomos[], int tipo, int inicio, int fin) {
      
  tipo_atomo pivote, tmp;
  
  int l,r,p;
  
  if (debug_vectores) {
  	rt_printk("atomos:%ld tipo:%d inicio:%d fin:%d\n", NumeroAtomos, tipo, inicio, fin);
  }
   
  while (inicio < fin) {
  
  	l=inicio;
  	p=(inicio+fin)/2;
  	r=fin;
  	
  	pivote = atomos[p];
  	
  	while (1) {
  	
  		switch (tipo) {
  		
  			case XMAX: // crecientes
  			while ( (l<=r) && (atomos[l].Xmax <= pivote.Xmax) ) l++;
  			while ( (l<=r) && (atomos[r].Xmax > pivote.Xmax) ) r--;
  			break;
  			
  			case XMIN: // decrecientes
  			while ( (l<=r) && (atomos[l].Xmin >= pivote.Xmin) ) l++;
  			while ( (l<=r) && (atomos[r].Xmin < pivote.Xmin) ) r--;
  			break;
  			
  			case YMAX: // crecientes
  			while ( (l<=r) && (atomos[l].Ymax <= pivote.Ymax) ) l++;
  			while ( (l<=r) && (atomos[r].Ymax > pivote.Ymax) ) r--;
  			break;
  			
  			case YMIN: // decrecientes
  			while ( (l<=r) && (atomos[l].Ymin >= pivote.Ymin) ) l++;
  			while ( (l<=r) && (atomos[r].Ymin < pivote.Ymin) ) r--;
  			break;
  			
  		}
  		
  		if (l>r) break;
  		
  		tmp = atomos[l];
  		atomos[l] = atomos[r];
  		atomos[r] = tmp;
  	
  		if (p==r) p=l;
  			
  		l++; 
  		r--;
  	
  	}
  
  	atomos[p] = atomos[r];
  	atomos[r] = pivote;
  	r--;
  	
    	if ((r-inicio) < (fin-l)) {
  	
  		OrdenarAtomosFueraCampo(atomos, tipo, inicio, r);
  		inicio = l;
  	
  	}
  	
  	else {
  	
  		OrdenarAtomosFueraCampo(atomos, tipo, l, fin);
  		fin = r;
  	
  	}
  	
  }
}

int EncontrarParametros(char caracter) {
  int x, y, linea, tempxmax, lineainicial;
  float factorajuste, alturalineatexto;
  bool caracterencontrado;
  char lineavector[50], *xchar, *ychar, lineacaracter[11]="CARACTER  ";
  
  if (debug_vectores) {
  	printf("EncontrarParametros Caracter:%c LineaCalcular:%d BloqueCalcular:%d\n", caracter, LineaCalcular, BloqueCalcular);
  }
  
    caracterencontrado = false;
  linea = 0;
  tempxmax = 0;
  lineacaracter[9] = caracter;
  lineainicial = 999999;
  
    switch (LineaCalcular) {
  
  	case 1:
  	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
  	break;
  
  	case 2:
  	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
  	break;
      
  	case 3:
      	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
  	break;
  	
  	case 4:
      	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
  	break;
     
  }
  
  // Calcula el factor de ajuste
  factorajuste = alturalineatexto * CalibracionCorreccion / yMaxFont;
  
  //printf("Altura Linea:%f factorajuste:%f\n", alturalineatexto,factorajuste);
  
    while ( !(caracterencontrado) && strlen(ArchivoFuentes[linea]) ){
  	
  	if ( strstr(ArchivoFuentes[linea], lineacaracter) ) {
  		caracterencontrado = true;
    	}
  	
  	linea++;
  }
  
    //if (!caracterencontrado) { 
  //	return -1;
  //}
  
    while (!strstr(ArchivoFuentes[linea],"CARACTER") && caracterencontrado && (linea < NumeroLineasArchivoFuentes)) {
  	
    	if ( (strstr(ArchivoFuentes[linea], "PU") == ArchivoFuentes[linea]) || (strstr(ArchivoFuentes[linea], "PD") == ArchivoFuentes[linea]) ) {
  	
    		if (Estrategia > 0) {
  		
  			if ((strstr(ArchivoFuentes[linea], "PU")) && (linea > lineainicial)){
  		
  				SaltoDentroAtomo[NumeroVectores] = 1;
  			}
  		
  			else {
  		
  				SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			}
  		
  			//rt_printk("linea:%d SaltoDentroAtomo[linea]:%d\n", linea, SaltoDentroAtomo[NumeroVectores]);
  			
  		}
  		
    		//lineavector = strdup (ArchivoFuentes[linea]); 
  		strcpy(lineavector, ArchivoFuentes[linea]);
  		
  		//printf("--- lineavector: %s\n", lineavector);
  		
    		strncpy (TipoMarcaje[NumeroVectores], lineavector, 2);
  		
  		//printf("--- TipoMarcaje[NumeroVectores]: %s\n", TipoMarcaje[NumeroVectores]);
  		
    		xchar = strtok (lineavector, "PUD ;");
  	
    	     	ychar = strtok (NULL, "PUD ;");
  		
  		//printf("--- xchar: %s   ychar: %s\n", xchar, ychar);
  		
  		// Coordenada X:
  		x = atoi(xchar);
  		xValues[NumeroVectores] = (int)(x * factorajuste * (Anchura / 100.0) + AnchuraCaracterAnterior);
      
  		if (x > tempxmax) {
          		tempxmax = x;
      		}
  		
  		// Coordenada Y:
  		y = atoi(ychar);
  		yValues[NumeroVectores] = (int)(y * factorajuste);
      		
      		//printf("--- x:%d   y:%d  tempxmax:%d \n", x, y, tempxmax);
      		
    		NumeroVectores++;
  		
    		if (NumeroVectores > NumeroMaximoVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  		
  	}
  	
  	//printf("linea:%d\n", linea);
  	
    	linea++;
  	
  }
          
  // Actualiza la anchura del caracter anterior
  AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + tempxmax * factorajuste * Anchura / 100.0);
  
    AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * xMaxFont));
  
    if (isspace(caracter)) {	
  	
  	AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + (Espaciado / 300.0) * factorajuste * xMaxFont);
  }
  
  if (debug_vectores) {
  	printf("--- AnchuraCaracterAnterior:%d Anchura:%d Espaciado:%d tempxmax:%d xMaxFont:%d\n", AnchuraCaracterAnterior, Anchura, Espaciado, tempxmax, xMaxFont);
  }
  
  return 0;
}

int LeerArchivoFuentes() {
  // Lee el archivo de fuentes la matriz ArchivoFuentes y asigna las variables globales xMaxFont e yMaxFont
  
    char record[50], *dato, nombrearchivo[50];	// array to hold each "record"
  FILE *fin;                      		// pointer to input file
  
    linea = 0;
  //for (i=0; i<3000; i++) {ArchivoFuentes[i][0]=0x00;}
  
  // nombre del archivo: 
  switch (ValorFuente) {
  
  	case 0:
  	strcpy(nombrearchivo, "arial.font");
  	break;
  	
  	case 1:
  	strcpy(nombrearchivo, "book_antigua.font");
  	break;
  	
  	case 2:
  	strcpy(nombrearchivo, "courier.font");
  	break;
  	
  	case 3:
  	strcpy(nombrearchivo, "palatino.font");
  	break;
  	
  	case 4:
  	strcpy(nombrearchivo, "rapida.font");
  	break;
  	
  	case 5:
  	strcpy(nombrearchivo, "rapida_doble.font");
  	break;
  	
  	case 6:
  	strcpy(nombrearchivo, "rapida_pet.font");
  	break;
  	
  	case 7:
  	strcpy(nombrearchivo, "sencilla.font");
  	break;
  	
  	case 8:
  	strcpy(nombrearchivo, "times_new_roman.font");
  	break;
  	
  	case 9:
  	strcpy(nombrearchivo, "india.font");
  	break;
  	
  }
  
  //printf("Leer archivo fuentes: %s\n", nombrearchivo);
  
  // Abre el archivo
  fin = fopen(nombrearchivo, "r");	
  
  if (fin == NULL) {
  	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  	rt_printk("Error al abrir el fichero de fuentes\n");
    	system("cp /rootFLS/itaca/*.font .");
    	
  	// sale del programa	
  	ExitOrdenadamente();
  	
  }
  
  while (!feof(fin)) {	// mientras no se haya llegado al final del archivo de fuentes
  
      
    	if (strlen(dato)>0) {
  		
  		strcpy(ArchivoFuentes[linea], dato);	
  		//printf("linea:%d - %s\n", linea, ArchivoFuentes[linea]);
  		
  		linea++;
  	
  	}
  
  }
  
    NumeroLineasArchivoFuentes = linea;
  
    xMaxFont = atoi(ArchivoFuentes[linea-2]);
      
    yMaxFont = atoi(ArchivoFuentes[linea-1]);
  
  //printf("xMaxFont:%d yMaxFont:%d\n",xMaxFont, yMaxFont);
  
  // cierra el archivo
  fclose(fin);	
  
  return 0;
}

int EncontrarParametrosBarcode() {
  int error, tempxmax;		
  float alturalineatexto;
  int incrementoX, incrementoY;
      unsigned int i, numerovectoreslaterales;
  bool vectoreslaterales;
  int spot, spots, spotbitsmodificado, tempymin, vectorinicial;		// para datamatrix
  
  if (debug_vectores) {
  	printf("EncontrarParametrosBarcode: LineaCalcular:%d BloqueCalcular:%d\n", LineaCalcular, BloqueCalcular);
  }
  
    tempxmax = 0;
  numerovectoreslaterales = 0;
  vectoreslaterales = false;
  
    switch (LineaCalcular) {
  
  	case 1:
  	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
  	break;
  
  	case 2:
  	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
  	break;
      
  	case 3:
      	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
  	break;
  	
  	case 4:
      	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
  	break;
     
  }
  
    if ((InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) && (numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] != 71)) {
  
  	vectoreslaterales = true;
  	numerovectoreslaterales = 5;
  	
  }
  
  // Calcula el factor de ajuste
  //factorajuste = alturalineatexto * CalibracionCorreccion / alturalineatexto;
  	
    error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);
  
  // Chequea posibles errores
  if(error != 0) {
               
          /* some error occurred */
          rt_printk("%s\n", BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->errtxt);
          
  }
          
  if(error > WARN_INVALID_OPTION) {
                  
          /* stop now */
          //ZBarcode_Delete(my_symbol);
          return 1;
          
  }
  
        
  if (debug_barcode) {
  	printf("numfilas:%d   numcolumnas:%d	SpotBits:%d\n", numfilas, numcolumnas, SpotBits);		
  }
  
  // procesa los datos del bitmap para generar los vectores
    
    switch(numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]) {
  
  	// Datamatrix: hay que recorrer filas y columnas, sin vectores laterales
  	// El incremento en Y es negativo, porque el origen del png es arriba a la izquierda
  	case 71:
  	incrementoX = (int)(alturalineatexto * CalibracionCorreccion / numcolumnas); 	//bits
  	incrementoY = (int)(-alturalineatexto * CalibracionCorreccion / numfilas);	//bits
  	
  	// hay que calcular cuantos spots caben en un incrementoX
  	spotbitsmodificado = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
  	spots = (int)((double)incrementoX / (double)spotbitsmodificado);
  	
    	if (spots == 0) { spots = 1;}
  	
  	if (debug_barcode) {
  		printf("Datamatrix: IncrementoX:%d IncrementoY:%d spotbitsmodificado:%d spots:%d\n", incrementoX, incrementoY, spotbitsmodificado, spots);
  	}
  	
    	vectorinicial = NumeroVectores;
  	tempymin = 0;
  	
  	// Para cada columna
  	for (columna = 0; columna < numcolumnas; columna++) {
  	
  		// Para cada spot
  		for (spot=0; spot < spots; spot++) {
  		
  			// Para cada fila
  			for (fila = 0; fila < numfilas; fila++) {
  
  				bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
  		
  				if (debug_barcode) {
  					printf("Columna:%d   Fila:%d   bitmap:%d\n", columna, fila, bitmap_red);		
  				}
  		
  				//if (InvertirBarcode[LineaCalcular - 1] == ON) {
  				//	if (bitmap_red == 0) {bitmap_red = 1;}
  				//	else {bitmap_red = 0;}
  				//}
  		
  				switch (bitmap_red) {
  		
  					case 0:		//negro
  			
  					// si es al principio de una columna (fila = 0) o el bit anterior no era negro
  					// empieza un vector
  					if ((fila == 0) || (bitmap_red_anterior != 0)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  	
  						// Inicio del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PU");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)(fila * incrementoY);
  				
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  			        			tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  	
    						NumeroVectores++;
  		
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					// si es al final de una columna (fila = height) termina un vector
  					if (fila == (numfilas - 1)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  						
  						// Fin del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PD");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)((fila+1) * incrementoY);
  					
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  			        			tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  
    						NumeroVectores++;
  		
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					break;
  			
  					default:	//cualquier otro valor indica que es blanco
  			
  					// si el bit anterior era negro y no es el principio de una columna termina un vector
  					if ((bitmap_red_anterior == 0) && (fila>0)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  						
  						// Inicio del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PD");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)((fila) * incrementoY);
  				
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  		        				tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  	
    						NumeroVectores++;
  			
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					break;
  			
  				}
      	
    				bitmap_red_anterior = bitmap_red;
  			
  			}
  		
  		}
  	
  	} 
  	
      	for (i=vectorinicial; i<NumeroVectores; i++) {
  		
  		yValues[i] = yValues[i] - tempymin;
  	
  	}
  	
  	break;
  	
  	case 58:
  	incrementoX = (int)(alturalineatexto * CalibracionCorreccion / numcolumnas); 	//bits
  	incrementoY = (int)(-alturalineatexto * CalibracionCorreccion / numfilas);	//bits
  	
  	// hay que calcular cuantos spots caben en un incrementoX
  	spotbitsmodificado = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
  	spots = (int)((double)incrementoX / (double)spotbitsmodificado);
  	
    	if (spots == 0) { spots = 1;}
  	
  	if (debug_barcode) {
  		printf("QR: IncrementoX:%d IncrementoY:%d spotbitsmodificado:%d spots:%d\n", incrementoX, incrementoY, spotbitsmodificado, spots);
  	}
  	
    	vectorinicial = NumeroVectores;
  	tempymin = 0;
  	
  	// Para cada columna
  	for (columna = 0; columna < numcolumnas; columna++) {
  	
  		// Para cada spot
  		for (spot=0; spot < spots; spot++) {
  		
  			// Para cada fila
  			for (fila = 0; fila < numfilas; fila++) {
  
  				bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
  		
  				if (debug_barcode) {
  					printf("Columna:%d   Fila:%d   bitmap:%d\n", columna, fila, bitmap_red);		
  				}
  		
  				//if (InvertirBarcode[LineaCalcular - 1] == ON) {
  				//	if (bitmap_red == 0) {bitmap_red = 1;}
  				//	else {bitmap_red = 0;}
  				//}
  		
  				switch (bitmap_red) {
  		
  					case 0:		//negro
  			
  					// si es al principio de una columna (fila = 0) o el bit anterior no era negro
  					// empieza un vector
  					if ((fila == 0) || (bitmap_red_anterior != 0)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  	
  						// Inicio del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PU");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)(fila * incrementoY);
  				
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  			        			tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  	
    						NumeroVectores++;
  		
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					// si es al final de una columna (fila = height) termina un vector
  					if (fila == (numfilas - 1)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  						
  						// Fin del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PD");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)((fila+1) * incrementoY);
  					
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  			        			tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  
    						NumeroVectores++;
  		
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					break;
  			
  					default:	//cualquier otro valor indica que es blanco
  			
  					// si el bit anterior era negro y no es el principio de una columna termina un vector
  					if ((bitmap_red_anterior == 0) && (fila>0)) {
  				
    						SaltoDentroAtomo[NumeroVectores] = 0;
  						
  						// Inicio del vector
  						strcpy (TipoMarcaje[NumeroVectores], "PD");
  						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
  						yValues[NumeroVectores] = (int)((fila) * incrementoY);
  				
  						// hay que guardar el ancho...
  						if (xValues[NumeroVectores] > tempxmax) {
  		        				tempxmax = xValues[NumeroVectores];
      						}
      						
    						if (yValues[NumeroVectores] < tempymin) {
  			        			tempymin = yValues[NumeroVectores];
      						}
      						
  						if (debug_vectores) {
  							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  						}
  	
    						NumeroVectores++;
  			
    						if (NumeroVectores > NumeroMaximoVectores) {
  							StopEjecucion();
    							ErrorVectores = ON;
  							ProcesarError();
  							return -1;
  						}
  				
  					}
  			
  					break;
  			
  				}
      	
    				bitmap_red_anterior = bitmap_red;
  			
  			}
  		
  		}
  	
  	} 
  	
      	for (i=vectorinicial; i<NumeroVectores; i++) {
  		
  		yValues[i] = yValues[i] - tempymin;
  	
  	}
  	
  	break;
  		
  	
  	
  	// ITF-14: hay que recorrer filas y columnas, con vectores laterales
  	case 89:
  	incrementoX = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
  	incrementoY = (int)(alturalineatexto * CalibracionCorreccion / numfilas);
  	
  	//printf("ITF-14: IncrementoX:%d IncrementoY:%d\n", incrementoX, incrementoY);
  
    	if (vectoreslaterales) {
  	
  		for (i=0; i<numerovectoreslaterales; i++) {
  			
    			SaltoDentroAtomo[NumeroVectores] = 0;
  						
  			strcpy (TipoMarcaje[NumeroVectores], "PU");
  			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = 0;
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  			
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PD");
  			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
      		
  		}
  	
  	}
  
  	// Para cada columna
  	for (columna = 0; columna < numcolumnas; columna++) {
  
  		// Para cada fila
  		for (fila = 0; fila < numfilas; fila++) {
  
  			bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
  		
  			//if (debug_barcode) {
  			//	printf("Columna:%d   Fila:%d   bitmap:%d\n", columna, fila, bitmap_red);		
  			//}
  		
  			if (InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) {
  				if (bitmap_red == 0) {bitmap_red = 1;}
  				else {bitmap_red = 0;}
  			}
  		
  			switch (bitmap_red) {
  		
  				case 0:		//negro
  			
  				// si es al principio de una columna (fila = 0) o el bit anterior no era negro
  				// empieza un vector
  				if ((fila == 0) || (bitmap_red_anterior != 0)) {
  				
    					SaltoDentroAtomo[NumeroVectores] = 0;
  		
  					// Inicio del vector
  					strcpy (TipoMarcaje[NumeroVectores], "PU");
  					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
  					yValues[NumeroVectores] = (int)(fila * incrementoY);
  				
  					// hay que guardar el ancho...
  					if (xValues[NumeroVectores] > tempxmax) {
  			        		tempxmax = xValues[NumeroVectores];
      					}
      		
  					if (debug_vectores) {
  						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  					}
  
    					NumeroVectores++;
  		
    					if (NumeroVectores > NumeroMaximoVectores) {
  						StopEjecucion();
    						ErrorVectores = ON;
  						ProcesarError();
  						return -1;
  					}
  				
  				}
  			
  				// si es al final de una columna (fila = height) termina un vector
  				else if (fila == (numfilas - 1)) {
  				
    					SaltoDentroAtomo[NumeroVectores] = 0;
  			
  					// Inicio del vector
  					strcpy (TipoMarcaje[NumeroVectores], "PD");
  					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
  					yValues[NumeroVectores] = (int)(fila * incrementoY);
  					
  					// hay que guardar el ancho...
  					if (xValues[NumeroVectores] > tempxmax) {
  		        			tempxmax = xValues[NumeroVectores];
      					}
      		
  					if (debug_vectores) {
  						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  					}
  
    					NumeroVectores++;
  		
    					if (NumeroVectores > NumeroMaximoVectores) {
  						StopEjecucion();
    						ErrorVectores = ON;
  						ProcesarError();
  						return -1;
  					}
  				
  				}
  						
  				break;
  			
  				default:	//cualquier otro valor indica que es blanco
  			
  				// si el bit anterior era negro y no es el principio de una columna termina un vector
  				if ((bitmap_red_anterior == 0) && (fila>0)) {
  				
    					SaltoDentroAtomo[NumeroVectores] = 0;
  			
  					// Inicio del vector
  					strcpy (TipoMarcaje[NumeroVectores], "PD");
  					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
  					yValues[NumeroVectores] = (int)(fila * incrementoY);
  				
  					// hay que guardar el ancho...
  					if (xValues[NumeroVectores] > tempxmax) {
  		        			tempxmax = xValues[NumeroVectores];
      					}
      		
  					if (debug_vectores) {
  						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  					}
  	
    					NumeroVectores++;
  			
    					if (NumeroVectores > NumeroMaximoVectores) {
  						StopEjecucion();
    						ErrorVectores = ON;
  						ProcesarError();
  						return -1;
  					}
  				
  				}
  			
  				break;
  			
  			}
      	
    			bitmap_red_anterior = bitmap_red;
  		
  		}
  	
  	} 
  
    	if (vectoreslaterales) {
  
  		for (i=0; i<numerovectoreslaterales; i++) {
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PU");
  			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = 0;
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PD");
  			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  
  		}
  
  	}
  	
  	break;
  	
    	default:
  	incrementoX = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
  	incrementoY = (int)(alturalineatexto * CalibracionCorreccion / numfilas);
  	
  	//printf("Resto - IncrementoX:%d IncrementoY:%d\n", incrementoX, incrementoY);
  
    	if (vectoreslaterales) {
  	
  		for (i=0; i<numerovectoreslaterales; i++) {
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PU");
  			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = 0;
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  			
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PD");
  			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
      		
  		}
  	
  	}
  
  	for (columna = 0; columna < numcolumnas; columna++) {
  
  		//for (fila = 0; fila < numfilas; fila++) {
  
    		fila = numfilas - 1;
  		
  		bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
  		
  		//if (debug_barcode) {
  		//	printf("Columna:%d   Fila:%d   bitmap:%d\n", columna, fila, bitmap_red);		
  		//}
  		
  		if (InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) {
  			if (bitmap_red == 0) {bitmap_red = 1;}
  			else {bitmap_red = 0;}
  		}
  		
  		switch (bitmap_red) {
  		
  			case 0:		//negro	
  			
    			SaltoDentroAtomo[NumeroVectores] = 0;
  				
  			// Inicio del vector
  			strcpy (TipoMarcaje[NumeroVectores], "PU");
  			xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = 0;
  				
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
  		        	tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  			
    			SaltoDentroAtomo[NumeroVectores] = 0;
  				
  			// Fin del vector
  			strcpy (TipoMarcaje[NumeroVectores], "PD");
  			xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = (int)((numfilas - 1) * incrementoY);
  				
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
  		       		tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  			
  			break;
  			
  			default:	//cualquier otro valor indica que es blanco, no se hace nada
  			break;
  			
  		}
      	
    		bitmap_red_anterior = bitmap_red;
  		
  		//}
  	} 
  
    	if (vectoreslaterales) {
  
  		for (i=0; i<numerovectoreslaterales; i++) {
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PU");
  			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = 0;
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  	
    			SaltoDentroAtomo[NumeroVectores] = 0;
  			
  			strcpy (TipoMarcaje[NumeroVectores], "PD");
  			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
  			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
  		
  			// hay que guardar el ancho...
  			if (xValues[NumeroVectores] > tempxmax) {
          			tempxmax = xValues[NumeroVectores];
      			}
      		
  			if (debug_vectores) {
  				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  			}
  
    			NumeroVectores++;
  		
    			if (NumeroVectores > NumeroMaximoVectores) {
  				StopEjecucion();
    				ErrorVectores = ON;
  				ProcesarError();
  				return -1;
  			}
  
  		}
  
  	}
  
  	break;
  	
  }
  		
  // Calcula el factor de ajuste
  //factorajuste = alturalineatexto * CalibracionCorreccion / height;
  
  //if (debug_vectores) {
  //	printf("Altura Linea:%f factorajuste:%f AnchuraBarcode[LineaCalcular - 1]:%d\n", alturalineatexto, factorajuste, AnchuraBarcode[LineaCalcular - 1]);
  //}
  
  // Actualiza la anchura del caracter anterior
  AnchuraCaracterAnterior = (int)(tempxmax);
  
    //AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * tempxmax));
  
  if (debug_vectores) {
  	printf("EncontrarParametrosBarcode terminado\n");
  }
  		
  return 0;
}

int EncontrarParametrosPlt() {
  int x, y, tempxmax;		// coordenadas x, y, tempxmax
  int xoffsetlogo, yoffsetlogo;
  long linea, lineasplt;
  float factorajuste, alturalineatexto;
  char *str;
    
  if (debug_vectores) {
  	
  	printf("EncontrarParametrosPlt: LineaCalcular:%d BloqueCalcular:%d\n", LineaCalcular, BloqueCalcular);
  	
  }
  
    tempxmax = 0;
  
  // Se rellena el array ArchivoPlt y las variables globales xMaxPlt, yMaxPlt, xMinPlt, yMinPlt
  lineasplt = LeerArchivoPlt(ArchivoPlt);
  
    if ((pltDemasiadoGrande) || (pltIncorrecto)) {
  
  	return 1;
  
  }
  
    switch (LineaCalcular) {
  
  	case 1:
  	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
  	break;
  
  	case 2:
  	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
  	break;
      
  	case 3:
      	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
  	break;
  	
  	case 4:
      	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
  	break;
     
  }
  
  // Calcula el factor de ajuste
  factorajuste = alturalineatexto * CalibracionCorreccion / (yMaxPlt - yMinPlt);
  
  if (debug_plt) {
  
    
  }
  
  // Va leyendo el tipo PU o PD y las coordenadas x e y del archivo plt
  
    linea = 0;
  
  // offsets del logo: origen en 0,0 como los caracteres
  xoffsetlogo = xMinPlt;
  yoffsetlogo = yMinPlt;
  
  //xoffsetlogo = (xMaxPlt - xMinPlt) / 2;
  //yoffsetlogo = (yMaxPlt - yMinPlt) / 2;
  
  while ( (linea < lineasplt) && (strlen(ArchivoPlt[linea]) > 0) ) {
  
  	//printf("\nArchivoPlt[%ld]:%s\n", linea, ArchivoPlt[linea]);
  	
    	SaltoDentroAtomo[NumeroVectores] = 0;
  	
  	// Inicio del vector
  	strncpy (TipoMarcaje[NumeroVectores], ArchivoPlt[linea], 2);
  	TipoMarcaje[NumeroVectores][2] = '\0';
  	
  	// coordenada x
  	str = strtok (ArchivoPlt[linea], " PUD;");
  	x = atoi(str) - xoffsetlogo;	// origen del plt en 0,0
  	xValues[NumeroVectores] = (int)(x * factorajuste) + AnchuraCaracterAnterior;
  	
  	//printf("str:(%s) x:%d\n", str, x);
  
  	// hay que guardar el ancho...
  	if (x > tempxmax) {
          	tempxmax = x;
      	}
      	
  	// coordenada y
  	str = strtok (NULL, " PUD;");
  	y = atoi(str) - yoffsetlogo;	// origen del plt en 0,0
  	yValues[NumeroVectores] = (int)(y * factorajuste);
  	
  	//printf("str:(%s) y:%d\n", str, y);
  
  	if (debug_vectores) {
  		printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
  	}
  
    	NumeroVectores++;
  	
    	if (NumeroVectores > NumeroMaximoVectores) {
  		StopEjecucion();
    		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}	
  
    	linea ++;
  	
  }
  
  // Actualiza la anchura del caracter anterior
  AnchuraCaracterAnterior = AnchuraCaracterAnterior + (int)(tempxmax * factorajuste);
  
    //AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * tempxmax));
  
  if (debug_vectores) {
    }
  		
  return 0;
}

int LeerArchivoPlt(char ArchivoPlt[MaximoLineasArchivoPlt][50]) {
  // Lee el archivo plt
    int linea, nuevalinea;
  int x, y, i, x2, y2;			
  FILE *fichero;                  // pointer to input file
    char *buffer;			// buffer donde se va a leer el archivo
  char *indice;
  size_t result;
  char strtmp[50], *dato, *nuevodato;	// array to hold each "record"
  
    linea = 0;
  xMaxPlt = -32768;
  yMaxPlt = -32768;
  xMinPlt = 32768;
  yMinPlt = 32768;
  pltIncorrecto = false;
  pltDemasiadoGrande = false;
  
  // Abre el archivo
  //printf("Linea:%d Bloque:%d NombreArchivoPlt:%s\n", LineaCalcular, BloqueCalcular,NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]); 
  fichero = fopen(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], "r");	
  
  if (fichero == NULL) {
  	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  	rt_printk("Error al abrir el fichero plt\n");
    	system("cp /rootFLS/itaca/*.plt .");
    	exit(1);
  }
  
  // Lee el archivo entero en memoria:
    fseek(fichero, 0, SEEK_END);
  lSize = ftell(fichero);
  
  // rebobina al principio del fichero
  rewind(fichero);
  
  // Reserva memoria para guardar todo el fichero en un buffer
  buffer = (char*) malloc (sizeof(char)*lSize);
  if (buffer == NULL) {
  	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  	rt_printk("Error de memoria al leer el archivo plt\n");
  }
  
  // Lee el fichero en el buffer
  result = fread (buffer, 1, lSize, fichero);
  if ((long)result != lSize) {
  	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
  	rt_printk("Error de lectura al leer el archivo plt\n");
  }
  
  // cierra el archivo
  fclose(fichero);	
  
  // debug
  if (debug_plt) {
  	
  	printf("Cerrado archivo plt\n");
  
  }
  
  // Lee hasta el primer retorno de carro o punto y coma
  indice = buffer;
  
  //printf("---buffer:%d\n", (int)buffer);
  
  dato = strtok(indice, ";\n"); 
  
  // avanza el cursor	
  indice = indice + strlen(dato) + 1;
  
  // Si hay varios separadores seguidos hay que adelantar el puntero
  while( (*indice == '\0') && (indice < (buffer+lSize) )) {indice ++;}
  	
  //printf("indice:%d strlen(dato):%d dato:%s\n", (int)indice, strlen(dato), dato);
  
    while ((indice < (buffer+lSize)) && (linea < MaximoLineasArchivoPlt)) {	
  
    	
  	//////////////////////////////////////////////////////////////////////////////////////////////////
  	// PLTs tradicionales de Corel
  
    	if ( ((strstr(dato,"PU"))||(strstr(dato,"PD"))) && (strstr(dato," "))) {
  			
  		// guarda la coordenada en el array tmpArchivoPlt
  		strcpy(tmpArchivoPlt[linea], dato);		
  		
  		// debug
  		if (debug_plt) {
  			printf("PUD - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  		}
  		
    		linea++;
  			
  		// saca la coordenada x
  		x = atoi(strtok(dato, " PUD;"));
  			
  		// calcula xMaxPlt y xMinPlt
  		if (x > xMaxPlt) {xMaxPlt = x;}
  		if (x < xMinPlt) {xMinPlt = x;}
  			
  		// y ahora la y
  		y = atoi(strtok(NULL, " PUD;"));
  						
  		// calcula yMaxPlt e yMinPlt
  		if (y > yMaxPlt) {yMaxPlt = y;}
  		if (y < yMinPlt) {yMinPlt = y;}
  				
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////////////////////////
  	// PLTs de Autocad
  	
  	// Si es "PUPA" lo siguiente tienen que ser coordenadas
  	else if (strstr(dato,"PUPA")) {
  	
  		// debug
  		//if (debug_plt) {
    		//}
  			
  		// avanza 4 posiciones para evitar el PUPA
  		dato +=4;
  			
  		do {
  					
  			// Obtiene las coordenadas x e y
  			nuevodato = strtok(dato, ",;");
  			dato = dato + strlen(nuevodato) + 1;
  			x = atoi(nuevodato);
  			
  			nuevodato = strtok(dato, ",;");
  			dato = dato + strlen(nuevodato) + 1;
  			y = atoi(nuevodato);
  			
  			// calcula xMaxPlt y xMinPlt
  			if (x > xMaxPlt) {xMaxPlt = x;}
  			if (x < xMinPlt) {xMinPlt = x;}
  			
  			// calcula yMaxPlt e yMinPlt
  			if (y > yMaxPlt) {yMaxPlt = y;}
  			if (y < yMinPlt) {yMinPlt = y;}
  
  			// guarda la coordenada en el array ArchivoPlt
  			sprintf(strtmp,"%s%d %d", "PU", x, y);
  			strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  			// debug
  			if (debug_plt) {
  				printf("	PUPA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  			}
  				
    			linea++;
  			
  		} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0));
    	
  	}
  	
  	// Si es "PDPA" lo siguiente tienen que ser coordenadas
  	else if (strstr(dato,"PDPA")) {
  	
  		// debug
  		//if (debug_plt) {
    		//}
  			
  		// avanza 4 posiciones para evitar el PDPA
  		dato +=4;
  			
  		do {
  					
  			// Obtiene las coordenadas x e y
  			nuevodato = strtok(dato, ",;");
  			dato = dato + strlen(nuevodato) + 1;
  			x = atoi(nuevodato);
  			
  			nuevodato = strtok(dato, ",;");
  			dato = dato + strlen(nuevodato) + 1;
  			y = atoi(nuevodato);
  			
  			// calcula xMaxPlt y xMinPlt
  			if (x > xMaxPlt) {xMaxPlt = x;}
  			if (x < xMinPlt) {xMinPlt = x;}
  			
  			// calcula yMaxPlt e yMinPlt
  			if (y > yMaxPlt) {yMaxPlt = y;}
  			if (y < yMinPlt) {yMinPlt = y;}
  
  			// guarda la coordenada en el array ArchivoPlt
  			sprintf(strtmp,"%s%d %d", "PD", x, y);
  			strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  			// debug
  			if (debug_plt) {
  				printf("	PDPA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  			}
  				
    			linea++;
  						
  		} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
    		
  	}
  	
    	else if (strstr(dato,"PA")) { 
  			
  		// saca la coordenada x
  		x = atoi(strtok(dato, " PA;,"));
  			
  		// calcula xMaxPlt y xMinPlt
  		if (x > xMaxPlt) {xMaxPlt = x;}
  		if (x < xMinPlt) {xMinPlt = x;}
  			
  		// y ahora la y
  		y = atoi(strtok(NULL, " PA;,"));
  						
  		// calcula yMaxPlt e yMinPlt
  		if (y > yMaxPlt) {yMaxPlt = y;}
  		if (y < yMinPlt) {yMinPlt = y;}
  		
  		// guarda la coordenada en el array ArchivoPlt
  		sprintf(strtmp,"%s%d %d", "PU", x, y);
  		strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  		// debug
  		if (debug_plt) {
  			printf("	PA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  		}
  				
    		linea++;
  					
  	}
  	
    	else if ( ((strstr(dato,"PU"))||(strstr(dato,"PD"))) && (strstr(dato,","))) {
  					
  		// saca la coordenada x
  		x = atoi(strtok(dato, ",PUD;"));
  			
  		// calcula xMaxPlt y xMinPlt
  		if (x > xMaxPlt) {xMaxPlt = x;}
  		if (x < xMinPlt) {xMinPlt = x;}
  			
  		// y ahora la y
  		y = atoi(strtok(NULL, ",PUD;"));
  						
  		// calcula yMaxPlt e yMinPlt
  		if (y > yMaxPlt) {yMaxPlt = y;}
  		if (y < yMinPlt) {yMinPlt = y;}
  		
  		// guarda la coordenada en el array ArchivoPlt
  		if (strstr(dato,"PU")) {
  			sprintf(strtmp,"%s%d %d", "PU", x, y);
  		}
  		else if (strstr(dato,"PD")) {
  			sprintf(strtmp,"%s%d %d", "PD", x, y);
  		}
  			
  		strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  		// debug
  		if (debug_plt) {
  			printf("	PUPA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  		}
  				
    		linea++;
  				
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////////////////////////
  	// PLTs de Scaps
  	// Si es "PU;" lo siguiente tiene que ser un PA con coordenadas
  	else if (strstr(dato,"PU")) {
  	
  		// lee hasta el siguiente retorno de carro o punto y coma
  		dato = strtok(indice, "\n;");
  		indice = indice + strlen(dato) + 1;
  		
  		// debug
  		//if (debug_plt) {
    		//}
  		
  		// comprueba que es un trozo de PA
  		if (strstr(dato,"PA")) {
  			
  			// avanza 2 posiciones para evitar el PA
  			dato +=2;
  			
  			do {
  								
  				// Obtiene las coordenadas x e y
  				nuevodato = strtok(dato, ",;");
  				dato = dato + strlen(nuevodato) + 1;
  				x = atoi(nuevodato);
  			
  				nuevodato = strtok(dato, ",;");
  				dato = dato + strlen(nuevodato) + 1;
  				y = atoi(nuevodato);
  			
  				// calcula xMaxPlt y xMinPlt
  				if (x > xMaxPlt) {xMaxPlt = x;}
  				if (x < xMinPlt) {xMinPlt = x;}
  			
  				// calcula yMaxPlt e yMinPlt
  				if (y > yMaxPlt) {yMaxPlt = y;}
  				if (y < yMinPlt) {yMinPlt = y;}
  
  				// guarda la coordenada en el array ArchivoPlt
  				sprintf(strtmp,"%s%d %d", "PU", x, y);
  				strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  				// debug
  				if (debug_plt) {
  					printf("	PU;PA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);				
  				}
  				
    				linea++;
  			
  			} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
    					
  		}
  		
  	}
  
  	// Si es "PD;" lo siguiente tiene que ser un PA con coordenadas
  	else if (strstr(dato,"PD")) {
  	
  		// lee hasta el siguiente retorno de carro o punto y coma
  		dato = strtok(indice, "\n;");
  		indice = indice + strlen(dato) + 1;
  		
  		// debug
  		//if (debug_plt) {
    		//}
  			
  		// comprueba que es un trozo de PA
  		if (strstr(dato,"PA")) {
  			
  			// avanza 2 posiciones para evitar el PA
  			dato +=2;
  			
  			do {
  					
  				// Obtiene las coordenadas x e y
  				nuevodato = strtok(dato, ",;");
  				dato = dato + strlen(nuevodato) + 1;
  				x = atoi(nuevodato);
  			
  				nuevodato = strtok(dato, ",;");
  				dato = dato + strlen(nuevodato) + 1;
  				y = atoi(nuevodato);
  			
  				// calcula xMaxPlt y xMinPlt
  				if (x > xMaxPlt) {xMaxPlt = x;}
  				if (x < xMinPlt) {xMinPlt = x;}
  			
  				// calcula yMaxPlt e yMinPlt
  				if (y > yMaxPlt) {yMaxPlt = y;}
  				if (y < yMinPlt) {yMinPlt = y;}
  
  				// guarda la coordenada en el array ArchivoPlt
  				sprintf(strtmp,"%s%d %d", "PD", x, y);
  				strcpy(tmpArchivoPlt[linea], strtmp);		
  				
  				// debug
  				if (debug_plt) {
  					printf("	PD;PA - linea:%d %s\n", linea, tmpArchivoPlt[linea]);
  				}
  						
    				linea++;
  			
  			} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
    						
  		}
  		
  	}
  	
  	//////////////////////////////////////////////////////////////////////////////////////////////////
  	// SIGUE.... 
  	
  	//printf("indice:%d strlen(indice):%d\n", (int)indice, strlen(indice));
  	
  	// Lee hasta el siguiente retorno de carro o punto y coma
  	if (strlen(indice)) {
  		dato = strtok(indice, ";\n"); 	
  		indice = indice + strlen(dato) + 1;
  	}
  			
  	// Si hay varios separadores seguidos hay que adelantar el puntero
  	while( (*indice == '\0') && (indice < (buffer+lSize) )) {indice ++;}
  	
  	//printf("indice:%d strlen(dato):%d dato:%s\n", (int)indice, strlen(dato), dato);
  	
  }
  
  // libera la memoria donde se ha leido el archivo
  free (buffer);
  
    if (linea >= MaximoLineasArchivoPlt) {
  
  	pltDemasiadoGrande = true;
  
  }
  
  // Si yMax e yMin son iguales no se puede procesar el archivo porque no tiene altura
  if (yMaxPlt == yMinPlt) {
  
  	pltIncorrecto = true;
  
  }
  
  
  // Si no hay problemas con el plt hay que optimizarlo
  if ( (!pltDemasiadoGrande) && (!pltIncorrecto) ) {
  
  	// debug
  	if (debug_plt) {
    	}
  					
    	nuevalinea = 0;
  	
    	if (!strstr(tmpArchivoPlt[nuevalinea+1], "PU")) {
  		
  		strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[0]);
  		nuevalinea++;
  		
  		// debug
  		if (debug_plt) {
  			printf("nuevalinea:%d %s\n", nuevalinea, ArchivoPlt[nuevalinea]);
  		}				
  		
  	}
  	
  	for (i=1; i<linea-1; i++) {
  	
  		///*
  		
    		if (strstr(tmpArchivoPlt[i], "PU")) {
  		
  			
    			if (strstr(tmpArchivoPlt[i+1], "PU")) {continue;}
  			
    			//strcpy(strtmp, tmpArchivoPlt[i]);
  			//x = atoi(strtok(strtmp, " PUD;"));
  			//y = atoi(strtok(NULL, " PUD;"));
  				
  			//strcpy(strtmp, tmpArchivoPlt[i-1]);
  			//x2 = atoi(strtok(strtmp, " PUD;"));
  			//y2 = atoi(strtok(NULL, " PUD;"));
  				
  			//printf("x=%d y=%d x2=%d y2=%d\n", x,y,x2,y2);
  				
  			//if ((x==x2) && (y==y2)) {continue;}
  			
  			// Si el vector siguiente es PD y tiene las mismas coordenadas, saltar
  			//if (strstr(tmpArchivoPlt[i+1], "PD")) {
  
  			//strcpy(strtmp, tmpArchivoPlt[i+1]);
  			//x2 = atoi(strtok(strtmp, " PUD;"));
  			//y2 = atoi(strtok(NULL, " PUD;"));
  				
  			//printf("x=%d y=%d x2=%d y2=%d\n", x,y,x2,y2);
  				
  			//if ((x==x2) && (y==y2)) {continue;}
  			
  			//}
  						
  		}
  		
    		else if (strstr(tmpArchivoPlt[i], "PD")) {
  		
  			// Coordenadas actuales
  			strcpy(strtmp, tmpArchivoPlt[i]);
  			x = atoi(strtok(strtmp, " PUD;"));
  			y = atoi(strtok(NULL, " PUD;"));
  				
  			// Si el siguiente es otro PD con las mismas coordenadas 
    			if (strstr(tmpArchivoPlt[i+1], "PD")) {
  			
  				strcpy(strtmp, tmpArchivoPlt[i+1]);
  				x2 = atoi(strtok(strtmp, " PUD;"));
  				y2 = atoi(strtok(NULL, " PUD;"));
  				
  				//printf("x=%d y=%d x2=%d y2=%d\n", x,y,x2,y2);
  				
  				if ((x==x2) && (y==y2)) {continue;}
  			
  			}
  			
  			// Si el anterior es un PU con las mismas coordenadas 
    			//if (strstr(tmpArchivoPlt[i-1], "PU")) {
  			
  			//	strcpy(strtmp, tmpArchivoPlt[i-1]);
  			//	x2 = atoi(strtok(strtmp, " PUD;"));
  			//	y2 = atoi(strtok(NULL, " PUD;"));
  				
  				//printf("x=%d y=%d x2=%d y2=%d\n", x,y,x2,y2);
  				
  			//	if ((x==x2) && (y==y2)) {continue;}
  			
  			//}
  			
  		}
  		
  		//*/
  		
    		strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[i]);
  				
  		// debug
  		if (debug_plt) {
  			printf("nuevalinea:%d %s\n", nuevalinea, ArchivoPlt[nuevalinea]);
  		}
  					
  		nuevalinea++;
  	
  	}
  	
    	strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[i]);
  	
  	// debug
  	if (debug_plt) {
  		printf("nuevalinea:%d %s\n", nuevalinea, ArchivoPlt[nuevalinea]);
  	}
  					
  	nuevalinea++; 
  
  }
  
      if (nuevalinea > 1) {
  
  	if ( !((strstr(ArchivoPlt[0],"PU")) && (strstr(ArchivoPlt[1],"PD"))) ){
  
  		pltIncorrecto = true;
  
  	}
  	
  }
  
  else {
  
  	pltIncorrecto = true;
  	
  }
  
  // debug
  if (debug_plt) {
  
  	printf("xMaxPlt:%d xMinPlt:%d yMaxPlt:%d yMinPlt:%d\n", xMaxPlt, xMinPlt, yMaxPlt, yMinPlt);
  
  }
  	
  return nuevalinea;
}

int CalcularMatrizCampo() {
  unsigned long i;
  
  NumeroVectores = 0;
  
  // Vector 0
  strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
  xValues[NumeroVectores] = MaximoBits;
  yValues[NumeroVectores] = MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 1
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = MaximoBits;
  yValues[NumeroVectores] = -MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 2
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = -MaximoBits;
  yValues[NumeroVectores] = -MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 3
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = -MaximoBits;
  yValues[NumeroVectores] = MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 4
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = MaximoBits;
  yValues[NumeroVectores] = MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  
  // Vector 5
  strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
  xValues[NumeroVectores] = MaximoBits;
  yValues[NumeroVectores] = 0;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 6
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = -MaximoBits;
  yValues[NumeroVectores] = 0;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 7
  strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
  xValues[NumeroVectores] = 0;
  yValues[NumeroVectores] = MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  // Vector 8
  strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
  xValues[NumeroVectores] = 0;
  yValues[NumeroVectores] = -MaximoBits;
  uValues[NumeroVectores] = 0;
  NumeroVectores++;
  
  ///////////////////////////////////////////////////////////////////////////////////
  // Debug y Control
  ///////////////////////////////////////////////////////////////////////////////////
      
  if (debug_vectores) {	
  	printf("CalcularMatrizCampo - Vectores: %ld\n", NumeroVectores);
  	for (i=0; i<NumeroVectores; i++) {	
  		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d\n", i, TipoMarcaje[i], xValues[i], yValues[i]);	
  	}
  }
  
  return 0;
}

void DescargarLista(int lista) {
  unsigned long j; 
  int result;
      
        if ((Estrategia == 2) && (EnEjecucion) && (MarcajeDinamicoActivo > 0)) {
  	
    	for (j=0; j<NumeroVectores; j++) {
  	
  		xValues[j] = xValues[j] + xOffsetDinamico;
  		yValues[j] = yValues[j] + yOffsetDinamico;
  		uValues[j] = uValues[j] + uOffsetDinamico;
  	
  	}
  
  }
  
  // Inicia la lista
  result = Set_Start_List(lista);
  
  //calcula la correccion de la posicion de los vectores por fichero de correccion
  /*for (j=0; j<NumeroVectores; j++) {
  	if (FicheroCorreccionActivo == 1){
  		result = CalcularCorreccionVector (xValues[j],yValues[j]);
  		xValues[j]=xcorregido;
  		yValues[j]=ycorregido;		
  	}
  }*/
  
  
  //descarga la lista:
  for (j=0; j<NumeroVectores; j++) {
      	
          if (strstr(TipoMarcaje[j],"PU")) {
  	
    		UmbralActual = uValues[j];
  		
  		//rt_printk("Iniciamos el Jump\n");
  		// calcula los microvectores del salto
          	result = Jump(xValues[j], yValues[j]);
  		//rt_printk("Acabamos el Jump\n");
  	}
  	   
          else { //es decir, TipoMarcaje(j)="PD" o "PS" para precorte
          
                    
                  	if (strstr(TipoMarcaje[j + 1],"PU")) { //es decir, el siguiente es un salto
                      
                            		
                          		if (strstr(TipoMarcaje[j],"PS")) { // Precorte
                          			result = MarkPrecorte(xValues[j], yValues[j]);
                          		}
                          		else {
                          			//rt_printk("Iniciamos el Mark\n");
                          			result = Mark(xValues[j], yValues[j]);
                          			//rt_printk("Acabamos el Mark\n");
  
                          		}
                          		
                          	}
                          	                       
                      		else {	//el anterior no es un salto
                          		//rt_printk("Iniciamos el PolC\n");
                          		result = PolC(xValues[j], yValues[j]);
                           		//rt_printk("Acabamos el PolC\n");
                      		}
                      
                  	}
                  	
                  	else {	//el siguiente no es un salto
                      
                      		if (strstr(TipoMarcaje[j - 1],"PD")) { //el anterior no es un salto
                            		//rt_printk("Iniciamos el PolB\n");                      
                          		result = PolB(xValues[j], yValues[j]);
                                          //rt_printk("Acabamos el PolB\n");
                      		}
                      		
                      		else {	//el anterior debe ser un salto
                            		//rt_printk("Iniciamos el PolA\n");                     
                          		result = PolA(xValues[j], yValues[j]);
                             		//rt_printk("Acabamos el PolA\n");
                      		}
                  
                  	}
              
              	}
              	
                    
                  	if (strstr(TipoMarcaje[j - 1],"PU")) { //el anterior era un salto
                      		
                      		if (strstr(TipoMarcaje[j],"PS")) { // Precorte
                          		result = MarkPrecorte(xValues[j], yValues[j]);
                          	}
                          	else {
                            		//rt_printk("Iniciamos el Mark ultimo vector\n");                      	
                          		result = Mark(xValues[j], yValues[j]);
                            		//rt_printk("Acabamos el Mark ultimo vector\n");                      	
                          	}
                      	
                      	}
                  	
                  	else {	//el anterior no era un salto
                      		
                      		result = PolC(xValues[j], yValues[j]);
                      
                  	}
                     
           	}
      
      	}
      	
  }
  
  result = Set_End_Of_List(lista); //Close the list    
  
  //DEBUG
  if (debug_listas) {
  
  	switch(lista) {
  	
  	case 0:
  		rt_printk("LISTA 0 Descargada: %ld mVectores\n", Lista0_NumeroMicroVectores-1);
  		break;
  		
  	case 1:
  		rt_printk("LISTA 1 Descargada: %ld mVectores\n", Lista1_NumeroMicroVectores-1);
  		break;
  	
  	case 2:
  		rt_printk("LISTA 2 Descargada: %ld mVectores\n", Lista2_NumeroMicroVectores-1);
  		break;
  	}
  
  }
}

int EjecutarLista(short lista) {
  int error = false;
  
    MicroVector = 0;
  
  switch (lista) {
  	
  case 1:
    	if ((Lista2_Exe == false) && ((Lista1_NumeroMicroVectores-1) > 0)) {
  		
  		Lista1_Exe = true;
  		
  		if (debug_Mvectores) {
  			rt_printk("################# InicioEjecucion Lista 1\n");
  		}
  	
  	}
  	
  	else {
  	
  		error = true;
  	
  	}
  	
  	break;
  	
  case 2:
    	if ((Lista1_Exe == false) && ((Lista2_NumeroMicroVectores-1) > 0)) {
  	
  		Lista2_Exe = true;
  		
  		if (debug_Mvectores) {
  			rt_printk("################# InicioEjecucion Lista 2\n");
  		}
  		
  	}
  	
  	else {
  	
  		error = true;
  	
  	}
  	
  	break;
  	
  default:
  
    	error = true;
  	ErrorVectores = ON;
  	ProcesarError();
  
  	break;
  
  }
  
  if ((debug_listas) && (error == false)) {
  	
  	switch (lista) {
  	
  	case 1:
    		break;
  	
  	case 2:
    		break;
  	}
  	
  }
  
  if (error == true) {
  	
  	switch (lista) {
  	
  	case 1:
    		break;
  	
  	case 2:
    		break;
  	}
  	
  	ErrorVectores = ON;
  	ProcesarError();
  
  }
  
  return error;
}

int Set_Start_List(int lista) {
  int error = false;
  //int result;
  //double x;
  //double y;
  
  
  //xValuesOrigenMV = xValuesPosicion;
  //yValuesOrigenMV = yValuesPosicion;
  
  switch (lista) {
  
  /*
  case 0:
  	// La otras dos listas deben estar cerradas
  	if ((Lista1_Open == false) && (Lista2_Open == false)) {
  		
  		Lista0_NumeroMicroVectores = 0;
  		Lista0_Open = true;
  		
  		xValuesOrigenMV = xValuesPosicion;
  		yValuesOrigenMV = yValuesPosicion;
  
  	}
  	
  	else {	
    		error = true;
  		ErrorVectores = ON;
  		ProcesarError();
  	}
  	
  	break;
  */
  	
  case 1:
  	
  	// La otras dos listas deben estar cerradas
  	if ((Lista0_Open == false) && (Lista2_Open == false)) {
  		
  		Lista1_NumeroMicroVectores = 0;
  		Lista1_Open = true;
  	
  	/*if (FicheroCorreccionActivo == 1){
  		x = (double)xValues[0];
  		y = (double)yValues[0];
  		result = CalcularCorreccionMicrovector (x, y);
  		xValuesOrigenMV=(int)xcorregidoMV;
  		yValuesOrigenMV=(int)ycorregidoMV;		
  	}	
  	else {*/
  		xValuesOrigenMV = xValues[0];
  		yValuesOrigenMV = yValues[0];
  	//}
  		//rt_printk("xvaluesorigenMV= %d yvaluesorigenMV= %d \n", xValuesOrigenMV , yValuesOrigenMV);
  	
  }
  	else {	
    		error = true;
  		ErrorVectores = ON;
  		ProcesarError();
  	}
  	
  	break;
  	
  case 2:
  	// La otras dos listas deben estar cerradas
  	if ((Lista0_Open == false) && (Lista1_Open == false)) {
  		
  		Lista2_NumeroMicroVectores = 0;
  		Lista2_Open = true;
  		
  		xValuesOrigenMV = xValues[0];
  		yValuesOrigenMV = yValues[0];
  	}
  	
  	else {
    		error = true;
  		ErrorVectores = ON;
  		ProcesarError();
  	}
  	
  	break;
  	
  default:
  	
    	error = true;
  	ErrorVectores = ON;
  	ProcesarError();
  
  	break;
  
  }
  
  if ((debug_listas) && (error == true)) {
  	rt_printk("Set_Start_Lista ERROR AL ABRIR LA LISTA %d\n", lista);
  }
  
  if (debug_posicion) {
  	rt_printk("SetStartList %d::OrigenMV=%ld,%ld\n", lista, xValuesOrigenMV, yValuesOrigenMV);
  }
  
  return error;
}

int Set_End_Of_List(int lista) {
  int error = false;
  unsigned int i;
  
  switch (lista) {
  	
  case 1:
  	Lista1_Open = false;
  	
  	// DEBUG
  	if (debug_Mvectores) {
  		
  		rt_printk("Set_End_Of_List::Lista1_NumeroMicroVectores: %ld\n", Lista1_NumeroMicroVectores);
  		
  		for (i=0; i<Lista1_NumeroMicroVectores; i++) {
  			rt_printk("MV:%d	x:%d	y:%d	Laser:%d\n", i, Lista1_xBits[i], Lista1_yBits[i], Lista1_EstadoLaser[i]);
  		}
  		
  	}
  	
  	break;
  	
  case 2:
  	Lista2_Open = false;
  	
  	// DEBUG
  	if (debug_Mvectores) {
  		
  		rt_printk("Set_End_Of_List::Lista2_NumeroMicroVectores: %ld\n", Lista2_NumeroMicroVectores);
  		
  		for (i=0; i<Lista2_NumeroMicroVectores; i++) {
  			rt_printk("MV:%d	x:%d	y:%d	Laser:%d\n", i, Lista2_xBits[i], Lista2_yBits[i], Lista2_EstadoLaser[i]);
  		}
  		
  	}
  	
  	break;
  	
  default:
    	error = true;
  	ErrorVectores = ON;
  	ProcesarError();
  
  	break;
  
  }
  
  if ((debug_listas) && (error == true)) {
  	rt_printk("Set_End_Of_List::ERROR AL CERRAR LA LISTA %d\n", lista);
  }
  
  return error;
}

int Mark(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  int result;
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("MARK::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("MARK::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("MARK	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  	
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);
  
  //rt_printk("xdestinomark:%d ydestinomark:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 
  
  if (debug_Mvectores) {
  	rt_printk("MARK::Microvectores Mark:%d \n", numeromicrovectores);
  }
  
    // hay que devolver un error retornar
  if (PeriodosRetardoLaserOn > numeromicrovectores) {
  	//StopEjecucion();
  	rt_printk("MARK::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\n", numeromicrovectores, PeriodosRetardoLaserOn); 
  	//ErrorVectores = ON;
  	//ProcesarError();
  	//return -1;
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  		
  	}
  	
    	else {
  		
  		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
  		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
  	//printf("i:%d x:%f y:%f\n", i, x, y);
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("MARK::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // RETARDO DE MARCAJE
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    // es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
    if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
  	numeromicrovectores = PeriodosRetardoLaserOff;
  }
  else {
  	numeromicrovectores = PeriodosRetardoMarcaje;
  }
  
    for (i=1; i<=numeromicrovectores; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  		
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("MARK::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("MARK::lista1:%ld 	lista2:%ld\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int MarkPrecorte(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  double MarkStepSizePrecorte;
  int result;
  
  // El precorte requiere un stepsize distinto
  MarkStepSizePrecorte = (unsigned int) ceil(VelocidadMarcaje * VelocidadPrecorte/100.0 * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("MARK::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("MARK::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("MARK	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSizePrecorte);
  
  //printf("distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", distancia, angulo, MarkStepSize, numeromicrovectores); 
  
  if (debug_Mvectores) {
  	rt_printk("MARK::Microvectores Mark:%d \n", numeromicrovectores);
  }
  
    // hay que devolver un error retornar
  if (PeriodosRetardoLaserOn > numeromicrovectores) {
  	//StopEjecucion();
  	rt_printk("MARK::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\n", numeromicrovectores, PeriodosRetardoLaserOn); 
  	//ErrorVectores = ON;
  	//ProcesarError();
  	//return -1;
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    	else {
  		
  		
  		xsinc = xsinc + ((double)MarkStepSizePrecorte * cos(angulo));
  		ysinc = ysinc + ((double)MarkStepSizePrecorte * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
  	//printf("i:%d x:%f y:%f\n", i, x, y);
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("MARK::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // RETARDO DE MARCAJE
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    // es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
    if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
  	numeromicrovectores = PeriodosRetardoLaserOff;
  }
  else {
  	numeromicrovectores = PeriodosRetardoMarcaje;
  }
  
    for (i=1; i<=numeromicrovectores; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  		
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("MARK::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("MARK::lista1:%ld 	lista2:%ld\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int Jump(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  int result;
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("JUMP::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("JUMP::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("JUMP	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  //rt_printk("xdestinojump:%f ydestinojump:%f xValuesOrigenMV:%d yValuesOrigenMV:%d \n", xsinc ,ysinc, xValuesOrigenMV, yValuesOrigenMV);
  
    if ( (xsinc == 0) && (ysinc == 0)){ 	
  	return 0;
  }
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)JumpStepSize);
  
  //rt_printk("xdestinojump:%d ydestinojump:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f JumpStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, JumpStepSize, numeromicrovectores); 
  if (debug_Mvectores) {
  	rt_printk("JUMP::Microvectores Salto:%d \n", numeromicrovectores);
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    	else {
  		
  		
  		xsinc = xsinc + ((double)JumpStepSize * cos(angulo));
  		ysinc = ysinc + ((double)JumpStepSize * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  				
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  	
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("JUMP::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // RETARDO DE SALTO
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    for (i=1; i<=PeriodosRetardoSalto; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("JUMP::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("JUMP::lista1:%ld lista2:%ld \n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int PolA(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  int result;
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("PolA::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("PolA::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("PolA	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);
  
  //rt_printk("xdestinopola:%d ydestinopola:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 
  
  if (debug_Mvectores) {
  	rt_printk("PolA::Microvectores PolA:%d \n", numeromicrovectores);
  }
  
    // hay que devolver un error retornar
  if (PeriodosRetardoLaserOn > numeromicrovectores) {
  	//StopEjecucion();
  	rt_printk("PolA::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\n", numeromicrovectores, PeriodosRetardoLaserOn); 
  	//ErrorVectores = ON;
  	//ProcesarError();
  	//return -1;
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    	else {
  		
  		
  		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
  		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		if (i <= PeriodosRetardoLaserOn) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolA::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    for (i=1; i<=PeriodosRetardoPoligono; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolA::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("PolA::lista1:%ld 	lista2:%ld\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int PolB(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  int result;
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("PolB::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("PolB::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("PolB	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  	
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);
  
  //rt_printk("xdestinopolb:%d ydestinopolb:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 
  
  if (debug_Mvectores) {
  	rt_printk("PolB::Microvectores PolB:%d \n", numeromicrovectores);
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    	else {
  		
  		
  		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
  		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolB::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    for (i=1; i<=PeriodosRetardoPoligono; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolB::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("PolB::lista1:%ld 	lista2:%ld\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int PolC(int xdestino, int ydestino) {
    double x, y;
    unsigned int numeromicrovectores, i;
  int result;
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // CONTROL DE LISTAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
  	StopEjecucion();
  	rt_printk("PolC::ERROR DE LISTAS ABIERTAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
    if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
  	StopEjecucion();
  	rt_printk("PolC::ERROR DE LISTAS CERRADAS\n"); 
  	ErrorVectores = ON;
  	ProcesarError();
  	return -1;
  }
  
  //if (debug_vectores) {
  //       	printf("PolC	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
  //}
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // COORDENADAS
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  	
  // Calcula el incremento en bits de cada coordenada
  xsinc = xdestino - xValuesOrigenMV;
  ysinc = ydestino - yValuesOrigenMV;
  
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));
  
    angulo = atan2(ysinc,xsinc);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);
  
  //rt_printk("xdestinopolc:%d ydestinopolc:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 
  
  if (debug_Mvectores) {
  	rt_printk("PolC::Microvectores PolC:%d \n", numeromicrovectores);
  }
  
    xsinc = xValuesOrigenMV;
  ysinc = yValuesOrigenMV;
  
  // Calcula las coordenadas los microvectores
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		xsinc = xdestino;
  		ysinc = ydestino;
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    	else {
  		
  		
  		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
  		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
  		
  		if (FicheroCorreccionActivo == 1) {
  		result = CalcularCorreccionMicrovector (xsinc,ysinc);
  		x=xcorregidoMV;
  		y=ycorregidoMV;		
  		}
  		else {
  		x=xsinc;
  		y=ysinc;
  		}
  	}
  	
    
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
    		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
    		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolC::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  
  } 
  
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // RETARDO DE MARCAJE
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    // es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
    if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
  	numeromicrovectores = PeriodosRetardoLaserOff;
  }
  else {
  	numeromicrovectores = PeriodosRetardoMarcaje;
  }
  
    for (i=1; i<=numeromicrovectores; i++) {
  
  	// Lista 1
  	if (Lista1_Open == ON) {
  	
  		// Guarda los valores
  		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
  		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
  		
    		Lista1_NumeroMicroVectores++;
  		
    		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}
  
  	// Lista 2
  	else if (Lista2_Open == ON) {
  	
  		// Guarda los valores
  		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
  		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
  		
      		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
  		
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
  		}
  		
  		else {
  			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
  		}
  		
  		// Guarda el umbral asociado a estos microvectores
  		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
  		
    		Lista2_NumeroMicroVectores++;
  		
    		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
  			StopEjecucion();
    			ErrorVectores = ON;
  			ProcesarError();
  			return -1;
  		}
  	
  	}	
  
  	// Error de listas
  	else {
  		StopEjecucion();
  		rt_printk("PolC::ERROR DE LISTAS\n"); 
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
    xValuesOrigenMV = xdestino;
  yValuesOrigenMV = ydestino;
  
  if (debug_Mvectores) {
         	rt_printk("PolC::lista1:%ld 	lista2:%ld\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
  }
  
  return 0;
}

int CalcularMarkStepSize() {
  int err;
  
  // Calcula el Mark Step Size en bits
  MarkStepSize = (unsigned int) ceil(VelocidadMarcaje * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);
  
  if (debug_step){
  	rt_printk("Mark Step Size en bits: %d\n", MarkStepSize);
  }
  
  return err;
}

int CalcularJumpStepSize() {
  int err;
  
  // Calcula el Jump Step Size en bits
  JumpStepSize = (unsigned int) ceil(VelocidadSalto * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);
  
  if (debug_step){
  	rt_printk("Jump Step Size en bits: %d\n", JumpStepSize);
  }
  
  return err;
}

int StartEjecucion() {
  int error = false;
  
    
  // Disparo interno
  if (TipoDisparo == DISPAROINTERNO) {
  
    	if (MarcajeDinamicoActivo == 0) {
  	
  		SeparacionEntreDisparos_cuentas = 0;
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 1) {
  	
  		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
  		
  	}
  	
    	else if (MarcajeDinamicoActivo == 2) {
  	
  		//SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
  		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * 25.0);
  		
  	}
  	
  	//printf("SeparacionEntreDisparos_mm:%d SeparacionEntreDisparos_cuentas:%ld\n", SeparacionEntreDisparos_mm, SeparacionEntreDisparos_cuentas);
  
  }
  
    Escribir_DAT("itaca.dat");
  
    switch (Control) {
  
  case DAQ:
  	
      	error = comedi_dio_write(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, HIGH);	
  	if(error < 0){
    		ErrorDAQ = ON;
  		ProcesarError();
  	}
  
    	if (ExtractorActivado == true) {
  
  		// Escribe en la salida digital
    		error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);	
  		if (error < 0) {
  			rt_printk("comedi_dio_write error = %d\n - Control de Extractor ON",error);
  			ErrorDAQ = ON;
  			ProcesarError();
  		}
  	
    		//Fl::wait(3);
  		sleep(3);
  
  	}	
  	
  	break;
  
  case FPGA:
  
    	outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);
  
    	if (ExtractorActivado == true) {
  
  		// Escribe en la salida digital
  		outb((COMANDO_EXTRACTOR|0x01), REGISTRO_ADDR);
  	
    		//Fl::wait(3);
  		sleep(3);
  
  	}	
  		
  	break;
  	
  } 
  
    VentanaPrincipal->activate();
  
      // Ni algunos campos del control de la marca
  
    if (!ServicioTecnico) {
  	GrupoControlTexto->deactivate();
  	GrupoControlTextoBloques->deactivate();
  	GrupoControlIntensidad->deactivate();
  	GrupoControlMarca->deactivate();	
  }
  
  else {
  
    	CuadroTextoLinea1->deactivate();
  	CuadroTextoLinea2->deactivate();
  	CuadroTextoLinea3->deactivate();
  	CuadroTextoLinea4->deactivate();
  	BotonDetallesLinea1->deactivate();
  	BotonDetallesLinea2->deactivate();
  	BotonDetallesLinea3->deactivate();
  	BotonDetallesLinea4->deactivate();
  	
  	CuadroTextoLinea1Bloque1->deactivate();
  	CuadroTextoLinea1Bloque2->deactivate();
  	CuadroTextoLinea1Bloque3->deactivate();
  	CuadroTextoLinea2Bloque1->deactivate();
  	CuadroTextoLinea2Bloque2->deactivate();
  	CuadroTextoLinea2Bloque3->deactivate();
  	CuadroTextoLinea3Bloque1->deactivate();
  	CuadroTextoLinea3Bloque2->deactivate();
  	CuadroTextoLinea3Bloque3->deactivate();
  	CuadroTextoLinea4Bloque1->deactivate();
  	CuadroTextoLinea4Bloque2->deactivate();
  	CuadroTextoLinea4Bloque3->deactivate();
  	BotonDetallesLinea1Bloque1->deactivate();
  	BotonDetallesLinea1Bloque2->deactivate();
  	BotonDetallesLinea1Bloque3->deactivate();
  	BotonDetallesLinea2Bloque1->deactivate();
  	BotonDetallesLinea2Bloque2->deactivate();
  	BotonDetallesLinea2Bloque3->deactivate();
  	BotonDetallesLinea3Bloque1->deactivate();
  	BotonDetallesLinea3Bloque2->deactivate();
  	BotonDetallesLinea3Bloque3->deactivate();
  	BotonDetallesLinea4Bloque1->deactivate();
  	BotonDetallesLinea4Bloque2->deactivate();
  	BotonDetallesLinea4Bloque3->deactivate();
  	
  	ChoiceFuente->deactivate();
  	SubgrupoJustificacion->deactivate();
  	
  }
  
  // Desactiva los botones de operaciones
  BotonMarcar->deactivate();
  BotonPrueba->deactivate();
  BotonTrabajos->deactivate();
  BotonTablaPrecorte->deactivate();
  BotonLaser->deactivate();
  BotonCampo->deactivate();
  BotonApagar->deactivate();
  
    BotonStop->activate();
  
  // Y el de la velocidad, si es preciso
  if (MarcajeDinamicoActivo == 1) {
  
  	CuadroTextoVLinea->activate();
  
  }
  
    LedLaser->color(FL_YELLOW);
  LedLaser->redraw();	
  
    //Fl::flush();
  
    //error = ControlEjecucionListas();
  
  // Se lanza como un thread independiente de FLTK para que al iniciar desde el puerto serie no se quede enganchado
  // el thread y pueda seguir leyendo el puerto
  // timeout 0 => inmediato
  
  Fl::add_timeout(0,ControlEjecucionListas);
  
  return error;
}

int StopEjecucion() {
  int error = false;
  int i, j;
  
    
    Lista1_Exe = false;
  Lista2_Exe = false;
  	
    EnEjecucion = false;
  
    Fl::remove_timeout(ControlEjecucionListas);
  				
  // y ahora apaga el laser; no se debe apagar antes, ya que si las listas no se han detenido
  // se puede volver a arrancar
  //if (EstadoLaser == ON) {
  	
  	Control_Laser(OFF);
  
  //}
  
    EsperaFotocelula = false;
  
    EsperaRetardoDisparo = false;
  
    ControlMarkInProgress(OFF);		
  
    switch (Control) {
  
  case DAQ:
  	
      	error = comedi_dio_write(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, OFF);	
  	if (error < 0) {
    		ErrorDAQ = ON;
  		ProcesarError();
  	}
  
    	if (ExtractorActivado == true) {
  
  		// Escribe en la salida digital
    		error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, OFF);	
  		if (error < 0) {
  			rt_printk("comedi_dio_write error = %d\n - Extractor OFF\n",error);
  			ErrorDAQ = ON;
  			ProcesarError();
  		}
  	
  	}	
  	
  	break;
  
  case FPGA:
  
    	outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);
  
    	if (ExtractorActivado == true) {
  
  		// Escribe en la salida digital
  		outb((COMANDO_EXTRACTOR|0x00), REGISTRO_ADDR);
  	
  	}	
  		
  	break;
  	
  } 
  
  // Mueve los galvos al inicio de la lista si no se ha detenido por error de campo u otro error del sistema
  if ((FueraLimites == false) && (SistemaOk)) {
  	
  	// Mueve los galvos al inicio de la lista si es necesario
  	if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
  //	if (CalcularMoverGalvos(xValuesPosicion, yValuesPosicion) > 0){
  		MoverGalvos();
  	}
  	
  }
  
    if ((!ServicioTecnico) || (PruebaMarcaje)) {
  	GrupoControlIntensidad->activate();
  	GrupoControlTexto->activate();
  	GrupoControlTextoBloques->activate();
  	GrupoControlMarca->activate();
  }
  
  else {
  
    	if ( ValorTipoLinea[0][0] != GRAFICO) {
  		CuadroTextoLinea1->activate();
  		CuadroTextoLinea1Bloque1->activate();
  	}
  	
  	if ( ValorTipoLinea[0][1] != GRAFICO) {
  		CuadroTextoLinea1Bloque2->activate();
  	}
  	
  	if ( ValorTipoLinea[0][2] != GRAFICO) {
  		CuadroTextoLinea1Bloque3->activate();
  	}
  	
  	if ( ValorTipoLinea[1][0] != GRAFICO) {
  		CuadroTextoLinea2->activate();
  		CuadroTextoLinea2Bloque1->activate();
  	}
  	
  	if ( ValorTipoLinea[1][1] != GRAFICO) {
  		CuadroTextoLinea2Bloque2->activate();
  	}
  	
  	if ( ValorTipoLinea[1][2] != GRAFICO) {
  		CuadroTextoLinea2Bloque3->activate();
  	}
  	
  	if ( ValorTipoLinea[2][0] != GRAFICO) {
  		CuadroTextoLinea3->activate();
  		CuadroTextoLinea3Bloque1->activate();
  	}
  	
  	if ( ValorTipoLinea[2][1] != GRAFICO) {
  		CuadroTextoLinea3Bloque2->activate();
  	}
  	
  	if ( ValorTipoLinea[2][2] != GRAFICO) {
  		CuadroTextoLinea3Bloque3->activate();
  	}
  	
  	if ( ValorTipoLinea[3][0] != GRAFICO) {
  		CuadroTextoLinea4->activate();
  		CuadroTextoLinea4Bloque1->activate();
  	}
  	
  	if ( ValorTipoLinea[3][1] != GRAFICO) {
  		CuadroTextoLinea4Bloque2->activate();
  	}
  	
  	if ( ValorTipoLinea[3][2] != GRAFICO) {
  		CuadroTextoLinea4Bloque3->activate();
  	}
  	
  	BotonDetallesLinea1->activate();
  	BotonDetallesLinea1Bloque1->activate();
  	BotonDetallesLinea1Bloque2->activate();
  	BotonDetallesLinea1Bloque3->activate();
  	
  	BotonDetallesLinea2->activate();
  	BotonDetallesLinea2Bloque1->activate();
  	BotonDetallesLinea2Bloque2->activate();
  	BotonDetallesLinea2Bloque3->activate();
  	
  	BotonDetallesLinea3->activate();
  	BotonDetallesLinea3Bloque1->activate();
  	BotonDetallesLinea3Bloque2->activate();
  	BotonDetallesLinea3Bloque3->activate();
  	
  	BotonDetallesLinea4->activate();
  	BotonDetallesLinea4Bloque1->activate();
  	BotonDetallesLinea4Bloque2->activate();
  	BotonDetallesLinea4Bloque3->activate();
  	
  	ChoiceFuente->activate();
  	SubgrupoJustificacion->activate();
  	
  }
  
  // Apaga los botones de prueba y marcar
  BotonMarcar->value(OFF);
  BotonPrueba->value(OFF);
  
  // Apaga los botones de laser y campo
  BotonLaser->value(OFF);
  BotonCampo->value(OFF);
  
  // Activa los botones de operaciones
  if (!ErrorValidacion) {
  	BotonMarcar->activate();
  }
  
  BotonPrueba->activate();
  BotonTrabajos->activate();
  BotonTablaPrecorte->activate();
  CounterVelocidadLinea->activate();
  CounterEncoder->activate();
  BotonCampo->activate();
  BotonLaser->activate();
  BotonApagar->activate();
  
    BotonStop->deactivate();
  
    LedLaser->color(FL_DARK3);
  LedLaser->redraw();
  
  // Actualiza el contador
  CuadroTextoContador->value(Contador);
  
    ProcesarError();
  
    for (i=0; i<NumeroLineasTexto; i++) {
  	
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		if ((StatusNumeroSerie[i][j]) && (PruebaMarcaje == false)) {
  			
    			if (NumeroUnidadesLote[i][j] >1) {
  				NumeroUnidadesLoteActual[i][j]--;
  			}
  			else {
  				if (NumeroSerie[i][j] > 0) {
  					NumeroSerie[i][j]--;
  				}
  			}
  	
  			//actualizarserie = true;
  		}		
  	}
  }
  
  // Actualizar fecha, hora y serie
  ActualizarFechaHoraSerie();
  
    if ( ValorTipoLinea[0][0] != GRAFICO) {
  	CuadroTextoLinea1->value(LineaTexto1[0]);
  	CuadroTextoLinea1Bloque1->value(LineaTexto1[0]);
  }
  	
  if ( ValorTipoLinea[0][1] != GRAFICO) {
  	CuadroTextoLinea1Bloque2->value(LineaTexto1[1]);
  }
  	
  if ( ValorTipoLinea[0][2] != GRAFICO) {
  	CuadroTextoLinea1Bloque3->value(LineaTexto1[2]);
  }
  	
  if ( ValorTipoLinea[1][0] != GRAFICO) {
  	CuadroTextoLinea2->value(LineaTexto2[0]);
  	CuadroTextoLinea2Bloque1->value(LineaTexto2[0]);
  }
  	
  if ( ValorTipoLinea[1][1] != GRAFICO) {
  	CuadroTextoLinea2Bloque2->value(LineaTexto2[1]);
  }
  	
  if ( ValorTipoLinea[1][2] != GRAFICO) {
  	CuadroTextoLinea2Bloque3->value(LineaTexto2[2]);
  }
  	
  if ( ValorTipoLinea[2][0] != GRAFICO) {
  	CuadroTextoLinea3->value(LineaTexto3[0]);
  	CuadroTextoLinea3Bloque1->value(LineaTexto3[0]);
  }
  	
  if ( ValorTipoLinea[2][1] != GRAFICO) {
  	CuadroTextoLinea3Bloque2->value(LineaTexto3[1]);
  }
  	
  if ( ValorTipoLinea[2][2] != GRAFICO) {
  	CuadroTextoLinea3Bloque3->value(LineaTexto3[2]);
  }
  
  if ( ValorTipoLinea[3][0] != GRAFICO) {
  	CuadroTextoLinea4->value(LineaTexto4[0]);
  	CuadroTextoLinea4Bloque1->value(LineaTexto4[0]);
  }
  	
  if ( ValorTipoLinea[3][1] != GRAFICO) {
  	CuadroTextoLinea4Bloque2->value(LineaTexto4[1]);
  }
  	
  if ( ValorTipoLinea[3][2] != GRAFICO) {
  	CuadroTextoLinea4Bloque3->value(LineaTexto4[2]);
  }
  
  //Para Oscilador Fibra
  switch(TipoLaser){
  case 1:
  Parar_Oscilador_Fibra();
  break;
  }
  
  
  // Guarda los datos actuales de la marca
  Escribir_DAT("itaca.dat");
  
  // Desactiva el flag de prueba de marcaje
  PruebaMarcaje = false;
  
  return error;
}

void ControlEjecucionListas(void*) {
  int listaorigen;
  unsigned long long i=0;
  
    MarcajeOk = true;
  EnEjecucion = true;
  ErrorEjecucionListas = false;
  listaorigen = 1;
  ActualizarPuertoSerie=false;
  ContadorDisparosParado = 0;
  
  // Calcula la matriz
  if (CalcularMatriz() != NoError) {
  	
  	rt_printk("ControlEjecucionListas: problema al CalcularMatriz\n");
  	StopEjecucion();
  	ErrorEjecucionListas = true;
  	return;
  	//return -1;
  
  }
  
  // Disparo externo
  if (TipoDisparo == DISPAROEXTERNO) {
  
    	EsperaFotocelula = false;	
  	LecturasConsecutivasDisparo = 0;
  	
    	CambioFotocelula = false;
  
  }
  
  // Disparo interno
  else if (TipoDisparo == DISPAROINTERNO) {
  
  	EsperaSeparacionEntreDisparos = false;	
  	IncrementoAcumulado_Espera = 0;
  
  }
  
    ResetJumpList = false;
   		
  // Descarga la lista 1
  DescargarLista(listaorigen);
  
  // DEBUG
  if (debug_listas) {
  	rt_printk("Entrando en bucle\n");
  }
  
  // Inicializa las variables para la lectura de las cuentas del encoder
    if (MarcajeDinamicoActivo > 0) {
  				
  	IncrementoAcumulado = 0;
  				
  	// Hay que activar la siguiente espera de disparo
  	EsperaRetardoDisparo = true;
  				
  }
  		
  // Mueve los galvos al inicio de la lista si es necesario
  if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
  	MoverGalvos();
  }
  	
  // Bucle principal de marcaje
  while ((EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
          
            if (ControlarErrorGalvos) {
          
  		ErrorGalvos = ComprobarPosicion(xValues[0],yValues[0]);
  		
  		if (ErrorGalvos) {
  		
  			ErroresConsecutivosGalvos++;
  			
  			if (ErroresConsecutivosGalvos >= MaximoErroresConsecutivosGalvos) {
  				
    				ProcesarError();
  				
  				rt_printk("ControlEjecucionListas: Error de galvos\n");
  				StopEjecucion();
      				return;
      			
      			}
      		
      		}
      			
      		else {
      		
      			ErroresConsecutivosGalvos = 0;
      		
      		}
  	
  	}
  	
  	// Disparo externo
  	if (TipoDisparo == DISPAROEXTERNO) {
  	
    		EsperaFotocelula = true;
  	
  	}
  	
  	// Disparo interno
  	else if (TipoDisparo == DISPAROINTERNO) {
  
    		EsperaSeparacionEntreDisparos = true;	
  		
  	}
  	
          // Ejecuta la lista actual
          EjecutarLista(listaorigen);
          
          // Comprueba si hay que hacer actualizaciones de los datos
      	//Actualizar = false;
      	
      	//if ((StatusFecha == true) || (StatusHora == true) || (StatusNumeroSerie == true)) {
          	ActualizarFechaHoraSerie();
  	//}
          
          switch (listaorigen) {
          	
          case 1:
          	// Mientras se ejecuta la lista actual actualiza la otra lista, si es necesario
          	if (Actualizar || ActualizarPuertoSerie) {
          	
          		// Calcula la nueva matriz
  			if (CalcularMatriz() != NoError) {
  	
  				rt_printk("ControlEjecucionListas: problema al CalcularMatriz\n");
  				StopEjecucion();
  				ErrorEjecucionListas = true;
  				//return -1;
  				return;
  
  			}
          		
          		// Descarga la lista 2
          		DescargarLista(2);
          		
            		listaorigen = 2;	
          		
          	}
          	
            	while ( ((Lista1_Exe) || (Lista0_Exe)) && (EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
          	
          		// Espera un periodo 
          		Fl::wait(PERIODO_WAIT);
          	
          	}
          	
          	break;
          	
          case 2:
          	// Mientras se ejecuta la lista actual actualiza la otra lista, si es necesario
          	if (Actualizar || ActualizarPuertoSerie) {
          	
          		// Calcula la nueva matriz
  			if (CalcularMatriz() != NoError) {
  	
  				rt_printk("ControlEjecucionListas: problema al CalcularMatriz\n");
  				StopEjecucion();
  				ErrorEjecucionListas = true;
  				//return -1;
  				return;
  
  			}
          		
          		// Descarga la lista 1
          		DescargarLista(1);
          		
            		listaorigen = 1;	
          		
          	}
          	
            	while ( ((Lista2_Exe) || (Lista0_Exe)) && (EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
          	
          		// Espera un periodo 
          		Fl::wait(PERIODO_WAIT);
          	
          	}
          	
          	break;
          	
          }
          
            if (EnEjecucion) {
          	Contador++;
          }
          
          // Presenta en pantalla el valor del contador formateado     
          CuadroTextoContador->value(Contador);
          
          // Presenta en pantalla el valor del tiempo de la marca formateado en ms     
          CuadroTextoTMarca->value((double)(tFinMarca - tInicioMarca)/1E6);
          	
  	// DEBUG
  	if (debug_listas) {
    		i++;
  	}   
  	
  }
  
    if (MarcajeOk == false) {
  	
  	//MarcajeOk = true;
    	StopEjecucion();
  	ErrorEjecucionListas = true;
  	//return -1;
  	return;
  	
  }
  
  //return error;
}

int ControlMarkInProgress(int OnOff) {
  int error = false;
  
  switch (Control) {
  
  case DAQ:
  	
    	if (OnOff == ON) {
  	
  	
  	switch(TipoLaser){
  		
  		case 1: 
    			error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE On\n",error);
  				error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);
  				if (error<0){
  					rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE On\n",error);
  					ErrorDAQ = ON;
  					ProcesarError();
  				}
  			}
  
    			//LedLaser->color(FL_RED);	// Led rojo
  		
  		
  			break;
  		/*
    			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_gate_source 0 laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  	
  			// configura el modo del contador
  			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_counter_mode laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// asigna el reloj: 20MHz clock
  			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_clock_source laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set initial counter value by writing to channel 0
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks inicial laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set "load a" register to the number of clock ticks the counter output should remain low
  			// by writing to channel 1.
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks load a laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set "load b" register to the number of clock ticks the counter output should remain high
  			// writing to channel 2 
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write up_ticks load b laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  	
  			// arma el contador
  			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
  			if (error < 0){
  				rt_printk("ERROR comedi_arm laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  			break;
  			*/
  		case 0:
  		
    			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - Mark In Progress On\n",error);
  				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);
  				if (error<0){
  					rt_printk("comedi_dio_write error = %d - Mark In Progress On duplicado\n",error);
  					ErrorDAQ = ON;
  					ProcesarError();
  				}
  			}
  		
    			//LedLaser->color(FL_GREEN);	// Led verde
  		
  		
  			break;
  			}			
  		
  		
  
  	}
  
    	else {
  			
  		switch(TipoLaser){
  			case 0:
    			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - Mark In Progress Off\n",error);
  				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);
  				if (error<0){
  					rt_printk("comedi_dio_write error = %d - Mark In Progress Off duplicado\n",error);
  					ErrorDAQ = ON;
  					ProcesarError();
  				}
  			}
  
    			//LedLaser->color(FL_RED);	// Led rojo
  		
  		
  			break;
  			
  			/*
  			// Resetea el contador
  			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  			if (error < 0){
  				rt_printk("ERROR comedi_reset laser %d\n", error);
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  			break;
  			*/
  			
  			case 1:
  		
    			error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, LOW);	
  			if (error < 0) {
  				rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE Off\n",error);
  				error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, LOW);
  				if (error<0){
  					rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE Off\n",error);
  					ErrorDAQ = ON;
  					ProcesarError();
  				}
  			}
  
    			//LedLaser->color(FL_RED);	// Led rojo
  		
  		
  			break;
  		
  		}		
  		
  		
  	}
  
  	
  	break;
  
  case FPGA:
  
    	// Creo que el comentario anterior es incorrecto...
  	
    	if (OnOff == ON) {
  	
    		outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);	
  	}
  
    	else {	
  
    		outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);	
  	}	
  	
  	break;
  	
  } 
  
  //LedLaser->redraw();		// Marca el Led para redraw
          
  return error;
}

int EjecutarMicrovector(int lista) {
  int error;
      
    // leer las cuentas del encoder y actualizar los valores de la lista
  if ((MarcajeDinamicoActivo > 0) && (PruebaMarcaje == false) && (ResetJumpList == false)){
  	
  	// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
  	// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
  	if (MarcajeDinamicoActivo == 1) {
  
  		// Leer las cuentas del encoder
  		//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual);
  		//if (error < 0) {
  		//	rt_printk("LEER ENCODER comedi_data_read = %d\n",error);
  		//	ErrorDAQ = ON;
  		//	ProcesarError();
  		//}
  		
  		// Calcular el incremento de cuentas
  		if (ValorCuentasActual >= ValorCuentasAnterior) {
  			IncrementoCuentasPeriodo = (float)(ValorCuentasActual - ValorCuentasAnterior);
  		}
    			IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior) + ValorCuentasActual);
  			//StopEjecucion();
  			//LedEstado->label("Encoder: overflow");
  			rt_printk("OVERFLOW MV %ld Actual:%d INCR:%f ACUM:%d\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
  			return false;
  		}
  	
  		// debug excesos del encoder
  		if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado<0))) {
  			
  			//StopEjecucion();
  			
  			LedEstado->label("Encoder: incremento");
  			rt_printk("MV%ld Actual:%d INCR:%f ACUM:%f\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
  			return false;
  		
  		}
  	
    		ValorCuentasAnterior = ValorCuentasActual;
  	
  	}
  	
  	// Acumula las cuentas
  	IncrementoAcumulado += IncrementoCuentasPeriodo;
  	
  	//DEBUG
  	if (debug_encoder == true) {
  		rt_printk("MV%ld Actual:%d INCR:%f ACUM:%f\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
  	}
  		
  }
  
  else {	// Anula el incremento de cuentas
  	IncrementoAcumulado = 0;
  }
  	
  // Ejecuta el microvector de la lista que se trate		
  switch (lista) {
  
    	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza los galvos: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	xBitsDouble = (double)(Lista0_xBits[MicroVector]);
  	yBitsDouble = (double)(Lista0_yBits[MicroVector]);	
  				
  	// Coordenada X:
  	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
  	
  	//rt_printk("xBitsDouble:%f Kx_Bits_a_Voltios:%f xBitsDouble * Kx_Bits_a_Voltios:%f \n",xBitsDouble, Kx_Bits_a_Voltios, xBitsDouble * Kx_Bits_a_Voltios );
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vx) > VGalvoMax) {
  		
  	    		rt_printk("ErrorCampo - Lista 0: MV=%ld Vx=%f mayor que VGalvoMax\n", MicroVector, fabs(Vx));
  
  			ErroresConsecutivosCampoX++;
  		
    		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoX = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vx);
  
  		// escribe en el galvo X
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false; 
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo X
  		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
  		
  		break;
  	
  	} 
  	
  	// Coordenada Y:
  	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vy) > VGalvoMax) {
  
  	    		rt_printk("ErrorCampo - Lista 0: MV=%ld Vy=%f mayor que VGalvoMax\n", MicroVector, fabs(Vy));
  		
  			ErroresConsecutivosCampoY++;
  		
    		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoY = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vy);
  
  		// escribe en el galvo Y
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false;
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo Y
  		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
  		
  		break;
  	
  	} 
  		
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el laser: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	
  	if (Lista0_EstadoLaser[MicroVector] != EstadoLaser) { //Hay que cambiar el estado del laser
  		Control_Laser(Lista0_EstadoLaser[MicroVector]);
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
    	/////////////////////////////////////////////////////////////////////////////////////
  	xValuesPosicion = (long)xBitsDouble;
  	yValuesPosicion = (long)yBitsDouble;	
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el microvector: 
  	/////////////////////////////////////////////////////////////////////////////////////			
  
    	//if ((MicroVector == (Lista0_NumeroMicroVectores - 1)) || (Lista0_NumeroMicroVectores == 0)) {
  	if (MicroVector == (Lista0_NumeroMicroVectores - 1)) {
  	
  		Lista0_Exe = false;
  		ResetJumpList = false;	
  		
  		if (debug_listas) {
    		}
  		
  	}
  	
  	// Si no, incrementar en microvector
  	else {
  		MicroVector++;
  	}
  			
  	break;
  	
    
    	//rt_printk("Lista 1: MV=%ld\n", MicroVector);
  
  	// Si hay un retardo de disparo pendiente comprobarlo ahora
  	if ((MarcajeDinamicoActivo > 0) && ((RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional) > 0)	&& (EsperaRetardoDisparo == true)) {
  	
    		if ((int)IncrementoAcumulado < (RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional)) {
  	
  			return true;
  		
  		}
  	
    		else {
  	
  			IncrementoAcumulado = 0;
  			EsperaRetardoDisparo = false;
  		}	
  
  	}
  	
      	if (Estrategia == 2) {
  	
  			
  		// Si el valor del upbral es negativo tiene que superar -MaximoBits para poder imprimirse
  		if (Lista1_Umbral[MicroVector] < 0) {
  		
  			if ((Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) < -MaximoBits) {
  				
  				/*
  				if (ImprimirMV){
  					rt_printk("Espera umbral en Lista1 Microvector:%ld Umbral:%d Actual:%d\n", MicroVector, Lista1_Umbral[MicroVector], Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
  					ImprimirMV=false;
  				}
  				*/
  				
  				return true;
  		
  			}
  		
  		}
  		
  		// Si es positivo para proseguir tiene que ser menor que MaximoBits
  		else {
  		
  			if ((Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) > MaximoBits) {
  		
  				/*		
  				if (ImprimirMV){
  					rt_printk("Espera umbral en Lista1 Microvector:%ld Umbral:%d Actual:%d\n", MicroVector, Lista1_Umbral[MicroVector], Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
  					ImprimirMV=false;
  				}				
  				*/
  				
  				return true;
  		
  			}
  			
  		} 
  		
  		//ImprimirMV = true;
  	
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza los galvos: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	
  	xBitsDouble = (double)(Lista1_xBits[MicroVector]+(IncrementoAcumulado*Kx_Cuentas_a_Bits));
  	yBitsDouble = (double)(Lista1_yBits[MicroVector]+(IncrementoAcumulado*Ky_Cuentas_a_Bits));	
  	
  	// Coordenada X:
  	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vx) > VGalvoMax) {
  
  	    		rt_printk("ErrorCampo - Lista 1: MV=%ld Vx=%f mayor que VGalvoMax\n", MicroVector, fabs(Vx));
  		
  			ErroresConsecutivosCampoX++;
  		
    		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoX = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vx);
  
  		// escribe en el galvo X
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false; 
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo X
  		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
  		
  		break;
  	
  	} 
  	
  	// Coordenada Y:
  	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vy) > VGalvoMax) {
  		
  	    		rt_printk("ErrorCampo - Lista 1: MV=%ld Vy=%f mayor que VGalvoMax\n", MicroVector, fabs(Vy));
  
  			ErroresConsecutivosCampoY++;
  		
    		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoY = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vy);
  
  		// escribe en el galvo Y
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false;
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo Y
  		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
  		
  		break;
  	
  	} 		
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el laser: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	
  	if (Lista1_EstadoLaser[MicroVector] != EstadoLaser) { //Hay que cambiar el estado del laser
  		Control_Laser(Lista1_EstadoLaser[MicroVector]);		
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el tiempo de marca: 
  	/////////////////////////////////////////////////////////////////////////////////////			
  	
  	if (MicroVector == 0) {
  	
  		// Guarda el tiempo de inicio de la marca
  		tInicioMarca = rt_get_time_ns();
  		
  		// Guarda el tiempo de fin de la marca hasta ahora, para evitar tiempos negativos
  		tFinMarca = rt_get_time_ns();
  	
  	}				
  	
  	else {
  	
  		// Guarda el tiempo de fin de la marca hasta ahora
  		tFinMarca = rt_get_time_ns();
  
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
    	/////////////////////////////////////////////////////////////////////////////////////
  	xValuesPosicion = (long) xBitsDouble;
  	yValuesPosicion = (long) yBitsDouble;	
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el microvector: 
  	/////////////////////////////////////////////////////////////////////////////////////	
  		
    	if (MicroVector == (Lista1_NumeroMicroVectores - 1)) {
  		
  		// debug
  		if (debug_listas) {
    		}
  			
  		// Si es una prueba de marcaje reactivar el interfaz
  		if (PruebaMarcaje == true) {
  			
  			Lista1_Exe = false;
  		
  		}
  		
  		// Si no es una prueba es que se trata del bucle de marcaje:
  		else {
  
  			// Prepara el movimiento de los galvos al origen de la lista
  			//if (ResetJumpList == false) {
  			
  				// Calcula el movimiento de los galvos al inicio de la lista
  				//CalcularMoverGalvos(xValues[0], yValues[0]);
  
  			//}	
  			
    			if (MarcajeDinamicoActivo > 0) {
  				
  				IncrementoAcumulado = 0;
  				
  				// Hay que activar la siguiente espera de disparo
  				EsperaRetardoDisparo = true;
  				
  			}
  			
    			ControlMarkInProgress(OFF);
  		
  			// Calcula el movimiento de los galvos al inicio de la lista
  			CalcularMoverGalvos(xValues[0], yValues[0]);
  			
  			// Ahora ya detiene la lista actual y lanza el movimiento de los galvos
  			Lista1_Exe = false;
  			MicroVector = 0;
  			ResetJumpList = true;
  			Lista0_Exe = true;
  			
  		}
  		
  	}
  	
  	// Si no, incrementar el microvector
  	else {
  		MicroVector++;
  	}
  			
  	break;
  	
    	
  	// Si hay un retardo de disparo pendiente comprobarlo ahora
  	if ((MarcajeDinamicoActivo > 0) && ((RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional) > 0)	&& (EsperaRetardoDisparo == true)) {
  	
    		if ((int)IncrementoAcumulado < (RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional)) {
  	
  			return true;
  		
  		}
  	
    		else {
  	
  			IncrementoAcumulado = 0;
  			EsperaRetardoDisparo = false;
  		}	
  
  	}
  	
      	if (Estrategia == 2) {
  		
  		// Si el valor del umpbral es negativo tiene que superar -MaximoBits para poder imprimirse
  		if (Lista2_Umbral[MicroVector] < 0) {
  		
  			if ((Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) < -MaximoBits) {
  				
  				/*
  				if (ImprimirMV){
  					rt_printk("Espera umbral en Lista2 Microvector:%ld Umbral:%d Actual:%d\n", MicroVector, Lista2_Umbral[MicroVector], Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
  					ImprimirMV=false;
  				}
  				*/
  				
  				return true;
  		
  			}
  		
  		}
  		
  		// Si es positivo para proseguir tiene que ser menor que MaximoBits
  		else {
  		
  			if ((Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) > MaximoBits) {
  		
  				/*
  				if (ImprimirMV){
  					rt_printk("Espera umbral en Lista2 Microvector:%ld Umbral:%d Actual:%d\n", MicroVector, Lista2_Umbral[MicroVector], Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
  					ImprimirMV=false;
  				}
  				*/
  				
  				return true;
  		
  			}
  			
  		} 
  		
  		//ImprimirMV = true;
  	
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza los galvos: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	
  	xBitsDouble = (double)(Lista2_xBits[MicroVector]+(IncrementoAcumulado*Kx_Cuentas_a_Bits));
  	yBitsDouble = (double)(Lista2_yBits[MicroVector]+(IncrementoAcumulado*Ky_Cuentas_a_Bits));	
  				
  	// Coordenada X:
  	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vx) > VGalvoMax) {
  
  	    		rt_printk("ErrorCampo - Lista 2: MV=%ld Vx=%f mayor que VGalvoMax\n", MicroVector, fabs(Vx));
  		
  			ErroresConsecutivosCampoX++;
  		
    		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoX = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vx);
  
  		// escribe en el galvo X
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false; 
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo X
  		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
  		
  		break;
  	
  	} 
  	
  	// Coordenada Y:
  	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
  	
        	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) {
  
    		if (fabs(Vy) > VGalvoMax) {
  
  			rt_printk("ErrorCampo - Lista 2: MV=%ld Vy=%f mayor que VGalvoMax\n", MicroVector, fabs(Vy));
  
  			ErroresConsecutivosCampoY++;
  		
    		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) {
  	    			ErrorCampo = ON;
  	    			return false;
  	    		}
  	    	
  		}
  		
  		else {
  		
  			ErroresConsecutivosCampoY = 0;
  		
  		}
  	
  	}
  	
  	switch (Control) {
  
  	case DAQ:
  	
  		// Convierte los voltios en las unidades precisas para escribir en el driver
  		AOdata = itaca_comedi_from_phys(Vy);
  
  		// escribe en el galvo Y
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false;
  		}
  	
  		break;
  
  	case FPGA:
  
  		// escribe en el galvo Y
  		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
  		
  		break;
  	
  	} 		
  		
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el laser: 
  	/////////////////////////////////////////////////////////////////////////////////////
  	
  	if (Lista2_EstadoLaser[MicroVector] != EstadoLaser) { //Hay que cambiar el estado del laser
  		Control_Laser(Lista2_EstadoLaser[MicroVector]);		
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el tiempo de marca: 
  	/////////////////////////////////////////////////////////////////////////////////////			
  	
  	if (MicroVector == 0) {
  	
  		// Guarda el tiempo de inicio de la marca
  		tInicioMarca = rt_get_time_ns();
  		
  		// Guarda el tiempo de fin de la marca hasta ahora, para evitar tiempos negativos
  		tFinMarca = rt_get_time_ns();
  	
  	}				
  	
  	else {
  	
  		// Guarda el tiempo de fin de la marca hasta ahora
  		tFinMarca = rt_get_time_ns();
  
  	}
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
    	/////////////////////////////////////////////////////////////////////////////////////
  	xValuesPosicion = (long) xBitsDouble;
  	yValuesPosicion = (long) yBitsDouble;	
  	
  	/////////////////////////////////////////////////////////////////////////////////////		
  	// Actualiza el microvector: 
  	/////////////////////////////////////////////////////////////////////////////////////			
  		
    	if (MicroVector == (Lista2_NumeroMicroVectores - 1)) {
  		
  		// debug
  		if (debug_listas) {
    		}
  		
  		// Si es una prueba de marcaje reactivar el interfaz
  		if (PruebaMarcaje == true) {
  			
  			Lista2_Exe = false;
  		
  		}
  		
  		// Si no es una prueba es que se trata del bucle de marcaje:
  		else {				
  			
  			// Prepara el movimiento de los galvos al origen de la lista
  			//if (ResetJumpList == false) {
  			
  				// Calcula el movimiento de los galvos al inicio de la lista
  				//CalcularMoverGalvos(xValues[0], yValues[0]);
  			
  			//}
  			
    			if (MarcajeDinamicoActivo > 0) {
  				
  				IncrementoAcumulado = 0;
  				
  				// Hay que activar la siguiente espera de disparo
  				EsperaRetardoDisparo = true;
  				
  			}
  			
    			ControlMarkInProgress(OFF);
  			
  			// Calcula el movimiento de los galvos al inicio de la lista
  			CalcularMoverGalvos(xValues[0], yValues[0]);
  			
  			// Ahora ya detiene la lista actual y lanza el movimiento de los galvos
  			Lista2_Exe = false;
  			MicroVector = 0;
  			ResetJumpList = true;
  			Lista0_Exe = true;
  			
  		}	
  		
  	}
  	
  	// Si no, incrementar el microvector
  	else {
  		MicroVector++;
  	}
  	
  	break;
  
  default:
  	
      	ErrorVectores = ON;
  	rt_printk("EjecutarMicrovector: ErrorVectores\n");
  	return false;
  	break;
  
  }
  
  if ((debug_listas) && (error < 0)) {
    	return false;
  }
  
  if (debug_EjecucionMvectores) {
  
  	rt_printk("LISTA %d MV %ld\n", lista, MicroVector);
  }
  
    return true;
}

int ActualizarFechaHoraSerie() {
  static int error = false;
  static int actualizarlinea1bloque1, actualizarlinea1bloque2, actualizarlinea1bloque3;
  static int actualizarlinea2bloque1, actualizarlinea2bloque2, actualizarlinea2bloque3;
  static int actualizarlinea3bloque1, actualizarlinea3bloque2, actualizarlinea3bloque3;
  static int actualizarlinea4bloque1, actualizarlinea4bloque2, actualizarlinea4bloque3;
  
  static int statusfecha, statushora, statusnumeroserie;
  static char strFecha[LongitudMaximaStringFecha], tmpFecha[LongitudMaximaStringFecha];
  char strHora[LongitudMaximaStringHora], tmpHora[LongitudMaximaStringHora];
  static unsigned int i, j, k;
  
    static time_t curtime, tmptime;
  static struct tm *loctime;
  static struct tm *loctimelinea[NumeroLineasTexto][NumeroBloquesLinea];
  
    static time_t curtimeserie;
  static struct tm *loctimeserie;
  static char tmpfechaserie[LongitudMaximaStringFecha];
  
  //if (debug_camposvariables) {
  //	rt_printk("ActualizarFechaHoraSerie: \n");
  //}
   
    actualizarlinea1bloque1 = false;
  actualizarlinea1bloque2 = false;
  actualizarlinea1bloque3 = false;
  actualizarlinea2bloque1 = false;
  actualizarlinea2bloque2 = false;
  actualizarlinea2bloque3 = false;
  actualizarlinea3bloque1 = false;
  actualizarlinea3bloque2 = false;
  actualizarlinea3bloque3 = false;
  actualizarlinea4bloque1 = false;
  actualizarlinea4bloque2 = false;
  actualizarlinea4bloque3 = false;
  
  statusfecha = false;
  statushora = false;
  statusnumeroserie = false;
  
    for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		if (StatusFecha[i][j]) {statusfecha = true;}
  		if (StatusHora[i][j]) {statushora = true;}
  		if (StatusNumeroSerie[i][j]) {statusnumeroserie = true;}	
  	
  	}
  	
  }
  
    if ( !(statusfecha) && !(statushora) && !(statusnumeroserie) ) {
  	return 0;
  }
  
    if ((statusfecha) || (statushora)) {
  
  	// Get the current time
  	curtime = time (NULL);
       	
  	// Convert it to local time representation
  	loctime = localtime (&curtime);
  
  }
  
    for (i=0; i<NumeroLineasTexto; i++) {
  
  	for (j=0; j<NumeroBloquesLinea; j++) {
  	
  		// Fecha
  		if (StatusFecha[i][j]) {
  	
    			loctimelinea[i][j] = localtime (&curtime);
  		
         			if (Caducidad[i][j]) {
       	
         				loctimelinea[i][j]->tm_mon += Caducidad[i][j];
       		
  	     			// y recalcular la fecha
       				tmptime = mktime(loctimelinea[i][j]);
       				loctimelinea[i][j] = localtime (&tmptime);
       		
  	     		}
    
  			// Calcula el primer campo de la fecha formateada
  			switch (ValorFormatoFecha1[i][j]) {
  
  				case 0:	// " "
  				strcpy (tmpFecha, "");
  				break;
  	
  				case 1:	// DD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
  				break;
  	
  				case 2:	// DDD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 3:	// DIA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 4:	// MM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
  				break;
  	
  				case 5:	// MMM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 6:	// MES
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 7:	// AA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
  				break;
  			
  				case 8:	// AAAA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
  				break;
  			
  				case 9:	// SS
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
  				break;
  			
  				case 10:// DS 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
  				break;
  			
  				case 11:// JJ 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
  				break;		
  	
  			}
  		
  		
    			strcpy (strFecha, tmpFecha);
  			
    			if ((ValorSeparadorFecha[i][j] > 0) && (ValorFormatoFecha2[i][j] > 0)) {
  				strcat (strFecha, SeparadorFecha[ValorSeparadorFecha[i][j]]);
  			}	
  		
  			// Calcula el segundo campo de la fecha formateada
  			switch (ValorFormatoFecha2[i][j]) {
  
  				case 0:	// ""
  				strcpy (tmpFecha, "");
  				break;
  	
  				case 1:	// DD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
  				break;
  	
  				case 2:	// DDD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 3:	// DIA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 4:	// MM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
  				break;
  	
  				case 5:	// MMM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 6:	// MES
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 7:	// AA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
  				break;
  			
  				case 8:	// AAAA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
  				break;
  			
  				case 9:	// SS
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
  				break;
  			
  				case 10:// DS 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
  				break;
  			
  				case 11:// JJ 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
  				break;		
  	
  			}
  		
    			strcat (strFecha, tmpFecha);
  		
    			if ((ValorSeparadorFecha[i][j] > 0) && (ValorFormatoFecha3[i][j] > 0)) {
  				strcat (strFecha, SeparadorFecha[ValorSeparadorFecha[i][j]]);
  			}
  			
  			// Calcula el tercer campo de la fecha formateada
  			switch (ValorFormatoFecha3[i][j]) {
  
  				case 0:	// " "
  				strcpy (tmpFecha, "");
  				break;	
  	
  				case 1:	// DD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
  				break;
  	
  				case 2:	// DDD
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 3:	// DIA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 4:	// MM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
  				break;
  	
  				case 5:	// MMM
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 6:	// MES
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
    				for (k=0; k<strlen(tmpFecha); k++) {
  					tmpFecha[k] = Mayusculas(tmpFecha[k]);
  				}
  				break;
  			
  				case 7:	// AA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
  				break;
  			
  				case 8:	// AAAA
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
  				break;
  			
  				case 9:	// SS
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
  			
  				case 10:// DS 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
  				break;
  			
  				case 11:// JJ 
  				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
  				break;		
  	
  			}
  		
    			strcat (strFecha, tmpFecha);
  		
  			// Hay que ver si ha cambiado
  			if (strcmp(Fecha[i][j], strFecha)) {
  	
  				// Activa el flag de actualizar
  				//actualizarfecha = true;
  			
  				// Copia el nuevo valor en la variable global
  				strcpy(Fecha[i][j], strFecha);
  	
    				switch (i) {
  			
  				case 0:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea1bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea1bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea1bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 1:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea2bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea2bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea2bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 2:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea3bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea3bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea3bloque3 = true;
  						break;
  					}
  					
  					break;
  					
  				case 3:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea4bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea4bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea4bloque3 = true;
  						break;
  					}
  					
  					break;
  		
  				}
  		
  				if (debug_camposvariables) {
  		            		rt_printk("Actualizar Fecha[%d,%d] %s\n", i, j, Fecha[i][j]);
  	        	    	}   
  		
  			}
  		
  		}
  			
  		// Hora
  		if (StatusHora[i][j]) {
  	
  			// calcula el primer campo de la hora formateada
  			switch (ValorFormatoHora1[i][j]) {
  
  				case 0:	// " "
  				strcpy (tmpHora, "");
  				break;
  	
  				case 1:	// HH
  				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
  				break;
  	
  				case 2:	// hh
  				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
  				break;
  	
  				case 3:	// MM
  				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
  				break;
  			
  				case 4:	// SS
  				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
  				break;
  				
  				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
  				CalcularTurno(loctime, tmpHora);
  				break;
  				
  			}
  		
    			strcpy (strHora, tmpHora);
  		
  			if ((ValorSeparadorHora[i][j] > 0) && (ValorFormatoHora2[i][j] > 0)) {
  				strcat (strHora, SeparadorHora[ValorSeparadorHora[i][j]]);
  			}
  			
  			// calcula el segundo campo de la hora formateada
  			switch (ValorFormatoHora2[i][j]) {
  
  				case 0:	// ""
  				strcpy (tmpHora, "");
  				break;
  	
  				case 1:	// HH
  				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
  				break;
  	
  				case 2:	// hh
  				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
  				break;
  	
  				case 3:	// MM
  				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
  				break;
  			
  				case 4:	// SS
  				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
  				break;
  				
  				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
  				CalcularTurno(loctime, tmpHora);
  				break;
  	
  			}
  		
    			strcat (strHora, tmpHora);
  		
    			if ((ValorSeparadorHora[i][j] > 0) && (ValorFormatoHora3[i][j] > 0)) {
  				strcat (strHora, SeparadorHora[ValorSeparadorHora[i][j]]);
  			}
  			
  			// calcula el tercer campo de la hora formateada
  			switch (ValorFormatoHora3[i][j]) {
  
  				case 0:	// " "
  				strcpy (tmpHora, "");
  				break;
  	
  				case 1:	// HH
  				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
  				break;
  	
  				case 2:	// hh
  				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
  				break;
  	
  				case 3:	// MM
  				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
  				break;
  			
  				case 4:	// SS
  				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
  				break;
  				
  				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
  				CalcularTurno(loctime, tmpHora);
  				break;
  	
  			}
  		
    			strcat (strHora, tmpHora);
  		
  			// Hay que ver si ha cambiado
  			if (strcmp(Hora[i][j], strHora)) {
  	
  				// Activa el flag de actualizar
  				//actualizarhora = true;
  			
  				// Copia el nuevo valor en la variable global
  				strcpy(Hora[i][j], strHora);
  	
    				switch (i) {
  			
  				case 0:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea1bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea1bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea1bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 1:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea2bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea2bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea2bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 2:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea3bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea3bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea3bloque3 = true;
  						break;
  					}
  					
  					break;
  					
  				case 3:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea4bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea4bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea4bloque3 = true;
  						break;
  					}
  					
  					break;
  		
  				}
  				
  				if (debug_camposvariables) {
  	            			rt_printk("Actualizar Hora[%d,%d] %s\n", i, j, Hora[i][j]);
  	            		} 
  	            	
  			}
  	
  		}
  
    		if (StatusNumeroSerie[i][j]) {
  
    			if (EnEjecucion) {
  				
  				
  				// Get the current time
  				curtimeserie = time (NULL);
       	
  				// Convert it to local time representation
  				loctimeserie = localtime (&curtimeserie);
  				
  				strftime (tmpfechaserie, LongitudMaximaStringFecha, "%d", loctimeserie);
  				//strcpy(FechaInicioMarca,tmpfechaserie);
  				//rt_printk("FechaInicioMarca %s\n", FechaInicioMarca);
  				//rt_printk("TMPFECHASERIE %s\n", tmpfechaserie);
  				
  				// Hay lote
  				if (NumeroUnidadesLote[i][j] > 1) {
  				
    					NumeroUnidadesLoteActual[i][j]++;
  			
  					// mira a ver si ha terminado el lote
  					if (NumeroUnidadesLoteActual[i][j] > NumeroUnidadesLote[i][j]) {
  			
  						// activa el flag de actualizar
  						//actualizarserie = true;
  				
  						
    						if (ResetSerieFecha == 0){
  							NumeroSerie[i][j]++;
  					
  						}
  						else {
  							if (strcmp(tmpfechaserie,FechaInicioMarca)==0){
  							NumeroSerie[i][j]++;
  							}
  							else {
  							NumeroSerie[i][j]=NumeroSerieInicial[i][j];
  							strcpy(FechaInicioMarca,tmpfechaserie);
  							}
  						}
  						
  						// reinicia TempLote
  						NumeroUnidadesLoteActual[i][j] = 1;
  				
  					}
  			
  				}
  		
  				// No hay lote
  				else {
  			
  					// activa el flag de actualizar
  					//actualizarserie = true;
  					
  					
    					if (ResetSerieFecha == 0){
  						NumeroSerie[i][j]++;		
  						}
  					else {
  					//rt_printk("FechaInicioMarca %s\n", FechaInicioMarca);
  
  						if (strcmp(tmpfechaserie,FechaInicioMarca)==0){
  							NumeroSerie[i][j]++;
  							//rt_printk("FechaInicioMarca %s\n", FechaInicioMarca);
  						}
  						else {
  							NumeroSerie[i][j]=NumeroSerieInicial[i][j];
  							strcpy(FechaInicioMarca,tmpfechaserie);
  						}
  					}
  					
  				}
  		
  			}
  	
    			if (NumeroSerieFinal[i][j] > 0) {
  		
  				if (NumeroSerie[i][j] > NumeroSerieFinal[i][j]) {
  		
  					NumeroSerie[i][j] = NumeroSerieInicial[i][j];
  					sprintf(strNumeroSerie[i][j], "%0*ld", NumeroDigitosNumeroSerie[i][j], NumeroSerie[i][j]);
  			
  				}
  			
  			}
  		
  			// si ha cambiado el valor
  			//if (actualizarserie) {
  		
  				// Escribe el valor formateado en un string
  				sprintf(strNumeroSerie[i][j], "%0*ld", NumeroDigitosNumeroSerie[i][j], NumeroSerie[i][j]);
  	
    				switch (i) {
  			
  				case 0:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea1bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea1bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea1bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 1:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea2bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea2bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea2bloque3 = true;
  						break;
  					}
  					
  					break;
  				
  				case 2:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea3bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea3bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea3bloque3 = true;
  						break;
  					}
  					
  					break;
  					
  				case 3:
  					
  					switch(j) {
  					
  					case 0:
  						actualizarlinea4bloque1 = true;
  						break;
  					case 1:
  						actualizarlinea4bloque2 = true;
  						break;
  					case 2:
  						actualizarlinea4bloque3 = true;
  						break;
  					}
  					
  					break;
  		
  				}
  				
  				if (debug_camposvariables) {
  	            			rt_printk("Actualizar strNumeroSerie[%d,%d] %s\n", i, j, strNumeroSerie[i][j]);
  	            		} 
  		
  			//}
  	
  		}
  
  	}
  	
  }
  
  if ((actualizarlinea1bloque1)||(actualizarlinea1bloque2)||(actualizarlinea1bloque3)||(actualizarlinea2bloque1)||(actualizarlinea2bloque2)||(actualizarlinea2bloque3)||(actualizarlinea3bloque1)||(actualizarlinea3bloque2)||(actualizarlinea3bloque3)||(actualizarlinea4bloque1)||(actualizarlinea4bloque2)||(actualizarlinea4bloque3)) {
  
  	// Flag global
  	Actualizar = true;
  	
    	if (actualizarlinea1bloque1) {
  		LineaTexto_calcular(1,1);
  	}
  	
  	if (actualizarlinea1bloque2) {
  		LineaTexto_calcular(1,2);
  	}
  	
  	if (actualizarlinea1bloque3) {
  		LineaTexto_calcular(1,3);
  	}
  	
  	if (actualizarlinea2bloque1) {
  		LineaTexto_calcular(2,1);
  	}
  	
  	if (actualizarlinea2bloque2) {
  		LineaTexto_calcular(2,2);
  	}
  	
  	if (actualizarlinea2bloque3) {
  		LineaTexto_calcular(2,3);
  	}
  	
  	if (actualizarlinea3bloque1) {
  		LineaTexto_calcular(3,1);
  	}
  	
  	if (actualizarlinea3bloque2) {
  		LineaTexto_calcular(3,2);
  	}
  	
  	if (actualizarlinea3bloque3) {
  		LineaTexto_calcular(3,3);
  	}
  	
  	if (actualizarlinea4bloque1) {
  		LineaTexto_calcular(4,1);
  	}
  	
  	if (actualizarlinea4bloque2) {
  		LineaTexto_calcular(4,2);
  	}
  	
  	if (actualizarlinea4bloque3) {
  		LineaTexto_calcular(4,3);
  	}
  	
  	//actualizarfecha = false;
  	//actualizarhora = false;
  	//actualizarserie = false;
  
  }
  
  else {
  
  	// Flag global
  	Actualizar = false;
  
  }
  
  return error;
}

void CalcularTurno(struct tm *loctime, char* returnstr) {
    int hora, minuto, minutodia,i;
  char tmpstr[LongitudMaximaStringHora];
  
    strftime (tmpstr, LongitudMaximaStringHora, "%H", loctime);
  hora = atoi(tmpstr);
  
    strftime (tmpstr, LongitudMaximaStringHora, "%M", loctime);
  minuto = atoi(tmpstr);
  
    minutodia = (hora*60) + minuto;
  
  //rt_printk("Turno: %d:%d\n", hora, minuto);
  
    for (i=0; i<NumeroTurnos; i++) {
  
  	//rt_printk("Turno:%d minutodia:%d minutoinicio:%d minutofin:%d texto:%s\n", i+1, minutodia, MinutoDiaInicioTurno[i], MinutoDiaFinTurno[i], TextoTurno[i]);
  
  	if ((minutodia>=MinutoDiaInicioTurno[i]) && (minutodia<=MinutoDiaFinTurno[i])) {
  	
  		if (strlen(TextoTurno[i])) {
  			strcpy(returnstr, TextoTurno[i]);
  			//rt_printk("Turno:%d minutodia:%d minutoinicio:%d minutofin:%d texto:%s\n", i+1, minutodia, MinutoDiaInicioTurno[i], MinutoDiaFinTurno[i], TextoTurno[i]);
  		}
  		
  		return;
  
  	}
  
  }
  
    strcpy(returnstr, "");
  
  return;
}

int Mayusculas(char caracter) {
  // si es una letra acentuada hay que quitar el acento
  switch(caracter) {
  
        	strcpy(&caracter,"A");
  	break;
  	
        	strcpy(&caracter,"E");
  	break;
  	
        	strcpy(&caracter,"I");
  	break;
  	
        	strcpy(&caracter,"O");
  	break;
  	
        	strcpy(&caracter,"U");
  	break;
  	
  	default:
  	caracter = toupper(caracter);
  
  }
  
  return caracter;
}

int ObtenerPosicionActual() {
  int error = false;
      
    if (MovimientoInicialGalvos == 1){
  	xValuesPosicionMedida = 30000;
  	yValuesPosicionMedida = 30000;
  	return error;
  }
  
    if ((!ControlarErrorGalvos) || (Control == FPGA)) {
  
  	xValuesPosicionMedida = xValuesPosicion;
  	yValuesPosicionMedida = yValuesPosicion;
  	return error;
  	
  }
  
    switch (Control) {
  
  case DAQ:
  	
    	error = comedi_data_read(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionX, 0, AREF_GROUND, &AOdata);
  
  	if (error < 0) {
  			
  		rt_printk("ObtenerPosicionActual: comedi_data_read Posicion X error=%d\n",error);
  		ErrorDAQ = ON;
  		ProcesarError();  			
  	
  	}	
  
    	xValuesPosicionMedida = (long) (FactorPosicion * ((double)itaca_comedi_to_phys(AOdata) / Kx_Bits_a_Voltios));
  
  	//printf("X AOdata:%d xValuesPosicion:%ld\n", AOdata, xValuesPosicion);
  
    	error = comedi_data_read(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionY, 0, AREF_GROUND, &AOdata);
  
  	if (error < 0) {
  		
  		rt_printk("ObtenerPosicionActual: comedi_data_read Posicion Y error=%d\n",error);
  		ErrorDAQ = ON;
  		ProcesarError();  
  	
  	}	
  			
    	yValuesPosicionMedida = (long) (FactorPosicion * ((double)itaca_comedi_to_phys(AOdata) / Ky_Bits_a_Voltios));
  
  	
  	break;
  
  case FPGA:
  
  	// Leer la posiciÃ³n
    	dato = LeerPosicionGalvoX_FPGA();
  
    	xValuesPosicionMedida = (long) (FactorPosicion * ((double)FPGA_to_phys(dato) / Kx_Bits_a_Voltios));
  
  	//printf("X dato:%d xValuesPosicion:%ld\n", dato, xValuesPosicion);
  
    	dato = LeerPosicionGalvoY_FPGA();
  			
    	yValuesPosicionMedida = (long) (FactorPosicion * ((double)FPGA_to_phys(dato) / Ky_Bits_a_Voltios));
  
  	break;
  	
  } 		
  
  //printf("Y AOdata:%d yValuesPosicion:%ld\n", AOdata, yValuesPosicion);
  
  if (debug_posicion) {
    }
  
  // Comprueba los valores calculados
  if (xValuesPosicionMedida > MaximoBits) {
  	xValuesPosicionMedida = MaximoBits;
  	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
  }
  
  if (xValuesPosicionMedida < (-MaximoBits)) {
  	xValuesPosicionMedida = -MaximoBits;
  	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
  
  }
  
  if (yValuesPosicionMedida > MaximoBits) {
  	yValuesPosicionMedida = MaximoBits;
  	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
  }
  
  if (yValuesPosicionMedida < (-MaximoBits)) {
  	yValuesPosicionMedida = -MaximoBits;
  	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
  }
  
  return error;
}

int CalcularMoverGalvos(int xdestino, int ydestino) {
        
    unsigned int numeromicrovectores, i;
    
  long difX, difY;
  long errorX, errorY;
  
    if (!EnEjecucion) {
  
  	// Mide las coordenadas actuales y las devuelve en xValuesPosicionMedida e yValuesPosicionMedida
  	//if (Control != FPGA) {
  		ObtenerPosicionActual();
  	//}
  	
    	difX = (long)abs(xValuesPosicion - xValuesPosicionMedida);
  	difY = (long)abs(yValuesPosicion - yValuesPosicionMedida);
  
  	errorX = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)xValuesPosicion) + ToleranciaPosicionBits);
  	errorY = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)yValuesPosicion) + ToleranciaPosicionBits);
  
  	if (debug_posicion) {
  		rt_printk("CalcularMoverGalvos::difX=%ld errorX=%ld difY=%ld errorY=%ld\n", difX, errorX, difY, errorY);
  	}
  	
      	if (!((difX <= errorX) && (difY <= errorY))){ 
  
  	     	rt_printk("# Resetear coordenadas: de %d,%d a %d,%d\n", xValuesPosicion, yValuesPosicion, xValuesPosicionMedida, yValuesPosicionMedida);
  
  		xValuesPosicion = xValuesPosicionMedida;
  		yValuesPosicion = yValuesPosicionMedida;
  	
  	}
  
  }
  
      // Comprueba los valores calculados
  if (xdestino > MaximoBits) {
  	xdestino = MaximoBits;
  }
  
  if (xdestino < (-MaximoBits)) {
  	xdestino = -MaximoBits;
  
  }
  
  if (ydestino > MaximoBits) {
  	ydestino = MaximoBits;
  }
  
  if (ydestino < (-MaximoBits)) {
  	ydestino = -MaximoBits;
  }
  
  if (debug_posicion) {
       	rt_printk("CalcularMoverGalvos::Desde %d,%d hasta %d,%d\n", xValuesPosicion, yValuesPosicion, xdestino, ydestino);
  }
  
  // Calcula el incremento en bits de cada coordenada
  x = xdestino - xValuesPosicion;
  y = ydestino - yValuesPosicion;
  
  errorX = (int)(fabs(ToleranciaPosicionTantoPorUno * (float)xdestino) + ToleranciaPosicionBits);
  errorY = (int)(fabs(ToleranciaPosicionTantoPorUno * (float)ydestino) + ToleranciaPosicionBits);
  
    if ((fabs(x) <= errorX) && (fabs(y) <= errorY)){ 
  	
  	if (debug_posicion) {
         		rt_printk("CalcularMoverGalvos::Return sin mover nada\n");
  	}
  	
  	return 0;
  }
  
  // Abre la lista 0
  //result = Set_Start_List(0);
  Lista0_NumeroMicroVectores = 0;
  Lista0_Open = true;
  		
  // Descarga la lista 0:
  // Calcula la distancia al punto destino en bits
  distancia = sqrt(pow(x,2) + pow(y,2));
  
    angulo = atan2(y,x);
  	
    numeromicrovectores = (unsigned int) ceil((double)distancia/(double)JumpStepSize);
  
  if (debug_Mvectores) {
  	rt_printk("CalcularMoverGalvos::Microvectores Salto:%d \n", numeromicrovectores);
  }
  
    x = xValuesPosicion;
  y = yValuesPosicion;
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Calcula las coordenadas los microvectores
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  for (i=1; i<=numeromicrovectores; i++) {
  
  	// Siguiente coordenada: 
  	
    	if (i == numeromicrovectores) {
  		x = xdestino;
  		y = ydestino;
  	}
  	
    	else {
  		x = x + ((double)JumpStepSize * cos(angulo));
  		y = y + ((double)JumpStepSize * sin(angulo));
  	}
  	
    	
  	// Guarda los valores en la lista 0
  	Lista0_xBits[Lista0_NumeroMicroVectores] = (int)x;
  	Lista0_yBits[Lista0_NumeroMicroVectores] = (int)y;
  		
    	Lista0_EstadoLaser[Lista0_NumeroMicroVectores] = OFF;
  		
    	Lista0_NumeroMicroVectores++;
  	
    	if (Lista0_NumeroMicroVectores > NumeroMaximoMicroVectores) {
    		//StopEjecucion();
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  	
  
  } 
  
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // RETARDO DE SALTO
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
    numeromicrovectores = (unsigned int) ceil((double)RetardoSalto/(double)PERIODO_MICROSEGUNDOS);
  
  if (debug_Mvectores) {
  	rt_printk("CalcularMoverGalvos::Microvectores Retardo Salto:%d \n", numeromicrovectores);
  }
  
    for (i=1; i<=numeromicrovectores; i++) {
  	
  	// Guarda los valores
  	Lista0_xBits[Lista0_NumeroMicroVectores] = (int)x;
  	Lista0_yBits[Lista0_NumeroMicroVectores] = (int)y;
  		
    	Lista0_EstadoLaser[Lista0_NumeroMicroVectores] = OFF;
  		
    	Lista0_NumeroMicroVectores++;
  	
    	if (Lista0_NumeroMicroVectores > NumeroMaximoMicroVectores) {
    		//StopEjecucion();
  		ErrorVectores = ON;
  		ProcesarError();
  		return -1;
  	}
  	
  }
  
  if (debug_Mvectores) {
         	rt_printk("CalcularMoverGalvos::JUMP - lista 0:%ld \n", Lista0_NumeroMicroVectores-1);
  }
  
  // Cierra la lista 0
  Lista0_Open = false; 
  
  //for (i=0; i<Lista0_NumeroMicroVectores; i++) {
  //	rt_printk("Lista 0 MV:%d x=%d y=%d\n", i, Lista0_xBits[i], Lista0_yBits[i]);
  //}
  
  return 1;
}

void MoverGalvos() {
    // Previamente se han calculado los vectores en la lista 0 con CalcularMoverGalvos(x,y)
  // Ejecuta la lista 0 para mover los galvos
  
  ResetJumpList = true; // Para que no se utilicen las cuentas del encoder para actualizar coordenadas
  
  MicroVector = 0;	
  Lista0_Exe = true;
  	
    while ((Lista0_Exe) && (SistemaOk)) {
          	
  	// Espera un periodo (100 microsegundos)
         	Fl::wait(PERIODO_WAIT);
          	
  }
  
  //rt_printk("Lista 0 ejecutada MV=%d\n", MicroVector);
}

int ComprobarPosicion(int x_teorica, int y_teorica) {
    int errorPosicion;
  long difX, difY;
  long errorX, errorY;
  
  // Mide las coordenadas actuales y las devuelve en xValuesPosicionMedida e yValuesPosicionMedida
  ObtenerPosicionActual();
  
    difX = (long)abs(xValuesPosicion - xValuesPosicionMedida);
  difY = (long)abs(yValuesPosicion - yValuesPosicionMedida);
  
  errorX = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)xValuesPosicion) + ToleranciaPosicionBits);
  errorY = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)yValuesPosicion) + ToleranciaPosicionBits);
  
  if (debug_posicion) {
    }
  
    if ((difX <= errorX) && (difY <= errorY)) { 
  
  	errorPosicion = false;
  	
  }
  
    else {
        	
        	errorPosicion = true;
        	
    	
  }
  
  return errorPosicion;
}

void InicializarIndicadorHorizontal() {
    if (Centrado) {
  	IndicadorHorizontal->maximum((int)Semicampo);
  	IndicadorHorizontal->minimum((int)-Semicampo);
  }
  	
    else {
  
  	switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
                  
  		case -180:
  		case 180:
  			
    			if (Estrategia < 2){
  				IndicadorHorizontal->maximum(0);
  				IndicadorHorizontal->minimum(-Semicampo*2);
  			}
  			
  			// Si la estrategia es fuera de campo puede haber un offset horizontal positivo arbitrario
    			else {
  				IndicadorHorizontal->maximum(Semicampo*2);
  				IndicadorHorizontal->minimum(-RetardoDisparo_mm);
  			}
  		
        			break;
          
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		case 0:
  		case 360:
  			
    			if (Estrategia < 2){
  				IndicadorHorizontal->maximum(Semicampo*2);
  				IndicadorHorizontal->minimum(0);
  			}
  			
  			// Si la estrategia es fuera de campo puede haber un offset horizontal negativo arbitrario
    			else {
  				IndicadorHorizontal->maximum(RetardoDisparo_mm);
  				IndicadorHorizontal->minimum(-Semicampo*2);
  			}
  						
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
              	// Puede haber un offset horizontal positivo o negativo
  		case -270:
  		case 90:
  			
  			IndicadorHorizontal->maximum(Semicampo);
  			IndicadorHorizontal->minimum(-Semicampo);
              		
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
  		// Puede haber un offset horizontal positivo o negativo
  		case -90:
  		case 270:
  			
  			IndicadorHorizontal->maximum(Semicampo);
  			IndicadorHorizontal->minimum(-Semicampo);
              		
  			break;
  
          	}
          
  }
  
    if ( (Horizontal < IndicadorHorizontal->minimum()) || (Horizontal > IndicadorHorizontal->maximum()) ) {
  
  	Horizontal = 0;
  	IndicadorHorizontal->value(Horizontal);
  
  }
  
  if (debug_resto){
    }
}

void InicializarIndicadorVertical() {
    if (Centrado) {
  	IndicadorVertical->maximum(Semicampo);
  	IndicadorVertical->minimum(-Semicampo);
  }
  	
    else {
  
  	switch (Orientacion - Avance) {
                  
                  // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
  		// Puede haber un offset vertical positivo o negativo
  		case -180:
  		case 180:
  			
  			IndicadorVertical->maximum(Semicampo);
  			IndicadorVertical->minimum(-Semicampo);
  			
        			break;
          
          	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
  		// Puede haber un offset vertical positivo o negativo
  		case 0:
  		case 360:
  			
  			IndicadorVertical->maximum(Semicampo);
  			IndicadorVertical->minimum(-Semicampo);
  			
  			break;
              
              	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
    		case -270:
  		case 90:
  						
    			if (Estrategia < 2){
  				IndicadorVertical->maximum(0);
  				IndicadorVertical->minimum(-Semicampo*2);
  			}
  			
  			// Si la estrategia es fuera de campo puede haber un offset vertical positivo
    			else {
  				IndicadorVertical->maximum(Semicampo*2);
  				IndicadorVertical->minimum(-RetardoDisparo_mm);
  				
  			
  			}
              		
  			break;
  	
  		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
    		case -90:
  		case 270:
  			
    			if (Estrategia < 2){
  				IndicadorVertical->maximum(Semicampo*2);
  				IndicadorVertical->minimum(0);
  			}
  			
  			// Si la estrategia es fuera de campo puede haber un offset vertical negativo
    			else {
  				IndicadorVertical->maximum(RetardoDisparo_mm);
  				IndicadorVertical->minimum(-Semicampo*2);
  			}
  			
  			
              		
  			break;
  
          	}
          
  }
  
    if ( (Vertical < IndicadorVertical->minimum()) || (Vertical > IndicadorVertical->maximum()) ) {
  
  	Vertical = 0;
  	IndicadorVertical->value(Vertical);
  	
  }
  
  if (debug_resto){
    }
}

lsampl_t itaca_comedi_from_phys(double volts) {
    // Se asume un rango de -10V a +10V
  lsampl_t retval;
  
  retval = (lsampl_t) (((kFromPhysAO/10.0) * volts) + kFromPhysAO);
  
  if (debug_aodata) {
  
  	rt_printk("V:%f AOData:%d\n", volts, retval);
  
  }
  
  return retval;
}

double itaca_comedi_to_phys(lsampl_t dato) {
    // Se asume un rango de -10V a +10V
  double retval;
  
  //retval = (lsampl_t) (((kFromPhysAO/10.0) * volts) + kFromPhysAO);
  
  retval = (double) (((10.0/kFromPhysAO) * (double) dato ) - 10.0);
  
  if (debug_aodata) {
  
  	rt_printk("Dato:%d Volts:%f\n", dato, retval);
  
  }
  
  return retval;
}

lsampl_t itaca_comedi_reset(comedi_t *device, unsigned subdevice) {
  comedi_insn insn;
  lsampl_t data[1];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = 0;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_RESET;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

lsampl_t itaca_comedi_arm(comedi_t *device, unsigned subdevice, unsigned target) {
  comedi_insn insn;
  lsampl_t data[2];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = 0;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_ARM;
  data[1] = target;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

lsampl_t itaca_comedi_set_counter_mode(comedi_t *device, unsigned subdevice, unsigned channel, unsigned mode_bits) {
  comedi_insn insn;
  lsampl_t data[2];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = channel;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_SET_COUNTER_MODE;
  data[1] = mode_bits;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

lsampl_t itaca_comedi_set_clock_source(comedi_t *device, unsigned subdevice, unsigned clock, unsigned period_ns) {
  comedi_insn insn;
  lsampl_t data[3];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = 0;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_SET_CLOCK_SRC;
  data[1] = clock;
  data[2] = period_ns;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

lsampl_t itaca_comedi_set_gate_source(comedi_t *device, unsigned subdevice, unsigned channel,
	unsigned gate_index, unsigned gate_source) {
  comedi_insn insn;
  lsampl_t data[3];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = channel;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_SET_GATE_SRC;
  data[1] = gate_index;
  data[2] = gate_source;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

lsampl_t itaca_comedi_set_routing(comedi_t *device, unsigned subdevice, unsigned channel, unsigned routing) {
  comedi_insn insn;
  lsampl_t data[2];
  
  memset(&insn, 0, sizeof(comedi_insn));
  insn.insn = INSN_CONFIG;
  insn.subdev = subdevice;
  insn.chanspec = channel;
  insn.data = data;
  insn.n = sizeof(data) / sizeof(data[0]);
  data[0] = INSN_CONFIG_SET_ROUTING;
  data[1] = routing;
  
  if(comedi_do_insn(device, &insn) >= 0) return 0;
  else return -1;
}

void ActualizaUI(void *) {
  CuadroTextoVLinea->redraw();
}

void ActualizaControlAcceso(void *) {
  ControlAcceso = ON;
}

void ExitOrdenadamente() {
  // Si no hay error de DAQ/FPGA
  if ((ErrorDAQ == false) && (ErrorFPGA == false)) {
  
  	// Flag para desactivar el timer de estado
  	Apagar = true;
  
  	// espera para dar tiempo a salir al bucle de estado
  	usleep(100000);
  
  	//if ((Control == DAQ) || ((Control == FPGA) && (!debug_FPGA))) {
  	
    		Desactivar_Laser();
  	
  		// Lleva los galvos al origen
  		if (CalcularMoverGalvos(0, 0) > 0){
  			MoverGalvos();
  		}
  		
  	//}
  
  	switch (Control) {
  
  	case DAQ:
  	
  		// Libera los recursos de la tarjeta ni pci 6221
  		Desactivar_DAQ_comedi();
  
  		break;
  
  	case FPGA:
  
  		// Desprograma la FPGA
  		Desactivar_FPGA();	
  	
  		break;
  
  	}
  	
  	// Desactiva el timer RT
  	//if (!debug_FPGA) {
  	
  		// Desactiva el timer RT
  		Desactivar_RTAI();
  	
  	//}
  	
  	// Desactiva el thread de estado
  	if (!ENDESARROLLO) {
  		Desactivar_thread_estado();
  	}
  	
    	if (!ENDESARROLLO) {
  
  		// Desactiva el watchdog
  		write(fd_watchdog,"V",1);
  		close(fd_watchdog);
  	
  	}
  
  }
  	
  if (PuertoSerieActivo == ON) {
  	Desactivar_PuertoSerie();
  }
  
  if (ConfiguracionModificada) {
  
  	Escribir_Configuracion();
  	
  }
  
  rt_printk("\n################# FIN ########################\n\n");
  
  // sale del programa	
  exit(0);
}

void Inicializar_Widgets() {
  //////////////////////////////////////////////////////////////////////////////
  // Recarga el valor de los widgets de la ventana principal
  IndicadorPotencia->value(PotenciaLaser);
  IndicadorVelocidad->value(VelocidadMarcaje);
  
  InicializarIndicadorHorizontal();
  IndicadorHorizontal->value(Horizontal);
  InicializarIndicadorVertical();
  IndicadorVertical->value(Vertical);
  
  ChoiceFuente->value(ValorFuente);
  
  IndicadorAnchura->value(Anchura);
  IndicadorEspaciado->value(Espaciado);
  IndicadorSeparacion->value(SeparacionLineas);
  
  CheckJustificacionCentro->value(JustificacionCentro);
  CheckJustificacionIzquierda->value(JustificacionIzquierda);
  CheckJustificacionDerecha->value(JustificacionDerecha);
  
    
    
  // Bloque 1
  LineaCalcular=1; 
  BloqueCalcular=1; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  // Cuadro de texto de funcionalidad normal
  CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea1->deactivate();
  }
  IndicadorAlturaLinea1->value(AlturaLineaTexto1[BloqueCalcular-1]);
  BotonDetallesLinea1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea1->deactivate();
  }
  else {
  	CuadroTextoLinea1->activate();
  }
  	
  // Cuadro de texto de funcionalidad de bloques
  CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea1Bloque1->deactivate();
  }
  IndicadorAlturaLinea1Bloque1->value(AlturaLineaTexto1[BloqueCalcular-1]);
  BotonDetallesLinea1Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea1Bloque1->deactivate();
  }
  else {
  	CuadroTextoLinea1Bloque1->activate();
  }
  
  // Bloque 2
  LineaCalcular=1; 
  BloqueCalcular=2; 
  CargarTexto(); 
  ProcesarTexto(); 
  	
  CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea1Bloque2->deactivate();
  }
  IndicadorAlturaLinea1Bloque2->value(AlturaLineaTexto1[BloqueCalcular-1]);
  BotonDetallesLinea1Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea1Bloque2->deactivate();
  }
  else {
  	CuadroTextoLinea1Bloque2->activate();
  }
  
  // Bloque 3
  LineaCalcular=1; 
  BloqueCalcular=3; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea1Bloque3->deactivate();
  }
  IndicadorAlturaLinea1Bloque3->value(AlturaLineaTexto1[BloqueCalcular-1]);
  BotonDetallesLinea1Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea1Bloque3->deactivate();
  }
  else {
  	CuadroTextoLinea1Bloque3->activate();
  }
  
    
  // Bloque 1
  LineaCalcular=2; 
  BloqueCalcular=1; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  // Cuadro de texto de funcionalidad normal
  CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea2->deactivate();
  }
  IndicadorAlturaLinea2->value(AlturaLineaTexto2[BloqueCalcular-1]);
  BotonDetallesLinea2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea2->deactivate();
  }
  else {
  	CuadroTextoLinea2->activate();
  }
  // Cuadro de texto de funcionalidad de bloques
  CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea2Bloque1->deactivate();
  }
  IndicadorAlturaLinea2Bloque1->value(AlturaLineaTexto2[BloqueCalcular-1]);
  BotonDetallesLinea2Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea2Bloque1->deactivate();
  }
  else {
  	CuadroTextoLinea2Bloque1->activate();
  }
  
  // Bloque 2
  LineaCalcular=2; 
  BloqueCalcular=2; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea2Bloque2->deactivate();
  }
  IndicadorAlturaLinea2Bloque2->value(AlturaLineaTexto2[BloqueCalcular-1]);
  BotonDetallesLinea2Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea2Bloque2->deactivate();
  }
  else {
  	CuadroTextoLinea2Bloque2->activate();
  }
  
  // Bloque 3
  LineaCalcular=2; 
  BloqueCalcular=3; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea2Bloque3->deactivate();
  }
  IndicadorAlturaLinea2Bloque3->value(AlturaLineaTexto2[BloqueCalcular-1]);
  BotonDetallesLinea2Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea2Bloque3->deactivate();
  }
  else {
  	CuadroTextoLinea2Bloque3->activate();
  }
  
    
  // Bloque 1
  LineaCalcular=3; 
  BloqueCalcular=1; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  // Cuadro de texto de funcionalidad normal
  CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea3->deactivate();
  }
  IndicadorAlturaLinea3->value(AlturaLineaTexto3[BloqueCalcular-1]);
  BotonDetallesLinea3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea3->deactivate();
  }
  else {
  	CuadroTextoLinea3->activate();
  }
  
  // Cuadro de texto de funcionalidad de bloques
  CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea3Bloque1->deactivate();
  }
  IndicadorAlturaLinea3Bloque1->value(AlturaLineaTexto3[BloqueCalcular-1]);
  BotonDetallesLinea3Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea3Bloque1->deactivate();
  }
  else {
  	CuadroTextoLinea3Bloque1->activate();
  }
  
  // Bloque 2
  LineaCalcular=3; 
  BloqueCalcular=2; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea3Bloque2->deactivate();
  }
  IndicadorAlturaLinea3Bloque2->value(AlturaLineaTexto3[BloqueCalcular-1]);
  BotonDetallesLinea3Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea3Bloque2->deactivate();
  }
  else {
  	CuadroTextoLinea3Bloque2->activate();
  }
  
  // Bloque 3
  LineaCalcular=3; 
  BloqueCalcular=3; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea3Bloque3->deactivate();
  }
  IndicadorAlturaLinea3Bloque3->value(AlturaLineaTexto3[BloqueCalcular-1]);
  BotonDetallesLinea3Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea3Bloque3->deactivate();
  }
  else {
  	CuadroTextoLinea3Bloque3->activate();
  }
  
    
  // Bloque 1
  LineaCalcular=4; 
  BloqueCalcular=1; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  // Cuadro de texto de funcionalidad normal
  CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea4->deactivate();
  }
  IndicadorAlturaLinea4->value(AlturaLineaTexto4[BloqueCalcular-1]);
  BotonDetallesLinea4->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea4->deactivate();
  }
  else {
  	CuadroTextoLinea4->activate();
  }
  
  // Cuadro de texto de funcionalidad de bloques
  CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea4Bloque1->deactivate();
  }
  IndicadorAlturaLinea4Bloque1->value(AlturaLineaTexto4[BloqueCalcular-1]);
  BotonDetallesLinea4Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea4Bloque1->deactivate();
  }
  else {
  	CuadroTextoLinea4Bloque1->activate();
  }
  
  // Bloque 2
  LineaCalcular=4; 
  BloqueCalcular=2; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea4Bloque2->deactivate();
  }
  IndicadorAlturaLinea4Bloque2->value(AlturaLineaTexto4[BloqueCalcular-1]);
  BotonDetallesLinea4Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea4Bloque2->deactivate();
  }
  else {
  	CuadroTextoLinea4Bloque2->activate();
  }
  
  // Bloque 3
  LineaCalcular=4; 
  BloqueCalcular=3; 
  CargarTexto(); 
  ProcesarTexto(); 
  
  CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular-1]);
  if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
  	CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
  	CuadroTextoLinea4Bloque3->deactivate();
  }
  IndicadorAlturaLinea4Bloque3->value(AlturaLineaTexto4[BloqueCalcular-1]);
  BotonDetallesLinea4Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
  if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
  	CuadroTextoLinea4Bloque3->deactivate();
  }
  else {
  	CuadroTextoLinea4Bloque3->activate();
  }
}

int ValidarSistema() {
    // que en el archivo /etc/conf.d/itaca
  
  char strMacEth0[20], strMacEth1[20];	// strings para obtener las mac
  char strEth0[20], strEth1[20], *str; 	// strings auxiliares
  long long lMacEth0, lMacEth1;	// variables long para guardar las mac
  FILE *fp;
  long long valorcalculado, valorleido;
  char record[255], *dato;	/* array to hold each "record" */ 
  FILE *fichero;                  /* pointer to input file */
  
  // Obtiene los string de las Mac
  fp = popen("ifconfig eth0|grep HWaddr|awk '{print $5}'", "r");
  if (fp == NULL) {
  
    	rt_printk("Sistema NO Validado\n");
  	return 0;
  
  }
  
  fgets(strMacEth0, sizeof(strMacEth0)-1, fp);
  pclose(fp);
  
  fp = popen("ifconfig eth1|grep HWaddr|awk '{print $5}'", "r");
  if (fp == NULL) {
  
    	rt_printk("Sistema NO Validado\n");
  	return 0;
  
  }
  fgets(strMacEth1, sizeof(strMacEth1)-1, fp);
  pclose(fp);
  
  //rt_printk("str Mac eth0 = %s\nstr Mac eth1 = %s\n", strMacEth0, strMacEth1);
  
    strcpy(strEth0, "0x");
  str = strtok (strMacEth0, ":");
  strcat(strEth0, str);
  strcat(strEth0, strtok(NULL, ":"));
  strcat(strEth0, strtok(NULL, ":"));
  strcat(strEth0, strtok(NULL, ":"));
  strcat(strEth0, strtok(NULL, ":"));
  strcat(strEth0, strtok(NULL, ":"));
  
  strcpy(strEth1, "0x");
  str = strtok (strMacEth1, ":");
  strcat(strEth1, str);
  strcat(strEth1, strtok(NULL, ":"));
  strcat(strEth1, strtok(NULL, ":"));
  strcat(strEth1, strtok(NULL, ":"));
  strcat(strEth1, strtok(NULL, ":"));
  strcat(strEth1, strtok(NULL, ":"));
  
  //rt_printk("str eth0 = %s\n str eth1 = %s\n", strEth0, strEth1);
  
    lMacEth0 = (long long)(strtod(strEth0, NULL));
  lMacEth1 = (long long)(strtod(strEth1, NULL));
  
  valorcalculado = (lMacEth0 * 0x28660) + lMacEth1;
  
  //rt_printk("eth0 = %lld\n eth1 = %lld\n valor = %lld\n", lMacEth0, lMacEth1, valorcalculado);
  
      
  /* open the file to read */
  fichero = fopen("/etc/conf.d/itaca", "r");		
  
  if (fichero == NULL) {
  
    	rt_printk("Sistema NO Validado\n");
  	
    	return 0;
  
  }
  
  // Lee el valor
  fgets(record, sizeof(record), fichero);
  dato = strtok(record, "\t\n");
  //valorleido = (long long) (strtol(dato, NULL, 10));
  valorleido = atoll(dato);
  
  // cierra el archivo
  fclose(fichero);
  
  if (valorleido == valorcalculado) {
  
  	ErrorValidacion = false;
  	rt_printk("Sistema Validado\n");
  	return 1;
  
  }
  
  else {
  
  	ErrorValidacion = true;
  	ProcesarError();
  	rt_printk("Sistema NO Validado. Leido=%lld\n", valorleido);
  	return 0;
  
  }
}

short int FPGA_from_phys(double volts) {
      short retval;
  
  retval = (short) ((kFromPhysFPGA * volts) + (10.0 * kFromPhysFPGA));
  
  if (debug_aodata) {
  
  	rt_printk("V:%f FPGA_Data:%d\n", volts, retval);
  
  }
  
  return retval;
}

double FPGA_to_phys(short int dato) {
      double retval;
  
  retval = (double) (((double)dato/kFromPhysFPGA) - 1.0);
  
  if (debug_aodata) {
  
  	rt_printk("Dato:%d Volts:%f\n", dato, retval);
  
  }
  
  return retval;
}

void EscribirGalvoX_FPGA(short valor) {
    static short valoranterior=2048; // guarda el valor anterior, inicializando a 0V (valor 2048) (FPGA)
  BYTE LSB_byte, comando;
  //RTIME t0, t1;
  
  if (valor == valoranterior) {return;}
  
  // Si el salto es mayor que 0.1V (0.5%) = 205 bits (4096/20V) pon traza
  if ((valor - valoranterior) > 205) {
  
  	rt_printk("### Salto en X - Valor=%d Anterior=%d MV=%ld\n", valor, valoranterior, MicroVector);
  
  }
  
  // guarda el valor
  valoranterior = valor;
  
  // Escribe el byte menos significativo en el registro data
  LSB_byte = (unsigned char)(valor & 0x00FF);
  
  //t0=rt_get_cpu_time_ns();
  outb(LSB_byte, REGISTRO_DATA);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("%f ", float(t1-t0)/1000.0);
  
  // Manda el comando a la FPGA: 
    comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_X | ((valor >> 8) & 0x000F));
  
  //t0=rt_get_cpu_time_ns();
  outb(comando, REGISTRO_ADDR);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("t=%f\n", float(t1-t0)/1000.0);
}

void EscribirGalvoY_FPGA(short valor) {
    static short valoranterior=2048; // guarda el valor anterior, inicializando a 0V (valor 2048) (FPGA)
  BYTE LSB_byte, comando;
  //RTIME t0, t1;
  
  if (valor == valoranterior) {return;}
  
  // Si el salto es mayor que 0.1V (0.5%) = 205 bits (4096/20V) pon traza
  if ((valor - valoranterior) > 205) {
  
  	rt_printk("### Salto en Y - Valor=%d Anterior=%d MV=%ld\n", valor, valoranterior, MicroVector);
  
  }
  
  // guarda el valor
  valoranterior = valor;
  
  // Escribe el byte menos significativo en el registro data
  LSB_byte = (unsigned char)(valor & 0x00FF);
  
  //t0=rt_get_cpu_time_ns();
  outb(LSB_byte, REGISTRO_DATA);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("%f ", float(t1-t0)/1000.0);
  
  // Manda el comando a la FPGA: 
    comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_Y | ((valor >> 8) & 0x000F));
  
  //t0=rt_get_cpu_time_ns();
  outb(comando, REGISTRO_ADDR);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("t=%f\n", float(t1-t0)/1000.0);
}

short LeerPosicionGalvoX_FPGA() {
    unsigned short posicion;
  
  /*
  BYTE LSB_byte, MSB_byte;
  
  // Manda el comando a la FPGA
  outb(COMANDO_LEER_POSICION_GALVO_X_LSB, REGISTRO_ADDR);
  
  // Lee el byte menos significativo
  LSB_byte = inb(REGISTRO_DATA);
  
  // Manda el comando a la FPGA
  outb(COMANDO_LEER_POSICION_GALVO_X_MSB, REGISTRO_ADDR);
  
    MSB_byte = inb(REGISTRO_DATA);
  
  // Compone el valor final
  posicion = MSB_byte;
  posicion <<= 8;
  posicion += LSB_byte;
  */
  
  return posicion;
}

short LeerPosicionGalvoY_FPGA() {
    unsigned short posicion;
  
  /*
  BYTE LSB_byte, MSB_byte;
  
  // Manda el comando a la FPGA
  outb(COMANDO_LEER_POSICION_GALVO_Y_LSB, REGISTRO_ADDR);
  
  // Lee el byte menos significativo
  LSB_byte = inb(REGISTRO_DATA);
  
  // Manda el comando a la FPGA
  outb(COMANDO_LEER_POSICION_GALVO_Y_MSB, REGISTRO_ADDR);
  
    MSB_byte = inb(REGISTRO_DATA);
  
  // Compone el valor final
  posicion = MSB_byte;
  posicion <<= 8;
  posicion += LSB_byte;
  */
  
  return posicion;
}

unsigned short LeerCuentasEncoder_FPGA() {
  // Lee las cuentas del encoder
  unsigned short cuentas;
  //RTIME t0, t1;
  
  // Manda el comando a la FPGA
  // Con este comando se copia el valor de las cuentas del encoder en la FPGA (8 bits)
  
  //t0=rt_get_cpu_time_ns();
  outb(COMANDO_LEER_CUENTAS_ENCODER, REGISTRO_ADDR);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("Encoder outb:%f ", float(t1-t0)/1000.0);
  
  // Lee el byteo
  //t0=rt_get_cpu_time_ns();
  cuentas = inb(REGISTRO_DATA);
  //t1=rt_get_cpu_time_ns();
  //rt_printk("inb:%f\n", float(t1-t0)/1000.0);
  
  return cuentas;
}

float Maximo(float a, float b, float c) {
  float max;
  
  if (a > b) { max = a; }
  
  else { max = b; }
  
  if (c > max) { max = c; }
  
  return max;
}

int Iniciar_Oscilador_Fibra() {
  int error = false;
  
  // debug
  if (debug_resto){
  	printf("Entrando-----------------Inicializar_laser\n");
  }
  
    // ha definido al inicializar el control
  Laser_Up_Ticks = (unsigned short int)((PeriodoTrenPulsos*10*PotenciaLaser) + Clock_Period_ns / 2) / Clock_Period_ns;
  Laser_Down_Ticks = (unsigned short int)((PeriodoTrenPulsos*1000) + Clock_Period_ns / 2) / Clock_Period_ns - Laser_Up_Ticks;
  
  switch (Control) {
  
  case DAQ:
    			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_gate_source 0 laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  	
  			// configura el modo del contador
  			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_counter_mode laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// asigna el reloj: 20MHz clock
  			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
  			if (error < 0){
  				rt_printk("ERROR comedi_set_clock_source laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set initial counter value by writing to channel 0
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks inicial laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set "load a" register to the number of clock ticks the counter output should remain low
  			// by writing to channel 1.
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write down_ticks load a laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  
  			// set "load b" register to the number of clock ticks the counter output should remain high
  			// writing to channel 2 
  			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
  			if (error < 0){
  				rt_printk("ERROR comedi_data_write up_ticks load b laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  	
  			// arma el contador
  			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
  			if (error < 0){
  				rt_printk("ERROR comedi_arm laser\n");
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  			
    			error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, LOW);	
  			sleep(1);
  			error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);
  			
  			if(error < 0){
  			rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \n",error);
  			ErrorDAQ = ON;
  			ProcesarError();
  			}
  	break;
  
  case FPGA:
  
    	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
  
    	outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);
  
  	//rt_printk("Laser_Up_Ticks=%d	Laser_Down_Ticks=%d\n", Laser_Up_Ticks, Laser_Down_Ticks);
  
  	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
  	// if (laser_down_ticks == 0) {laser_down_ticks=1;}
  
    
  	// Ticks Laser Up:
  
  	// Byte menos significativo (LSB)
  	outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);
  
  	// comando LSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);
  
    	outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);
  
  	// comando MSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);
  
  	// Ticks Laser Down:
  
  	// Byte menos significativo (LSB)
  	outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);
  
  	// comando LSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);
  
    	outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);
  
  	// comando MSB
  	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);
  	
  	break;
  	
  } 
  
  // debug
  if (debug_resto){
  	printf("Saliendo-----------------Inicializar_laser\n");
  }
  
  return error;
}

int Llevar_Galvos_Origen() {
  int error = false;
  
  MovimientoInicialGalvos = 1;
  // Mover los galvos al origen
  		xValuesPosicion = 0;
  		yValuesPosicion = 0;
  		if (CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0){
  			MoverGalvos();
  		}
  		
  MovimientoInicialGalvos = 0;
  /*
  // escribe en el galvo X
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, 0, 1);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false; 
  		}
  
  
  
  // escribe en el galvo Y
  		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, 0, 1);
  		if (error < 0) {
  			rt_printk("comedi_data_write error=%d\n", error);
  		    	ErrorDAQ = ON; 
      			return false;
  		}
  */
  return error;
}

int CalcularCorreccionVector(int xsincorregir, int ysincorregir) {
  double xdeformada;
  double ydeformada;
  double xpincushion;
  double ypincushion;
  double factorcorreccionx;
  double factorcorrecciony;
  double angulox;
  double anguloy;
  double distanciabarrel;
  
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("xsincorregir:%d ysincorregir:%d\n", xsincorregir, ysincorregir);
  	
  }	
  
  
  angulox = xsincorregir*17*6.28/32768/360;
  anguloy = ysincorregir*17*6.28/32768/360;
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("ANGULOX:%f ANGULOY:%f\n", angulox, anguloy);	
  }
  
  //correccion pincushion
  xpincushion=4000*tan(angulox)*(1 + (117000/4000/cos(anguloy)));
  ypincushion=117000*tan(anguloy);
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("Xpincushion:%f Ypincushion:%f\n", xpincushion, ypincushion);
  	
  }
  
  //correccion barrel
  distanciabarrel=sqrt(pow(xpincushion/32678,2)+pow(ypincushion/32768,2));
  xdeformada=xpincushion*(1-(0.05*distanciabarrel));
  ydeformada=ypincushion*(1-(0.05*distanciabarrel));
  
  	factorcorreccionx=xdeformada/xsincorregir;
  	factorcorrecciony=ydeformada/ysincorregir;
  	
  if (xdeformada !=0) {
  	xcorregido=int(xsincorregir*xsincorregir/xdeformada);
  	}
  else {
  	xcorregido=0;
  }
  if (ydeformada!=0) {
  	ycorregido=int(ysincorregir*ysincorregir/ydeformada);
  	}
  else {
  	ycorregido=0;
  }
  
  
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  		//rt_printk(" X:%d Y:%d\n", xcorregido, ycorregido);	
  	
  }
  return 1;
}

int CalcularCorreccionMicrovector(double xsincorregirMV,double ysincorregirMV) {
  double xdeformadaMV;
  double ydeformadaMV;
  double xpincushionMV;
  double ypincushionMV;
  double factorcorreccionxMV;
  double factorcorreccionyMV;
  double anguloxMV;
  double anguloyMV;
  double distanciabarrelMV;
  
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("xsincorregirMV:%f ysincorregirMV:%f\n", xsincorregirMV, ysincorregirMV);
  	
  }	
  
  
  anguloxMV = xsincorregirMV*18*6.28/32768/360;
  anguloyMV = ysincorregirMV*18*6.28/32768/360;
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("ANGULOX:%f ANGULOY:%f\n", anguloxMV, anguloyMV);	
  }
  
  //correccion pincushion
  xpincushionMV=4000*tan(anguloxMV)*(1 + (110000/4000/cos(anguloyMV)));
  ypincushionMV=110000*tan(anguloyMV);
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  	//rt_printk("XpincushionMV:%f YpincushionMV:%f\n", xpincushionMV, ypincushionMV);
  	
  }
  
  //correccion barrel
  distanciabarrelMV=sqrt(pow(xpincushionMV/32678,2)+pow(ypincushionMV/32768,2));
  xdeformadaMV=xpincushionMV*(1-(0.05*distanciabarrelMV));
  ydeformadaMV=ypincushionMV*(1-(0.05*distanciabarrelMV));
  
  	factorcorreccionxMV=xdeformadaMV/xsincorregirMV;
  	factorcorreccionyMV=ydeformadaMV/ysincorregirMV;
  	
  if (xdeformadaMV !=0) {
  	xcorregidoMV=(xsincorregirMV*xsincorregirMV/xdeformadaMV);
  	}
  else {
  	xcorregidoMV=0;
  }
  if (ydeformadaMV!=0) {
  	ycorregidoMV=(ysincorregirMV*ysincorregirMV/ydeformadaMV);
  	}
  else {
  	ycorregidoMV=0;
  }
  
  
  if (debug_vectores) {	
  	//rt_printk("CalcularMatriz - Vectores: %ld\n", NumeroVectores);
  		
  		//rt_printk(" X:%f Y:%f\n", xcorregidoMV, ycorregidoMV);	
  	
  }
  return 1;
}

int Parar_Oscilador_Fibra() {
  int error = false;
  
  // Resetea el contador
  			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
  			if (error < 0){
  				rt_printk("ERROR comedi_reset laser %d\n", error);
  				ErrorDAQ = ON;
  				ProcesarError();
  				return -1;
  			}
  			return error;
}

Fl_Double_Window *VentanaPrincipal=(Fl_Double_Window *)0;

Fl_Box *LedLaser=(Fl_Box *)0;

Fl_Button *LedEstado=(Fl_Button *)0;

static void cb_LedEstado(Fl_Button* o, void*) {
  // Vuelve al estado inicial cuando se presiona el Led tras un error (rearma el sistema)
// Sólo si el error es de obturador, galvos, laser Ok,  
// Si es de RTAI o DAQ estará deshabilitado el botón

if (LedEstado->color() == (Fl_Color)1)  { // está rojo

	// Vuelve a poner el Led en verde
	LedEstado->color((Fl_Color)2); 	// Led verde
	LedEstado->redraw();		// Marca el Led para redraw
	
	// Actualiza el mensaje
	switch (Idioma) {
			
		case ESP:
		LedEstado->label("Sistema OK");
		break; 
			
		case ING:
		LedEstado->label("System OK");
		break;
			
		case ITA:
		LedEstado->label("Sistema OK");
		break;
			
	}
	  
	// Vuelve a activar los botones
	BotonMarcar->activate();
	BotonPrueba->activate();
	if (ServicioTecnico) {
		BotonLaser->activate();
		BotonCampo->activate();
	}
	
	// resetea el error de encoder
	ErrorEncoder = OFF;
	ContadorDisparosParado = 0;
	
	// resetea el error de campo
	ErrorCampo = OFF;
		
	// y actualiza el GUI
	Fl::flush();	

};
}

Fl_Box *LogoItacaVentanaPrincipal=(Fl_Box *)0;

Fl_Box *BoxVersionSW=(Fl_Box *)0;

Fl_Value_Output *CuadroTextoContador=(Fl_Value_Output *)0;

static void cb_CuadroTextoContador(Fl_Value_Output* o, void*) {
  o->value(Contador);
}

Fl_Value_Output *CuadroTextoVLinea=(Fl_Value_Output *)0;

Fl_Value_Output *CuadroTextoTMarca=(Fl_Value_Output *)0;

Fl_Group *GrupoControlIntensidad=(Fl_Group *)0;

Fl_Counter *IndicadorPotencia=(Fl_Counter *)0;

static void cb_IndicadorPotencia(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia la potencia
	PotenciaLaser = (int) o->value();

	// Inicializa de nuevo el láser, variando el tren de pulsos de acuerdo a la nueva potencia
	if ((!ErrorDAQ)&&(!ErrorFPGA)) {
		Inicializar_Laser();
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(PotenciaLaser);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorVelocidad=(Fl_Counter *)0;

static void cb_IndicadorVelocidad(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Por debajo de 500 la velocidad varía de 25 en 25, por encima de 100 en 100
	if (VelocidadMarcaje > 500) {
		
		o->step(100);
	
	} 
	
	else if (VelocidadMarcaje < 500) {
		
		o->step(25);
		
	}
	
	else { // es 500!
	
		if (o->value() > VelocidadMarcaje) { // Incrementa
			
			o->step(100);
			o->value(600);
						
	
		}
		
		else {	// Decrementa
		
			o->step(25);
			o->value(475);
		
		}
	
	}
	
	// Cambia la velocidad de marcaje
	VelocidadMarcaje = (int) o->value();
	
	// Recalcula el MarkStepSize
	CalcularMarkStepSize();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {
	
	// Restaura el valor original
	o->value(VelocidadMarcaje);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoControlMarca=(Fl_Group *)0;

Fl_Counter *IndicadorHorizontal=(Fl_Counter *)0;

static void cb_IndicadorHorizontal(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia la posición horizontal
	Horizontal = (int) o->value();	// en mm

	xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion);	// en bits
	
	// Habrá que volver a calcular los parámetros relacionados
	Inicializar_Marcaje();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Horizontal);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorVertical=(Fl_Counter *)0;

static void cb_IndicadorVertical(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia la posición vertical
	Vertical = (int) o->value();	// en mm

	yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits

	// Habrá que volver a calcular los parámetros relacionados
	Inicializar_Marcaje();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Vertical);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Choice *ChoiceFuente=(Fl_Choice *)0;

static void cb_ChoiceFuente(Fl_Choice* o, void*) {
  if (!ControlAcceso) {

	// Almacena el valor seleccionado en la variable ValorFuente
	ValorFuente = o->value();

	// Marca el archivo como no abierto
	ArchivoFuentesAbierto = false;
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(ValorFuente);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAnchura=(Fl_Counter *)0;

static void cb_IndicadorAnchura(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia la anchura de los caracteres
	Anchura = (int)o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Anchura);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorEspaciado=(Fl_Counter *)0;

static void cb_IndicadorEspaciado(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia el espaciado entre caracteres
	Espaciado = (int) o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Espaciado);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorSeparacion=(Fl_Counter *)0;

static void cb_IndicadorSeparacion(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	// Cambia la separación entre líneas
	SeparacionLineas = (float)o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionLineas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubgrupoJustificacion=(Fl_Group *)0;

Fl_Round_Button *CheckJustificacionCentro=(Fl_Round_Button *)0;

static void cb_CheckJustificacionCentro(Fl_Round_Button* o, void*) {
  if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionCentro = (int) o->value();

	JustificacionIzquierda = OFF;
	CheckJustificacionIzquierda->value(OFF);

	JustificacionDerecha = OFF;
	CheckJustificacionDerecha->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionCentro);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Round_Button *CheckJustificacionDerecha=(Fl_Round_Button *)0;

static void cb_CheckJustificacionDerecha(Fl_Round_Button* o, void*) {
  if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionDerecha = (int) o->value();

	JustificacionIzquierda = OFF;
	CheckJustificacionIzquierda->value(OFF);

	JustificacionCentro = OFF;
	CheckJustificacionCentro->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionDerecha);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Round_Button *CheckJustificacionIzquierda=(Fl_Round_Button *)0;

static void cb_CheckJustificacionIzquierda(Fl_Round_Button* o, void*) {
  if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionIzquierda = (int) o->value();

	JustificacionCentro = OFF;
	CheckJustificacionCentro->value(OFF);

	JustificacionDerecha = OFF;
	CheckJustificacionDerecha->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionIzquierda);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoControlTexto=(Fl_Group *)0;

Fl_Group *SubGrupoLinea1=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea1=(Fl_Output *)0;

static void cb_CuadroTextoLinea1(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea1=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea1(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto1[0] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea1=(Fl_Button *)0;

static void cb_BotonDetallesLinea1(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea2=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea2=(Fl_Output *)0;

static void cb_CuadroTextoLinea2(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea2=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea2(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto2[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea2=(Fl_Button *)0;

static void cb_BotonDetallesLinea2(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea3=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea3=(Fl_Output *)0;

static void cb_CuadroTextoLinea3(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea3=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea3(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto3[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea3=(Fl_Button *)0;

static void cb_BotonDetallesLinea3(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea4=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea4=(Fl_Output *)0;

static void cb_CuadroTextoLinea4(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea4=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea4(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto4[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea4=(Fl_Button *)0;

static void cb_BotonDetallesLinea4(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoControlTextoBloques=(Fl_Group *)0;

Fl_Group *SubGrupoLinea1Bloques=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea1Bloque1=(Fl_Output *)0;

static void cb_CuadroTextoLinea1Bloque1(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea1Bloque1=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea1Bloque1(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto1[0] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea1Bloque1=(Fl_Button *)0;

static void cb_BotonDetallesLinea1Bloque1(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea1Bloque2=(Fl_Output *)0;

static void cb_CuadroTextoLinea1Bloque2(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea1Bloque2=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea1Bloque2(Fl_Counter* o, void*) {
  if (!ControlAcceso) {
	
	AlturaLineaTexto1[1] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea1Bloque2=(Fl_Button *)0;

static void cb_BotonDetallesLinea1Bloque2(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;


	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea1Bloque3=(Fl_Output *)0;

static void cb_CuadroTextoLinea1Bloque3(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea1Bloque3=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea1Bloque3(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto1[2] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea1Bloque3=(Fl_Button *)0;

static void cb_BotonDetallesLinea1Bloque3(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea2Bloques=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea2Bloque1=(Fl_Output *)0;

static void cb_CuadroTextoLinea2Bloque1(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea2Bloque1=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea2Bloque1(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto2[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea2Bloque1=(Fl_Button *)0;

static void cb_BotonDetallesLinea2Bloque1(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea2Bloque2=(Fl_Output *)0;

static void cb_CuadroTextoLinea2Bloque2(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea2Bloque2=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea2Bloque2(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto2[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea2Bloque2=(Fl_Button *)0;

static void cb_BotonDetallesLinea2Bloque2(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea2Bloque3=(Fl_Output *)0;

static void cb_CuadroTextoLinea2Bloque3(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea2Bloque3=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea2Bloque3(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto2[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea2Bloque3=(Fl_Button *)0;

static void cb_BotonDetallesLinea2Bloque3(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea3Bloques=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea3Bloque1=(Fl_Output *)0;

static void cb_CuadroTextoLinea3Bloque1(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea3Bloque1=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea3Bloque1(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto3[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea3Bloque1=(Fl_Button *)0;

static void cb_BotonDetallesLinea3Bloque1(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea3Bloque2=(Fl_Output *)0;

static void cb_CuadroTextoLinea3Bloque2(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea3Bloque2=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea3Bloque2(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto3[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea3Bloque2=(Fl_Button *)0;

static void cb_BotonDetallesLinea3Bloque2(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea3Bloque3=(Fl_Output *)0;

static void cb_CuadroTextoLinea3Bloque3(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea3Bloque3=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea3Bloque3(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto3[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea3Bloque3=(Fl_Button *)0;

static void cb_BotonDetallesLinea3Bloque3(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *SubGrupoLinea4Bloques=(Fl_Group *)0;

Fl_Output *CuadroTextoLinea4Bloque1=(Fl_Output *)0;

static void cb_CuadroTextoLinea4Bloque1(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea4Bloque1=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea4Bloque1(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto4[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea4Bloque1=(Fl_Button *)0;

static void cb_BotonDetallesLinea4Bloque1(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea4Bloque2=(Fl_Output *)0;

static void cb_CuadroTextoLinea4Bloque2(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea4Bloque2=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea4Bloque2(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto4[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea4Bloque2=(Fl_Button *)0;

static void cb_BotonDetallesLinea4Bloque2(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Output *CuadroTextoLinea4Bloque3=(Fl_Output *)0;

static void cb_CuadroTextoLinea4Bloque3(Fl_Output*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *IndicadorAlturaLinea4Bloque3=(Fl_Counter *)0;

static void cb_IndicadorAlturaLinea4Bloque3(Fl_Counter* o, void*) {
  if (!ControlAcceso) {

	AlturaLineaTexto4[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Button *BotonDetallesLinea4Bloque3=(Fl_Button *)0;

static void cb_BotonDetallesLinea4Bloque3(Fl_Button*, void*) {
  if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Group *GrupoControlOperacion=(Fl_Group *)0;

Fl_Light_Button *BotonMarcar=(Fl_Light_Button *)0;

static void cb_BotonMarcar(Fl_Light_Button*, void*) {
  // Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaMarcar->show();
}

Fl_Light_Button *BotonPrueba=(Fl_Light_Button *)0;

static void cb_BotonPrueba(Fl_Light_Button*, void*) {
  // Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaPrueba->show();
}

Fl_Button *BotonStop=(Fl_Button *)0;

static void cb_BotonStop(Fl_Button*, void*) {
  // Ha sido ordenado desde el interfaz:
ModoImpresionSerie = false;

// Detiene la ejecución
StopEjecucion();


if (debug_listas) {
	rt_printk("\n>>>>>>>>>>>>DETENIDA EJECUCIÓN LISTA \n\n");
};
}

Fl_Button *BotonTrabajos=(Fl_Button *)0;

static void cb_BotonTrabajos(Fl_Button*, void*) {
  // Muestra la ventana de trabajos
CargarVentanaTrabajos();
}

Fl_Button *BotonTablaPrecorte=(Fl_Button *)0;

static void cb_BotonTablaPrecorte(Fl_Button*, void*) {
  // Muestra la ventana de repeticiones
VentanaPrincipal->deactivate();
CargarVentanaRepeticiones();
}

Fl_Button *BotonApagar=(Fl_Button *)0;

static void cb_BotonApagar(Fl_Button*, void*) {
  // Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaApagarSistema->show();
}

Fl_Light_Button *BotonLaser=(Fl_Light_Button *)0;

static void cb_BotonLaser(Fl_Light_Button* o, void*) {
  if (!ControlAcceso) {

	if (o->value() == ON) { // el usuario ha hecho click en el botón y lo ha activado, o sea que previamente estaba desactivado

		// Desactiva los botones de operaciones
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		BotonTrabajos->deactivate();
		CounterVelocidadLinea->deactivate();
		CounterEncoder->deactivate();
		BotonCampo->deactivate();
		BotonApagar->deactivate();
		BotonLaser->deactivate();
	
		// Activa el botón de Stop
		BotonStop->activate();
	
		// Actualiza el Led del láser a amarillo
		LedLaser->color(FL_YELLOW);
		LedLaser->redraw();	

		// Fuerza la actualización del interfaz
		Fl::flush();
	
		// Mover los galvos al origen
		xValuesPosicion = 0;
		yValuesPosicion = 0;
		if (CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0){
			MoverGalvos();
		}
							
		// Actualiza la señal de MarkInProgress y el Led del láser
		ControlMarkInProgress(ON);

		// Enciende el láser
		Control_Laser(ON);
	
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(OFF);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Light_Button *BotonCampo=(Fl_Light_Button *)0;

static void cb_BotonCampo(Fl_Light_Button* o, void*) {
  if (!ControlAcceso) {

	if (o->value() == ON) { // el usuario ha hecho click en el botón y lo ha activado, o sea que previamente estaba desactivado

		// Desactiva los grupos de control de intensidad, de marca y de texto
		GrupoControlIntensidad->deactivate();
		GrupoControlMarca->deactivate();
		GrupoControlTexto->deactivate();

		// Desactiva los botones de operaciones
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		BotonTrabajos->deactivate();
		CounterVelocidadLinea->deactivate();
		CounterEncoder->deactivate();
		BotonLaser->deactivate();
		BotonCampo->deactivate();
		BotonApagar->deactivate();

		// Activa el botón de stop
		BotonStop->activate();

		// Actualiza el led del láser
		LedLaser->color(FL_YELLOW);
		LedLaser->redraw();
		
		// Fuerza la actualización del interfaz	
		Fl::flush();
	
		// Calcula la matriz correspondiente al campo
		CalcularMatrizCampo();
		//Inicia Oscilador Fibra
		switch(TipoLaser){
		case 1:
		Iniciar_Oscilador_Fibra();
		sleep(1);
		break;
		}	
		// Mueve los galvos al inicio de la lista
		if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
			MoverGalvos();
		}
		
		// Activa el flag de prueba de marcaje
		PruebaMarcaje = true;
		ResetJumpList = false;

		// Descarga la lista 1
		DescargarLista(1);
		
		// Desactiva la espera del disparo de la fotocélula
		EsperaFotocelula = false;
	
		// Desactiva la espera del retardo de disparo
		EsperaRetardoDisparo = false;

		// Desactiva la espera de la separación entre disparos
		EsperaSeparacionEntreDisparos = false;

		// Desactiva las cuentas de marcaje dinámico 
		IncrementoAcumulado = 0;

		// Activa señal de MarkInProgress y el Led del láser
		ControlMarkInProgress(ON);

		// Ejecuta la lista 1
		MarcajeOk = true;
		EjecutarLista(1);
		
		// Espera a que termine la ejecución de la lista actual:
		while (((Lista1_Exe) || (Lista0_Exe)) && (PruebaMarcaje) && (SistemaOk)) {
        	
			// Espera un periodo
        		Fl::wait(PERIODO_WAIT);
        		
		}
		
		// Restaura el interfaz
		StopEjecucion();
		//Para Oscilador Fibra
		switch(TipoLaser){
		case 1:
		Parar_Oscilador_Fibra();
		break;
		}
		
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(OFF);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

};
}

Fl_Counter *CounterEncoder=(Fl_Counter *)0;

static void cb_CounterEncoder(Fl_Counter* o, void*) {
  // Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
CalibracionEncoder = o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Si está marcando habrá que volver a calcular la matriz
if (EnEjecucion) {Actualizar=true;}

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");
}

Fl_Counter *CounterVelocidadLinea=(Fl_Counter *)0;

static void cb_CounterVelocidadLinea(Fl_Counter* o, void*) {
  // Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
VelocidadLinea = o->value();

// Actualiza también el indicador en la parte de arriba de la pantalla
CuadroTextoVLinea->value(VelocidadLinea);

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Si está marcando habrá que volver a calcular la matriz
if (EnEjecucion) {Actualizar=true;}

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");
}

Fl_Counter *CounterRetardoDisparo=(Fl_Counter *)0;

static void cb_CounterRetardoDisparo(Fl_Counter* o, void*) {
  // Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
RetardoDisparo_mm = (int)o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Y los límites del desplazamiento horizontal y vertical
InicializarIndicadorHorizontal();
InicializarIndicadorVertical();

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");
}

Fl_Counter *CounterSeparacionEntreDisparos=(Fl_Counter *)0;

static void cb_CounterSeparacionEntreDisparos(Fl_Counter* o, void*) {
  // Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
SeparacionEntreDisparos_mm = (int)o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");
}

Fl_Button *BotonFPGA=(Fl_Button *)0;

static void cb_BotonFPGA(Fl_Button*, void*) {
  VentanaPrincipal->hide();
VentanaFPGA->show();
}

Fl_Button *BotonResetContador=(Fl_Button *)0;

static void cb_BotonResetContador(Fl_Button*, void*) {
  Contador = 0;
CuadroTextoContador->value(Contador);
}

int main(int argc, char **argv) {
    rt_printk("\n################# INICIO #####################\n");
  
  // Fija la apariencia plastic para todos los widgets
  Fl::scheme("plastic");
  
  // Elimina los recuadros de foco para todos los widgets
  Fl::visible_focus(OFF);
  
  // Inicializa variables de control de errores
  ErrorDAQ = OFF;
  ErrorFPGA = OFF;
  ErrorRTAI = OFF;
  ErrorGalvos = OFF;
  ErrorLaserOk = OFF;	
  ErrorTemperatura = OFF;
  ErrorExtractor = OFF;	
  ErrorVectores = OFF;
  ErrorWatchdog = OFF;	
  ErrorEncoder = OFF;
  SistemaOk = true;
  ConfiguracionModificada = false;
  ErrorValidacion = OFF;
  
    Leer_Configuracion();
  
  // leer datos de marcaje representados en el interfaz del archivo itaca.gui
  Leer_DAT("itaca.dat");
  
    Inicializar_Marcaje();
  
  // Crear las ventanas emergentes de confirmar/cancelar prueba de marcaje, marcar, 
    // y guardar trabajos
  
    Make_Window_Confirmar_Prueba();
  Make_Window_Confirmar_Marcar();
  Make_Window_Confirmar_Apagar();
  Make_Window_Modificar_Texto();
  Make_Window_Detalles_Linea();
  Make_Window_Trabajos();
  Make_Window_Password();
  Make_Window_Confirmar_CargarTrabajo();
  Make_Window_Confirmar_GuardarTrabajo();
  Make_Window_Repeticiones();
  Make_Window_Confirmar_BorrarTrabajo();
  
  if (debug_FPGA) {Make_Window_FPGA();}
  
  // Crear la ventana utilizada para presentar mensajes al usuario
  Make_Window_Mensaje();
  
  // Fija el locale del idioma elegido, para los mensajes de formateo de fechas
  switch (Idioma) {
  
  	case ESP:
  	setlocale(LC_TIME, "es_ES");
  	break;
  	
  	case ING:
  	setlocale(LC_TIME, "en_US");
  	break;
  	
  	case ITA:
  	setlocale(LC_TIME, "it_IT");
  	break;
  	
  }
  { VentanaPrincipal = new Fl_Double_Window(800, 600);
    VentanaPrincipal->color(FL_BACKGROUND2_COLOR);
    VentanaPrincipal->selection_color(FL_BACKGROUND2_COLOR);
    VentanaPrincipal->labelcolor(FL_INACTIVE_COLOR);
    VentanaPrincipal->when(FL_WHEN_CHANGED);
    { Fl_Box* o = LedLaser = new Fl_Box(165, 3, 27, 27, "L\301SER ");
      LedLaser->box(FL_OFLAT_BOX);
      LedLaser->color((Fl_Color)30);
      LedLaser->labeltype(FL_NO_LABEL);
      LedLaser->labelfont(8);
      LedLaser->labelsize(15);
      LedLaser->align(Fl_Align(192|FL_ALIGN_INSIDE));
      LedLaser->when(FL_WHEN_CHANGED);
      o->color(FL_DARK3); // inicialización
      switch (Idioma) {case ESP:o->label("LÁSER");break; case ING:o->label("LASER");break; case ITA:o->label("LASER");break;}
    } // Fl_Box* LedLaser
    { Fl_Button* o = LedEstado = new Fl_Button(10, 3, 150, 27, "Sistema Ok");
      LedEstado->box(FL_RFLAT_BOX);
      LedEstado->down_box(FL_RFLAT_BOX);
      LedEstado->color(FL_GREEN);
      LedEstado->labelfont(8);
      LedEstado->labelsize(13);
      LedEstado->callback((Fl_Callback*)cb_LedEstado);
      LedEstado->align(Fl_Align(192|FL_ALIGN_INSIDE));
      //o->label("Sistema Ok"); //inicialización
      switch (Idioma) {case ESP:o->label("Sistema Ok");break; case ING:o->label("System Ok");break; case ITA:o->label("Sistema Ok");break;}
    } // Fl_Button* LedEstado
    { LogoItacaVentanaPrincipal = new Fl_Box(631, 0, 165, 65);
      LogoItacaVentanaPrincipal->color(FL_BACKGROUND2_COLOR);
      LogoItacaVentanaPrincipal->image(image_fls);
      LogoItacaVentanaPrincipal->labelsize(12);
      LogoItacaVentanaPrincipal->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
    } // Fl_Box* LogoItacaVentanaPrincipal
    { BoxVersionSW = new Fl_Box(630, 60, 165, 15, "Itaca v6.0");
      BoxVersionSW->labelfont(8);
      BoxVersionSW->labelsize(10);
      BoxVersionSW->labelcolor((Fl_Color)5);
      BoxVersionSW->align(Fl_Align(224|FL_ALIGN_INSIDE));
      // #ifdef _68pines BoxVersionSW->label("Itaca v2.0.68p"); #else BoxVersionSW->label("Itaca v2.0"); #endif
      // La línea comentada arriba está en la post inicialización, porque fluid no maneja bien las
      // directivas del preprocesador
    } // Fl_Box* BoxVersionSW
    { Fl_Value_Output* o = CuadroTextoContador = new Fl_Value_Output(250, 3, 70, 27, "Marcas");
      CuadroTextoContador->box(FL_RFLAT_BOX);
      CuadroTextoContador->color(FL_DARK1);
      CuadroTextoContador->labelfont(8);
      CuadroTextoContador->labelsize(12);
      CuadroTextoContador->textfont(8);
      CuadroTextoContador->textsize(12);
      CuadroTextoContador->callback((Fl_Callback*)cb_CuadroTextoContador);
      o->precision(0); o->value(Contador); //inicialización
      //if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico
      switch (Idioma) {case ESP:o->label("Marcas");break; case ING:o->label("Marks");break; case ITA:o->label("Stampe");break;}
    } // Fl_Value_Output* CuadroTextoContador
    { Fl_Value_Output* o = CuadroTextoVLinea = new Fl_Value_Output(570, 3, 50, 27, "V L\355nea");
      CuadroTextoVLinea->box(FL_RFLAT_BOX);
      CuadroTextoVLinea->color(FL_DARK1);
      CuadroTextoVLinea->labelfont(8);
      CuadroTextoVLinea->labelsize(11);
      CuadroTextoVLinea->textfont(8);
      CuadroTextoVLinea->textsize(11);
      o->precision(1); //inicialización
      //if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico
      switch (Idioma) {case ESP:o->label("V Línea");break; case ING:o->label("Line Speed");break; case ITA:o->label("V linea");break;}
    } // Fl_Value_Output* CuadroTextoVLinea
    { Fl_Value_Output* o = CuadroTextoTMarca = new Fl_Value_Output(430, 3, 60, 27, "Tmark");
      CuadroTextoTMarca->box(FL_RFLAT_BOX);
      CuadroTextoTMarca->color(FL_DARK1);
      CuadroTextoTMarca->labelfont(8);
      CuadroTextoTMarca->labelsize(11);
      CuadroTextoTMarca->textfont(8);
      CuadroTextoTMarca->textsize(11);
      o->precision(2); //inicialización
      if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico
      switch (Idioma) {case ESP:o->label("Tmarca");break; case ING:o->label("Tmark");break; case ITA:o->label("Tmark");break;}
    } // Fl_Value_Output* CuadroTextoTMarca
    { Fl_Group* o = GrupoControlIntensidad = new Fl_Group(10, 35, 180, 120);
      GrupoControlIntensidad->box(FL_PLASTIC_DOWN_BOX);
      GrupoControlIntensidad->color((Fl_Color)170);
      GrupoControlIntensidad->selection_color(FL_BACKGROUND2_COLOR);
      GrupoControlIntensidad->labeltype(FL_NO_LABEL);
      GrupoControlIntensidad->labelsize(10);
      GrupoControlIntensidad->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Counter* o = IndicadorPotencia = new Fl_Counter(20, 60, 160, 30, "Potencia (%)");
        IndicadorPotencia->type(1);
        IndicadorPotencia->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorPotencia->color(FL_INACTIVE_COLOR);
        IndicadorPotencia->selection_color(FL_LIGHT3);
        IndicadorPotencia->labelfont(8);
        IndicadorPotencia->labelsize(15);
        IndicadorPotencia->minimum(1);
        IndicadorPotencia->maximum(100);
        IndicadorPotencia->step(1);
        IndicadorPotencia->value(50);
        IndicadorPotencia->textfont(8);
        IndicadorPotencia->textsize(15);
        IndicadorPotencia->callback((Fl_Callback*)cb_IndicadorPotencia);
        IndicadorPotencia->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        IndicadorPotencia->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(PotenciaLaser); //inicialización
        if (o->value() == 0) {o->value(1);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Potencia (%)");break; case ING:o->label("Power (%)");break; case ITA:o->label("Potenza (%)");break;}
      } // Fl_Counter* IndicadorPotencia
      { Fl_Counter* o = IndicadorVelocidad = new Fl_Counter(20, 115, 160, 30, "Velocidad (mm/s)");
        IndicadorVelocidad->type(1);
        IndicadorVelocidad->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorVelocidad->color(FL_INACTIVE_COLOR);
        IndicadorVelocidad->labelfont(8);
        IndicadorVelocidad->labelsize(15);
        IndicadorVelocidad->minimum(25);
        IndicadorVelocidad->maximum(20000);
        IndicadorVelocidad->step(100);
        IndicadorVelocidad->value(1000);
        IndicadorVelocidad->textfont(8);
        IndicadorVelocidad->textsize(15);
        IndicadorVelocidad->callback((Fl_Callback*)cb_IndicadorVelocidad);
        IndicadorVelocidad->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        IndicadorVelocidad->when(3);
        o->value(VelocidadMarcaje); //inicialización
        if (VelocidadMarcaje > 500) {o->step(100);} else {o->step(25);} // Por debajo de 500 varía de 25 en 25
        if (o->value() == 0) {o->value(25);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Velocidad (mm/s)");break; case ING:o->label("Speed (mm/s)");break; case ITA:o->label("Velocità (mm/s)");break;}
      } // Fl_Counter* IndicadorVelocidad
      //if (ControlAcceso) {o->deactivate();}
      GrupoControlIntensidad->end();
    } // Fl_Group* GrupoControlIntensidad
    { Fl_Group* o = GrupoControlMarca = new Fl_Group(10, 160, 180, 435);
      GrupoControlMarca->box(FL_PLASTIC_DOWN_BOX);
      GrupoControlMarca->color((Fl_Color)36);
      GrupoControlMarca->selection_color(FL_BACKGROUND2_COLOR);
      GrupoControlMarca->labeltype(FL_NO_LABEL);
      GrupoControlMarca->labelsize(10);
      GrupoControlMarca->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Counter* o = IndicadorHorizontal = new Fl_Counter(20, 185, 160, 30, "Horizontal (mm)");
        IndicadorHorizontal->type(1);
        IndicadorHorizontal->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorHorizontal->color(FL_INACTIVE_COLOR);
        IndicadorHorizontal->labelfont(8);
        IndicadorHorizontal->labelsize(15);
        IndicadorHorizontal->minimum(-1000);
        IndicadorHorizontal->maximum(1000);
        IndicadorHorizontal->step(1);
        IndicadorHorizontal->textfont(8);
        IndicadorHorizontal->textsize(15);
        IndicadorHorizontal->callback((Fl_Callback*)cb_IndicadorHorizontal);
        IndicadorHorizontal->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        IndicadorHorizontal->when(FL_WHEN_RELEASE_ALWAYS);
        InicializarIndicadorHorizontal(); // fija el máximo y el míinimo
        o->value(Horizontal); //inicialización
        xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion); // en bits
        switch (Idioma) {case ESP:o->label("Horizontal (mm)");break; case ING:o->label("Horizontal (mm)");break; case ITA:o->label("Orizzontale (mm)");break;}
      } // Fl_Counter* IndicadorHorizontal
      { Fl_Counter* o = IndicadorVertical = new Fl_Counter(20, 235, 160, 30, "Vertical (mm)");
        IndicadorVertical->type(1);
        IndicadorVertical->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorVertical->color(FL_INACTIVE_COLOR);
        IndicadorVertical->labelfont(8);
        IndicadorVertical->labelsize(15);
        IndicadorVertical->minimum(-1000);
        IndicadorVertical->maximum(1000);
        IndicadorVertical->step(1);
        IndicadorVertical->textfont(8);
        IndicadorVertical->textsize(15);
        IndicadorVertical->callback((Fl_Callback*)cb_IndicadorVertical);
        IndicadorVertical->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        IndicadorVertical->when(FL_WHEN_RELEASE_ALWAYS);
        InicializarIndicadorVertical(); // fija el máximo y el mínimo
        o->value(Vertical); //inicialización
        yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits
        switch (Idioma) {case ESP:o->label("Vertical (mm)");break; case ING:o->label("Vertical (mm)");break; case ITA:o->label("Verticale (mm)");break;}
      } // Fl_Counter* IndicadorVertical
      { Fl_Choice* o = ChoiceFuente = new Fl_Choice(20, 289, 160, 30, "Fuente");
        ChoiceFuente->box(FL_PLASTIC_THIN_UP_BOX);
        ChoiceFuente->down_box(FL_PLASTIC_THIN_DOWN_BOX);
        ChoiceFuente->selection_color(FL_YELLOW);
        ChoiceFuente->labelfont(8);
        ChoiceFuente->labelsize(15);
        ChoiceFuente->textfont(8);
        ChoiceFuente->textsize(15);
        ChoiceFuente->callback((Fl_Callback*)cb_ChoiceFuente);
        ChoiceFuente->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        ChoiceFuente->when(FL_WHEN_RELEASE_ALWAYS);
        int i; for (i=0; i<NumeroFuentes; i++) {o->add(Fuentes[Idioma][i]);}//inicialización
        o->value(ValorFuente); // carga el valor inicial
        switch (Idioma) {case ESP:o->label("Fuente");break; case ING:o->label("Font");break; case ITA:o->label("Fonte");break;}
      } // Fl_Choice* ChoiceFuente
      { Fl_Counter* o = IndicadorAnchura = new Fl_Counter(20, 345, 160, 30, "Anchura (%)");
        IndicadorAnchura->type(1);
        IndicadorAnchura->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorAnchura->color(FL_INACTIVE_COLOR);
        IndicadorAnchura->labelfont(8);
        IndicadorAnchura->labelsize(15);
        IndicadorAnchura->minimum(1);
        IndicadorAnchura->maximum(200);
        IndicadorAnchura->step(1);
        IndicadorAnchura->value(100);
        IndicadorAnchura->textfont(8);
        IndicadorAnchura->textsize(15);
        IndicadorAnchura->callback((Fl_Callback*)cb_IndicadorAnchura);
        IndicadorAnchura->align(Fl_Align(133));
        IndicadorAnchura->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(Anchura); //inicialización
        if (o->value() == 0) {o->value(100);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Anchura (%)");break; case ING:o->label("Width (%)");break; case ITA:o->label("Larghezza (%)");break;}
      } // Fl_Counter* IndicadorAnchura
      { Fl_Counter* o = IndicadorEspaciado = new Fl_Counter(20, 400, 160, 30, "Espaciado (%)");
        IndicadorEspaciado->type(1);
        IndicadorEspaciado->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorEspaciado->color(FL_INACTIVE_COLOR);
        IndicadorEspaciado->labelfont(8);
        IndicadorEspaciado->labelsize(15);
        IndicadorEspaciado->minimum(1);
        IndicadorEspaciado->maximum(200);
        IndicadorEspaciado->step(1);
        IndicadorEspaciado->value(100);
        IndicadorEspaciado->textfont(8);
        IndicadorEspaciado->textsize(15);
        IndicadorEspaciado->callback((Fl_Callback*)cb_IndicadorEspaciado);
        IndicadorEspaciado->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        IndicadorEspaciado->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(Espaciado); //inicialización
        if (o->value() == 0) {o->value(100);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Espaciado (%)");break; case ING:o->label("Spacing (%)");break; case ITA:o->label("Spaziatura (%)");break;}
      } // Fl_Counter* IndicadorEspaciado
      { Fl_Counter* o = IndicadorSeparacion = new Fl_Counter(20, 455, 160, 30, "Entre l\355neas (mm)");
        IndicadorSeparacion->type(1);
        IndicadorSeparacion->box(FL_PLASTIC_THIN_UP_BOX);
        IndicadorSeparacion->color(FL_INACTIVE_COLOR);
        IndicadorSeparacion->labelfont(8);
        IndicadorSeparacion->labelsize(15);
        IndicadorSeparacion->minimum(0.1);
        IndicadorSeparacion->maximum(10);
        IndicadorSeparacion->value(1);
        IndicadorSeparacion->textfont(8);
        IndicadorSeparacion->textsize(15);
        IndicadorSeparacion->callback((Fl_Callback*)cb_IndicadorSeparacion);
        IndicadorSeparacion->align(Fl_Align(133));
        IndicadorSeparacion->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(SeparacionLineas); //inicialización
        if (o->value() == 0) {o->value(1.0);} // No puede valer 0
        switch (Idioma) {case ESP:o->label("Entre líneas (mm)");break; case ING:o->label("Betw. lines (mm)");break; case ITA:o->label("Dist. linee (mm)");break;}
      } // Fl_Counter* IndicadorSeparacion
      { Fl_Group* o = SubgrupoJustificacion = new Fl_Group(20, 510, 160, 75, "Justificaci\363n");
        SubgrupoJustificacion->box(FL_PLASTIC_UP_FRAME);
        SubgrupoJustificacion->color(FL_DARK3);
        SubgrupoJustificacion->labelfont(8);
        SubgrupoJustificacion->labelsize(15);
        SubgrupoJustificacion->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        { Fl_Round_Button* o = CheckJustificacionCentro = new Fl_Round_Button(30, 540, 125, 15, " Centro");
          CheckJustificacionCentro->down_box(FL_PLASTIC_DOWN_BOX);
          CheckJustificacionCentro->color(FL_FOREGROUND_COLOR);
          CheckJustificacionCentro->labelfont(8);
          CheckJustificacionCentro->labelsize(15);
          CheckJustificacionCentro->callback((Fl_Callback*)cb_CheckJustificacionCentro);
          CheckJustificacionCentro->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(JustificacionCentro); //inicialización
          switch (Idioma) {case ESP:o->label("Centro");break; case ING:o->label("Center");break; case ITA:o->label("Centro");break;}
        } // Fl_Round_Button* CheckJustificacionCentro
        { Fl_Round_Button* o = CheckJustificacionDerecha = new Fl_Round_Button(30, 560, 125, 15, " Derecha");
          CheckJustificacionDerecha->down_box(FL_PLASTIC_DOWN_BOX);
          CheckJustificacionDerecha->color(FL_FOREGROUND_COLOR);
          CheckJustificacionDerecha->labelfont(8);
          CheckJustificacionDerecha->labelsize(15);
          CheckJustificacionDerecha->callback((Fl_Callback*)cb_CheckJustificacionDerecha);
          CheckJustificacionDerecha->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(JustificacionDerecha); //inicialización
          switch (Idioma) {case ESP:o->label("Derecha");break; case ING:o->label("Right");break; case ITA:o->label("Destra");break;}
        } // Fl_Round_Button* CheckJustificacionDerecha
        { Fl_Round_Button* o = CheckJustificacionIzquierda = new Fl_Round_Button(30, 520, 125, 15, " Izquierda");
          CheckJustificacionIzquierda->down_box(FL_PLASTIC_DOWN_BOX);
          CheckJustificacionIzquierda->color(FL_FOREGROUND_COLOR);
          CheckJustificacionIzquierda->labelfont(8);
          CheckJustificacionIzquierda->labelsize(15);
          CheckJustificacionIzquierda->callback((Fl_Callback*)cb_CheckJustificacionIzquierda);
          CheckJustificacionIzquierda->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(JustificacionIzquierda); //inicialización
          if ((!JustificacionIzquierda) && (!JustificacionCentro) && (!JustificacionDerecha)) {JustificacionIzquierda = ON; o->value(JustificacionIzquierda);}
          switch (Idioma) {case ESP:o->label("Izquierda");break; case ING:o->label("Left");break; case ITA:o->label("Sinistra");break;}
        } // Fl_Round_Button* CheckJustificacionIzquierda
        switch (Idioma) {case ESP:o->label("Justificación");break; case ING:o->label("Justification");break; case ITA:o->label("Giustificazione");break;}
        SubgrupoJustificacion->end();
      } // Fl_Group* SubgrupoJustificacion
      //if (ControlAcceso) {o->deactivate();}
      GrupoControlMarca->end();
    } // Fl_Group* GrupoControlMarca
    { Fl_Group* o = GrupoControlTexto = new Fl_Group(200, 35, 420, 560);
      GrupoControlTexto->color(FL_LIGHT3);
      GrupoControlTexto->selection_color(FL_BACKGROUND2_COLOR);
      GrupoControlTexto->labeltype(FL_NO_LABEL);
      GrupoControlTexto->labelsize(10);
      GrupoControlTexto->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Group* o = SubGrupoLinea1 = new Fl_Group(200, 35, 420, 135, "L\355nea 1");
        SubGrupoLinea1->box(FL_PLASTIC_THIN_DOWN_BOX);
        SubGrupoLinea1->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea1->selection_color((Fl_Color)55);
        SubGrupoLinea1->labelfont(9);
        SubGrupoLinea1->labelsize(15);
        SubGrupoLinea1->labelcolor((Fl_Color)14);
        SubGrupoLinea1->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea1 = new Fl_Output(225, 60, 380, 30, "L\355nea 1");
          CuadroTextoLinea1->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea1->color((Fl_Color)175);
          CuadroTextoLinea1->labeltype(FL_NO_LABEL);
          CuadroTextoLinea1->labelfont(8);
          CuadroTextoLinea1->labelsize(15);
          CuadroTextoLinea1->textsize(15);
          CuadroTextoLinea1->callback((Fl_Callback*)cb_CuadroTextoLinea1);
          CuadroTextoLinea1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        } // Fl_Output* CuadroTextoLinea1
        { Fl_Counter* o = IndicadorAlturaLinea1 = new Fl_Counter(225, 124, 140, 30, "Altura (mm)");
          IndicadorAlturaLinea1->type(1);
          IndicadorAlturaLinea1->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea1->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea1->labelfont(8);
          IndicadorAlturaLinea1->labelsize(15);
          IndicadorAlturaLinea1->minimum(1);
          IndicadorAlturaLinea1->maximum(100);
          IndicadorAlturaLinea1->value(2.5);
          IndicadorAlturaLinea1->textsize(15);
          IndicadorAlturaLinea1->callback((Fl_Callback*)cb_IndicadorAlturaLinea1);
          IndicadorAlturaLinea1->align(Fl_Align(37));
          IndicadorAlturaLinea1->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto1[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea1
        { Fl_Button* o = BotonDetallesLinea1 = new Fl_Button(385, 125, 220, 30, "Tipo L\355nea");
          BotonDetallesLinea1->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea1->color(FL_BACKGROUND2_COLOR);
          BotonDetallesLinea1->labelfont(8);
          BotonDetallesLinea1->labelsize(15);
          BotonDetallesLinea1->callback((Fl_Callback*)cb_BotonDetallesLinea1);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[0][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea1
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        SubGrupoLinea1->end();
      } // Fl_Group* SubGrupoLinea1
      { Fl_Group* o = SubGrupoLinea2 = new Fl_Group(200, 175, 420, 135, "L\355nea 2");
        SubGrupoLinea2->box(FL_PLASTIC_THIN_DOWN_BOX);
        SubGrupoLinea2->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea2->selection_color((Fl_Color)55);
        SubGrupoLinea2->labelfont(9);
        SubGrupoLinea2->labelsize(15);
        SubGrupoLinea2->labelcolor((Fl_Color)14);
        SubGrupoLinea2->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea2 = new Fl_Output(225, 200, 380, 30, "L\355nea 2");
          CuadroTextoLinea2->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea2->color((Fl_Color)175);
          CuadroTextoLinea2->labeltype(FL_NO_LABEL);
          CuadroTextoLinea2->labelfont(8);
          CuadroTextoLinea2->labelsize(15);
          CuadroTextoLinea2->textsize(15);
          CuadroTextoLinea2->callback((Fl_Callback*)cb_CuadroTextoLinea2);
          CuadroTextoLinea2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        } // Fl_Output* CuadroTextoLinea2
        { Fl_Counter* o = IndicadorAlturaLinea2 = new Fl_Counter(225, 264, 140, 30, "Altura (mm)");
          IndicadorAlturaLinea2->type(1);
          IndicadorAlturaLinea2->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea2->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea2->labelfont(8);
          IndicadorAlturaLinea2->labelsize(15);
          IndicadorAlturaLinea2->minimum(1);
          IndicadorAlturaLinea2->maximum(100);
          IndicadorAlturaLinea2->value(2.5);
          IndicadorAlturaLinea2->textsize(15);
          IndicadorAlturaLinea2->callback((Fl_Callback*)cb_IndicadorAlturaLinea2);
          IndicadorAlturaLinea2->align(Fl_Align(37));
          IndicadorAlturaLinea2->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto2[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea2
        { Fl_Button* o = BotonDetallesLinea2 = new Fl_Button(385, 265, 220, 30, "Tipo L\355nea");
          BotonDetallesLinea2->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea2->color(FL_BACKGROUND2_COLOR);
          BotonDetallesLinea2->labelfont(8);
          BotonDetallesLinea2->labelsize(15);
          BotonDetallesLinea2->callback((Fl_Callback*)cb_BotonDetallesLinea2);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[1][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea2
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        SubGrupoLinea2->end();
      } // Fl_Group* SubGrupoLinea2
      { Fl_Group* o = SubGrupoLinea3 = new Fl_Group(200, 315, 420, 135, "L\355nea 3");
        SubGrupoLinea3->box(FL_PLASTIC_THIN_DOWN_BOX);
        SubGrupoLinea3->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea3->selection_color((Fl_Color)55);
        SubGrupoLinea3->labelfont(9);
        SubGrupoLinea3->labelsize(15);
        SubGrupoLinea3->labelcolor((Fl_Color)14);
        SubGrupoLinea3->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea3 = new Fl_Output(225, 340, 380, 30, "L\355nea 3");
          CuadroTextoLinea3->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea3->color((Fl_Color)175);
          CuadroTextoLinea3->labeltype(FL_NO_LABEL);
          CuadroTextoLinea3->labelfont(8);
          CuadroTextoLinea3->labelsize(15);
          CuadroTextoLinea3->textsize(15);
          CuadroTextoLinea3->callback((Fl_Callback*)cb_CuadroTextoLinea3);
          CuadroTextoLinea3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        } // Fl_Output* CuadroTextoLinea3
        { Fl_Counter* o = IndicadorAlturaLinea3 = new Fl_Counter(225, 404, 140, 30, "Altura (mm)");
          IndicadorAlturaLinea3->type(1);
          IndicadorAlturaLinea3->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea3->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea3->labelfont(8);
          IndicadorAlturaLinea3->labelsize(15);
          IndicadorAlturaLinea3->minimum(1);
          IndicadorAlturaLinea3->maximum(100);
          IndicadorAlturaLinea3->value(2.5);
          IndicadorAlturaLinea3->textsize(15);
          IndicadorAlturaLinea3->callback((Fl_Callback*)cb_IndicadorAlturaLinea3);
          IndicadorAlturaLinea3->align(Fl_Align(37));
          IndicadorAlturaLinea3->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto3[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea3
        { Fl_Button* o = BotonDetallesLinea3 = new Fl_Button(385, 405, 220, 30, "Tipo L\355nea");
          BotonDetallesLinea3->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea3->color(FL_BACKGROUND2_COLOR);
          BotonDetallesLinea3->labelfont(8);
          BotonDetallesLinea3->labelsize(15);
          BotonDetallesLinea3->callback((Fl_Callback*)cb_BotonDetallesLinea3);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[2][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea3
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        SubGrupoLinea3->end();
      } // Fl_Group* SubGrupoLinea3
      { Fl_Group* o = SubGrupoLinea4 = new Fl_Group(200, 455, 420, 135, "L\355nea 4");
        SubGrupoLinea4->box(FL_PLASTIC_THIN_DOWN_BOX);
        SubGrupoLinea4->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea4->selection_color((Fl_Color)55);
        SubGrupoLinea4->labelfont(9);
        SubGrupoLinea4->labelsize(15);
        SubGrupoLinea4->labelcolor((Fl_Color)14);
        SubGrupoLinea4->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea4 = new Fl_Output(225, 480, 380, 30, "L\355nea 3");
          CuadroTextoLinea4->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea4->color((Fl_Color)175);
          CuadroTextoLinea4->labeltype(FL_NO_LABEL);
          CuadroTextoLinea4->labelfont(8);
          CuadroTextoLinea4->labelsize(15);
          CuadroTextoLinea4->textsize(15);
          CuadroTextoLinea4->callback((Fl_Callback*)cb_CuadroTextoLinea4);
          CuadroTextoLinea4->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        } // Fl_Output* CuadroTextoLinea4
        { Fl_Counter* o = IndicadorAlturaLinea4 = new Fl_Counter(225, 544, 140, 30, "Altura (mm)");
          IndicadorAlturaLinea4->type(1);
          IndicadorAlturaLinea4->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea4->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea4->labelfont(8);
          IndicadorAlturaLinea4->labelsize(15);
          IndicadorAlturaLinea4->minimum(1);
          IndicadorAlturaLinea4->maximum(100);
          IndicadorAlturaLinea4->value(2.5);
          IndicadorAlturaLinea4->textsize(15);
          IndicadorAlturaLinea4->callback((Fl_Callback*)cb_IndicadorAlturaLinea4);
          IndicadorAlturaLinea4->align(Fl_Align(37));
          IndicadorAlturaLinea4->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto4[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea4
        { Fl_Button* o = BotonDetallesLinea4 = new Fl_Button(385, 545, 220, 30, "Tipo L\355nea");
          BotonDetallesLinea4->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea4->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea4->color(FL_BACKGROUND2_COLOR);
          BotonDetallesLinea4->labelfont(8);
          BotonDetallesLinea4->labelsize(15);
          BotonDetallesLinea4->callback((Fl_Callback*)cb_BotonDetallesLinea4);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[3][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea4
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}
        SubGrupoLinea4->end();
      } // Fl_Group* SubGrupoLinea4
      if (Funcionalidad != BLOQUES) {o->show();} else {o->hide();}
      GrupoControlTexto->end();
    } // Fl_Group* GrupoControlTexto
    { Fl_Group* o = GrupoControlTextoBloques = new Fl_Group(200, 35, 420, 560);
      GrupoControlTextoBloques->color(FL_LIGHT3);
      GrupoControlTextoBloques->selection_color(FL_BACKGROUND2_COLOR);
      GrupoControlTextoBloques->labeltype(FL_NO_LABEL);
      GrupoControlTextoBloques->labelsize(10);
      GrupoControlTextoBloques->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Group* o = SubGrupoLinea1Bloques = new Fl_Group(200, 35, 420, 140, "L\355nea 1");
        SubGrupoLinea1Bloques->box(FL_THIN_DOWN_BOX);
        SubGrupoLinea1Bloques->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea1Bloques->selection_color((Fl_Color)55);
        SubGrupoLinea1Bloques->labelfont(9);
        SubGrupoLinea1Bloques->labelsize(15);
        SubGrupoLinea1Bloques->labelcolor((Fl_Color)14);
        SubGrupoLinea1Bloques->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea1Bloque1 = new Fl_Output(215, 55, 120, 30, "L\355nea 1");
          CuadroTextoLinea1Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea1Bloque1->color((Fl_Color)175);
          CuadroTextoLinea1Bloque1->labeltype(FL_NO_LABEL);
          CuadroTextoLinea1Bloque1->labelfont(8);
          CuadroTextoLinea1Bloque1->labelsize(15);
          CuadroTextoLinea1Bloque1->textfont(8);
          CuadroTextoLinea1Bloque1->textsize(15);
          CuadroTextoLinea1Bloque1->callback((Fl_Callback*)cb_CuadroTextoLinea1Bloque1);
          CuadroTextoLinea1Bloque1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque1->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        } // Fl_Output* CuadroTextoLinea1Bloque1
        { Fl_Counter* o = IndicadorAlturaLinea1Bloque1 = new Fl_Counter(215, 108, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea1Bloque1->type(1);
          IndicadorAlturaLinea1Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea1Bloque1->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea1Bloque1->labelfont(8);
          IndicadorAlturaLinea1Bloque1->labelsize(15);
          IndicadorAlturaLinea1Bloque1->minimum(1);
          IndicadorAlturaLinea1Bloque1->maximum(100);
          IndicadorAlturaLinea1Bloque1->value(2.5);
          IndicadorAlturaLinea1Bloque1->textfont(8);
          IndicadorAlturaLinea1Bloque1->textsize(15);
          IndicadorAlturaLinea1Bloque1->callback((Fl_Callback*)cb_IndicadorAlturaLinea1Bloque1);
          IndicadorAlturaLinea1Bloque1->align(Fl_Align(37));
          IndicadorAlturaLinea1Bloque1->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto1[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea1Bloque1
        { Fl_Button* o = BotonDetallesLinea1Bloque1 = new Fl_Button(215, 140, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea1Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea1Bloque1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea1Bloque1->color(FL_DARK3);
          BotonDetallesLinea1Bloque1->labelfont(8);
          BotonDetallesLinea1Bloque1->labelsize(15);
          BotonDetallesLinea1Bloque1->callback((Fl_Callback*)cb_BotonDetallesLinea1Bloque1);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[0][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea1Bloque1
        { Fl_Output* o = CuadroTextoLinea1Bloque2 = new Fl_Output(350, 55, 120, 30, "L\355nea 1");
          CuadroTextoLinea1Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea1Bloque2->color((Fl_Color)175);
          CuadroTextoLinea1Bloque2->labeltype(FL_NO_LABEL);
          CuadroTextoLinea1Bloque2->labelfont(8);
          CuadroTextoLinea1Bloque2->labelsize(15);
          CuadroTextoLinea1Bloque2->textfont(8);
          CuadroTextoLinea1Bloque2->textsize(15);
          CuadroTextoLinea1Bloque2->callback((Fl_Callback*)cb_CuadroTextoLinea1Bloque2);
          CuadroTextoLinea1Bloque2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=2; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque2->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        } // Fl_Output* CuadroTextoLinea1Bloque2
        { Fl_Counter* o = IndicadorAlturaLinea1Bloque2 = new Fl_Counter(350, 108, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea1Bloque2->type(1);
          IndicadorAlturaLinea1Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea1Bloque2->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea1Bloque2->labelfont(8);
          IndicadorAlturaLinea1Bloque2->labelsize(15);
          IndicadorAlturaLinea1Bloque2->minimum(1);
          IndicadorAlturaLinea1Bloque2->maximum(100);
          IndicadorAlturaLinea1Bloque2->value(2.5);
          IndicadorAlturaLinea1Bloque2->textfont(8);
          IndicadorAlturaLinea1Bloque2->textsize(15);
          IndicadorAlturaLinea1Bloque2->callback((Fl_Callback*)cb_IndicadorAlturaLinea1Bloque2);
          IndicadorAlturaLinea1Bloque2->align(Fl_Align(37));
          IndicadorAlturaLinea1Bloque2->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto1[1]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea1Bloque2
        { Fl_Button* o = BotonDetallesLinea1Bloque2 = new Fl_Button(350, 140, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea1Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea1Bloque2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea1Bloque2->color(FL_DARK3);
          BotonDetallesLinea1Bloque2->labelfont(8);
          BotonDetallesLinea1Bloque2->labelsize(15);
          BotonDetallesLinea1Bloque2->callback((Fl_Callback*)cb_BotonDetallesLinea1Bloque2);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][1] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[0][1]]);//inicialización
        } // Fl_Button* BotonDetallesLinea1Bloque2
        { Fl_Output* o = CuadroTextoLinea1Bloque3 = new Fl_Output(485, 55, 120, 30, "L\355nea 1");
          CuadroTextoLinea1Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea1Bloque3->color((Fl_Color)175);
          CuadroTextoLinea1Bloque3->labeltype(FL_NO_LABEL);
          CuadroTextoLinea1Bloque3->labelfont(8);
          CuadroTextoLinea1Bloque3->labelsize(15);
          CuadroTextoLinea1Bloque3->textfont(8);
          CuadroTextoLinea1Bloque3->textsize(15);
          CuadroTextoLinea1Bloque3->callback((Fl_Callback*)cb_CuadroTextoLinea1Bloque3);
          CuadroTextoLinea1Bloque3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=3; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque3->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        } // Fl_Output* CuadroTextoLinea1Bloque3
        { Fl_Counter* o = IndicadorAlturaLinea1Bloque3 = new Fl_Counter(485, 108, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea1Bloque3->type(1);
          IndicadorAlturaLinea1Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea1Bloque3->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea1Bloque3->labelfont(8);
          IndicadorAlturaLinea1Bloque3->labelsize(15);
          IndicadorAlturaLinea1Bloque3->minimum(1);
          IndicadorAlturaLinea1Bloque3->maximum(100);
          IndicadorAlturaLinea1Bloque3->value(2.5);
          IndicadorAlturaLinea1Bloque3->textfont(8);
          IndicadorAlturaLinea1Bloque3->textsize(15);
          IndicadorAlturaLinea1Bloque3->callback((Fl_Callback*)cb_IndicadorAlturaLinea1Bloque3);
          IndicadorAlturaLinea1Bloque3->align(Fl_Align(37));
          IndicadorAlturaLinea1Bloque3->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto1[2]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea1Bloque3
        { Fl_Button* o = BotonDetallesLinea1Bloque3 = new Fl_Button(485, 140, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea1Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea1Bloque3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea1Bloque3->color(FL_DARK3);
          BotonDetallesLinea1Bloque3->labelfont(8);
          BotonDetallesLinea1Bloque3->labelsize(15);
          BotonDetallesLinea1Bloque3->callback((Fl_Callback*)cb_BotonDetallesLinea1Bloque3);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][2] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[0][2]]);//inicialización
        } // Fl_Button* BotonDetallesLinea1Bloque3
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}
        SubGrupoLinea1Bloques->end();
      } // Fl_Group* SubGrupoLinea1Bloques
      { Fl_Group* o = SubGrupoLinea2Bloques = new Fl_Group(200, 175, 420, 140, "L\355nea 2");
        SubGrupoLinea2Bloques->box(FL_THIN_DOWN_BOX);
        SubGrupoLinea2Bloques->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea2Bloques->selection_color((Fl_Color)55);
        SubGrupoLinea2Bloques->labelfont(9);
        SubGrupoLinea2Bloques->labelsize(15);
        SubGrupoLinea2Bloques->labelcolor((Fl_Color)14);
        SubGrupoLinea2Bloques->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea2Bloque1 = new Fl_Output(215, 195, 120, 30, "L\355nea 2");
          CuadroTextoLinea2Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea2Bloque1->color((Fl_Color)175);
          CuadroTextoLinea2Bloque1->labeltype(FL_NO_LABEL);
          CuadroTextoLinea2Bloque1->labelfont(8);
          CuadroTextoLinea2Bloque1->labelsize(15);
          CuadroTextoLinea2Bloque1->textfont(8);
          CuadroTextoLinea2Bloque1->textsize(15);
          CuadroTextoLinea2Bloque1->callback((Fl_Callback*)cb_CuadroTextoLinea2Bloque1);
          CuadroTextoLinea2Bloque1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque1->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        } // Fl_Output* CuadroTextoLinea2Bloque1
        { Fl_Counter* o = IndicadorAlturaLinea2Bloque1 = new Fl_Counter(215, 248, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea2Bloque1->type(1);
          IndicadorAlturaLinea2Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea2Bloque1->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea2Bloque1->labelfont(8);
          IndicadorAlturaLinea2Bloque1->labelsize(15);
          IndicadorAlturaLinea2Bloque1->minimum(1);
          IndicadorAlturaLinea2Bloque1->maximum(100);
          IndicadorAlturaLinea2Bloque1->value(2.5);
          IndicadorAlturaLinea2Bloque1->textfont(8);
          IndicadorAlturaLinea2Bloque1->textsize(15);
          IndicadorAlturaLinea2Bloque1->callback((Fl_Callback*)cb_IndicadorAlturaLinea2Bloque1);
          IndicadorAlturaLinea2Bloque1->align(Fl_Align(37));
          IndicadorAlturaLinea2Bloque1->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto2[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea2Bloque1
        { Fl_Button* o = BotonDetallesLinea2Bloque1 = new Fl_Button(215, 280, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea2Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea2Bloque1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea2Bloque1->color(FL_DARK3);
          BotonDetallesLinea2Bloque1->labelfont(8);
          BotonDetallesLinea2Bloque1->labelsize(15);
          BotonDetallesLinea2Bloque1->callback((Fl_Callback*)cb_BotonDetallesLinea2Bloque1);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[1][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea2Bloque1
        { Fl_Output* o = CuadroTextoLinea2Bloque2 = new Fl_Output(350, 195, 120, 30, "L\355nea 2");
          CuadroTextoLinea2Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea2Bloque2->color((Fl_Color)175);
          CuadroTextoLinea2Bloque2->labeltype(FL_NO_LABEL);
          CuadroTextoLinea2Bloque2->labelfont(8);
          CuadroTextoLinea2Bloque2->labelsize(15);
          CuadroTextoLinea2Bloque2->textfont(8);
          CuadroTextoLinea2Bloque2->textsize(15);
          CuadroTextoLinea2Bloque2->callback((Fl_Callback*)cb_CuadroTextoLinea2Bloque2);
          CuadroTextoLinea2Bloque2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=2; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque2->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        } // Fl_Output* CuadroTextoLinea2Bloque2
        { Fl_Counter* o = IndicadorAlturaLinea2Bloque2 = new Fl_Counter(350, 248, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea2Bloque2->type(1);
          IndicadorAlturaLinea2Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea2Bloque2->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea2Bloque2->labelfont(8);
          IndicadorAlturaLinea2Bloque2->labelsize(15);
          IndicadorAlturaLinea2Bloque2->minimum(1);
          IndicadorAlturaLinea2Bloque2->maximum(100);
          IndicadorAlturaLinea2Bloque2->value(2.5);
          IndicadorAlturaLinea2Bloque2->textfont(8);
          IndicadorAlturaLinea2Bloque2->textsize(15);
          IndicadorAlturaLinea2Bloque2->callback((Fl_Callback*)cb_IndicadorAlturaLinea2Bloque2);
          IndicadorAlturaLinea2Bloque2->align(Fl_Align(37));
          IndicadorAlturaLinea2Bloque2->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto2[1]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea2Bloque2
        { Fl_Button* o = BotonDetallesLinea2Bloque2 = new Fl_Button(350, 280, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea2Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea2Bloque2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea2Bloque2->color(FL_DARK3);
          BotonDetallesLinea2Bloque2->labelfont(8);
          BotonDetallesLinea2Bloque2->labelsize(15);
          BotonDetallesLinea2Bloque2->callback((Fl_Callback*)cb_BotonDetallesLinea2Bloque2);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][1] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[1][1]]);//inicialización
        } // Fl_Button* BotonDetallesLinea2Bloque2
        { Fl_Output* o = CuadroTextoLinea2Bloque3 = new Fl_Output(485, 195, 120, 30, "L\355nea 2");
          CuadroTextoLinea2Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea2Bloque3->color((Fl_Color)175);
          CuadroTextoLinea2Bloque3->labeltype(FL_NO_LABEL);
          CuadroTextoLinea2Bloque3->labelfont(8);
          CuadroTextoLinea2Bloque3->labelsize(15);
          CuadroTextoLinea2Bloque3->textfont(8);
          CuadroTextoLinea2Bloque3->textsize(15);
          CuadroTextoLinea2Bloque3->callback((Fl_Callback*)cb_CuadroTextoLinea2Bloque3);
          CuadroTextoLinea2Bloque3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=3; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque3->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        } // Fl_Output* CuadroTextoLinea2Bloque3
        { Fl_Counter* o = IndicadorAlturaLinea2Bloque3 = new Fl_Counter(485, 248, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea2Bloque3->type(1);
          IndicadorAlturaLinea2Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea2Bloque3->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea2Bloque3->labelfont(8);
          IndicadorAlturaLinea2Bloque3->labelsize(15);
          IndicadorAlturaLinea2Bloque3->minimum(1);
          IndicadorAlturaLinea2Bloque3->maximum(100);
          IndicadorAlturaLinea2Bloque3->value(2.5);
          IndicadorAlturaLinea2Bloque3->textfont(8);
          IndicadorAlturaLinea2Bloque3->textsize(15);
          IndicadorAlturaLinea2Bloque3->callback((Fl_Callback*)cb_IndicadorAlturaLinea2Bloque3);
          IndicadorAlturaLinea2Bloque3->align(Fl_Align(37));
          IndicadorAlturaLinea2Bloque3->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto2[2]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea2Bloque3
        { Fl_Button* o = BotonDetallesLinea2Bloque3 = new Fl_Button(485, 280, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea2Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea2Bloque3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea2Bloque3->color(FL_DARK3);
          BotonDetallesLinea2Bloque3->labelfont(8);
          BotonDetallesLinea2Bloque3->labelsize(15);
          BotonDetallesLinea2Bloque3->callback((Fl_Callback*)cb_BotonDetallesLinea2Bloque3);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][2] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[1][2]]);//inicialización
        } // Fl_Button* BotonDetallesLinea2Bloque3
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}
        SubGrupoLinea2Bloques->end();
      } // Fl_Group* SubGrupoLinea2Bloques
      { Fl_Group* o = SubGrupoLinea3Bloques = new Fl_Group(200, 315, 420, 140, "L\355nea 3");
        SubGrupoLinea3Bloques->box(FL_THIN_DOWN_BOX);
        SubGrupoLinea3Bloques->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea3Bloques->selection_color((Fl_Color)55);
        SubGrupoLinea3Bloques->labelfont(9);
        SubGrupoLinea3Bloques->labelsize(15);
        SubGrupoLinea3Bloques->labelcolor((Fl_Color)14);
        SubGrupoLinea3Bloques->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea3Bloque1 = new Fl_Output(215, 335, 120, 30, "L\355nea 3");
          CuadroTextoLinea3Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea3Bloque1->color((Fl_Color)175);
          CuadroTextoLinea3Bloque1->labeltype(FL_NO_LABEL);
          CuadroTextoLinea3Bloque1->labelfont(8);
          CuadroTextoLinea3Bloque1->labelsize(15);
          CuadroTextoLinea3Bloque1->textfont(8);
          CuadroTextoLinea3Bloque1->textsize(15);
          CuadroTextoLinea3Bloque1->callback((Fl_Callback*)cb_CuadroTextoLinea3Bloque1);
          CuadroTextoLinea3Bloque1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque1->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        } // Fl_Output* CuadroTextoLinea3Bloque1
        { Fl_Counter* o = IndicadorAlturaLinea3Bloque1 = new Fl_Counter(215, 388, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea3Bloque1->type(1);
          IndicadorAlturaLinea3Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea3Bloque1->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea3Bloque1->labelfont(8);
          IndicadorAlturaLinea3Bloque1->labelsize(15);
          IndicadorAlturaLinea3Bloque1->minimum(1);
          IndicadorAlturaLinea3Bloque1->maximum(100);
          IndicadorAlturaLinea3Bloque1->value(2.5);
          IndicadorAlturaLinea3Bloque1->textfont(8);
          IndicadorAlturaLinea3Bloque1->textsize(15);
          IndicadorAlturaLinea3Bloque1->callback((Fl_Callback*)cb_IndicadorAlturaLinea3Bloque1);
          IndicadorAlturaLinea3Bloque1->align(Fl_Align(37));
          IndicadorAlturaLinea3Bloque1->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto3[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea3Bloque1
        { Fl_Button* o = BotonDetallesLinea3Bloque1 = new Fl_Button(215, 420, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea3Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea3Bloque1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea3Bloque1->color(FL_DARK3);
          BotonDetallesLinea3Bloque1->labelfont(8);
          BotonDetallesLinea3Bloque1->labelsize(15);
          BotonDetallesLinea3Bloque1->callback((Fl_Callback*)cb_BotonDetallesLinea3Bloque1);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[2][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea3Bloque1
        { Fl_Output* o = CuadroTextoLinea3Bloque2 = new Fl_Output(350, 335, 120, 30, "L\355nea 3");
          CuadroTextoLinea3Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea3Bloque2->color((Fl_Color)175);
          CuadroTextoLinea3Bloque2->labeltype(FL_NO_LABEL);
          CuadroTextoLinea3Bloque2->labelfont(8);
          CuadroTextoLinea3Bloque2->labelsize(15);
          CuadroTextoLinea3Bloque2->textfont(8);
          CuadroTextoLinea3Bloque2->textsize(15);
          CuadroTextoLinea3Bloque2->callback((Fl_Callback*)cb_CuadroTextoLinea3Bloque2);
          CuadroTextoLinea3Bloque2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=2; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque2->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        } // Fl_Output* CuadroTextoLinea3Bloque2
        { Fl_Counter* o = IndicadorAlturaLinea3Bloque2 = new Fl_Counter(350, 388, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea3Bloque2->type(1);
          IndicadorAlturaLinea3Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea3Bloque2->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea3Bloque2->labelfont(8);
          IndicadorAlturaLinea3Bloque2->labelsize(15);
          IndicadorAlturaLinea3Bloque2->minimum(1);
          IndicadorAlturaLinea3Bloque2->maximum(100);
          IndicadorAlturaLinea3Bloque2->value(2.5);
          IndicadorAlturaLinea3Bloque2->textfont(8);
          IndicadorAlturaLinea3Bloque2->textsize(15);
          IndicadorAlturaLinea3Bloque2->callback((Fl_Callback*)cb_IndicadorAlturaLinea3Bloque2);
          IndicadorAlturaLinea3Bloque2->align(Fl_Align(37));
          IndicadorAlturaLinea3Bloque2->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto3[1]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea3Bloque2
        { Fl_Button* o = BotonDetallesLinea3Bloque2 = new Fl_Button(350, 420, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea3Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea3Bloque2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea3Bloque2->color(FL_DARK3);
          BotonDetallesLinea3Bloque2->labelfont(8);
          BotonDetallesLinea3Bloque2->labelsize(15);
          BotonDetallesLinea3Bloque2->callback((Fl_Callback*)cb_BotonDetallesLinea3Bloque2);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][1] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[2][1]]);//inicialización
        } // Fl_Button* BotonDetallesLinea3Bloque2
        { Fl_Output* o = CuadroTextoLinea3Bloque3 = new Fl_Output(485, 335, 120, 30, "L\355nea 3");
          CuadroTextoLinea3Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea3Bloque3->color((Fl_Color)175);
          CuadroTextoLinea3Bloque3->labeltype(FL_NO_LABEL);
          CuadroTextoLinea3Bloque3->labelfont(8);
          CuadroTextoLinea3Bloque3->labelsize(15);
          CuadroTextoLinea3Bloque3->textfont(8);
          CuadroTextoLinea3Bloque3->textsize(15);
          CuadroTextoLinea3Bloque3->callback((Fl_Callback*)cb_CuadroTextoLinea3Bloque3);
          CuadroTextoLinea3Bloque3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=3; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque3->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        } // Fl_Output* CuadroTextoLinea3Bloque3
        { Fl_Counter* o = IndicadorAlturaLinea3Bloque3 = new Fl_Counter(485, 388, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea3Bloque3->type(1);
          IndicadorAlturaLinea3Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea3Bloque3->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea3Bloque3->labelfont(8);
          IndicadorAlturaLinea3Bloque3->labelsize(15);
          IndicadorAlturaLinea3Bloque3->minimum(1);
          IndicadorAlturaLinea3Bloque3->maximum(100);
          IndicadorAlturaLinea3Bloque3->value(2.5);
          IndicadorAlturaLinea3Bloque3->textfont(8);
          IndicadorAlturaLinea3Bloque3->textsize(15);
          IndicadorAlturaLinea3Bloque3->callback((Fl_Callback*)cb_IndicadorAlturaLinea3Bloque3);
          IndicadorAlturaLinea3Bloque3->align(Fl_Align(37));
          IndicadorAlturaLinea3Bloque3->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto3[2]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea3Bloque3
        { Fl_Button* o = BotonDetallesLinea3Bloque3 = new Fl_Button(485, 420, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea3Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea3Bloque3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea3Bloque3->color(FL_DARK3);
          BotonDetallesLinea3Bloque3->labelfont(8);
          BotonDetallesLinea3Bloque3->labelsize(15);
          BotonDetallesLinea3Bloque3->callback((Fl_Callback*)cb_BotonDetallesLinea3Bloque3);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][2] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[2][2]]);//inicialización
        } // Fl_Button* BotonDetallesLinea3Bloque3
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}
        SubGrupoLinea3Bloques->end();
      } // Fl_Group* SubGrupoLinea3Bloques
      { Fl_Group* o = SubGrupoLinea4Bloques = new Fl_Group(200, 455, 420, 140, "L\355nea 4");
        SubGrupoLinea4Bloques->box(FL_THIN_DOWN_BOX);
        SubGrupoLinea4Bloques->color(FL_BACKGROUND2_COLOR);
        SubGrupoLinea4Bloques->selection_color((Fl_Color)55);
        SubGrupoLinea4Bloques->labelfont(9);
        SubGrupoLinea4Bloques->labelsize(15);
        SubGrupoLinea4Bloques->labelcolor((Fl_Color)14);
        SubGrupoLinea4Bloques->align(Fl_Align(FL_ALIGN_TOP|FL_ALIGN_INSIDE));
        { Fl_Output* o = CuadroTextoLinea4Bloque1 = new Fl_Output(215, 475, 120, 30, "L\355nea 3");
          CuadroTextoLinea4Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea4Bloque1->color((Fl_Color)175);
          CuadroTextoLinea4Bloque1->labeltype(FL_NO_LABEL);
          CuadroTextoLinea4Bloque1->labelfont(8);
          CuadroTextoLinea4Bloque1->labelsize(15);
          CuadroTextoLinea4Bloque1->textfont(8);
          CuadroTextoLinea4Bloque1->textsize(15);
          CuadroTextoLinea4Bloque1->callback((Fl_Callback*)cb_CuadroTextoLinea4Bloque1);
          CuadroTextoLinea4Bloque1->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=1; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque1->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}
        } // Fl_Output* CuadroTextoLinea4Bloque1
        { Fl_Counter* o = IndicadorAlturaLinea4Bloque1 = new Fl_Counter(215, 528, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea4Bloque1->type(1);
          IndicadorAlturaLinea4Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea4Bloque1->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea4Bloque1->labelfont(8);
          IndicadorAlturaLinea4Bloque1->labelsize(15);
          IndicadorAlturaLinea4Bloque1->minimum(1);
          IndicadorAlturaLinea4Bloque1->maximum(100);
          IndicadorAlturaLinea4Bloque1->value(2.5);
          IndicadorAlturaLinea4Bloque1->textfont(8);
          IndicadorAlturaLinea4Bloque1->textsize(15);
          IndicadorAlturaLinea4Bloque1->callback((Fl_Callback*)cb_IndicadorAlturaLinea4Bloque1);
          IndicadorAlturaLinea4Bloque1->align(Fl_Align(37));
          IndicadorAlturaLinea4Bloque1->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto4[0]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea4Bloque1
        { Fl_Button* o = BotonDetallesLinea4Bloque1 = new Fl_Button(215, 560, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea4Bloque1->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea4Bloque1->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea4Bloque1->color(FL_DARK3);
          BotonDetallesLinea4Bloque1->labelfont(8);
          BotonDetallesLinea4Bloque1->labelsize(15);
          BotonDetallesLinea4Bloque1->callback((Fl_Callback*)cb_BotonDetallesLinea4Bloque1);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][0] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[3][0]]);//inicialización
        } // Fl_Button* BotonDetallesLinea4Bloque1
        { Fl_Output* o = CuadroTextoLinea4Bloque2 = new Fl_Output(350, 475, 120, 30, "L\355nea 3");
          CuadroTextoLinea4Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea4Bloque2->color((Fl_Color)175);
          CuadroTextoLinea4Bloque2->labeltype(FL_NO_LABEL);
          CuadroTextoLinea4Bloque2->labelfont(8);
          CuadroTextoLinea4Bloque2->labelsize(15);
          CuadroTextoLinea4Bloque2->textfont(8);
          CuadroTextoLinea4Bloque2->textsize(15);
          CuadroTextoLinea4Bloque2->callback((Fl_Callback*)cb_CuadroTextoLinea4Bloque2);
          CuadroTextoLinea4Bloque2->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=2; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque2->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}
        } // Fl_Output* CuadroTextoLinea4Bloque2
        { Fl_Counter* o = IndicadorAlturaLinea4Bloque2 = new Fl_Counter(350, 528, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea4Bloque2->type(1);
          IndicadorAlturaLinea4Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea4Bloque2->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea4Bloque2->labelfont(8);
          IndicadorAlturaLinea4Bloque2->labelsize(15);
          IndicadorAlturaLinea4Bloque2->minimum(1);
          IndicadorAlturaLinea4Bloque2->maximum(100);
          IndicadorAlturaLinea4Bloque2->value(2.5);
          IndicadorAlturaLinea4Bloque2->textfont(8);
          IndicadorAlturaLinea4Bloque2->textsize(15);
          IndicadorAlturaLinea4Bloque2->callback((Fl_Callback*)cb_IndicadorAlturaLinea4Bloque2);
          IndicadorAlturaLinea4Bloque2->align(Fl_Align(37));
          IndicadorAlturaLinea4Bloque2->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto4[1]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea4Bloque2
        { Fl_Button* o = BotonDetallesLinea4Bloque2 = new Fl_Button(350, 560, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea4Bloque2->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea4Bloque2->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea4Bloque2->color(FL_DARK3);
          BotonDetallesLinea4Bloque2->labelfont(8);
          BotonDetallesLinea4Bloque2->labelsize(15);
          BotonDetallesLinea4Bloque2->callback((Fl_Callback*)cb_BotonDetallesLinea4Bloque2);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][1] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[3][1]]);//inicialización
        } // Fl_Button* BotonDetallesLinea4Bloque2
        { Fl_Output* o = CuadroTextoLinea4Bloque3 = new Fl_Output(485, 475, 120, 30, "L\355nea 3");
          CuadroTextoLinea4Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          CuadroTextoLinea4Bloque3->color((Fl_Color)175);
          CuadroTextoLinea4Bloque3->labeltype(FL_NO_LABEL);
          CuadroTextoLinea4Bloque3->labelfont(8);
          CuadroTextoLinea4Bloque3->labelsize(15);
          CuadroTextoLinea4Bloque3->textfont(8);
          CuadroTextoLinea4Bloque3->textsize(15);
          CuadroTextoLinea4Bloque3->callback((Fl_Callback*)cb_CuadroTextoLinea4Bloque3);
          CuadroTextoLinea4Bloque3->align(Fl_Align(FL_ALIGN_TOP_LEFT));
          BloqueCalcular=3; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización
          if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque3->deactivate();}
          o->clear_visible_focus(); // Para que no se vea "^" en el widget
          switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}
        } // Fl_Output* CuadroTextoLinea4Bloque3
        { Fl_Counter* o = IndicadorAlturaLinea4Bloque3 = new Fl_Counter(485, 528, 120, 24, "Altura (mm)");
          IndicadorAlturaLinea4Bloque3->type(1);
          IndicadorAlturaLinea4Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          IndicadorAlturaLinea4Bloque3->color(FL_INACTIVE_COLOR);
          IndicadorAlturaLinea4Bloque3->labelfont(8);
          IndicadorAlturaLinea4Bloque3->labelsize(15);
          IndicadorAlturaLinea4Bloque3->minimum(1);
          IndicadorAlturaLinea4Bloque3->maximum(100);
          IndicadorAlturaLinea4Bloque3->value(2.5);
          IndicadorAlturaLinea4Bloque3->textfont(8);
          IndicadorAlturaLinea4Bloque3->textsize(15);
          IndicadorAlturaLinea4Bloque3->callback((Fl_Callback*)cb_IndicadorAlturaLinea4Bloque3);
          IndicadorAlturaLinea4Bloque3->align(Fl_Align(37));
          IndicadorAlturaLinea4Bloque3->when(FL_WHEN_RELEASE_ALWAYS);
          o->value(AlturaLineaTexto4[2]);
          if (o->value() == 0) {o->value(1.0);} // No puede valer 0
          switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}
        } // Fl_Counter* IndicadorAlturaLinea4Bloque3
        { Fl_Button* o = BotonDetallesLinea4Bloque3 = new Fl_Button(485, 560, 120, 25, "Tipo L\355nea");
          BotonDetallesLinea4Bloque3->box(FL_PLASTIC_THIN_UP_BOX);
          BotonDetallesLinea4Bloque3->down_box(FL_PLASTIC_THIN_DOWN_BOX);
          BotonDetallesLinea4Bloque3->color(FL_DARK3);
          BotonDetallesLinea4Bloque3->labelfont(8);
          BotonDetallesLinea4Bloque3->labelsize(15);
          BotonDetallesLinea4Bloque3->callback((Fl_Callback*)cb_BotonDetallesLinea4Bloque3);
          if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][2] = TEXTO; o->hide();}
          else {o->show();}
          o->label(strTiposLinea[Idioma][ValorTipoLinea[3][2]]);//inicialización
        } // Fl_Button* BotonDetallesLinea4Bloque3
        //if (ControlAcceso) {o->deactivate();}
        switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}
        SubGrupoLinea4Bloques->end();
      } // Fl_Group* SubGrupoLinea4Bloques
      if (Funcionalidad == BLOQUES) {o->show();} else {o->hide();}
      GrupoControlTextoBloques->end();
    } // Fl_Group* GrupoControlTextoBloques
    { GrupoControlOperacion = new Fl_Group(630, 75, 165, 520);
      GrupoControlOperacion->color((Fl_Color)53);
      GrupoControlOperacion->selection_color(FL_BACKGROUND2_COLOR);
      GrupoControlOperacion->labeltype(FL_NO_LABEL);
      GrupoControlOperacion->labelsize(10);
      GrupoControlOperacion->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      { Fl_Light_Button* o = BotonMarcar = new Fl_Light_Button(630, 115, 165, 65, "Marcar");
        BotonMarcar->box(FL_PLASTIC_UP_BOX);
        BotonMarcar->down_box(FL_PLASTIC_DOWN_BOX);
        BotonMarcar->color(FL_INACTIVE_COLOR);
        BotonMarcar->selection_color(FL_FOREGROUND_COLOR);
        BotonMarcar->labelfont(8);
        BotonMarcar->labelsize(20);
        BotonMarcar->callback((Fl_Callback*)cb_BotonMarcar);
        BotonMarcar->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
        if (!ENDESARROLLO) {o->deactivate();} // se inicia desactivado - tras inicializar los galvos se activa el botón
        switch (Idioma) {case ESP:o->label("Marcar");break; case ING:o->label("Mark");break; case ITA:o->label("Stampa");break;}
      } // Fl_Light_Button* BotonMarcar
      { Fl_Light_Button* o = BotonPrueba = new Fl_Light_Button(630, 185, 165, 65, "Prueba");
        BotonPrueba->box(FL_PLASTIC_UP_BOX);
        BotonPrueba->down_box(FL_PLASTIC_DOWN_BOX);
        BotonPrueba->color(FL_INACTIVE_COLOR);
        BotonPrueba->selection_color(FL_FOREGROUND_COLOR);
        BotonPrueba->labelfont(8);
        BotonPrueba->labelsize(20);
        BotonPrueba->callback((Fl_Callback*)cb_BotonPrueba);
        BotonPrueba->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
        if (!ENDESARROLLO) {o->deactivate();} // se inicia desactivado - tras inicializar los galvos se activa el botón
        switch (Idioma) {case ESP:o->label("Prueba");break; case ING:o->label("Test");break; case ITA:o->label("Prova");break;}
      } // Fl_Light_Button* BotonPrueba
      { Fl_Button* o = BotonStop = new Fl_Button(630, 255, 165, 65, "Stop");
        BotonStop->box(FL_PLASTIC_UP_BOX);
        BotonStop->down_box(FL_PLASTIC_DOWN_BOX);
        BotonStop->color(FL_INACTIVE_COLOR);
        BotonStop->selection_color(FL_BACKGROUND2_COLOR);
        BotonStop->labelfont(8);
        BotonStop->labelsize(20);
        BotonStop->callback((Fl_Callback*)cb_BotonStop);
        o->deactivate(); //inicialización
        switch (Idioma) {case ESP:o->label("Stop");break; case ING:o->label("Stop");break; case ITA:o->label("Stop");break;}
      } // Fl_Button* BotonStop
      { Fl_Button* o = BotonTrabajos = new Fl_Button(630, 325, 165, 40, "Trabajos");
        BotonTrabajos->box(FL_PLASTIC_UP_BOX);
        BotonTrabajos->down_box(FL_PLASTIC_DOWN_BOX);
        BotonTrabajos->color((Fl_Color)23);
        BotonTrabajos->selection_color(FL_BACKGROUND2_COLOR);
        BotonTrabajos->labelfont(8);
        BotonTrabajos->callback((Fl_Callback*)cb_BotonTrabajos);
        //o->deactivate(); //inicialización
        switch (Idioma) {case ESP:o->label("Trabajos");break; case ING:o->label("Jobs");break; case ITA:o->label("Lavoro");break;}
      } // Fl_Button* BotonTrabajos
      { Fl_Button* o = BotonTablaPrecorte = new Fl_Button(630, 370, 165, 40, "Tabla-Precorte");
        BotonTablaPrecorte->box(FL_PLASTIC_UP_BOX);
        BotonTablaPrecorte->down_box(FL_PLASTIC_DOWN_BOX);
        BotonTablaPrecorte->color((Fl_Color)23);
        BotonTablaPrecorte->selection_color(FL_BACKGROUND2_COLOR);
        BotonTablaPrecorte->labelfont(8);
        BotonTablaPrecorte->callback((Fl_Callback*)cb_BotonTablaPrecorte);
        if (ControlTablaPrecorte) {o->show();} //inicialización
        else {o->hide();}
        switch (Idioma) {case ESP:o->label("Tabla-Precorte");break; case ING:o->label("Table-Slitting");break; case ITA:o->label("Quadro-Pretagliato");break;}
      } // Fl_Button* BotonTablaPrecorte
      { Fl_Button* o = BotonApagar = new Fl_Button(630, 525, 165, 70, "Apagar");
        BotonApagar->box(FL_PLASTIC_UP_BOX);
        BotonApagar->down_box(FL_PLASTIC_DOWN_BOX);
        BotonApagar->color(FL_INACTIVE_COLOR);
        BotonApagar->selection_color(FL_BACKGROUND2_COLOR);
        BotonApagar->labelfont(8);
        BotonApagar->labelsize(20);
        BotonApagar->callback((Fl_Callback*)cb_BotonApagar);
        switch (Idioma) {case ESP:o->label("Apagar");break; case ING:o->label("Exit");break; case ITA:o->label("Spegnere");break;}
      } // Fl_Button* BotonApagar
      { Fl_Light_Button* o = BotonLaser = new Fl_Light_Button(715, 75, 80, 35, "L\341ser");
        BotonLaser->box(FL_PLASTIC_UP_BOX);
        BotonLaser->down_box(FL_PLASTIC_DOWN_BOX);
        BotonLaser->color(FL_INACTIVE_COLOR);
        BotonLaser->selection_color(FL_FOREGROUND_COLOR);
        BotonLaser->labelfont(10);
        BotonLaser->labelsize(12);
        BotonLaser->labelcolor((Fl_Color)1);
        BotonLaser->callback((Fl_Callback*)cb_BotonLaser);
        if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico
        //o->deactivate(); // se inicia desactivado - tras inicializar los galvos se activa el botÂ´on
        switch (Idioma) {case ESP:o->label("Láser");break; case ING:o->label("Laser");break; case ITA:o->label("Laser");break;}
      } // Fl_Light_Button* BotonLaser
      { Fl_Light_Button* o = BotonCampo = new Fl_Light_Button(630, 75, 80, 35, "Campo");
        BotonCampo->box(FL_PLASTIC_UP_BOX);
        BotonCampo->down_box(FL_PLASTIC_DOWN_BOX);
        BotonCampo->color(FL_INACTIVE_COLOR);
        BotonCampo->selection_color(FL_FOREGROUND_COLOR);
        BotonCampo->labelfont(10);
        BotonCampo->labelsize(12);
        BotonCampo->callback((Fl_Callback*)cb_BotonCampo);
        if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico
        //o->deactivate(); // se inicia desactivado - tras inicializar los galvos se activa el botÂ´on
        switch (Idioma) {case ESP:o->label("Campo");break; case ING:o->label("Field");break; case ITA:o->label("Campo");break;}
      } // Fl_Light_Button* BotonCampo
      { Fl_Counter* o = CounterEncoder = new Fl_Counter(630, 430, 165, 35, "Encoder (cuentas/mm)");
        CounterEncoder->box(FL_PLASTIC_THIN_UP_BOX);
        CounterEncoder->color((Fl_Color)48);
        CounterEncoder->labelsize(12);
        CounterEncoder->minimum(1);
        CounterEncoder->maximum(10000);
        CounterEncoder->textfont(13);
        CounterEncoder->textsize(12);
        CounterEncoder->callback((Fl_Callback*)cb_CounterEncoder);
        CounterEncoder->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        CounterEncoder->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(CalibracionEncoder);
        if ((!ServicioTecnico) || (MarcajeDinamicoActivo != 1)) {o->hide();}
        switch (Idioma) {case ESP:o->label("Encoder (cuentas/mm)");break; case ING:o->label("Encoder (counts/mm)");break; case ITA:o->label("Encoder (conta/mm)");break;}
      } // Fl_Counter* CounterEncoder
      { Fl_Counter* o = CounterVelocidadLinea = new Fl_Counter(630, 430, 165, 35, "Velocidad l\355nea (m/min)");
        CounterVelocidadLinea->box(FL_PLASTIC_THIN_UP_BOX);
        CounterVelocidadLinea->color((Fl_Color)48);
        CounterVelocidadLinea->labelsize(12);
        CounterVelocidadLinea->minimum(0.1);
        CounterVelocidadLinea->maximum(1000);
        CounterVelocidadLinea->textfont(13);
        CounterVelocidadLinea->textsize(12);
        CounterVelocidadLinea->callback((Fl_Callback*)cb_CounterVelocidadLinea);
        CounterVelocidadLinea->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        CounterVelocidadLinea->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(VelocidadLinea);
        if ((!ServicioTecnico) || (MarcajeDinamicoActivo != 2)) {o->hide();}
        switch (Idioma) {case ESP:o->label("Velocidad línea (m/min)");break; case ING:o->label("Line speed (m/min)");break; case ITA:o->label("Velocità linea (m/min)");break;}
      } // Fl_Counter* CounterVelocidadLinea
      { Fl_Counter* o = CounterRetardoDisparo = new Fl_Counter(630, 485, 165, 35, "Retardo disparo (mm)");
        CounterRetardoDisparo->box(FL_PLASTIC_THIN_UP_BOX);
        CounterRetardoDisparo->color((Fl_Color)48);
        CounterRetardoDisparo->labelsize(12);
        CounterRetardoDisparo->minimum(0);
        CounterRetardoDisparo->maximum(1000);
        CounterRetardoDisparo->step(1);
        CounterRetardoDisparo->textfont(13);
        CounterRetardoDisparo->textsize(12);
        CounterRetardoDisparo->callback((Fl_Callback*)cb_CounterRetardoDisparo);
        CounterRetardoDisparo->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        CounterRetardoDisparo->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(RetardoDisparo_mm);
        o->lstep(10.0); // fija el incremento de la flecha doble del contador
        if ((!ServicioTecnico) || (TipoDisparo != DISPAROEXTERNO)) {o->hide();}
        switch (Idioma) {case ESP:o->label("Retardo disparo (mm)");break; case ING:o->label("trigger delay (mm)");break; case ITA:o->label("Ritardo trigger (mm)");break;}
      } // Fl_Counter* CounterRetardoDisparo
      { Fl_Counter* o = CounterSeparacionEntreDisparos = new Fl_Counter(630, 485, 165, 35, "Separaci\363n (mm)");
        CounterSeparacionEntreDisparos->box(FL_PLASTIC_THIN_UP_BOX);
        CounterSeparacionEntreDisparos->color((Fl_Color)48);
        CounterSeparacionEntreDisparos->labelsize(12);
        CounterSeparacionEntreDisparos->minimum(1);
        CounterSeparacionEntreDisparos->maximum(10000);
        CounterSeparacionEntreDisparos->step(1);
        CounterSeparacionEntreDisparos->value(1);
        CounterSeparacionEntreDisparos->textfont(13);
        CounterSeparacionEntreDisparos->textsize(12);
        CounterSeparacionEntreDisparos->callback((Fl_Callback*)cb_CounterSeparacionEntreDisparos);
        CounterSeparacionEntreDisparos->align(Fl_Align(133));
        CounterSeparacionEntreDisparos->when(FL_WHEN_RELEASE_ALWAYS);
        o->value(SeparacionEntreDisparos_mm); //inicialización
        o->lstep(10.0); // fija el incremento de la flecha doble del contador
        if ((!ServicioTecnico) || (TipoDisparo == DISPAROEXTERNO)) {o->hide();}
        switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}
      } // Fl_Counter* CounterSeparacionEntreDisparos
      GrupoControlOperacion->end();
    } // Fl_Group* GrupoControlOperacion
    { Fl_Button* o = BotonFPGA = new Fl_Button(630, 2, 165, 48, "FPGA");
      BotonFPGA->box(FL_PLASTIC_UP_BOX);
      BotonFPGA->down_box(FL_PLASTIC_DOWN_BOX);
      BotonFPGA->color((Fl_Color)5);
      BotonFPGA->selection_color(FL_BACKGROUND2_COLOR);
      BotonFPGA->labelfont(8);
      BotonFPGA->labelsize(15);
      BotonFPGA->callback((Fl_Callback*)cb_BotonFPGA);
      if (debug_FPGA) {o->show();} else {o->hide();}; //inicialización
    } // Fl_Button* BotonFPGA
    { BotonResetContador = new Fl_Button(330, 3, 50, 27, "Reset");
      BotonResetContador->box(FL_PLASTIC_UP_BOX);
      BotonResetContador->down_box(FL_PLASTIC_DOWN_BOX);
      BotonResetContador->color(FL_INACTIVE_COLOR);
      BotonResetContador->selection_color(FL_FOREGROUND_COLOR);
      BotonResetContador->labelfont(8);
      BotonResetContador->labelsize(12);
      BotonResetContador->callback((Fl_Callback*)cb_BotonResetContador);
    } // Fl_Button* BotonResetContador
    VentanaPrincipal->set_modal();
    VentanaPrincipal->clear_border();
    VentanaPrincipal->size_range(800, 600, 800, 600);
    VentanaPrincipal->end();
  } // Fl_Double_Window* VentanaPrincipal
    
    #ifdef _68pines
  	BoxVersionSW->label("Itaca v6.0.30.68p");
  #else 
  	BoxVersionSW->label("Itaca v6.0.33"); 
  #endif
  
    if (ENDESARROLLO) {
  
  	BoxVersionSW->label("Desarrollo v5.07");
  	
  }
  
  if (PuertoSerieActivo == ON) {
  
  	Inicializar_PuertoSerie();
  	
  	// Arranca el timer del puerto serie
  	Fl::add_timeout(0.1, ControlPuertoSerie);
  
  }
  	
  // Inicializar sistema de control:
  Inicializar_Control();
  
  // Espera 1 segundo antes de seguir para dar tiempo a los galvos a inicializarse
  sleep(1);
  
    switch (MarcajeDinamicoActivo) {
  
  // desactivado
  case 0:
  	CuadroTextoVLinea->hide();
  	CuadroTextoVLinea->value();
  	CounterVelocidadLinea->hide();
  	CounterEncoder->hide();
  	break;
  	
  // activado, valocidad variable (lectura de encoder)
  case 1:
  	// Inicializa el encoder
  	//Inicializar_Encoder();
  	
  	// Inicializar la lectura de cuentas del encoder
  	//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior_Estado);
  	//if (error < 0) {
  	//	rt_printk("ESTADO: LEER ENCODER comedi_data_read = %d\n",error);
  	//	ErrorDAQ = ON;
  	//	ProcesarError();
  	//}
  	
  	//CuadroTextoVLinea->deactivate();
  	ValorCuentasAnterior_Estado = ValorCuentasActual;
  	
  	CounterVelocidadLinea->hide();
  	
  	if (ServicioTecnico) {
  		CounterEncoder->show();
  	}
  	else {
  		CounterEncoder->hide();
  	}
  	
  	break;
  
  // activado, con velocidad constante (fijada en itaca.conf)
  case 2:
  	CuadroTextoVLinea->deactivate();
  	CuadroTextoVLinea->value(VelocidadLinea);
  	
  	if (ServicioTecnico) {
  		CounterVelocidadLinea->show();
  	}
  	else {
  		CounterVelocidadLinea->hide();
  	}
  	
  	CounterEncoder->hide();
  	
  	break;
  	
  // error
  default:
  	break;
  	
  }
  
  // Si no hay problema con la DAQ/FPGA sigue normalmente
  if ((ErrorDAQ == false) && (ErrorFPGA == false)) {
  	
  	// Coloca los galvos en el origen
  	Inicializar_Galvos();
  	
      	Inicializar_Laser();
  	
  	// Inicializa el encoder
  	Inicializar_Encoder();
  	
  	// Inicializar RTAI y el timer en tiempo real
  	Inicializar_RTAI();
  		
    	if (!ENDESARROLLO){
  		Inicializar_thread_estado();
  	}
  	
  	// thread check
  	if (MarcajeDinamicoActivo == 1) {
  		Fl::add_check(ActualizaUI);
  	}
  
  	// Activa los botones de marcaje
  	BotonMarcar->activate();
  	BotonPrueba->activate();
  	
  	// Mover los galvos al origen
  	// La posicion inicial corresponde a las coordenadas 0,0 con comedi, y a -10,-10 con FPGA
  	if (Control == DAQ) {
  		xValuesPosicion = 0;
  		yValuesPosicion = 0;
  		
  		if ((CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0) && (!debug_FPGA)) {
  			MoverGalvos();
  		}
  		
  	}
  	
  	else if (Control == FPGA) {
  		
      		EscribirGalvoX_FPGA(FPGA_from_phys(0.0));
  		EscribirGalvoY_FPGA(FPGA_from_phys(0.0));	
  	}
  	
  }
  
  // Si hay problema con la DAQ/FPGA procesa el error
  else {
  
  	//Actualiza el Led de estado
  	switch (Control) {
  
  	case DAQ:
  	
  		switch (Idioma) {
  	
  		case ESP:
  			LedEstado->label("DAQ");
  			break; 
  			
  		case ING:
  			LedEstado->label("DAQ");
  			break; 
  			
  		case ITA:
  			LedEstado->label("DAQ");
  			break;
  	
  		}
  		
  		break;
  
  	case FPGA:
  		
  		switch (Idioma) {
  	
  		case ESP:
  			LedEstado->label("FPGA");
  			break; 
  			
  		case ING:
  			LedEstado->label("FPGA");
  			break; 
  			
  		case ITA:
  			LedEstado->label("FPGA");
  			break;
  	
  		}
  			
  		break;
  	
  	} 	
  
  	
  			
  	LedEstado->color((Fl_Color)1); 	// Led rojo
  	LedEstado->redraw();		// Marca el Led para redraw
  	LedEstado->deactivate();	// Y lo desactiva, ya que no se puede recuperar de un error de DAQ
  	Fl::flush();			// Redraw all
  
  	// Desactiva los botones de marcaje, ya que no se pueden usar
  	//if (!ENDESARROLLO) {
  		
  		BotonMarcar->deactivate();
  		BotonPrueba->deactivate();
  		BotonCampo->deactivate();
  		BotonLaser->deactivate();
  	
  	//}
  	
  }
  
    if (!ValidarSistema()) {
  
  	ErrorValidacion = ON;
  	
  	//Actualiza el Led de estado
  	switch (Idioma) {
  	
  		case ESP:
    		break; 
  			
  		case ING:
  		LedEstado->label("Validation");
  		break; 
  			
  		case ITA:
  		LedEstado->label("Convalida");
  		break;
  	
  	}
  			
  	LedEstado->color(FL_YELLOW); 	// Led amarillo
  	LedEstado->redraw();		// Marca el Led para redraw
    	Fl::flush();			// Redraw all
  
  	// Desactiva los botones de marcaje, ya que no se pueden usar
  	//if (!ENDESARROLLO) {
  		
  		BotonMarcar->deactivate();
  	//	BotonMarcar->hide();		// Para que no se pueda marcar de ninguna manera
  	//	BotonPrueba->deactivate();
  	//	BotonCampo->deactivate();
  	//	BotonLaser->deactivate();
  	
  	//}
  
  }
  
    
  Llevar_Galvos_Origen();
  VentanaPrincipal->show(argc, argv);
  return Fl::run();
}

int Leer_Entradas_Temperatura() {
  int error = false;
}

int Salida_PWM_Ventilador() {
  int error = false;
}
