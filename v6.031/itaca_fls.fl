# data file for the Fltk User Interface Designer (fluid)
version 1.0107 
header_name {.h} 
code_name {.cxx}
comment {//==============================================================================
//
// Título:      Itaca
//
// Objetivo:    Coder en Linux aprovechando la infraestructura de tiempo real 
//		desarrollada para Resurfacing, y utilizando driver Comedi
//		
// Creado:	Mayo 2009 v1.3 A. López
//
//		Las versiones anteriores son para la DAQ NI pci6221 de 68 pines
//		Esta versión v1.3 es para la DAQ NI pci6221 de 37 pines
//		
//		Para versiones posteriors ver readme.txt
//
//		kernel 2.6.23.9 - vanilla compilado con genkernel 
//		(a partir de una instalación de gentoo)	
//
//		rtai 3.6
//		comedi 0.7.76 
//		comedilib 0.9.0
//		fltk/fluid 1.1.7
//		i686-pc-linux-gnu-g++ (GCC) 4.1.1 (Gentoo 4.1.1-r3)
//		Qt: 3.3.8
//		KDE: 3.5.8
//
// Copyright:   Fotonica Laser Systems
//
//==============================================================================

/*

Versiones:	
		v1.0 Septiembre 2008
		
		v1.1 Febrero 2009

		v1.2 Abril 2009
		
		v1.3 Mayo 2009
		
		- Adaptación a DAQ NI pci6221 37 pines
		- Comprobación de posición de galvos 
		- Comprobación de que la marca ha cabido en el campo
		- Velocidad constante (sin encoder)
		- Presentación de velocidad y tiempo marca
		- Control de overflow de encoder
		
		Para versiones posteriors ver readme.txt

*/

//==============================================================================} {in_source in_header
} 

decl {\#include "includes.h" //includes del programa} {public
} 

decl {\#include "constantes.h" //constantes del programa} {public
} 

decl {\#include "variables.h" //variables globales} {public
} 

Function {Make_Window_Confirmar_Prueba()} {C
} {
  Fl_Window VentanaPrueba {open
    xywh {250 210 460 230} type Double box BORDER_FRAME color 92 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 92
    } {
      Fl_Box {} {
        label {¿Prueba de marcaje?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Prueba de marcaje?");break; case ING:o->label("Test marking?");break; case ITA:o->label("Prova di stampa?");break;}}
      }
      Fl_Button Aceptar_VentanaPrueba {
        label Aceptar
        callback {// Oculta la ventana emergente actual
VentanaPrueba->hide();

// Activa la ventana principal para desactivar sólo lo necesario
VentanaPrincipal->activate();

// Activa el flag de prueba de marcaje
PruebaMarcaje = true;

// Calcula la matriz
if (CalcularMatriz() != NoError) {

	rt_printk("Error CalcularMatriz\\n");

	// Apaga el botón de prueba
	BotonPrueba->value(OFF);
	
	//StopEjecucion();
	return;

}

// Desactiva los grupos de control de intensidad, de marca y de texto
GrupoControlIntensidad->deactivate();
GrupoControlMarca->deactivate();
GrupoControlTexto->deactivate();
GrupoControlTextoBloques->deactivate();

// Desactiva los botones de operaciones
BotonMarcar->deactivate();
BotonPrueba->deactivate();
BotonTrabajos->deactivate();
BotonTablaPrecorte->deactivate();

CounterVelocidadLinea->deactivate();
CounterEncoder->deactivate();
BotonLaser->deactivate();
BotonCampo->deactivate();
BotonApagar->deactivate();

// Activa el botón de stop
BotonStop->activate();

// Actualiza el led del láser
LedLaser->color(FL_YELLOW);
LedLaser->redraw();

//Inicia Oscilador Fibra
switch(TipoLaser){
case 1:
Iniciar_Oscilador_Fibra();
sleep(1);
break;
}

		
// Fuerza la actualización del interfaz
Fl::flush();

// Mueve los galvos al inicio de la lista si es necesario
if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
	MoverGalvos();
}

// Descarga la lista 1
DescargarLista(1);

// Desactiva la espera del disparo de la fotocélula
EsperaFotocelula = false;

// Desactiva la espera del retardo de disparo
EsperaRetardoDisparo = false;

// Desactiva la espera de la separación entre disparos
EsperaSeparacionEntreDisparos = false;

// Desactiva las cuentas de marcaje dinámico 
IncrementoAcumulado = 0;

// Actualiza la señal de MarkInProgress y el Led del láser
ControlMarkInProgress(ON);
				
//rt_printk("inicia Prueba de Marcaje\\n");
	
// Ejecuta la lista 1
MarcajeOk = true;
EjecutarLista(1);

// Espera a que termine la ejecución de la lista actual:
while (((Lista1_Exe) || (Lista0_Exe)) && (PruebaMarcaje) && (SistemaOk) && (MarcajeOk)) {
        
	// Espera un periodo
        Fl::wait(PERIODO_WAIT);
        	
}

//rt_printk("termina Prueba de Marcaje\\n");

// Presenta en pantalla el valor del tiempo de la marca formateado en ms     
CuadroTextoTMarca->value((double)(tFinMarca - tInicioMarca)/1E6);
//Para el Oscilador Fibra
switch(TipoLaser){
case 1:
Parar_Oscilador_Fibra();
break;
}        
// Restaura el interfaz
StopEjecucion();}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaPrueba {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaPrueba->hide();

// Apaga el botón de prueba
BotonPrueba->value(OFF);

// Desactiva el botón de stop
BotonStop->deactivate();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_Confirmar_Marcar()} {C
} {
  Fl_Window VentanaMarcar {open
    xywh {250 200 460 230} type Double box BORDER_FRAME color 92 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 92
    } {
      Fl_Box {} {
        label {¿Iniciar el marcaje?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Iniciar el marcaje?");break; case ING:o->label("Start marking?");break; case ITA:o->label("Iniziare la stampa?");break;}}
      }
      Fl_Button Aceptar_VentanaMarcar {
        label Aceptar
        callback {// Ha sido ordenado desde el interfaz:
ModoImpresionSerie = false;

// Oculta la ventana emergente actual
VentanaMarcar->hide();

//Inicia Oscilador Fibra
switch(TipoLaser){
case 1:
Iniciar_Oscilador_Fibra();
sleep(1);
break;
}
// Variables para el cálculo de fecha y hora si hay que resetear el numero de serie por cambio de fecha
static time_t curtimeserie;
static struct tm *loctimeserie;
static char tmpfechaserie[LongitudMaximaStringFecha];
// Get the current time
	curtimeserie = time (NULL);
     	
	// Convert it to local time representation
	loctimeserie = localtime (&curtimeserie);
				
	strftime (tmpfechaserie, LongitudMaximaStringFecha, "%d", loctimeserie);
	strcpy(FechaInicioMarca,tmpfechaserie);


// Inicia la ejecución
StartEjecucion();}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaMarcar {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaMarcar->hide();

// Apaga el botón de marcar
BotonMarcar->value(OFF);

// Desactiva el botón de stop
BotonStop->deactivate();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_Confirmar_Apagar()} {C
} {
  Fl_Window VentanaApagarSistema {open
    xywh {250 200 460 230} type Double box BORDER_FRAME color 1 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 1
    } {
      Fl_Box {} {
        label {¿Apagar el sistema?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Apagar el sistema?");break; case ING:o->label("Power off the system?");break; case ITA:o->label("Spegnere il sistema?");break;}}
      }
      Fl_Button Aceptar_VentanaApagarSistema {
        label Aceptar
        callback {// Guarda los datos definidos en el interfaz; serán los que se cargarán en el próximo arranque de la máquina
Escribir_DAT("itaca.dat");

// sale del programa	
ExitOrdenadamente();}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaApagarSistema {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaApagarSistema->hide();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_Modificar_Texto()} {C
} {
  Fl_Window VentanaModificarTexto {open
    xywh {0 0 800 600} type Double color 7 selection_color 7 when 6 resizable modal noborder size_range {800 600 800 600} visible
  } {
    Fl_Box LogoItacaVentanaModificar {
      image {fls.png} xywh {630 0 165 75} color 7 labelsize 12 align 16
    }
    Fl_Group GrupoFecha {
      xywh {10 10 615 80} box PLASTIC_DOWN_BOX color 47 labelcolor 1
    } {
      Fl_Button BotonFecha {
        label {Añadir Fecha}
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Actualiza los campos variables para reflejar el valor actual
//ActualizarFechaHora();
//ActualizarFechaHoraSerie();

// Compone el formato de la fecha
// inicializa la variable del formato
strcpy(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], "");

// primer campo
if (ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// segundo campo
if (ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], SeparadorFecha[ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]]);
	}

	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// tercer campo
if (ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], SeparadorFecha[ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]]);
	}
	
	strcat(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1], FormatoFecha[Idioma][ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// Presenta un mensaje de error y sale si no hay campos definidos:
if (strlen(FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]) == 0) {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un valor");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a value");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezionare valore");
		break;
			
	}

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	//VentanaPrincipal->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	return;
	
}

// Procesa el texto
switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
case 0: //no tiene la hora
        
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: // no tiene numero de serie
 
        	// el primer campo variable es la fecha
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            	// guarda el texto anterior a la fecha
            	strcpy(textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
		// Actualiza el cuadro de texto
		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
            		
        case 1: //tiene ya el numero de serie
            		
            	// la fecha es el segundo campo variable
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 2;
            		
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
	        break;
	           	
        }
	
	break;
		
case 1: //tiene ya la hora y va en primer lugar
    
	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        case 0: // no tiene numero de serie
        	
        	// la fecha es el segundo campo variable
        	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 2;

		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
        	
        case 2:  // también tiene el número de serie
        
        	// la fecha es el tercer campo variable
            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
		CuadroTextoLinea->value(str);
			
        	break;
        		
        }
        	
        break;
        	
case 2: //tiene ya la hora y va en segundo lugar
    	
        switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       	case 1:
       		
       		// la fecha es el tercer campo variable
		OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
	        // Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
	            	
        	break;
        		
        }
        	
	break;
	
}
	
	
// Activa el flag de la fecha
StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
// Ahora desactiva los widgets relacionados con la fecha
BotonFecha->deactivate();
ChoiceFormatoFecha1->deactivate();
ChoiceFormatoFecha2->deactivate();
ChoiceFormatoFecha3->deactivate();
ChoiceSeparadorFecha->deactivate();
IndicadorCaducidad->deactivate();}
        xywh {20 21 150 60} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 18
        code0 {if (StatusFecha[LineaCalcular - 1]) {o->deactivate();} // si ya está definida la fecha, desactivar}
        code1 {else {o->activate();} // y si no, activar}
        code3 {switch (Idioma) {case ESP:o->label("Añadir Fecha");break; case ING:o->label("Add Date");break; case ITA:o->label("Creare Data");break;}}
      }
      Fl_Choice ChoiceFormatoFecha1 {
        label primero
        callback {// Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1] = o->value();} open
        xywh {180 44 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización}
        code1 {if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar}
        code2 {o->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);}
        code3 {switch (Idioma) {case ESP:o->label("primero");break; case ING:o->label("first");break; case ITA:o->label("primo");break;}}
      } {}
      Fl_Choice ChoiceFormatoFecha2 {
        label segundo
        callback {// Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1] = o->value();} open
        xywh {265 44 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización}
        code1 {if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar}
        code2 {o->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);}
        code3 {switch (Idioma) {case ESP:o->label("segundo");break; case ING:o->label("second");break; case ITA:o->label("secondo");break;}}
      } {}
      Fl_Choice ChoiceFormatoFecha3 {
        label tercero
        callback {// Almacena el valor seleccionado en la variable FormatoFecha
ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1] = o->value();}
        xywh {350 44 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosFecha; i++) {o->add(FormatoFecha[Idioma][i]);}//inicialización}
        code1 {if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar}
        code2 {o->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);}
        code3 {switch (Idioma) {case ESP:o->label("tercero");break; case ING:o->label("third");break; case ITA:o->label("terzo");break;}}
      } {}
      Fl_Choice ChoiceSeparadorFecha {
        label {sep.}
        callback {// Almacena el valor seleccionado
ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1] = o->value();} open
        xywh {435 44 60 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<SeparadoresFecha; i++) {o->add(SeparadorFecha[i]);}//inicialización}
        code1 {if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar}
        code2 {o->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);}
        code3 {switch (Idioma) {case ESP:o->label("sep.");break; case ING:o->label("sep.");break; case ITA:o->label("sep.");break;}}
      } {}
      Fl_Counter IndicadorCaducidad {
        label {Cad.(meses)}
        callback {// Cambia la caducidad
Caducidad[LineaCalcular - 1][BloqueCalcular - 1] = (int) o->value();	// en meses}
        xywh {505 44 110 36} type Simple box PLASTIC_THIN_UP_BOX color 0 labelfont 8 labelsize 15 align 1 minimum 0 maximum 120 step 1 textfont 8 textsize 15
        code0 {o->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]); //inicialización}
        code1 {if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la fecha, desactivar, y si no, activar}
        code3 {switch (Idioma) {case ESP:o->label("Cad.(meses)");break; case ING:o->label("Exp.(months)");break; case ITA:o->label("Scad.(mesi)");break;}}
      }
    }
    Fl_Group GrupoHora {
      xywh {10 95 615 80} box PLASTIC_DOWN_BOX color 47
    } {
      Fl_Button BotonHora {
        label {Añadir Hora}
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Actualiza los campos variables para reflejar el valor actual
//ActualizarFechaHora();
//ActualizarFechaHoraSerie();

// Compone el formato de la hora
// inicializa la variable del formato
strcpy(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], "");

// primer campo
if (ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	strcpy(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// segundo campo
if (ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1] > 0) {

	// separador
	if (ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], SeparadorHora[ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]]);
	}

	strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// tercer campo
if (ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	
	// separador
	if (ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
		strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], SeparadorHora[ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]]);
	}
	
	strcat(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1], FormatoHora[Idioma][ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]]);
}

// Presenta un mensaje de error y sale si no hay campos de finidos:
if (strlen(FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]) == 0) {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un valor");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a value");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezionare valore");
		break;
			
	}

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	//VentanaPrincipal->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	return;
	
}

// Procesa el texto
switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
case 0: //no tiene la fecha
        
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: // no tiene número de serie

       		// el primer campo variable es la hora
          	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            	// guarda el texto anterior a la hora
            	strcpy(textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
		// Actualiza el cuadro de texto
		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            	
            	break;
            		
        case 1: //ya tiene número de serie
            		
           	// la hora es el segundo campo variable
            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 2; 
            		
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
	        break;
	            	
        }
	
	break;
    	
case 1: //tiene ya la fecha y va en primer lugar

     	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        case 0: // no tiene número de serie

		// la hora es el segundo campo variable
        	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 2;

		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
            		
            	break;
        	
        case 2: // ya tiene número de serie
            	
            	// la hora es el tercer campo variable
            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            	// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
		CuadroTextoLinea->value(str);
			
        	break;
        		
        }
        	
        break;
        	
case 2: //tiene ya la fecha y va en segundo lugar
        	
       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
     	case 1:
	
		// la hora es el tercer campo variable
		OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
		// Actualiza el cuadro de texto
            	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            	strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            	CuadroTextoLinea->value(str);
	            	
        	break;
        		
        }
        	
	break;
	
}
	
// Activa el flag de la hora
StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
// Ahora desactiva los widgets relacionados con el número de serie
BotonHora->deactivate();
ChoiceFormatoHora1->deactivate();
ChoiceFormatoHora2->deactivate();
ChoiceFormatoHora3->deactivate();
ChoiceSeparadorHora->deactivate();}
        xywh {20 106 150 60} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 18
        code0 {if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} // si ya está definida la hora, desactivar}
        code1 {else {o->activate();} // y si no, activar}
        code3 {switch (Idioma) {case ESP:o->label("Añadir Hora");break; case ING:o->label("Add Time");break; case ITA:o->label("Creare Orario");break;}}
      }
      Fl_Choice ChoiceFormatoHora1 {
        label primero
        callback {// Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1] = o->value();}
        xywh {180 129 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización}
        code1 {o->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial}
        code2 {if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar}
        code3 {switch (Idioma) {case ESP:o->label("primero");break; case ING:o->label("first");break; case ITA:o->label("primo");break;}}
      } {}
      Fl_Choice ChoiceFormatoHora2 {
        label segundo
        callback {// Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1] = o->value();}
        xywh {265 129 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización}
        code1 {o->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial}
        code2 {if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar}
        code3 {switch (Idioma) {case ESP:o->label("segundo");break; case ING:o->label("second");break; case ITA:o->label("secondo");break;}}
      } {}
      Fl_Choice ChoiceFormatoHora3 {
        label tercero
        callback {// Almacena el valor seleccionado en la variable FormatoHora
ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1] = o->value();}
        xywh {350 129 80 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<FormatosHora; i++) {o->add(FormatoHora[Idioma][i]);}//inicialización}
        code1 {o->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial}
        code2 {if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar}
        code3 {switch (Idioma) {case ESP:o->label("tercero");break; case ING:o->label("third");break; case ITA:o->label("terzo");break;}}
      } {}
      Fl_Choice ChoiceSeparadorHora {
        label {sep.}
        callback {// Almacena el valor seleccionado
ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1] = o->value();}
        xywh {435 129 60 36} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {int i; for (i=0; i<SeparadoresHora; i++) {o->add(SeparadorHora[i]);}//inicialización}
        code1 {o->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);// carga el valor inicial}
        code2 {if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definida la hora, desactivar}
        code3 {switch (Idioma) {case ESP:o->label("sep.");break; case ING:o->label("sep.");break; case ITA:o->label("sep.");break;}}
      } {}
    }
    Fl_Group GrupoSerie {open
      xywh {10 180 615 80} box PLASTIC_DOWN_BOX color 47
    } {
      Fl_Button BotonSerie {
        label {Añadir Serie}
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// variables de estado para comprobar los campos
bool inicioOK, finalOK, unidadesloteOK, actualOK;

// control de estado de las variables

// número de inicio: basta con que exista
if (strlen(CuadroTextoSerie->value())) {
	inicioOK = true;
}

else {	
	inicioOK = false;
}

// número final, en caso de existir
if ( strlen(CuadroTextoSerieFinal->value()) ) {
	
	// si existe debe ser mayor que 0 y mayor que el de inicio
	if ( atoi(CuadroTextoSerieFinal->value()) > atoi(CuadroTextoSerie->value()) ){
		finalOK = true;
	}
	
	else {
		finalOK = false;
	}
}

// si no existe es correcto
else {	
	finalOK = true;
} 


// unidades por lote: tiene que ser mayor que 0 en caso de estar definido
if ( strlen(CuadroTextoUnidadesLote->value()) ) {
	
	// si existe debe ser mayor que el de inicio
	if ( atoi(CuadroTextoUnidadesLote->value()) > 0 ) {
		unidadesloteOK = true;
	}
	
	else {
		unidadesloteOK = false;
	}
}

// si no existe no es correcto
else {	
	unidadesloteOK = false;
}

// unidad actual, en caso de existir
if ( strlen(CuadroTextoUnidadesLoteActual->value()) ) {
	
	// si existe debe ser mayor o igual que 0 y menor o igual al número de unidades por lote
	if ( (atoi(CuadroTextoUnidadesLoteActual->value())>=0) && (atoi(CuadroTextoUnidadesLoteActual->value()) <= atoi(CuadroTextoUnidadesLote->value())) ){
		actualOK = true;
	}
	
	else {
		actualOK = false;
	}
}

// si no existe no es correcto
else {	
	actualOK = false;
} 


// si todo es correcto se sigue adelante
if ((inicioOK) && (finalOK) && (unidadesloteOK) && (actualOK)) {

	// Número de serie:
	NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoSerie->value());
	NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1] = NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1];
	NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoSerieFinal->value());
	
	// Guarda el número de dígitos para formatear
	NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = strlen(CuadroTextoSerie->value());
	
	// Escribe el valor formateado en un string
	sprintf(strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
	
	// Mira a ver si hay lote
	if (strlen(CuadroTextoUnidadesLote->value())) { // con lote
		
		NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoUnidadesLote->value());
		NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = atoi(CuadroTextoUnidadesLoteActual->value());
	}	
		
	else { // sin lote
		
		NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1] = 1;
		CuadroTextoUnidadesLote->value("1");
		NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = 1;
		CuadroTextoUnidadesLoteActual->value("1");
	}
	
	//printf("NumeroSerie:%ld %s NumeroUnidadesLote:%d\\n", NumeroSerie, strNumeroSerie, NumeroUnidadesLote);
	
	// Procesa el texto
	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
	
	case 0: //no tiene la hora
        
        	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: // no tiene la fecha

        		// el primer campo variable es el número de serie
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 1;

            		// guarda el texto anterior al número de serie
            		strcpy(textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1], CuadroTextoLinea->value());
			
			// Actualiza el cuadro de texto
			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
            		//printf("textoanteriorserie:%s strNumeroSerie:%s\\n", textoanteriorserie,strNumeroSerie);   
            		
            		break;
            		
        	case 1: //tiene ya la fecha
            		
            		// el número de serie es el segundo campo variable
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 2;
            		
            		// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
	            	break;
	            	
        	}
	
		break;
	
		
	case 1: //tiene ya la hora y va en primer lugar

       	 	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: // no tiene la fecha
        	
        		// el número de serie es el segundo campo variable
        		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 2;

			// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
            		
            		break;
        	
        	case 2:  // también tiene la fecha
        	
        		// el número de serie es el tercer campo variable
            		OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 3;
            	
            		// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
			
        		break;
        		
        	}
        	
        	break;
        
        	
        case 2: //tiene ya la hora y va en segundo lugar
        	
        	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 1:
       		
       			// el número de serie es el tercer campo variable
	            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 3;
	            	
	            	// Actualiza el cuadro de texto
            		strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);
	            	
        		break;
        		
        	}
        	
		break;
	
	}
	
	// Activa el flag del número de serie
	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = true;
	
	// Ahora desactiva los widgets relacionados con el número de serie
	BotonSerie->deactivate();
	CuadroTextoSerie->deactivate();
	CuadroTextoSerieFinal->deactivate();
	FrameLote->deactivate();
	CuadroTextoUnidadesLote->deactivate();
	CuadroTextoUnidadesLoteActual->deactivate();
	
	// El de actual se desactiva sólo si no hay lote; si hay lote se deja, para que pueda modificarse
	//if (NumeroUnidadesLote[LineaCalcular - 1] == 1) {
	//	CuadroTextoUnidadesLoteActual->deactivate();
	//}
	
	// Activa el botón de reiniciar
	BotonReiniciarSerie->activate();
	
	// Y pasa el cursor al cuadro de texto
	indice = 0;
	
}

// Agún campo es incorrecto: saca los mensajes apropiados
else {

	if (inicioOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca el número de inicio de la serie");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter the series start number");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre il numero di inizio della serie");
			break;
			
		}

	}
	
	if (finalOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número final superior al número de inicio de la serie");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter an end number higher than the start number");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero finale superiore al numero di inizio della serie");
			break;
			
		}	

	}
	
	if (unidadesloteOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número de unidades por lote mayor que 0");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter a number of units per batch higher than 0");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero per il lotto maggiore di 0");
			break;
			
		}

	}
	
	if (actualOK == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Introduzca un número actual mayor que cero e inferior o igual al número de unidades por lote");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Enter a current number bigger than 0 and equal or less than the number of units per batch");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Introdurre un numero attuale maggiore di 0 e inferiore o pari al numero di unità del lotto");
			break;
			
		}

	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaModificarTexto->deactivate();
	
	// Presenta la ventana con el mensaje emergente correspondiente al último error
	VentanaMensaje->show();

}}
        xywh {20 190 150 60} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 18
        code0 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar}
        code3 {switch (Idioma) {case ESP:o->label("Añadir Serie");break; case ING:o->label("Add Series");break; case ITA:o->label("Creare Serie");break;}}
      }
      Fl_Output CuadroTextoSerie {
        label Inicio
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 1;}
        xywh {180 219 80 26} box PLASTIC_THIN_DOWN_BOX labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {//char record[12]; sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1], NumeroSerieInicial[LineaCalcular - 1]);o->value(record); //inicialización}
        code1 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar}
        code2 {//o->clear_visible_focus(); // Para que no se vea "^" en el widget}
        code3 {switch (Idioma) {case ESP:o->label("Inicio");break; case ING:o->label("Start");break; case ITA:o->label("Inizio");break;}}
      }
      Fl_Output CuadroTextoSerieFinal {
        label Fin
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 3;}
        xywh {265 219 80 26} box PLASTIC_THIN_DOWN_BOX labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
        code0 {char record[12];}
        code1 {if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record);} else {o->value("");}}
        code2 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar}
        code3 {//o->clear_visible_focus(); switch (Idioma) {case ESP:o->label("Fin");break; case ING:o->label("End");break; case ITA:o->label("Fine");break;}}
      }
      Fl_Group FrameLote {
        label Lote open
        xywh {350 200 155 50} box BORDER_FRAME labelfont 8 labelsize 15
        code3 {switch (Idioma) {case ESP:o->label("Lote");break; case ING:o->label("Batch");break; case ITA:o->label("Lotto");break;}}
      } {
        Fl_Output CuadroTextoUnidadesLote {
          label unidades
          callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 2;}
          xywh {355 219 70 26} box PLASTIC_THIN_DOWN_BOX labelfont 8 labelsize 12 align 133 textfont 8 textsize 15
          code0 {char record[12]; sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record); //inicialización}
          code1 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar}
          code2 {//o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("unidades");break; case ING:o->label("units");break; case ITA:o->label("unità");break;}}
        }
        Fl_Output CuadroTextoUnidadesLoteActual {
          label actual
          callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 4;}
          xywh {430 219 70 26} box PLASTIC_THIN_DOWN_BOX labelfont 8 labelsize 12 align 133 textfont 8 textsize 15
          code0 {char record[12]; sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);o->value(record); //inicialización}
          code1 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->deactivate();} else {o->activate();} // si ya está definido el número de serie, desactivar, y si no, activar}
          code2 {//o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("actual");break; case ING:o->label("current");break; case ITA:o->label("attuale");break;}}
        }
      }
      Fl_Button BotonReiniciarSerie {
        label Reiniciar
        callback {char record[12];

// Carga el número de serie inicial
NumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1];

// Carga el número inicial de unidades del lote
NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = 1;
sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLoteActual->value(record);

// Actualiza los campos
//actualizarserie = true;
ActualizarFechaHoraSerie();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
CargarTexto();}
        xywh {530 191 80 30} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 15
        code0 {if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {o->activate();} else {o->deactivate();} // si ya está definido el número de serie, activar, y si no, desactivar}
        code3 {switch (Idioma) {case ESP:o->label("Reiniciar");break; case ING:o->label("Reset");break; case ITA:o->label("Reiniziare");break;}}
      }
      Fl_Check_Button CheckResetSerieFecha {
        label {Reset date}
        callback {ResetSerieFecha = (int) o->value();
rt_printk("ResetSerieFecha: %ld\\n", ResetSerieFecha);

/*if (o->value(ON)){
	ResetSerieFecha = (int) o->value();
	rt_printk("ResetSerieFecha: %ld\\n", ResetSerieFecha);
	}
	else {
	ResetSerieFecha = (int) o->value();
	rt_printk("ResetSerieFecha: %ld\\n", ResetSerieFecha);
	}
	*/}
        xywh {515 225 90 30} down_box DOWN_BOX
        code0 {o->value(ResetSerieFecha); //inicialización}
      }
    }
    Fl_Output CuadroTextoLinea {
      callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;}
      xywh {10 265 750 50} type Multiline box PLASTIC_THIN_DOWN_BOX color 175 labelfont 8 align 5 textfont 8
      code0 {//o->clear_visible_focus(); // Para que no se vea "^" en el widget}
      code1 {o->type(FL_MULTILINE_OUTPUT_WRAP);}
      class Fl_Output
    }
    Fl_Group GrupoTeclado {open
      xywh {10 320 750 270} box PLASTIC_UP_FRAME color 0
    } {
      Fl_Button Boton1 {
        label 1
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "1");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {20 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton2 {
        label 2
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "2");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {70 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton3 {
        label 3
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "3");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {120 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton4 {
        label 4
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "4");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {170 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton5 {
        label 5
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "5");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {220 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton6 {
        label 6
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "6");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {270 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton7 {
        label 7
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "7");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {320 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton8 {
        label 8
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "8");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {370 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton9 {
        label 9
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

	// concatena el nuevo carácter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(LineaTexto);
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "9");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	break;

}}
        xywh {420 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button Boton0 {
        label 0
        callback {switch (indice) {

// se está editando la linea de texto
case 0:

	// procesa el nuevo caracter
	ProcesarCaracter(o->label());
	
	break;
	
// se esta editando la linea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerie->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "0");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(LineaTexto);
	
	break;

// se está editando la linea del número de unidades por lote
case 2:

	// sólo permite añadir un 0 si no es el primer carácter
	if ( strlen(CuadroTextoUnidadesLote->value()) ) {
	
		// duplica el texto actual en una nueva variable
		strcpy(LineaTexto, CuadroTextoUnidadesLote->value());

		// concatena el nuevo carácter
		strcat(LineaTexto, "0");

		// asigna el nuevo texto al cuadro de texto
		CuadroTextoUnidadesLote->value(LineaTexto);
	
	}
	
	break;

// se esta editando la linea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(LineaTexto, CuadroTextoSerieFinal->value());

	// concatena el nuevo caracter
	strcat(LineaTexto, "0");

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(LineaTexto);
	
	break;


// se esta editando la linea del número actual de unidad en el lote
case 4:

	// sólo permite añadir un 0 si no es el primer carácter
	if ( strlen(CuadroTextoUnidadesLoteActual->value()) ) {
	
		// duplica el texto actual en una nueva variable
		strcpy(LineaTexto, CuadroTextoUnidadesLoteActual->value());

		// concatena el nuevo caracter
		strcat(LineaTexto, "0");

		// asigna el nuevo texto al cuadro de texto
		CuadroTextoUnidadesLoteActual->value(LineaTexto);
	
	}
	
	break;

}}
        xywh {470 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonBorrar {
        label Borrar
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// según qué campo está activo hay que proceder de distinta forma
switch (indice) {

/////////////////////////////////////////////////////////////////////////////////////////////	
// se esta editando la linea de texto
case 0: 
	// Codificación para entender los anidamientos: Fecha,Hora,Serie
	
	// Procesa el texto
	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
 	//////////////////////////////////////////////////////////////////////////////////////	
	case 0: //0
        
		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
		case 0: //0,0
        
		       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
		       	case 0: //0,0,0
 
 				if (strlen(CuadroTextoLinea->value())) {
        		
        				// copia el texto actual en una nueva variable
					strcpy(str, CuadroTextoLinea->value());

					// adelanta el carácter de fin de string un carácter, para borrar el último
					str[strlen(str) - 1] = '\\0';

					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
				
				}
            		
            			break; //0,0,0
            		
		        case 1: //0,0,1
		        
		        	// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	
		        	}
		        	
			        break; //0,0,1
	           	
        		}
	
			break; //0,0
		
		case 1: //0,1
    
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 			case 0: //0,1,0
       	
		        	// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// asigna el nuevo texto al cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				CuadroTextoLinea->value(textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	}
            		
            			break;//0,1,0
        	
        		case 2: //0,1,2
   
        			// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
			
        			break; //0,1,0
        		
        		}
        	
        		break; //0,1
        	
		case 2: //0,2
    	
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       			case 1: //0,2,1
   		
       				// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
	            	
        			break; //0,2,1
        		
        		}
        		
        		break; //0,2
        		
        	}
       	
		break; //0
		
        //////////////////////////////////////////////////////////////////////////////////////	    	
	case 1: //1

		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
		case 0: //1,0
        
		       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
		       	case 0: //1,0,0
 		
 				// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				CuadroTextoLinea->value(textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
		        	
		        	}
	            	
            			break;//1,0,0
            		
		        case 2: //1,0,2
	        
		        	// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
        	    			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
			        break; //1,0,2
	           	
        		}
	
			break; //1,0
		
		case 2: //1,2
    
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 			case 0: //1,2,0
       	
		        	// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto					
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
            		
            			break; //1,2,0
        	
        		case 3: //1,2,3
   
        			// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';
					
					// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
					strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
			
        			break; //1,2,3
        		
        		}
        	
        		break; //1,2
        	
		case 3: //1,3
    	
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       			case 2: //1,3,2
 		
       				// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el cuadro de texto
            				strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
	            	
        			break; //1,3,2
        		
        		} 
        		
        		break; //1,3
        		        	
        	} 
        	
        	break; //1
        
        //////////////////////////////////////////////////////////////////////////////////////	
	case 2: //2
        	
        	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 0: //2,0
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //2,0,1
        		
        			// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	
        			break; //2,0,1
        		
        		}
        		
        		break; //2,0
        	
        	case 1: //2,1
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 0: //2,1,0       	
                		
                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	
        			break; //2,1,0
        		
        		case 3: //2,1,3
      	
                		// borra el último carácter del texto posterior a serie
		        	if (strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';
					
					// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra el número de serie
			            	OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
        		
        			break; //2,1,3
        		
        		}
        		
        		break; //2,1
        	
        	case 3: //2,3
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //2,3,1
   	
                		// borra el último carácter del texto posterior a hora
		        	if (strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la hora
			            	OrdenHora[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusHora[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
            				strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}
		        		
        			break; //2,3,1
        		
        		}
        		
        		break; //2,3
        	
        	}
        	
		break; //2
	
        //////////////////////////////////////////////////////////////////////////////////////	
	case 3: //3
        	
        	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
        	case 1: //3,1 
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 2: //3,1,2

                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
					strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	        		
        			break; //3,1,2
        		
        		}
        		
        		break; //3,1
        	
        	case 2: //3,2
        		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        		case 1: //3,2,1

                		// borra el último carácter del texto posterior a fecha
		        	if (strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1])) {
		        	
					// adelanta el carácter de fin de string un carácter, para borrar el último
					textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1][strlen(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]) - 1] = '\\0';

					// actualiza el texto
					strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
					strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
					
					// actualiza el cuadro de texto
					CuadroTextoLinea->value(str);
		        	
		        	}
		        	
		        	else {
		        	
		        		// Borra la fecha
			            	OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1] = 0;
			            	StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] = false;
            		
        	    			// actualiza el texto
        	    			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            				strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            				
            				// actualiza el cuadro de texto
            				CuadroTextoLinea->value(str);
		        	
		        	}	
		        	        		
        			break; //3,2,1
        		
        		}
        		
        		break; //3,2
        	
        	}
        	
		break; //3
		
	} // de switch (OrdenFecha) inicial
		
	// Actualiza el estado de widgets
	// Fecha
	if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {		// Si ya está definida la fecha

		// Desactiva los widgets
		BotonFecha->deactivate();  
		ChoiceFormatoFecha1->deactivate();
		ChoiceFormatoFecha2->deactivate();
		ChoiceFormatoFecha3->deactivate();
		ChoiceSeparadorFecha->deactivate();
		IndicadorCaducidad->deactivate();
	
	}

	else {

		// Activa los widgets
		BotonFecha->activate();  
		ChoiceFormatoFecha1->activate();
		ChoiceFormatoFecha2->activate();
		ChoiceFormatoFecha3->activate();
		ChoiceSeparadorFecha->activate();
		IndicadorCaducidad->activate();

	}

	// Hora
	if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {		// Si ya está definida la hora

		// Desactiva los widgets
		BotonHora->deactivate();  
		ChoiceFormatoHora1->deactivate();
		ChoiceFormatoHora2->deactivate();
		ChoiceFormatoHora3->deactivate();
		ChoiceSeparadorHora->deactivate();
	
	}

	else {

		// Activa los widgets
		BotonHora->activate();  
		ChoiceFormatoHora1->activate();
		ChoiceFormatoHora2->activate();
		ChoiceFormatoHora3->activate();
		ChoiceSeparadorHora->activate();

	}

	// Número de serie
	if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {	// Si ya está definido el número de serie

		// Desactiva el botón y los cuadros de texto
		BotonSerie->deactivate();  
		CuadroTextoSerie->deactivate();
		CuadroTextoSerieFinal->deactivate();
		FrameLote->deactivate();
		CuadroTextoUnidadesLote->deactivate();
		CuadroTextoUnidadesLoteActual->deactivate();
	
		// Activa el botón de reiniciar
		BotonReiniciarSerie->activate();
	}

	else {

		// Activa el botón y los cuadros de texto
		BotonSerie->activate();  
		CuadroTextoSerie->activate();
		CuadroTextoSerieFinal->activate();
		FrameLote->activate();
		CuadroTextoUnidadesLote->activate();
		CuadroTextoUnidadesLoteActual->activate();
	
		// Desactiva el botón de reiniciar
		BotonReiniciarSerie->deactivate();

	}
	
	break; // de case 0 de switch(indice)
	
/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de serie
case 1:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoSerie->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerie->value(str);
	
	break;

/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de unidades por lote
case 2:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoUnidadesLote->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLote->value(str);
	
	break;
	
/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número de serie final
case 3:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoSerieFinal->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoSerieFinal->value(str);
	
	break;

/////////////////////////////////////////////////////////////////////////////////////////////	
// se está editando la línea del número actual de unidad en el lote
case 4:

	// duplica el texto actual en una nueva variable
	strcpy(str, CuadroTextoUnidadesLoteActual->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoUnidadesLoteActual->value(str);
	
	break;
	
}}
        xywh {520 330 95 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
        code3 {switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}}
      }
      Fl_Button BotonQ {
        label Q
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {45 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonW {
        label W
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {95 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonE {
        label E
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {145 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonR {
        label R
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {195 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonT {
        label T
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {245 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonY {
        label Y
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {295 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonU {
        label U
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {345 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonI {
        label I
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {395 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonO {
        label O
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {445 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonP {
        label P
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {495 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonA {
        label A
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {70 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonS {
        label S
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {120 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonD {
        label D
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {170 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonF {
        label F
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {220 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonG {
        label G
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {270 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonH {
        label H
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {320 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonJ {
        label J
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {370 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonK {
        label K
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {420 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonL {
        label L
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {470 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonEnhe {
        label {Ñ}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {520 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonX {
        label X
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {145 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonC {
        label C
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {195 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonV {
        label V
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {245 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonB {
        label B
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {295 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonN {
        label N
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {345 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonM {
        label M
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {395 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonComa {
        label {,}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {445 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonPunto {
        label {.}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {495 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonZ {
        label Z
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {95 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonEspacio {
        label { }
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {95 530 375 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonBarra {
        label {/}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {470 530 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonDosPuntos {
        label {:}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {520 530 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonMas {
        label {+}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {545 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonMenos {
        label {-}
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter
ProcesarCaracter(o->label());}
        xywh {545 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 18
      }
      Fl_Button BotonRupia {
        label Rupee
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la r para indicar la rupia
ProcesarCaracter("r");}
        xywh {20 480 75 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 17
        code0 {if (ValorFuente==9) {o->show();} //sólo fuente "india"}
        code1 {else {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Rupia");break; case ING:o->label("Rupee");break; case ITA:o->label("Rupee");break;}}
      }
      Fl_Button BotonISI {
        label ISI
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la i para indicar el logo de ISI
ProcesarCaracter("i");}
        xywh {20 530 75 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 17
        code0 {if (ValorFuente==9) {o->show();} //sólo fuente "india"}
        code1 {else {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("ISI");break; case ING:o->label("ISI");break; case ITA:o->label("ISI");break;}}
      }
      Fl_Button BotonDiametro {
        label Diam
        callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;

// procesa el nuevo caracter: se utiliza la i para indicar el logo de ISI
ProcesarCaracter("f");}
        xywh {570 530 75 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 17
        code0 {if (ValorFuente==4) {o->show();} //sólo fuente "india"}
        code1 {else {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Dia");break; case ING:o->label("Dia");break; case ITA:o->label("Dia");break;}}
      }
    }
    Fl_Button Cancelar_VentanaModificarTexto {
      label Cancelar
      callback {//Vuelve a la ventana principal sin hacer nada
char record[12];

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

// Actualiza el valor de los botones, etc

// Fecha
ChoiceFormatoFecha1->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha2->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha3->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorFecha->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);
IndicadorCaducidad->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonFecha->deactivate();
	ChoiceFormatoFecha1->deactivate();
	ChoiceFormatoFecha2->deactivate();
	ChoiceFormatoFecha3->deactivate();
	ChoiceSeparadorFecha->deactivate();
	IndicadorCaducidad->deactivate();
}

else {
	BotonFecha->activate();
	ChoiceFormatoFecha1->activate();
	ChoiceFormatoFecha2->activate();
	ChoiceFormatoFecha3->activate();
	ChoiceSeparadorFecha->activate();
	IndicadorCaducidad->activate();
}

// Hora
ChoiceFormatoHora1->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora2->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora3->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorHora->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonHora->deactivate();
	ChoiceFormatoHora1->deactivate();
	ChoiceFormatoHora2->deactivate();
	ChoiceFormatoHora3->deactivate();
	ChoiceSeparadorHora->deactivate();
}

else {
	BotonHora->activate();
	ChoiceFormatoHora1->activate();
	ChoiceFormatoHora2->activate();
	ChoiceFormatoHora3->activate();
	ChoiceSeparadorHora->activate();
}

// Serie
sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoSerie->value(record);

if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);
	CuadroTextoSerieFinal->value(record);
}

sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLote->value(record);

sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLoteActual->value(record);


// Activa el número actual y el botón de reinicio sólo si se trata de la línea con el numero de serie
// y el número de serie está activado
if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
	
	BotonSerie->deactivate();
	CuadroTextoSerie->deactivate();
	CuadroTextoSerieFinal->deactivate();
	FrameLote->deactivate();
	CuadroTextoUnidadesLote->deactivate();
	CuadroTextoUnidadesLoteActual->deactivate();
	BotonReiniciarSerie->activate();
	
}

else {
	
	BotonSerie->activate();
	CuadroTextoSerie->activate();
	CuadroTextoSerieFinal->activate();
	FrameLote->activate();
	CuadroTextoUnidadesLote->activate();
	CuadroTextoUnidadesLoteActual->activate();
	BotonReiniciarSerie->deactivate();
	
}

// Actualiza los campos
ActualizarFechaHoraSerie();

// Carga el cuadro de texto de la ventana que saldrá con el texto de la línea 1
CargarTexto();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
		break;	
	
	}
		
	break;

case 2:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 3:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 4:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
			
}

// Vacía el cuadro de texto, para evitar líos...
CuadroTextoLinea->value("");

// Oculta la ventana emergente actual
VentanaModificarTexto->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {640 100 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
    }
    Fl_Button Aceptar_VentanaModificarTexto {
      label Aceptar
      callback {int tmpactual, error;

// Actualiza el número actual de unidades en el lote, si hubiera cambiado
tmpactual = atoi(CuadroTextoUnidadesLoteActual->value());

if (!(tmpactual == NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]) && (tmpactual>0) ){

	NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] = tmpactual;

}

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
		break;	
	
	}
		
	break;

case 2:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
	
case 3:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;

case 4:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	switch (BloqueCalcular) {
	
	case 1:
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 2:
		CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
		break;
	
	case 3:
		CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
		break;	
	
	}
	
	break;
				
}

// Si la línea tiene un código de barras y no está vacía, comprueba si el texto introducido es válido
if ((ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] > TEXTOCIRCULAR) && (strlen(CuadroTextoLinea->value()))) {

	// Crea el código de barras
	error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);
	
	// Comprueba que se ha creado correctamente
        if(error) {
        
        	// Asigna el mensaje de error
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Código de barras inválido");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Invalid barcode");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Invalido di codici a barre");
			break;
			
		}
	
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		VentanaModificarTexto->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		
		// Desactiva el botón de Aceptar, para no poder consolidar un cambio erróneo
		//Aceptar_VentanaModificarTexto->deactivate();
		
		// No prosigue
		return;
			
        }
        
        else {
        	// Activa el botón de Aceptar
		//Aceptar_VentanaModificarTexto->activate();
	
	}
	
}

// Guarda todo
Escribir_DAT("itaca.dat");

// Vacía el cuadro de texto, para evitar líos...
CuadroTextoLinea->value("");

// Oculta la ventana emergente actual
VentanaModificarTexto->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {640 180 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
    }
  }
} 

Function {Make_Window_Detalles_Linea()} {C
} {
  Fl_Window VentanaDetallesLinea {open
    xywh {50 50 475 550} type Double box BORDER_BOX color 7 selection_color 7 when 6 modal noborder visible
  } {
    Fl_Choice ChoiceTipoLinea {
      label {Tipo de línea}
      callback {int error;

// Si no ha habido cambios no hace nada
if (o->value() == ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]) { return;}

// Almacena el valor seleccionado en la variable ValorTipoLinea
ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] = o->value();

// Si el tipo de línea es texto oculta los grupos de barcode y gráfico
if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {

	GrupoTexto->show();
	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();

	// Si había un código de barras borra el objeto
	//if(BarcodeSymbol[LineaCalcular - 1] != NULL) {
		//ZBarcode_Delete(BarcodeSymbol[LineaCalcular - 1]);
	//}

	if (Estrategia < 3) {
		TextoMinX->hide();
		TextoMinY->hide();
	}
	else {
		TextoMinX->show();
		
		TextoMinY->show();	
	}
	// Activa el botón de Aceptar, por si previamente había sido desactivado
	Aceptar_VentanaDetallesLinea->activate();
	
}

// Si el tipo de línea es gráfico, muestra el grupo gráfico y oculta el de barcode
else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {

	GrupoBarcode->hide();
	GrupoGrafico->show();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();

	// Si había un código de barras borra el objeto
	//if(BarcodeSymbol[LineaCalcular - 1] != NULL) {
		//ZBarcode_Delete(BarcodeSymbol[LineaCalcular - 1]);
	//}

	// Activa el botón de Aceptar, por si previamente había sido desactivado
	//Aceptar_VentanaDetallesLinea->activate();
	
	// Deselecciona lo que hubiera
	FileBrowserArchivosPlt->deselect(FileBrowserArchivosPlt->value());
	
	// Desactiva el botón de Aceptar hasta que se haga una seleccion
	Aceptar_VentanaDetallesLinea->deactivate();
	if (Estrategia < 3) {
		GraficoMinX->hide();
		GraficoMinY->hide();
	}
	else {
		GraficoMinX->show();
		
		GraficoMinY->show();	
	}

}

else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {

	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();
	
	if (Estrategia <3){
		switch (Idioma) {		
			case ESP:
			BoxVentanaMensaje->label("Estrategia incorrecta");
			break; 
			case ING:
			BoxVentanaMensaje->label("Invalid marking strategy");
			break; 
			case ITA:
			BoxVentanaMensaje->label("Invalido di estrategia marcatura");
			break;
			}
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		
		VentanaDetallesLinea->deactivate();
		Aceptar_VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	}

	else {
		if (Funcionalidad<1){
		switch (Idioma) {		
			case ESP:
			BoxVentanaMensaje->label("Funcionalidad incorrecta. Bloques no aceptados");
			break; 
			case ING:
			BoxVentanaMensaje->label("Invalid functionality. Blocks not accepted");
			break; 
			case ITA:
			BoxVentanaMensaje->label("Invalido di estrategia marcatura. Bloques no aceptados");
			break;
			}
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		
		VentanaDetallesLinea->deactivate();
		Aceptar_VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		}

	
		else {
		GrupoTextoCircular->show();
		Aceptar_VentanaDetallesLinea->activate();
		}

	}
	

	
	}
// Si es cualquier otro tipo muestra el grupo de barcode y oculta el grupo gráfico
else {

	GrupoBarcode->show();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();
	GrupoTexto->hide();

	if (Estrategia < 3) {
		BarcodeMinX->hide();
		BarcodeMinY->hide();
	}
	else {
		BarcodeMinX->show();
		
		BarcodeMinY->show();	
	}

	// Si es un datamatrix ocultar la opción de invertir el código, ya que no tiene sentido
	if ( numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] == 71) {
	
		CheckInvertirBarcode->hide();
	}
	
	else {
		CheckInvertirBarcode->show();
	
	}
	
	// Crea el código de barras
	error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);

	// Comprueba que se ha creado correctamente
        if(error) {
        
        	// Asigna el mensaje de error
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Código de barras inválido");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Invalid barcode");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Invalido di codici a barre");
			break;
			
		}
	
		// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
		VentanaDetallesLinea->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
		
		// Desactiva el botón de Aceptar, para no poder consolidar un cambio erróneo
		Aceptar_VentanaDetallesLinea->deactivate();
	
        }
        
        else {

        	// Activa el botón de Aceptar
		Aceptar_VentanaDetallesLinea->activate();
	
	}
        
}} open
      xywh {50 42 250 38} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 18 align 5 textfont 8 textsize 18
      code0 {int i; for (i=0; i<NumeroTiposLinea; i++) {o->add(strTiposLinea[Idioma][i]);}//inicialización}
      code3 {switch (Idioma) {case ESP:o->label("Tipo de línea");break; case ING:o->label("Line type");break; case ITA:o->label("Tipo di linea");break;}}
    } {}
    Fl_Group GrupoBarcode {open
      xywh {50 95 355 350} box PLASTIC_DOWN_BOX color 10
    } {
      Fl_Round_Button CheckInvertirBarcode {
        label { Invertir código}
        callback {// Almacena el valor seleccionado en la variable InvertirBarcode
InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] = o->value();

// Invertir
//if (o->value() == ON) {
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->fgcolour, "ffffff");
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->bgcolour, "000000");
//}
        
//else {
//        strcpy(BarcodeSymbol[LineaCalcular - 1]->fgcolour, "000000");
//	strcpy(BarcodeSymbol[LineaCalcular - 1]->bgcolour, "ffffff");
//}}
        xywh {100 120 180 25} down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 18
        code3 {switch (Idioma) {case ESP:o->label("Invertir código");break; case ING:o->label("Invert code");break; case ITA:o->label("Invertire codice");break;}}
      }
      Fl_Counter IndicadorEscalaBarcode {
        label {Escala %}
        callback {// Cambia la variable de la escala del código de barras
EscalaBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 184 240 36} type Simple box PLASTIC_THIN_UP_BOX color 0 labelfont 8 labelsize 18 align 133 minimum 50 maximum 200 step 50 value 100 textfont 8 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Escala %");break; case ING:o->label("Scale %");break; case ITA:o->label("Scala %");break;}}
      }
      Fl_Counter IndicadorSeparacionBarrasBarcode {
        label {Separación barras %}
        callback {// Cambia la variable de la anchura del código de barras
SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 240 240 36} type Simple box PLASTIC_THIN_UP_BOX color 0 labelfont 8 labelsize 18 align 133 minimum 50 maximum 200 step 10 value 100 textfont 8 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Separación barras %");break; case ING:o->label("Bar separation %");break; case ITA:o->label("Separazione fra le barre %");break;}}
      }
      Fl_Counter BarcodeMinX {
        label MinX
        callback {// Cambia la posicion del codigo de barras
MinXBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 290 240 36} type Simple box PLASTIC_THIN_UP_BOX align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}}
      }
      Fl_Counter BarcodeMinY {
        label MinY
        callback {// Cambia la posicion del codigo de barras
MinYBarcode[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 340 240 36} type Simple box PLASTIC_THIN_UP_BOX align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}}
      }
    }
    Fl_Group GrupoGrafico {open
      xywh {50 95 355 350} box PLASTIC_DOWN_BOX color 11 hide
    } {
      Fl_File_Browser FileBrowserArchivosPlt {
        label {Archivos de gráficos (.plt)}
        callback {if (o->value()){
	
	// guarda el nombre del archivo seleccionado
	strcpy(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], o->text(o->value()));

	if (debug_plt) {
		printf("NombreArchivoPlt:%s\\n", NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
	}

	// activa el botón de Aceptar ahora que se ha hecho una selección
	Aceptar_VentanaDetallesLinea->activate();

}}
        xywh {80 130 290 175} type Hold labelfont 8 labelsize 18 align 5 textfont 8 textsize 18
        code0 {o->filter("*.plt"); o->load(".");// Inicialización}
        code1 {o->remove(1); // Para eliminar la entrada con "../"}
      }
      Fl_Counter GraficoMinX {
        label MinX
        callback {// Cambia la posicion del grafico
MinXGrafico[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {75 330 240 36} align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}}
      }
      Fl_Counter GraficoMinY {
        label MinY
        callback {// Cambia la posicion del grafico
MinYGrafico[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {75 380 240 36} align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}}
      }
    }
    Fl_Button Cancelar_VentanaDetallesLinea {
      label Cancelar
      callback {//Vuelve a la ventana principal sin hacer nada

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

/*

// Actualiza los campos de la ventana principal
ActualizarFechaHoraSerie();

// Carga el cuadro de texto de la ventana que saldrá con el texto de la línea 1
CargarTexto();

// Procesa el texto rellenando las estructuras de datos correspondientes
ProcesarTexto();

// Vuelve a cargarlo en el interfaz
// Actualiza el cuadro de texto correspondiente a la línea que se ha calculado
switch (LineaCalcular) {

case 1:
	
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea1->value(LineaTexto1);
	break;

case 2:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea2->value(LineaTexto2);
	break;
	
case 3:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea3->value(LineaTexto3);
	break;

case 4:
	// Copia el texto a la variable de la línea y al cuadro de texto de la ventana
	CuadroTextoLinea4->value(LineaTexto4);
	break;
				
}

*/

// Oculta la ventana emergente actual
VentanaDetallesLinea->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {270 450 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code0 {//o->deactivate();// de momento no se implementa la posibilidad de cancelar los cambios}
      code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
    }
    Fl_Button Aceptar_VentanaDetallesLinea {
      label Aceptar
      callback {// Actualiza el botón del tipo de línea
switch (LineaCalcular) {

case 1:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea1Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea1Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea1Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea1->deactivate();
			CuadroTextoLinea1Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea1->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea1->activate();
			CuadroTextoLinea1Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular - 1]);
			CuadroTextoLinea1Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;

case 2:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea2Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea2Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea2Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea2->deactivate();
			CuadroTextoLinea2Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea2->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea2->activate();
			CuadroTextoLinea2Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular - 1]);
			CuadroTextoLinea2Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;
	
case 3:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea3Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea3Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea3Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea3->deactivate();
			CuadroTextoLinea3Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea3->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea3->activate();
			CuadroTextoLinea3Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular - 1]);
			CuadroTextoLinea3Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;

case 4:
	
	// Actualiza la etiqueta del botón de tipo de línea
	switch (BloqueCalcular) {
	
	case 1:
		BotonDetallesLinea4->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		BotonDetallesLinea4Bloque1->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 2:
		BotonDetallesLinea4Bloque2->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;
	
	case 3:
		BotonDetallesLinea4Bloque3->label((char *)strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]);
		break;	
	
	}
	
	// Si la línea es un gráfico pone el nombre del archivo en el campo de texto
	if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
	
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea4->deactivate();
			CuadroTextoLinea4Bloque1->deactivate();
			break;
	
		case 2:
			CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque2->deactivate();
			break;
	
		case 3:
			CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque3->deactivate();
			break;	
	
		}
	
	}
	
	else {
		
		// Copia el texto al cuadro de texto de la ventana
		CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
		
		// habilita el cuadro de texto para poder introducir texto
		CuadroTextoLinea4->activate();
		
		switch (BloqueCalcular) {
	
		case 1:
			CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular - 1]);
			
			// e inhabilita el cuadro de texto para no poder introducir texto
			CuadroTextoLinea4->activate();
			CuadroTextoLinea4Bloque1->activate();
			break;
	
		case 2:
			CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque2->activate();
			break;
	
		case 3:
			CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular - 1]);
			CuadroTextoLinea4Bloque3->activate();
			break;	
	
		}
		
	}
	
	break;
				
}

// Guarda todo
Escribir_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaDetallesLinea->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {50 450 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
    }
    Fl_Group GrupoTextoCircular {open
      xywh {50 95 355 240} box PLASTIC_DOWN_BOX color 93
    } {
      Fl_Counter Angulo {
        label Angulo
        callback {// Cambia el angulo de inicio del texto circular
AnguloTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 120 240 36} box THIN_UP_BOX labelfont 8 labelsize 12 align 133 minimum 0 maximum 359 step 1 textfont 8 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Angulo");break; case ING:o->label("Angle º");break; case ITA:o->label("Angulo º");break;}}
      }
      Fl_Counter Radio {
        label Radio
        callback {// Cambia el angulo de inicio del texto circular
RadioTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 170 240 36} box THIN_UP_BOX labelsize 12 align 133 minimum 10 maximum 100 step 1 value 10 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Radio mm");break; case ING:o->label("Radius mm");break; case ITA:o->label("Radio mm");break;}}
      }
      Fl_Counter TextoCircularCentroX {
        label CentroX
        callback {// Cambia la posicion del centro del texto circular
CentroXTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 220 240 36} box THIN_UP_BOX labelfont 8 labelsize 12 align 133 minimum -100 maximum 100 step 1 textfont 8 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Centro X");break; case ING:o->label("Center X");break; case ITA:o->label("Centro X");break;}}
      }
      Fl_Counter TextoCircularCentroY {
        label {Centro Y}
        callback {// Cambia el angulo de inicio del texto circular
CentroYTextoCircular[LineaCalcular - 1][BloqueCalcular - 1] = (int)o->value();}
        xywh {100 270 240 36} box THIN_UP_BOX labelfont 8 labelsize 12 align 133 minimum -100 maximum 100 step 1 textfont 8 textsize 18
        code3 {switch (Idioma) {case ESP:o->label("Centro Y");break; case ING:o->label("Center Y");break; case ITA:o->label("Centro Y");break;}}
      }
    }
    Fl_Group GrupoTexto {open
      xywh {50 95 355 240} when 1
    } {
      Fl_Counter TextoMinX {
        label MinX
        callback {// Cambia la posicion del texto
MinXTexto[LineaCalcular - 1][BloqueCalcular - 1] = (double)o->value();}
        xywh {100 220 240 36} type Simple align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min X");break; case ING:o->label("Min X");break; case ITA:o->label("Min X");break;}}
      }
      Fl_Counter TextoMinY {
        label MinY
        callback {// Cambia el angulo de inicio del texto circular
MinYTexto[LineaCalcular - 1][BloqueCalcular - 1] = (double)o->value();}
        xywh {100 270 240 36} type Simple align 133 minimum -100 maximum 100 step 1
        code3 {switch (Idioma) {case ESP:o->label("Min Y");break; case ING:o->label("Min Y");break; case ITA:o->label("Min Y");break;}}
      }
    }
  }
} 

Function {Make_Window_Trabajos()} {C
} {
  Fl_Window VentanaTrabajos {open
    xywh {0 0 800 600} type Double color 7 selection_color 7 when 6 modal noborder size_range {800 600 800 600} visible
  } {
    Fl_Box LogoItacaVentanaTrabajos {
      image {fls.png} xywh {630 0 165 75} color 7 labelsize 12 align 16
    }
    Fl_File_Browser FileBrowserArchivosTrabajos {
      label {Archivos de trabajos}
      callback {char str[50];

if (o->value()){
	
	// copia el nombre del archivo seleccionado
	strcpy(str, o->text(o->value()));
	
	// adelanta el carácter de fin de string 4 caracteres, para borrar la extensión
	str[strlen(str) - 4] = '\\0';
	
	// Actualiza la línea de texto
	CuadroTextoTrabajo->value(str);

	// activa el botón de Aceptar ahora que se ha hecho una selección
	//Aceptar_VentanaDetallesLinea->activate();

}}
      xywh {10 90 615 170} type Hold box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 16 align 5 textfont 8 textsize 18
      code0 {o->filter("*.trb"); o->load(".");// Inicialización}
      code1 {o->remove(1); // Para eliminar la entrada con "../"}
      code3 {switch (Idioma) {case ESP:o->label("Archivos de trabajos");break; case ING:o->label("Job files");break; case ITA:o->label("File di lavoro");break;}}
    }
    Fl_Output CuadroTextoTrabajo {
      callback {// variable que indica donde se ha fijado el foco, para el teclado
indice = 0;}
      xywh {10 270 615 40} box PLASTIC_THIN_DOWN_BOX color 175 labelfont 8 labelsize 20 align 5 textfont 8 textsize 20
      code0 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
    }
    Fl_Group GrupoTecladoTrabajos {
      xywh {10 320 615 270} box PLASTIC_UP_FRAME color 0
    } {
      Fl_Button Boton1t {
        label 1
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {20 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton2t {
        label 2
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {70 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton3t {
        label 3
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {120 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton4t {
        label 4
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {170 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton5t {
        label 5
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {220 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton6t {
        label 6
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {270 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton7t {
        label 7
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {320 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton8t {
        label 8
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {370 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton9t {
        label 9
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {420 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button Boton0t {
        label 0
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {470 330 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonBorrart {
        label Borrar
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

if (strlen(CuadroTextoTrabajo->value())) {
        		
	// copia el texto actual en una nueva variable
	strcpy(str, CuadroTextoTrabajo->value());

	// adelanta el carácter de fin de string un carácter, para borrar el último
	str[strlen(str) - 1] = '\\0';

	// asigna el nuevo texto al cuadro de texto
	CuadroTextoTrabajo->value(str);
	
}}
        xywh {520 330 95 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 17
        code3 {switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}}
      }
      Fl_Button BotonQt {
        label Q
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {45 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonWt {
        label W
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {95 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonEt {
        label E
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {145 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonRt {
        label R
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {195 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonTt {
        label T
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {245 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonYt {
        label Y
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {295 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonUt {
        label U
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {345 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonIt {
        label I
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {395 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonOt {
        label O
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {445 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonPt {
        label P
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {495 380 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonAt {
        label A
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {70 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonSt {
        label S
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {120 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonDt {
        label D
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {170 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonFt {
        label F
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {220 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonGt {
        label G
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {270 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonHt {
        label H
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {320 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonJt {
        label J
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {370 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonKt {
        label K
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {420 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonLt {
        label L
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {470 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonEnhet {
        label {Ñ}
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {520 430 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
        code0 {o->hide();// no se usa, problemas con el sistema de archivos}
      }
      Fl_Button BotonXt {
        label X
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {145 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonCt {
        label C
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {195 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonVt {
        label V
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {245 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonBt {
        label B
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {295 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonNt {
        label N
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {345 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonMt {
        label M
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {395 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonZt {
        label Z
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {95 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonEspaciot {
        label { }
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, " ");
CuadroTextoTrabajo->value(str);}
        xywh {120 530 350 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
      Fl_Button BotonMenost {
        label {-}
        callback {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// concatena el carácter al nombre del trabajo 			
strcpy(str, CuadroTextoTrabajo->value());
strcat(str, o->label());
CuadroTextoTrabajo->value(str);}
        xywh {445 480 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelfont 8 labelsize 20
      }
    }
    Fl_Button Cargar_VentanaTrabajos {
      label Cargar
      callback {// Si hay un trabajo lanza la ventana de confirmación
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuación
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar cargar trabajos
	CargarVentanaConfirmarCargarTrabajo();
	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

}}
      xywh {640 340 145 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Cargar");break; case ING:o->label("Load");break; case ITA:o->label("Carico");break;}}
    }
    Fl_Button Guardar_VentanaTrabajos {
      label Guardar
      callback {// Si hay un trabajo lanza la ventana de confirmacion
if (strlen(CuadroTextoTrabajo->value())) {
	
	if (ControlAcceso) {
		VentanaPassword->show();
	}
	
	else {
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar guardar trabajo
	CargarVentanaConfirmarGuardarTrabajo();
	}	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

}}
      xywh {640 425 145 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Guardar");break; case ING:o->label("Save");break; case ITA:o->label("Salvare");break;}}
    }
    Fl_Button Cancelar_VentanaTrabajos {
      label Cancelar
      callback {char str[50];

// Si no había trabajo seleccionado limpia todo
if (!ValorTrabajo) {

	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoTrabajo->value("");

	// Refresca el file browser para que no quede ninguna opción seleccionada
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"

}

// si no, restituye los valores correspondientes al trabajo actual
else {

	// Actualiza la selección en el file browser
	FileBrowserArchivosTrabajos->value(ValorTrabajo);
	
	// copia el nombre del archivo seleccionado
	strcpy(str, FileBrowserArchivosTrabajos->text(ValorTrabajo));
	
	// adelanta el carácter de fin de string 4 caracteres, para borrar la extensión
	str[strlen(str) - 4] = '\\0';
	
	// Actualiza la línea de texto
	CuadroTextoTrabajo->value(str);

}

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {640 510 145 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
    }
    Fl_Button Borrar_VentanaTrabajos {
      label Borrar
      callback {// Si hay un trabajo lanza la ventana de confirmacion
if (strlen(CuadroTextoTrabajo->value())) {
	
	if (ControlAcceso) {
		VentanaPassword->show();
	}
	
	else {
	// Desactiva la ventana de trabajos para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();

	// Cargar la ventana de confirmar guardar trabajo
	CargarVentanaConfirmarBorrarTrabajo();
	}	
}

else {	// error

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Seleccione un trabajo");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Select a job file");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Selezione un file di lavoro");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuacion
	VentanaTrabajos->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Activa la ventana actual
	VentanaTrabajos->activate();

}}
      xywh {640 200 145 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 88 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Borrar");break;}}
    }
  }
} 

Function {Make_Window_Mensaje()} {C
} {
  Fl_Window VentanaMensaje {open
    xywh {325 210 475 230} type Double box NO_BOX color 1 selection_color 1 labelfont 8 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 475 230} box PLASTIC_THIN_DOWN_BOX color 1
    } {
      Fl_Box BoxVentanaMensaje {
        xywh {10 20 450 70} labelfont 8 labelsize 20 align 144
      }
      Fl_Button Aceptar_VentanaMensaje {
        label Aceptar
        callback {// Oculta la ventana emergente actual
VentanaMensaje->hide();

// Y vuelve a presentar la ventana activa desde donde se invocó el mensaje
switch (VentanaActiva) {

	case VPrincipal:
	VentanaPrincipal->activate();
	break;

	case VModificar:
	VentanaModificarTexto->activate();
	break;
	
	case VDetalles:
	VentanaDetallesLinea->activate();
	break;
	
	case VPassword:
	VentanaPassword->activate();
	break;

}}
        xywh {165 120 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
    }
  }
} 

Function {Make_Window_Password()} {C
} {
  Fl_Window VentanaPassword {open
    xywh {207 140 460 460} type Double box BORDER_BOX color 46 selection_color 7 when 6 resizable modal noborder size_range {460 460 460 460} visible
  } {
    Fl_Output CuadroTextoPassword {
      label {Contraseña:}
      xywh {50 42 355 40} box PLASTIC_THIN_DOWN_BOX color 175 labelfont 8 labelsize 20 align 5 textsize 20
      code3 {switch (Idioma) {case ESP:o->label("Contraseña:");break; case ING:o->label("Password:");break; case ITA:o->label("Password:");break;}}
    }
    Fl_Group GrupoTecladop {
      xywh {50 95 355 240} box PLASTIC_UP_FRAME color 0
    } {
      Fl_Button Boton1p {
        label 1
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "1");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {150 215 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton2p {
        label 2
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "2");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {200 215 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton3p {
        label 3
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "3");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {250 215 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton4p {
        label 4
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "4");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {150 165 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton5p {
        label 5
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "5");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {200 165 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton6p {
        label 6
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "6");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {250 165 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton7p {
        label 7
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "7");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {150 115 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton8p {
        label 8
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "8");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {200 115 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton9p {
        label 9
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "9");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {250 115 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button Boton0p {
        label 0
        callback {char txt[25];

// concatena el nuevo carácter en la password
strcat(Password, "0");

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// concatena un asterisco para mostrar
strcat(txt, "*");

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {150 265 50 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 20
      }
      Fl_Button BotonBorrarp {
        label Borrar
        callback {char txt[25];

// adelanta el carácter de fin de string un carácter, para borrar el último de la password
Password[strlen(Password) - 1] = '\\0';

// duplica el texto actual en una nueva variable
strcpy(txt, CuadroTextoPassword->value());

// adelanta el carácter de fin de string un carácter, para borrar el último
txt[strlen(txt) - 1] = '\\0';

// asigna el nuevo texto al cuadro de texto
CuadroTextoPassword->value(txt);}
        xywh {200 265 100 50} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 labelsize 17
        code3 {switch (Idioma) {case ESP:o->label("Borrar");break; case ING:o->label("Delete");break; case ITA:o->label("Eliminare");break;}}
      }
    }
    Fl_Button Cancelar_VentanaPassword {
      label Cancelar
      callback {// Vacía el cuadro de texto, para evitar líos...
CuadroTextoPassword->value("");

// Oculta la ventana emergente actual
VentanaPassword->hide();

// Y vuelve a presentar la ventana principal
//VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {270 360 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
    }
    Fl_Button Aceptar_VentanaPassword {
      label Aceptar
      callback {// Si la contraseña es correcta sale:
if (!strcmp(Password, PasswordUsuario)) {

	// Desactiva el control de acceso
	ControlAcceso = OFF;
 
	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoPassword->value("");

	// Y la password
	strcpy(Password, "");
	
	// Oculta la ventana emergente actual
	VentanaPassword->hide();

	// Y vuelve a presentar la ventana principal
	VentanaActiva = VPrincipal;
	VentanaPrincipal->activate();
	VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);
	
	// Y lanza un time out para restaurar el control de acceso
	Fl::add_timeout(TIMEOUT_CONTROLACCESO, ActualizaControlAcceso);
	
}

// Si no, da un mensaje y vacía el cuadro de texto
else {

	// Asigna el mensaje
	switch (Idioma) {
			
		case ESP:
		BoxVentanaMensaje->label("Contraseña incorrecta");
		break; 
			
		case ING:
		BoxVentanaMensaje->label("Wrong password");
		break; 
			
		case ITA:
		BoxVentanaMensaje->label("Password errata");
		break;
			
	}
	
	// Desactiva la ventana actual para que resalte la ventana emergente que saldrá a continuación
	VentanaPassword->deactivate();
	
	// Presenta la ventana con el mensaje emergente
	VentanaMensaje->show();
	
	// Vacía el cuadro de texto, para evitar líos...
	CuadroTextoPassword->value("");
	
	// Y la password
	strcpy(Password, "");

}}
      xywh {50 360 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
    }
  }
} 

Function {Make_Window_Confirmar_CargarTrabajo()} {C
} {
  Fl_Window VentanaConfirmarCargarTrabajo {open
    xywh {260 210 460 230} type Double box BORDER_FRAME color 1 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 1
    } {
      Fl_Box {} {
        label {¿Cargar el trabajo?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Cargar el trabajo?");break; case ING:o->label("Load the job file?");break; case ITA:o->label("Caricare file di lavoro?");break;}}
      }
      Fl_Button Aceptar_VentanaConfirmarCargarTrabajo {
        label Aceptar
        callback {char str[50];

// Carga los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el índice del trabajo seleccionado
	ValorTrabajo = FileBrowserArchivosTrabajos->value();
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	Leer_DAT(str);
	
	// Inicializa los widgets con los nuevos valores
	Inicializar_Widgets();
	
	// Y los parámetros de marcaje
	Inicializar_Marcaje();
	
}

// Oculta la ventana emergente actual
VentanaConfirmarCargarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaConfirmarCargarTrabajo {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaConfirmarCargarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_Confirmar_GuardarTrabajo()} {C
} {
  Fl_Window VentanaConfirmarGuardarTrabajo {open
    xywh {340 220 460 230} type Double box BORDER_FRAME color 1 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 1
    } {
      Fl_Box {} {
        label {¿Guardar el trabajo?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Guardar el trabajo?");break; case ING:o->label("Save the job file?");break; case ITA:o->label("Salvare file di lavoro?");break;}}
      }
      Fl_Button Aceptar_VentanaConfirmarGuardarTrabajo {
        label Aceptar
        callback {char str[50];
char str2[100];
int i;

// Guarda los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	Escribir_DAT(str);
	sprintf(str2,"cp %s %s", str, "/rootFLS/itaca/");
	system("mount / -o rw,remount");
	system(str2);
	system("mount / -o ro,remount");
	
	// Refresca el file browser
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"
	
	// Y deja seleccionada la opción correspondiente al trabajo que se acaba de guardar
	for (i=1; i<=FileBrowserArchivosTrabajos->size(); i++) {
			
		// si son iguales los nombres, hay que seleccionar esa entrada
		if (strcmp(str, FileBrowserArchivosTrabajos->text(i)) == 0) {
			FileBrowserArchivosTrabajos->select(i);	
			ValorTrabajo = i;
		}
		
	}
	
}

// Oculta la ventana emergente actual
VentanaConfirmarGuardarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Oculta la ventana emergente actual
VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaConfirmarGuardarTrabajo {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaConfirmarGuardarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_Confirmar_BorrarTrabajo()} {C
} {
  Fl_Window VentanaConfirmarBorrarTrabajo {open
    xywh {270 220 460 230} type Double box BORDER_FRAME color 1 selection_color 1 labelcolor 7 modal noborder visible
  } {
    Fl_Group {} {open
      xywh {0 0 460 230} box PLASTIC_THIN_DOWN_BOX color 1
    } {
      Fl_Box {} {
        label {¿Cargar el trabajo?}
        xywh {55 28 345 42} color 175 labelfont 9 labelsize 22
        code3 {switch (Idioma) {case ESP:o->label("¿Borrar el trabajo?");break; case ING:o->label("Delete the job file?");break; case ITA:o->label("Borrare file di lavoro?");break;}}
      }
      Fl_Button Aceptar_VentanaConfirmarBorrarTrabajo {
        label Aceptar
        callback {char str[50];
char stra[50];
char str2[100];
char stra2[100];
int i;

// Guarda los datos del trabajo actual
if (strlen(CuadroTextoTrabajo->value())) {
	
	// Guarda el archivo añadiendo la extensión .trb
	strcpy(str, "/root/itaca/");
	strcat(str, CuadroTextoTrabajo->value());
	strcat(str, ".trb");
	strcpy(stra, "/rootFLS/itaca/");
	strcat(stra, CuadroTextoTrabajo->value());
	strcat(stra, ".trb");
	//Escribir_DAT(str);
	sprintf(str2,"rm %s", str);
	sprintf(stra2, "rm %s",stra);
	system ("mount / -o rw,remount");
	system(str2);
	system(stra2);
	system("mount / -o ro,remount");
	
	// Refresca el file browser
	FileBrowserArchivosTrabajos->filter("*.trb");
	FileBrowserArchivosTrabajos->load(".");
	FileBrowserArchivosTrabajos->remove(1); // Para eliminar la entrada con "../"
	
	// Y deja seleccionada la opción correspondiente al trabajo que se acaba de guardar
	for (i=1; i<=FileBrowserArchivosTrabajos->size(); i++) {
			
		// si son iguales los nombres, hay que seleccionar esa entrada
		if (strcmp(str, FileBrowserArchivosTrabajos->text(i)) == 0) {
			FileBrowserArchivosTrabajos->select(i);	
			ValorTrabajo = i;
		}
		
	}
	
}

// Oculta la ventana emergente actual
VentanaConfirmarBorrarTrabajo->hide();

// Activa la ventana de trabajos para la siguiente vez que sea llamada
VentanaTrabajos->activate();

// Cada vez que se carga la ventana se debe borrar el texto del cuadro
CuadroTextoTrabajo->value("");

// Oculta la ventana emergente actual
//VentanaTrabajos->hide();

// Y vuelve a presentar la ventana principal
//VentanaActiva = VPrincipal;
//VentanaPrincipal->activate();
//VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
        xywh {55 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
      }
      Fl_Button Cancelar_VentanaConfirmarBorrarTrabajo {
        label Cancelar
        callback {// Oculta la ventana emergente actual
VentanaConfirmarBorrarTrabajo->hide();

// Y vuelve a presentar la ventana de trabajos
VentanaTrabajos->activate();}
        xywh {250 99 150 75} box PLASTIC_UP_BOX color 0 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
      }
    }
  }
} 

Function {Make_Window_FPGA()} {C
} {
  Fl_Window VentanaFPGA {open
    xywh {5 5 800 600} type Double color 5 selection_color 7 when 6 hide modal noborder size_range {800 600 800 600}
  } {
    Fl_Button Aceptar_VentanaFPGA {
      label Aceptar
      callback {// Oculta la ventana emergente actual
VentanaFPGA->hide();

// Y vuelve a presentar la ventana principal
VentanaPrincipal->show();}
      xywh {640 510 145 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
    }
    Fl_Button LaserOn {
      label {Laser On}
      callback {outb((COMANDO_LASER|0x01), REGISTRO_ADDR);}
      xywh {20 120 150 25} color 31
    }
    Fl_Button LaserOff {
      label {Laser Off}
      callback {outb((COMANDO_LASER|0x00), REGISTRO_ADDR);}
      xywh {175 120 150 25} color 31
    }
    Fl_Button TicksUp {
      label {Ticks Up}
      callback {// Primero paramos el láser, para que no se líe la cuenta en la FPGA
//outb(COMANDO_LASER_OFF, REGISTRO_ADDR);

// Ticks Laser Up:

// Byte menos significativo (LSB)
outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);

//printf("Laser_Up_Ticks=%d	Laser_Up_Ticks & 0x00FF=%d\\n", Laser_Up_Ticks, Laser_Up_Ticks & 0x00FF);

// comando LSB
outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);

// Byte más significativo (MSB)
outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

//printf("Laser_Up_Ticks>>8=%d	(Laser_Up_Ticks >> 8) & 0x00FF=%d\\n", Laser_Up_Ticks >> 8, (Laser_Up_Ticks >> 8) & 0x00FF);

// comando MSB
outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);}
      xywh {20 90 150 25} color 31
    }
    Fl_Button TicksDown {
      label {Ticks Down}
      callback {// Primero paramos el láser, para que no se líe la cuenta en la FPGA
//outb(COMANDO_LASER_OFF, REGISTRO_ADDR);

// Ticks Laser Down:

// Byte menos significativo (LSB)
outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);

//printf("Laser_Down_Ticks=%d	Laser_Down_Ticks & 0x00FF=%d\\n", Laser_Down_Ticks, Laser_Down_Ticks & 0x00FF);

// comando LSB
outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);

// Byte más significativo (MSB)
outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

//printf("Laser_Down_Ticks>>8=%d	(Laser_Down_Ticks >> 8) & 0x00FF=%d\\n", Laser_Down_Ticks >> 8, (Laser_Down_Ticks >> 8) & 0x00FF);

// comando MSB
outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);}
      xywh {175 90 150 25} color 31
    }
    Fl_Button GalvosOn {
      label {Galvos On}
      callback {outb((COMANDO_GALVOS|0x01), REGISTRO_ADDR);}
      xywh {20 170 150 25} color 31
    }
    Fl_Button GalvosOff {
      label {Galvos Off}
      callback {outb((COMANDO_GALVOS|0x00), REGISTRO_ADDR);}
      xywh {175 170 150 25} color 31
    }
    Fl_Button ControlOn {
      label {Control On}
      callback {outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);}
      xywh {20 205 150 25} color 31
    }
    Fl_Button ControlOff {
      label {Control Off}
      callback {outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);}
      xywh {175 205 150 25} color 31
    }
    Fl_Button LaserEnableOn {
      label {Laser Enable On}
      callback {outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);}
      xywh {20 60 150 25} color 31 labelsize 12
    }
    Fl_Button LaserEnableOff {
      label {Laser Enable Off}
      callback {outb((COMANDO_LASER_ENABLE|0x00), REGISTRO_ADDR);}
      xywh {175 60 150 25} color 31 labelsize 12
    }
    Fl_Button ExtractorOn {
      label {Extractor On}
      callback {outb((COMANDO_EXTRACTOR|0x01), REGISTRO_ADDR);}
      xywh {20 240 150 25} color 31
    }
    Fl_Button ExtractorOff {
      label {Extractor Off}
      callback {outb((COMANDO_EXTRACTOR|0x00), REGISTRO_ADDR);}
      xywh {175 240 150 25} color 31
    }
    Fl_Button MarkInProgressOn {
      label {Mark In Progress On}
      callback {outb((COMANDO_MARK_IN_PROGRESS|0x01), REGISTRO_ADDR);}
      xywh {20 275 150 25} color 31 labelsize 12
    }
    Fl_Button MarkInProgressOff {
      label {Mark In Progress Off}
      callback {outb((COMANDO_MARK_IN_PROGRESS|0x00), REGISTRO_ADDR);}
      xywh {175 275 150 25} color 31 labelsize 12
    }
    Fl_Button Unconfigure {
      label {Unconfigure FPGA}
      callback {outb((COMANDO_ADMIN_FPGA|ARG_UNCONFIGURE_FPGA), REGISTRO_ADDR);}
      xywh {20 15 150 25} color 31
    }
    Fl_Button Reset {
      label {Reset FPGA}
      callback {outb((COMANDO_ADMIN_FPGA|ARG_RESET_IO), REGISTRO_ADDR);}
      xywh {175 15 150 25} color 31
    }
    Fl_Button EncoderOn {
      label {Encoder On}
      callback {outb((COMANDO_ENCODER|0x01), REGISTRO_ADDR);}
      xywh {20 345 150 25} color 31
    }
    Fl_Button EncoderOff {
      label {Encoder Off}
      callback {outb((COMANDO_ENCODER|0x00), REGISTRO_ADDR);}
      xywh {175 345 150 25} color 31
    }
    Fl_Value_Output CuentasEncoder {
      xywh {175 375 150 25} color 31
    }
    Fl_Button LeerEncoder {
      label {Leer Encoder:}
      callback {// Lee las cuentas del encoder
unsigned short cuentas;
//RTIME t0, t1;

// Manda el comando a la FPGA
// Con este comando se copia el valor de las cuentas del encoder en la FPGA (8 bits)

//t0=rt_get_cpu_time_ns();
outb(COMANDO_LEER_CUENTAS_ENCODER, REGISTRO_ADDR);
//t1=rt_get_cpu_time_ns();
//rt_printk("Encoder outb:%f ", float(t1-t0)/1000.0);

// Lee el byteo
//t0=rt_get_cpu_time_ns();
cuentas = inb(REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("inb:%f\\n", float(t1-t0)/1000.0);

// Y lo presenta:
CuentasEncoder->value(cuentas);}
      xywh {20 375 150 25} color 31
    }
    Fl_Value_Output Fotocelula {
      xywh {175 425 150 25} color 31
    }
    Fl_Button LeerFotocelula {
      label {Leer Fotocelula:}
      callback {BYTE inbyte, valor;

inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\\n", inbyte);

// En la fotocélula se lee -con la máscara- 32 cuando está conectada a tierra, y 0 cuando está
// conectada a 5V

if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {valor = 0;}
else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {valor = 1;}
else valor = -1; // error

// Lee la señal de la fotocélula
//Fotocelula->value(inb(REGISTRO_STATUS) & MASCARA_ENTRADA_FOTOCELULA);

Fotocelula->value(valor);}
      xywh {20 425 150 25} color 31
    }
    Fl_Value_Output LaserOk {
      xywh {175 455 150 25} color 31
    }
    Fl_Button LeerLaserOk {
      label {Leer Laser Ok:}
      callback {BYTE inbyte, valor;

// Redirige la entrada de Laser Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_LASER_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

LaserOk->value(valor);}
      xywh {20 455 150 25} color 31
    }
    Fl_Value_Output TemperaturaOk {
      xywh {175 485 150 25} color 31
    }
    Fl_Button LeerTemperaturaOk {
      label {Leer Temp. Ok:}
      callback {BYTE inbyte, valor;

// Redirige la entrada de Temperatura Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_TEMPERATURA_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

TemperaturaOk->value(valor);}
      xywh {20 485 150 25} color 31
    }
    Fl_Value_Output ExtractorOk {
      xywh {175 515 150 25} color 31
    }
    Fl_Button LeerExtractorOk {
      label {Leer Extractor Ok:}
      callback {BYTE inbyte, valor;

// Redirige la entrada de Extractor Ok al pin 13 del puerto paralelo
outb((COMANDO_LEER_DI|ARG_LEER_EXTRACTOR_OK), REGISTRO_ADDR);

// Lee el registro de status
inbyte = inb(REGISTRO_STATUS);

//printf("Registro Status: %d\\n", inbyte);

// En la entrada digital se lee -con la máscara- 16 cuando está conectada a 5V, 
// y 0 cuando está conectada a tierra

if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 16) {valor = 1;}
else if ((inbyte & MASCARA_ENTRADAS_DIGITALES) == 0) {valor = 0;}
else valor = -1; // error

ExtractorOk->value(valor);}
      xywh {20 515 150 25} color 31
    }
    Fl_Button LeeGalvoX {
      label {Leer Galvo X:}
      callback {/*
unsigned short posicion;
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;

// Y lo presenta:
GalvoX->value(posicion);
*/}
      xywh {455 115 150 25}
    }
    Fl_Value_Output GalvoX {
      xywh {610 115 150 25}
    }
    Fl_Button LeeGalvoY {
      label {Leer Galvo Y:}
      callback {/*
unsigned short posicion;
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;

// Y lo presenta:
GalvoY->value(posicion);
*/}
      xywh {455 240 150 25}
    }
    Fl_Value_Output GalvoY {
      xywh {610 240 150 25}
    }
    Fl_Counter FPGAEscribirGalvoX {
      label {Galvo X:}
      callback {BYTE LSB_byte, comando;
short valor;
RTIME t0, t1;

valor = FPGA_from_phys(FPGAEscribirGalvoX->value());

rt_printk("X: valor=%d ", valor);

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_X | ((valor >> 8) & 0x000F));

t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
t1=rt_get_cpu_time_ns();
rt_printk("t=%f\\n", float(t1-t0)/1000.0);}
      xywh {520 70 240 35} align 4 minimum -10 maximum 10
      code0 {o->value(-10.0);}
    }
    Fl_Counter FPGAEscribirGalvoY {
      label {Galvo Y:}
      callback {BYTE LSB_byte, comando;
short valor;
RTIME t0, t1;

valor = FPGA_from_phys(FPGAEscribirGalvoY->value());

rt_printk("Y: valor=%d ", valor);

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_Y | ((valor >> 8) & 0x000F));

t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
t1=rt_get_cpu_time_ns();
rt_printk("t=%f\\n", float(t1-t0)/1000.0);}
      xywh {520 195 240 35} align 4 minimum -10 maximum 10
      code0 {o->value(-10.0);}
    }
  }
} 

Function {Make_Window_Repeticiones()} {C
} {
  Fl_Window VentanaRepeticiones {open
    xywh {207 71 460 460} type Double box BORDER_BOX color 7 selection_color 7 when 6 modal noborder visible
  } {
    Fl_Group GrupoFilas {open
      xywh {50 15 355 75} box PLASTIC_DOWN_BOX color 48
    } {
      Fl_Counter IndicadorFilas {
        label Filas
        callback {if (!ControlAcceso) {

	// Cambia el número de filas
	NumeroFilas = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(NumeroFilas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {65 45 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 1 maximum 20 step 1 value 1 textfont 8 textsize 15
        code0 {o->value(NumeroFilas); //inicialización}
        code1 {if (o->value() == 0) {NumeroFilas=1; o->value(NumeroFilas);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Filas");break; case ING:o->label("Rows");break; case ITA:o->label("Righe");break;}}
      }
      Fl_Counter IndicadorSeparacionFilas {
        label {Separación (mm)}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	SeparacionFilas = (float)o->value();
	ySeparacionFilas = (int)(SeparacionFilas * CalibracionCorreccion);	// en bits
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionFilas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {240 45 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum -100 maximum 100 textfont 8 textsize 15
        code0 {o->value(SeparacionFilas); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}}
      }
    }
    Fl_Group GrupoColumnas {open
      xywh {50 100 355 75} box PLASTIC_DOWN_BOX color 48
    } {
      Fl_Counter IndicadorColumnas {
        label Columnas
        callback {if (!ControlAcceso) {

	// Cambia el número de columnas
	NumeroColumnas = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(NumeroColumnas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {65 130 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 1 maximum 20 step 1 value 1 textfont 8 textsize 15
        code0 {o->value(NumeroColumnas); //inicialización}
        code1 {if (o->value() == 0) {NumeroColumnas=1; o->value(NumeroColumnas);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Columnas");break; case ING:o->label("Columns");break; case ITA:o->label("Colonne");break;}}
      }
      Fl_Counter IndicadorSeparacionColumnas {
        label {Separación (mm)}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	SeparacionColumnas = (float)o->value();
	xSeparacionColumnas = (int)(SeparacionColumnas * CalibracionCorreccion);	// en bits

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionColumnas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {240 130 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum -100 maximum 100 textfont 8 textsize 15
        code0 {o->value(SeparacionColumnas); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}}
      }
    }
    Fl_Group GrupoPrecorte {open
      xywh {50 185 355 150} box PLASTIC_DOWN_BOX color 48
    } {
      Fl_Round_Button CheckPrecorte {
        label { Precorte}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	Precorte = (int) o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Precorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {65 205 145 35} down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 16 when 6
        code0 {o->value(Precorte); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Precorte");break; case ING:o->label("Slitting");break; case ITA:o->label("Pretagliato");break;}}
      }
      Fl_Counter IndicadorLongitudPrecorte {
        label {Longitud (%)}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	LongitudPrecorte = (int)o->value();
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(LongitudPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {245 215 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 1 maximum 100 step 1 value 100 textfont 8 textsize 15
        code0 {o->value(LongitudPrecorte); //inicialización}
        code1 {if (o->value() == 0) {LongitudPrecorte=100; o->value(LongitudPrecorte);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Longitud (%)");break; case ING:o->label("Length (%)");break; case ITA:o->label("Longitude (%)");break;}}
      }
      Fl_Counter IndicadorSeparacionPrecorte {
        label {Separación (mm)}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	SeparacionPrecorte = (float)o->value();
	SeparacionPrecorteBits = (int)(SeparacionPrecorte * CalibracionCorreccion);	// en bits

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {65 280 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum -100 maximum 100 textfont 8 textsize 15
        code0 {o->value(SeparacionPrecorte); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}}
      }
      Fl_Counter IndicadorVelocidadPrecorte {
        label {Velocidad (%)}
        callback {if (!ControlAcceso) {

	// Cambia el valor
	VelocidadPrecorte = (int) o->value();

}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(VelocidadPrecorte);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {245 280 150 35} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 10 maximum 1000 step 10 value 100 textfont 8 textsize 15
        code0 {o->value(VelocidadPrecorte); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Velocidad (%)");break; case ING:o->label("Speed (%)");break; case ITA:o->label("Velocità (%)");break;}}
      }
    }
    Fl_Button Cancelar_VentanaRepeticiones {
      label Cancelar
      callback {//Vuelve a la ventana principal sin hacer nada

// Carga todo de nuevo, tal como estaba antes de realizar cambios, 
// ya que todavía no se han grabado
Leer_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaRepeticiones->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {270 355 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code0 {//o->deactivate();// de momento no se implementa la posibilidad de cancelar los cambios}
      code3 {switch (Idioma) {case ESP:o->label("Cancelar");break; case ING:o->label("Cancel");break; case ITA:o->label("Cancellare");break;}}
    }
    Fl_Button Aceptar_VentanaRepeticiones {
      label Aceptar
      callback {// Guarda todo
Escribir_DAT("itaca.dat");

// Oculta la ventana emergente actual
VentanaRepeticiones->hide();

// Y vuelve a presentar la ventana principal
VentanaActiva = VPrincipal;
VentanaPrincipal->activate();
VentanaPrincipal->cursor(FL_CURSOR_DEFAULT);}
      xywh {50 355 135 75} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 20
      code3 {switch (Idioma) {case ESP:o->label("Aceptar");break; case ING:o->label("Accept");break; case ITA:o->label("Acettare");break;}}
    }
  }
} 

Function {CargarVentanaModificarTexto()} {C return_type void
} {
  code {char record[12];

////////////////////////////////////////////////////////////7
// Estado de los widgets de la ventana de modificar texto

// Botones de rupia y logo ISI: sólo se muestran si el font es "india"
if (ValorFuente==9) {
	BotonRupia->show();
	BotonISI->show();
}

else {
	BotonRupia->hide();
	BotonISI->hide();
}
 
// Fecha
ChoiceFormatoFecha1->value(ValorFormatoFecha1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha2->value(ValorFormatoFecha2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoFecha3->value(ValorFormatoFecha3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorFecha->value(ValorSeparadorFecha[LineaCalcular - 1][BloqueCalcular - 1]);
IndicadorCaducidad->value(Caducidad[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonFecha->deactivate();
	ChoiceFormatoFecha1->deactivate();
	ChoiceFormatoFecha2->deactivate();
	ChoiceFormatoFecha3->deactivate();
	ChoiceSeparadorFecha->deactivate();
	IndicadorCaducidad->deactivate();
}

else {
	BotonFecha->activate();
	ChoiceFormatoFecha1->activate();
	ChoiceFormatoFecha2->activate();
	ChoiceFormatoFecha3->activate();
	ChoiceSeparadorFecha->activate();
	IndicadorCaducidad->activate();
}

// Hora
ChoiceFormatoHora1->value(ValorFormatoHora1[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora2->value(ValorFormatoHora2[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceFormatoHora3->value(ValorFormatoHora3[LineaCalcular - 1][BloqueCalcular - 1]);
ChoiceSeparadorHora->value(ValorSeparadorHora[LineaCalcular - 1][BloqueCalcular - 1]);

if (StatusHora[LineaCalcular - 1][BloqueCalcular - 1]) {
	BotonHora->deactivate();
	ChoiceFormatoHora1->deactivate();
	ChoiceFormatoHora2->deactivate();
	ChoiceFormatoHora3->deactivate();
	ChoiceSeparadorHora->deactivate();
}

else {
	BotonHora->activate();
	ChoiceFormatoHora1->activate();
	ChoiceFormatoHora2->activate();
	ChoiceFormatoHora3->activate();
	ChoiceSeparadorHora->activate();
}

// Serie
sprintf(record, "%0*ld", NumeroDigitosNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1], NumeroSerieInicial[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoSerie->value(record);

if (NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1] > 0) {
	sprintf(record, "%ld", NumeroSerieFinal[LineaCalcular - 1][BloqueCalcular - 1]);
	CuadroTextoSerieFinal->value(record);
}
else {
	CuadroTextoSerieFinal->value("");
}

sprintf(record, "%ld", NumeroUnidadesLote[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLote->value(record);

sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
CuadroTextoUnidadesLoteActual->value(record);

// Activa el número actual y el botón de reinicio sólo si se trata de la línea con el numero de serie
// y el número de serie está activado
if (StatusNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
	
	BotonSerie->deactivate();
	CuadroTextoSerie->deactivate();
	CuadroTextoSerieFinal->deactivate();
	FrameLote->deactivate();
	CuadroTextoUnidadesLote->deactivate();
	CuadroTextoUnidadesLoteActual->deactivate();
	BotonReiniciarSerie->activate();
	
}

else {
	
	BotonSerie->activate();
	CuadroTextoSerie->activate();
	CuadroTextoSerieFinal->activate();
	FrameLote->activate();
	CuadroTextoUnidadesLote->activate();
	CuadroTextoUnidadesLoteActual->activate();
	BotonReiniciarSerie->deactivate();
	
}

// Carga el cuadro de texto de la ventana que saldrá con el texto de la línea 1
CargarTexto();

// Carga el número actual de unidades en el lote, ya que si se ha marcado habrá variado
if (NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1] > 0) {	//si no es mayor que 0 el campo no tiene significado
	sprintf(record, "%ld", NumeroUnidadesLoteActual[LineaCalcular - 1][BloqueCalcular - 1]);
	CuadroTextoUnidadesLoteActual->value(record);
}

// Muestra la nueva ventana		
VentanaActiva = VModificar;
VentanaModificarTexto->show();} {}
} 

Function {CargarVentanaDetallesLinea()} {C return_type void
} {
  code {// Estado de los widgets de la ventana de detalles de tipo de línea
int i;

// Tipo de línea
ChoiceTipoLinea->value(ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]);

// Si el tipo de línea es texto oculta los grupos de barcode y gráfico
if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {

	GrupoTexto->show();
	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();
	
	if (Estrategia < 3) {
		TextoMinX->hide();
		TextoMinY->hide();
	}
	else {
		TextoMinX->show();
		TextoMinX->value(MinXTexto[LineaCalcular-1][BloqueCalcular-1]);
		TextoMinY->show();
		TextoMinY->value(MinYTexto[LineaCalcular-1][BloqueCalcular-1]);	
	}
}

// Si el tipo de línea es gráfico, muestra el grupo gráfico y oculta el de barcode
else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {

	GrupoTexto->hide();
	GrupoBarcode->hide();
	GrupoGrafico->show();
	GrupoTextoCircular->hide();
	
	if (Estrategia < 3) {
		GraficoMinX->hide();
		GraficoMinY->hide();
	}
	else {
		GraficoMinX->show();
		GraficoMinX->value(MinXGrafico[LineaCalcular-1][BloqueCalcular-1]);
		GraficoMinY->show();
		GraficoMinY->value(MinYGrafico[LineaCalcular-1][BloqueCalcular-1]);	
	}

	
	// Desactiva el botón de Aceptar hasta que se haga una seleccion
	Aceptar_VentanaDetallesLinea->deactivate();

	// Selecciona el archivo que corresponda
	if (strlen(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]) > 0) {
	
		if (debug_plt) {
			printf("NombreArchivoPlt[%d,%d]:%s\\n", LineaCalcular-1, BloqueCalcular - 1, NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]);
		}
			
		for (i=1; i<=FileBrowserArchivosPlt->size(); i++) {
		
			if (debug_plt) {
				printf("FileBrowserArchivosPlt->text(%d):%s\\n", i, FileBrowserArchivosPlt->text(i));
			}
			
			// si son iguales los nombres, hay que seleccionar esa entrada
			if (strcmp(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], FileBrowserArchivosPlt->text(i)) == 0) {
				FileBrowserArchivosPlt->select(i);	
			}
		
		}
	
	}

	
	// O ninguno, si no había ninguno seleccionado
	else {
	
		if (debug_plt) {
			printf("Ningún archivo plt seleccionado\\n");
		}
	
		FileBrowserArchivosPlt->deselect(FileBrowserArchivosPlt->value());
			
	}

}
else if ( ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {

	GrupoTexto->hide();
	GrupoBarcode->hide();
	GrupoGrafico->hide();
	GrupoTextoCircular->show();
	
	if (Estrategia < 3) {
		TextoCircularCentroX->hide();
		TextoCircularCentroY->hide();
		Angulo->hide();
		Radio->hide();
	}
	else {
		TextoCircularCentroX->show();
		TextoCircularCentroX->value(CentroXTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
		TextoCircularCentroY->show();
		TextoCircularCentroY->value(CentroYTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
		Angulo->show();
		Angulo->value(AnguloTextoCircular[LineaCalcular-1][BloqueCalcular-1]);
		Radio->show();
		Radio->value(RadioTextoCircular[LineaCalcular-1][BloqueCalcular-1]);	
	}
		Aceptar_VentanaDetallesLinea->activate();

	
}
// Si es cualquier otro tipo muestra el grupo de barcode y oculta el grupo gráfico
else {

	GrupoTexto->hide();	
	GrupoBarcode->show();
	GrupoGrafico->hide();
	GrupoTextoCircular->hide();

	// Si es un datamatrix ocultar la opción de invertir el código, ya que no tiene sentido
	if ( numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] == 71) {
	
		CheckInvertirBarcode->hide();
	}
	
	else {
		CheckInvertirBarcode->show();
	
	}
	
	// Invertir
	CheckInvertirBarcode->value(InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1]);

	// Escala Barcode
	IndicadorEscalaBarcode->value(EscalaBarcode[LineaCalcular - 1][BloqueCalcular - 1]);

	// Separación barras Barcode
	IndicadorSeparacionBarrasBarcode->value(SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1]);

	if (Estrategia < 3) {
		BarcodeMinX->hide();
		BarcodeMinY->hide();
	}
	else {
		BarcodeMinX->show();
		BarcodeMinX->value(MinXBarcode[LineaCalcular-1][BloqueCalcular-1]);
		BarcodeMinY->show();
		BarcodeMinY->value(MinYBarcode[LineaCalcular-1][BloqueCalcular-1]);	
	}

	Aceptar_VentanaDetallesLinea->activate();

}

// Muestra la nueva ventana		
VentanaActiva = VDetalles;
VentanaDetallesLinea->show();} {}
} 

Function {CargarVentanaTrabajos()} {C return_type void
} {
  code {// Cada vez que se carga la ventana se debe borrar el texto del cuadro
CuadroTextoTrabajo->value("");


// Muestra la nueva ventana		
VentanaActiva = VTrabajos;
VentanaTrabajos->show();} {}
} 

Function {CargarVentanaPassword()} {C return_type void
} {
  code {// Muestra la nueva ventana		
VentanaActiva = VPassword;
VentanaPassword->show();} {}
} 

Function {CargarVentanaConfirmarCargarTrabajo()} {C return_type void
} {
  code {// Muestra la nueva ventana		
VentanaActiva = VConfirmarCargarTrabajo;
VentanaConfirmarCargarTrabajo->show();} {}
} 

Function {CargarVentanaConfirmarGuardarTrabajo()} {C return_type void
} {
  code {// Muestra la nueva ventana		
VentanaActiva = VConfirmarGuardarTrabajo;
VentanaConfirmarGuardarTrabajo->show();} {}
} 

Function {CargarVentanaConfirmarBorrarTrabajo()} {C return_type void
} {
  code {// Muestra la nueva ventana		
VentanaActiva = VConfirmarCargarTrabajo;
VentanaConfirmarBorrarTrabajo->show();} {}
} 

Function {CargarVentanaRepeticiones()} {C return_type void
} {
  code {// Estado de los widgets de la ventana de detalles de tipo de línea
IndicadorFilas->value(NumeroFilas);
IndicadorSeparacionFilas->value(SeparacionFilas);

IndicadorColumnas->value(NumeroColumnas);
IndicadorSeparacionColumnas->value(SeparacionColumnas);

CheckPrecorte->value(Precorte);
IndicadorLongitudPrecorte->value(LongitudPrecorte);
IndicadorSeparacionPrecorte->value(SeparacionPrecorte);

// Muestra la nueva ventana
VentanaActiva = VRepeticiones;
VentanaRepeticiones->show();} {}
} 

Function {CrearBarcode(int linea, int bloque)} {C return_type int
} {
  code {int error;
//float alturalineatexto;
int datamsize;
int qrsize;
char datamsquare;
struct zint_symbol *barcodePNG;	// Objeto código de barras para hacer debug y ver el png

// Si había un código de barras borra el objeto
if(BarcodeSymbol[linea][bloque] != NULL) {

	ZBarcode_Delete(BarcodeSymbol[linea][bloque]);

}

// Crea el objeto barcode
BarcodeSymbol[linea][bloque] = ZBarcode_Create();

// Comprueba si se ha creado correctamente
if(BarcodeSymbol[linea][bloque] == NULL) {	// No se ha creado correctamente
        
        return -1;
               
}
        
else {	// Sí se ha creado correctamente: ajusta los parámetros
        
        // Tipo
        BarcodeSymbol[linea][bloque]->symbology = numTiposLinea[ValorTipoLinea[linea][bloque]];
        
        
        // Tamaño Datamatrix
        if(numTiposLinea[ValorTipoLinea[linea][bloque]]==71){
        datamsize = 8;
        datamsquare = char(DM_SQUARE);
        	//BarcodeSymbol[linea][bloque]->option_2 = datamsize; //numTiposLinea[ValorTipoLinea[linea][bloque]];
        	BarcodeSymbol[linea][bloque]->option_3 = datamsquare; //numTiposLinea[ValorTipoLinea[linea][bloque]];
            	
        }


        if(numTiposLinea[ValorTipoLinea[linea][bloque]]==58){
        qrsize = 8;
        	//BarcodeSymbol[linea][bloque]->option_2 = qrsize; //numTiposLinea[ValorTipoLinea[linea][bloque]];
        	//BarcodeSymbol[linea][bloque]->option_3 = datamsquare; //numTiposLinea[ValorTipoLinea[linea][bloque]];
            	
        }        
        // Invertir
        //if (InvertirBarcode[linea] == ON) {
        //	strcpy(BarcodeSymbol[linea]->fgcolour, "ffffff");
	//	strcpy(BarcodeSymbol[linea]->bgcolour, "000000");
        //}
        
        //else {
        //	strcpy(BarcodeSymbol[linea]->fgcolour, "000000");
	//	strcpy(BarcodeSymbol[linea]->bgcolour, "ffffff");
        //}
        
        // obtiene la altura de texto correspondiente a la línea    
	//switch (linea) {

	//	case 0:
	//	alturalineatexto = AlturaLineaTexto1;
	//	break;

	//	case 1:
	//	alturalineatexto = AlturaLineaTexto2;
	//	break;
    
	//	case 2:
	//    	alturalineatexto = AlturaLineaTexto3;
	//	break;
   	
   	//	case 3:
	//    	alturalineatexto = AlturaLineaTexto4;
	//
	
	//}
        
        // factor de escala
        BarcodeSymbol[linea][bloque]->scale = EscalaBarcode[linea][bloque]/100.0;
        
        // barras laterales
        //BarcodeSymbol[linea]->border_width = 10;
        
        // Fija la máxima coordenada Y en la generación del código
        //height = (int)((alturalineatexto/(double)Spot*1000.0*50.0/(double)EscalaBarcode[linea]));
	//BarcodeSymbol[linea]->height = height;
        
        // Genera a imprime el código de barras en el archivo barcode.svg
        //strcpy(BarcodeSymbol[LineaCalcular - 1]->outfile, "barcode.svg");  
        
        // Codifica  	
        switch (linea) {

		case 0:
		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto1[bloque], 0);
		break;
        
	        case 1:
		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto2[bloque], 0);
		break;
		
		case 2:
		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto3[bloque], 0);
		break;
		
		case 3:
		error = ZBarcode_Encode(BarcodeSymbol[linea][bloque], (unsigned char *)LineaTexto4[bloque], 0);
		break;
		
	}
	
	// Chequea posibles errores
	if(error != 0) {
             
        	// some error occurred
	        rt_printk("CrearBarcode %s\\n", BarcodeSymbol[linea][bloque]->errtxt);
        
	}
        
	if(error > WARN_INVALID_OPTION) {
                
        	// stop now
	        //ZBarcode_Delete(my_symbol);
        	return 1;
        
	}
	
	// Elimina el human readable text
	strcpy((char *)BarcodeSymbol[linea][bloque]->text, "");
	
	// Genera el bitmap en memoria con la imagen del código
	ZBarcode_Buffer(BarcodeSymbol[linea][bloque], 0);
	
}

// si hay debug de barcode, crear el mismo código en png, para poder verlo, pero en una variable distinta
// para evitar stacked symbols
if (debug_barcode) {

	// Crea el objeto barcode
	barcodePNG = ZBarcode_Create();

	// Tipo
        barcodePNG->symbology = numTiposLinea[ValorTipoLinea[linea][bloque]];
        
	// Escala
	barcodePNG->scale = EscalaBarcode[linea][bloque]/100.0;
	
	// Fija la máxima coordenada Y en la generación del código
	//barcodePNG->height = height;
	
        // Invertir
        if (InvertirBarcode[linea][bloque] == ON) {
        	strcpy(barcodePNG->fgcolour, "ffffff");
		strcpy(barcodePNG->bgcolour, "000000");
        }
        
        else {
        	strcpy(barcodePNG->fgcolour, "000000");
		strcpy(barcodePNG->bgcolour, "ffffff");
        }
	       
        // Genera a imprime el código de barras en el archivo barcode.png
	strcpy(barcodePNG->outfile, "barcode.png");
	
	// Codifica  	
        switch (linea) {

		case 0:
		error = ZBarcode_Encode(barcodePNG, (unsigned char *)LineaTexto1[bloque], 0);
		break;
        
	        case 1:
		error = ZBarcode_Encode(barcodePNG, (unsigned char *)LineaTexto2[bloque], 0);
		break;
		
		case 2:
		error = ZBarcode_Encode(barcodePNG, (unsigned char *)LineaTexto3[bloque], 0);
		break;
		
		case 3:
		error = ZBarcode_Encode(barcodePNG, (unsigned char *)LineaTexto4[bloque], 0);
		break;
		
	}
	
	// Elimina el human readable text
	strcpy((char *)barcodePNG->text, "");
	
	// Genera el bitmap en memoria con la imagen del código
	ZBarcode_Print(barcodePNG, 0);
	
	// y borra el objeto, ya que no es necesario anymore
	ZBarcode_Delete(barcodePNG);

}
        
return 0;} {}
} 

Function {CargarTexto()} {C return_type void
} {
  code {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Compone el texto de la línea
//OrdenFecha = OrdenFechaLinea[LineaCalcular - 1];
//OrdenHora = OrdenHoraLinea[LineaCalcular - 1];
//OrdenNumeroSerie = OrdenNumeroSerieLinea[LineaCalcular - 1];

// Codificación para entender los anidamientos: Fecha,Hora,Serie
	
// Procesa el texto
switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
//////////////////////////////////////////////////////////////////////////////////////	
case 0: //0
        
	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
	case 0: //0,0
        
	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
	       	case 0: //0,0,0
 			
                	switch(LineaCalcular) {	
                	
                	case 1:
                		strcpy(str, LineaTexto1[BloqueCalcular - 1]);
                		break;
                	
                	case 2:
                		strcpy(str, LineaTexto2[BloqueCalcular - 1]);
                		break;
                		
                	case 3:
                		strcpy(str, LineaTexto3[BloqueCalcular - 1]);
                		break;
                		
                	case 4:
                		strcpy(str, LineaTexto4[BloqueCalcular - 1]);
                		break;
                	
                	}
                	
            		CuadroTextoLinea->value(str);
            		
            		if (debug_texto) {
	            		printf("Cargar 0.0.0 %s\\n", str);
	            	} 
            		
           		break; //0,0,0
            		
		case 1: //0,0,1
		        
		       	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	        	

			if (debug_texto) {
	            		printf("Cargar 0.0.1 %s\\n", str);
	            	} 
	            			        	
		        break; //0,0,1
	           	
        	}
	
		break; //0,0
		
	case 1: //0,1
    
		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 		case 0: //0,1,0
	      
	        	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	        			        	
            		
            		if (debug_texto) {
	            		printf("Cargar 0.1.0 %s\\n", str);
	            	} 
	            	
            		break;//0,1,0
        	
        	case 2: //0,1,2
        		
		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	       
			
			if (debug_texto) {
	            		printf("Cargar 0.1.2 %s\\n", str);
	            	} 
	            	
        		break; //0,1,0
        		
        	}
        	
        	break; //0,1
        	
	case 2: //0,2
    	
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 1: //0,2,1
       	
	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	        
	            	
	            	if (debug_texto) {
	            		printf("Cargar 0.2.1 %s\\n", str);
	            	} 
	            	
        		break; //0,2,1
        		
        	}
        		
        	break; //0,2
        		
        }
       	
	break; //0
		
//////////////////////////////////////////////////////////////////////////////////////	    	
case 1: //1

	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
	case 0: //1,0
        
	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
	       	case 0: //1,0,0

			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea->value(str);
	            	
	            	if (debug_texto) {
	            		printf("Cargar 1.0.0 %s\\n", str);
	            	} 
	            	
            		break;//1,0,0
            		
		case 2: //1,0,2

		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	       
		        
		        if (debug_texto) {
	            		printf("Cargar 1.0.2 %s\\n", str);
	            	} 
	            		
		        break; //1,0,2
	           	
        	}
	
		break; //1,0
		
	case 2: //1,2
    
		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 		case 0: //1,2,0
                  	      
	        	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	        
	            	
            		if (debug_texto) {
	            		printf("Cargar 1.2.0 %s\\n", str);
	            	} 
	            	
            		break; //1,2,0
        	
        	case 3: //1,2,3
   	
		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	    
			
			if (debug_texto) {
	            		printf("Cargar 1.2.3 %s\\n", str);
	            	} 
	            	
        		break; //1,2,3
        		
        	}
        	
        	break; //1,2
        	
	case 3: //1,3
    	
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 2: //1,3,2
 			
		        strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	   
            			
            		if (debug_texto) {
	            		printf("Cargar 1.3.2 %s\\n", str);
	            	} 
	            	
        		break; //1,3,2
        		
        	} 
        		
        	break; //1,3
        		        	
        } 
        	
        break; //1
        
//////////////////////////////////////////////////////////////////////////////////////	
case 2: //2
        	
       	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: //2,0
        		
       		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
       		case 1: //2,0,1
       			
			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea->value(str);
		        
		        if (debug_texto) {
	            		printf("Cargar 2.0.1 %s\\n", str);
	            	} 
	            		
        		break; //2,0,1
        		
        	}
        		
        	break; //2,0
        	
        case 1: //2,1
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 0: //2,1,0       	
          			
 			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea->value(str);
		        
		        if (debug_texto) {
	            		printf("Cargar 2.1.0 %s\\n", str);
	            	} 
	            	
        		break; //2,1,0
        		
        	case 3: //2,1,3
           			
		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
                	CuadroTextoLinea->value(str);
                	
                	if (debug_texto) {
	            		printf("Cargar 2.1.3 %s\\n", str);
	            	} 
	            	
        		break; //2,1,3
        		
        	}
        		
        	break; //2,1
        	
        case 3: //2,3
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 1: //2,3,1
   				
	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		CuadroTextoLinea->value(str);	   
            		
            		if (debug_texto) {
	            		printf("Cargar 2.3.1 %s\\n", str);
	            	} 
	            			
        		break; //2,3,1
        		
        	}
        		
        	break; //2,3
        	
        }
        	
	break; //2
	
//////////////////////////////////////////////////////////////////////////////////////	
case 3: //3
        	
       	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 1: //3,1 
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 2: //3,1,2
          		
 			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea->value(str);
		        
		        if (debug_texto) {
	            		printf("Cargar 3.1.2 %s\\n", str);
	            	} 
	            		        		
        		break; //3,1,2
        		
        	}
        		
        	break; //3,1
        	
        case 2: //3,2
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 1: //3,2,1
	
 			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			CuadroTextoLinea->value(str);
		        
		        if (debug_texto) {
	            		printf("Cargar 3.2.1 %s\\n", str);
	            	} 
	            		        		
        		break; //3,2,1
        		
        	}
        		
        	break; //3,2
        	
        }
        	
	break; //3
		
} // de switch (OrdenFecha) inicial} {}
} 

Function {ProcesarCaracter(const char *caracter)} {C return_type void
} {
  code {// string de texto auxiliar
char str[NumeroMaximoCaracteresLinea];

// Codificación para entender los anidamientos: Fecha,Hora,Serie
	
// Procesa el texto
switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) {
    	
//////////////////////////////////////////////////////////////////////////////////////	
case 0: //0
        
	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
	case 0: //0,0
        
	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
	       	case 0: //0,0,0
 			
 			strcpy(str, CuadroTextoLinea->value());
			
			strcat(str, caracter);
            		
            		CuadroTextoLinea->value(str);
            		
           		break; //0,0,0
            		
		case 1: //0,0,1
		        
		       	strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		       	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	        	
		        	
		        break; //0,0,1
	           	
        	}
	
		break; //0,0
		
	case 1: //0,1
    
		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 		case 0: //0,1,0
     	
	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
	        	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	        			        	
            		
            		break;//0,1,0
        	
        	case 2: //0,1,2

        		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	       
			
        		break; //0,1,0
        		
        	}
        	
        	break; //0,1
        	
	case 2: //0,2
    	
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 1: //0,2,1
	
       			strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	        
	            	
        		break; //0,2,1
        		
        	}
        		
        	break; //0,2
        		
        }
       	
	break; //0
		
//////////////////////////////////////////////////////////////////////////////////////	    	
case 1: //1

	switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
    
	case 0: //1,0
        
	       	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
	       	case 0: //1,0,0

			strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
 				
			strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
	            	
            		break;//1,0,0
            		
		case 2: //1,0,2

		       	strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	       
		        	
		        break; //1,0,2
	           	
        	}
	
		break; //1,0
		
	case 2: //1,2
    
		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
 		case 0: //1,2,0
                    
	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
	        	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	        
	            	
            		
            		break; //1,2,0
        	
        	case 3: //1,2,3
   
         		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		       	strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	    
			
        		break; //1,2,3
        		
        	}
        	
        	break; //1,2
        	
	case 3: //1,3
    	
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
       		
       		case 2: //1,3,2
 		
	           	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		        strcpy(str, textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	   
            			
        		break; //1,3,2
        		
        	} 
        		
        	break; //1,3
        		        	
        } 
        	
        break; //1
        
//////////////////////////////////////////////////////////////////////////////////////	
case 2: //2
        	
       	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 0: //2,0
        		
       		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
       		case 1: //2,0,1
       		
       			strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
 				
			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
		        	
        		break; //2,0,1
        		
        	}
        		
        	break; //2,0
        	
        case 1: //2,1
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 0: //2,1,0       	
          		
                	strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
 				
 			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
		        	
        		break; //2,1,0
        		
        	case 3: //2,1,3
           		
               		strcat(textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
		       	strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
                	
                	CuadroTextoLinea->value(str);
                		
        		break; //2,1,3
        		
        	}
        		
        	break; //2,1
        	
        case 3: //2,3
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 1: //2,3,1
   			        	
	        	strcat(textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1], caracter);
		        	
	        	strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		
            		CuadroTextoLinea->value(str);	   
            				
        		break; //2,3,1
        		
        	}
        		
        	break; //2,3
        	
        }
        	
	break; //2
	
//////////////////////////////////////////////////////////////////////////////////////	
case 3: //3
        	
       	switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) {
        	
       	case 1: //3,1 
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 2: //3,1,2
          		
               		strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
 			
 			strcpy(str, textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
           		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
		        	        		
        		break; //3,1,2
        		
        	}
        		
        	break; //3,1
        	
        case 2: //3,2
        		
        	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) {
        		
        	case 1: //3,2,1

	             	strcat(textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1], caracter);
 				
 			strcpy(str, textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, strNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoHora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            		strcat(str, FormatoCompletoFecha[LineaCalcular - 1][BloqueCalcular - 1]);
			strcat(str, textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
			
			CuadroTextoLinea->value(str);
		        	        		
        		break; //3,2,1
        		
        	}
        		
        	break; //3,2
        	
        }
        	
	break; //3
		
} // de switch (OrdenFecha) inicial} {}
} 

Function {ProcesarTexto()} {C return_type void
} {
  code {// Si hay texto introducido:
//if (strlen(CuadroTextoLinea->value())) \{

	// Guarda el orden de los campos variables para la línea que se está calculando
	//OrdenFechaLinea[LineaCalcular - 1] = OrdenFecha;
	//OrdenHoraLinea[LineaCalcular - 1] = OrdenHora;
	//OrdenNumeroSerieLinea[LineaCalcular - 1] = OrdenNumeroSerie;
   
	// Calcula la fecha/hora si es necesario
	if ((StatusFecha[LineaCalcular - 1][BloqueCalcular - 1] > 0) || (StatusHora[LineaCalcular - 1][BloqueCalcular - 1] > 0))\{
		
		//LineaFecha = LineaCalcular;
		
		//Actualiza la fecha
		//ActualizarFechaHora();
		ActualizarFechaHoraSerie();
		
	\}

	
	//if (OrdenNumeroSerie[LineaCalcular - 1] > 0) \{
		
		//LineaSerie = LineaCalcular;
	
	//\}

	// Procesa la línea
	switch (OrdenFecha[LineaCalcular - 1][BloqueCalcular - 1]) \{
    	
		//////////////////////////////////////////////////////////////////////////////////////	
		case 0: //0
        
		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) \{
    	
			case 0: //0,0
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        	
	       			case 1: //0,0,1      	
				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);    
            			if (debug_texto) \{
	            			printf("Procesar 0.0.1\\n");
	            		\}     		
		        	break; //0,0,1
	           	
        		\}
	
			break; //0,0
		
			case 1: //0,1
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        	
 				case 0: //0,1,0
     				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			if (debug_texto) \{
	            			printf("Procesar 0.1.0\\n");
	            		\}   
            			break;//0,1,0
        	
		        	case 2: //0,1,2
				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);       				
        			if (debug_texto) \{
	            			printf("Procesar 0.1.2\\n");
	            		\}   
        			break; //0,1,2
        		
        		\}
        	
		        break; //0,1
        	
			case 2: //0,2
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
       		
    		   		case 1: //0,2,1
				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);		
        			if (debug_texto) \{
	            			printf("Procesar 0.2.1\\n");
	            		\}   
        			break; //0,2,1
        		
      			\}
        		
        		break; //0,2
        		
  		\}
       	
		break; //0
		
		//////////////////////////////////////////////////////////////////////////////////////	    	
		case 1: //1

		switch (OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) \{
    
			case 0: //1,0
	 	    	switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
	  		    	case 0: //1,0,0
	       			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			if (debug_texto) \{
	            			printf("Procesar 1.0.0\\n");
	            		\}   
            			break;//1,0,0
            		
				case 2: //1,0,2
		 		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
				if (debug_texto) \{
	            			printf("Procesar 1.0.2\\n");
	            		\}   
				break; //1,0,2
	           	
        		\}
	
			break; //1,0
		
			case 2: //1,2
			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        	
 				case 0: //1,2,0
				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);          				
            			if (debug_texto) \{
	            			printf("Procesar 1.2.0\\n");
	            		\}   
            			break; //1,2,0
        	
        			case 3: //1,2,3
        			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 1.2.3\\n");
	            		\}   
        			break; //1,2,3
        		
        		\}
        	
		        break; //1,2
        	
			case 3: //1,3
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
       		
       				case 2: //1,3,2
		        	strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 1.3.2\\n");
	            		\}   
        			break; //1,3,2
        		
        		\} 
        		
        		break; //1,3
        		        	
        	\} 
        	
        	break; //1
        
		//////////////////////////////////////////////////////////////////////////////////////	
		case 2: //2
        	
       		switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) \{
       		
       			case 0: //2,0	
       			switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
       				case 1: //2,0,1      				
       				strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 2.0.1\\n");
	            		\}   
        			break; //2,0,1
        		
        		\}
        		
        		break; //2,0
        	
        		case 1: //2,1
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
        			case 0: //2,1,0       	
                		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 2.1.0\\n");
	            		\}   
        			break; //2,1,0
        		
        			case 3: //2,1,3
           			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 2.1.3\\n");
	            		\}   
        			break; //2,1,3
        		
        		\}
        		
        		break; //2,1
        	
        		case 3: //2,3
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
        			case 1: //2,3,1	
	        		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 2.3.1\\n");
	            		\}   
        			break; //2,3,1
        		
        		\}
        		
        		break; //2,3
        	
        	\}
        	
		break; //2
	
		//////////////////////////////////////////////////////////////////////////////////////	
		case 3: //3
        	
      		switch(OrdenHora[LineaCalcular - 1][BloqueCalcular - 1]) \{
        	
       			case 1: //3,1 		
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
        			case 2: //3,1,2
               			strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);		
        			if (debug_texto) \{
	            			printf("Procesar 3.1.2\\n");
	            		\}   
        			break; //3,1,2
        		
        		\}
        		
		        break; //3,1
        	
		        case 2: //3,2
        		switch (OrdenNumeroSerie[LineaCalcular - 1][BloqueCalcular - 1]) \{
        		
		        	case 1: //3,2,1
	        		strcpy(lineaanterior[LineaCalcular - 1][BloqueCalcular - 1], textoanteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorserie[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineamedio2[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorhora[LineaCalcular - 1][BloqueCalcular - 1]);
            			strcpy(lineafinal[LineaCalcular - 1][BloqueCalcular - 1], textoposteriorfecha[LineaCalcular - 1][BloqueCalcular - 1]);
        			if (debug_texto) \{
	            			printf("Procesar 3.2.1\\n");
	            		\}   
        			break; //3,2,1
        		
        		\}
        		
        		break; //3,2
        	
        	\}
        	
		break; //3
		
	\} // de switch (OrdenFecha) inicial
			
// Actualiza la línea correspondiente
LineaTexto_calcular(LineaCalcular, BloqueCalcular);} {}
} 

Function {LineaTexto_calcular(int linea, int bloque)} {C return_type void
} {
  code {char lineatexto[NumeroMaximoCaracteresLinea];

// Codificación para entender los anidamientos: Fecha,Hora,Serie
if (debug_texto) {
	printf("LineaTexto_calcular: línea:%d bloque:%d\\n", linea, bloque);
} 
	
// Procesa el texto
switch (OrdenFecha[linea - 1][bloque - 1]) {
    	
//////////////////////////////////////////////////////////////////////////////////////	
case 0: //0
        
	switch (OrdenHora[linea - 1][bloque - 1]) {
    
	case 0: //0,0
        
	       	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        	
	       	case 0: //0,0,0
 			
 			strcpy(lineatexto, CuadroTextoLinea->value());
            		
           		break; //0,0,0
            		
		case 1: //0,0,1
		        
		       	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
            		strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
	            	
		        break; //0,0,1
	           	
        	}
	
		break; //0,0
		
	case 1: //0,1
    
		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        	
 		case 0: //0,1,0
     			
     			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
            		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
            		
            		break;//0,1,0
        	
        	case 2: //0,1,2

			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
            		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
            		strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
			
        		break; //0,1,2
        		
        	}
        	
        	break; //0,1
        	
	case 2: //0,2
    	
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
       		
       		case 1: //0,2,1
	
			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
			strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
            		strcat(lineatexto, Hora[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
			
        		break; //0,2,1
        		
        	}
        		
        	break; //0,2
        		
        }
       	
	break; //0
		
//////////////////////////////////////////////////////////////////////////////////////	    	
case 1: //1

	switch (OrdenHora[linea - 1][bloque - 1]) {
    
	case 0: //1,0
        
	       	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        	
	       	case 0: //1,0,0
						
			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
            		strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
            		break;//1,0,0
            		
		case 2: //1,0,2

		       	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
		        	
		        break; //1,0,2
	           	
        	}
	
		break; //1,0
		
	case 2: //1,2
    
		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        	
 		case 0: //1,2,0

			strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
	        	
            		break; //1,2,0
        	
        	case 3: //1,2,3
                
         		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Hora[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
			
        		break; //1,2,3
        		
        	}
        	
        	break; //1,2
        	
	case 3: //1,3
    	
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
       		
       		case 2: //1,3,2
 		
	           	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Fecha[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
            			
        		break; //1,3,2
        		
        	} 
        		
        	break; //1,3
        		        	
        } 
        	
        break; //1
        
//////////////////////////////////////////////////////////////////////////////////////	
case 2: //2
        	
       	switch(OrdenHora[linea - 1][bloque - 1]) {
        	
       	case 0: //2,0
        		
       		switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        		
       		case 1: //2,0,1
       			
	           	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);    		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
		        	
        		break; //2,0,1
        		
        	}
        		
        	break; //2,0
        	
        case 1: //2,1
        		
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        		
        	case 0: //2,1,0       	
          		
                	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);    		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
		        	
        		break; //2,1,0
        		
        	case 3: //2,1,3

           		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
                		
        		break; //2,1,3
        		
        	}
        		
        	break; //2,1
        	
        case 3: //2,3
        		
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        		
        	case 1: //2,3,1
   			        	
	        	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, Hora[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
            				
        		break; //2,3,1
        		
        	}
        		
        	break; //2,3
        	
        }
        	
	break; //2
	
//////////////////////////////////////////////////////////////////////////////////////	
case 3: //3
        	
       	switch(OrdenHora[linea - 1][bloque - 1]) {
        	
       	case 1: //3,1 
        		
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        		
        	case 2: //3,1,2
          		
               		strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, Hora[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
		       	        		
        		break; //3,1,2
        		
        	}
        		
        	break; //3,1
        	
        case 2: //3,2
        		
        	switch (OrdenNumeroSerie[linea - 1][bloque - 1]) {
        		
        	case 1: //3,2,1

	             	strcpy(lineatexto, lineaanterior[linea - 1][bloque - 1]);
		       	strcat(lineatexto, strNumeroSerie[linea - 1][bloque - 1]);
		       	strcat(lineatexto, lineamedio[linea - 1][bloque - 1]);
			strcat(lineatexto, Hora[linea - 1][bloque - 1]);  
			strcat(lineatexto, lineamedio2[linea - 1][bloque - 1]);
			strcat(lineatexto, Fecha[linea - 1][bloque - 1]);           		
            		strcat(lineatexto, lineafinal[linea - 1][bloque - 1]);
		        	        		
        		break; //3,2,1
        		
        	}
        		
        	break; //3,2
        	
        }
        	
	break; //3
		
} // de switch (OrdenFecha) inicial

// Actualiza la línea y el cuadro de texto de la pantalla principal
switch (linea) {

	case 1:
	strcpy(LineaTexto1[bloque - 1], lineatexto);
	//CuadroTextoLinea1->value(lineatexto);
	break;
	
	case 2:
	strcpy(LineaTexto2[bloque - 1], lineatexto);
	//CuadroTextoLinea2->value(lineatexto);
	break;
	
	case 3:
	strcpy(LineaTexto3[bloque - 1], lineatexto);
	//CuadroTextoLinea3->value(lineatexto);
	break;
	
	case 4:
	strcpy(LineaTexto4[bloque - 1], lineatexto);
	//CuadroTextoLinea4->value(lineatexto);
	break;
	
}

if (debug_texto) {
	printf("lineatexto: %s\\n", lineatexto);
}} {}
} 

Function {Leer_Configuracion()} {C return_type int
} {
  code {// función para leer datos de configuración globales del sistema
char record[255], *dato;	/* array to hold each "record" */ 
FILE *fichero;                  /* pointer to input file */
int caracter, i;

/* open the file to read */
fichero = fopen("itaca.conf", "r");		

if (fichero == NULL) {
	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n");
	rt_printk("Error al abrir el fichero itaca.conf\\n");
	rt_printk("Restaurando la configuración original de fábrica\\n");
	system("cp /rootFLS/itaca/itaca.conf.ok itaca.conf");
	rt_printk("SALIENDO DE LA APLICACIÓN - vuelva a arrancar la aplicación para aplicar los cambios\\n");
	exit(0);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL DE LÁSER */
fgets(record, sizeof(record), fichero);

/* Lee el valor del periodo del tren de pulsos utilizado para excitar el láser */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
PeriodoTrenPulsos = atoi(dato);

if (debug_resto){
	printf("Dato %s PeriodoTrenPulsos %d\\n", dato, PeriodoTrenPulsos);
}

/* Lee el valor del retardo de Láser On */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoLaserOn = atoi(dato);

if (debug_resto){
	printf("Dato %s RetardoLaserOn %d\\n", dato, RetardoLaserOn);
}

/* Lee el valor del retardo de Láser Off */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoLaserOff = atoi(dato);

if (debug_resto){
	printf("Dato %s RetardoLaserOff %d\\n", dato, RetardoLaserOff);
}


//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL DE SALTO */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la velocidad de salto */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
VelocidadSalto = atoi(dato);

if (debug_resto){
	printf("Dato %s VelocidadSalto %d\\n", dato, VelocidadSalto);
}

/* Lee el valor del retardo de salto */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoSalto = atoi(dato);

if (debug_resto){
	printf("Dato %s RetardoSalto %d\\n", dato, RetardoSalto);
}


//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: RETARDOS POLÍGONO Y MARCAJE */
fgets(record, sizeof(record), fichero);

/* Lee el valor del Retardo de polígono */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoPoligono = atoi(dato);

if (debug_resto){
	printf("Dato %s RetardoPoligono %d\\n", dato, RetardoPoligono);
}

/* Lee el valor del Retardo de marcaje */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoMarcaje = atoi(dato);

if (debug_resto){
	printf("Dato %s RetardoMarcaje %d\\n", dato, RetardoMarcaje);
}


//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: FICHERO CORRECCIÓN */
fgets(record, sizeof(record), fichero);

/* Lee el valor del factor de calibración del fichero de corrección */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
CalibracionCorreccion = atof(dato);

if (debug_resto){
	printf("Dato %s CalibracionCorreccion %f\\n", dato, CalibracionCorreccion);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: ORIENTACIÓN Y AVANCE */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la Orientación */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Orientacion = atoi(dato);

if (debug_resto){
	printf("Dato %s Orientacion %d\\n", dato, Orientacion);
}

/* Lee el valor del Avance */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Avance = atoi(dato);

if (debug_resto){
	printf("Dato %s Avance %d\\n", dato, Avance);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: MARCAJE DINÁMICO */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la variable de estado que indica si el marcaje dinámico está o no activo */
// 0 indica no activado, 1 indica activado con velocidad variable (usa encoder) y 2 es activado con 
// CheckCentrado->activate();	velocidad constante
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
MarcajeDinamicoActivo = atoi(dato);

if (debug_resto){
	printf("Dato %s MarcajeDinamicoActivo %d\\n", dato, MarcajeDinamicoActivo);
}

/* Lee el valor de la calibración del encoder */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
CalibracionEncoder = atof(dato);

if (debug_resto){
	printf("Dato %s CalibracionEncoder %f\\n", dato, CalibracionEncoder);
}

/* Lee el valor de la velocidad de la lÂ´inea */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
VelocidadLinea = atof(dato);

if (debug_resto){
	printf("Dato %s VelocidadLinea %f\\n", dato, VelocidadLinea);
}


//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL GALVOS */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la tensión de alimentación del galvo que produce un desplazamiento máximo */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
VGalvoRef_MaximoBits = atof(dato);

VGalvoMax = VGalvoRef_MaximoBits * 1.001; // Para controlar el error de campo

if (debug_resto){
	printf("Dato %s VGalvoRef_MaximoBits %f\\n", dato, VGalvoRef_MaximoBits);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL EXTRACTOR */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la tensión de alimentación del galvo que produce un desplazamiento máximo */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ExtractorActivado = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (desactivado)
if ((ExtractorActivado != 0) && (ExtractorActivado != 1)) {ExtractorActivado = 0;}

if (debug_resto){
	printf("Dato %s ExtractorActivado %d\\n", dato, ExtractorActivado);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL DISPARO FOTOCÉLULA */
fgets(record, sizeof(record), fichero);

/* Lee el valor de disparo de la fotocélula */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ValorDisparo = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0
if ((ValorDisparo != 0) && (ValorDisparo != 1)) {ValorDisparo = 0;}

if (debug_resto){
	printf("Dato %s ValorDisparo %d\\n", dato, ValorDisparo);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: PERIODO */
fgets(record, sizeof(record), fichero);

/* Lee el valor del periodo en microsegundos */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
PERIODO_MICROSEGUNDOS = atoi(dato);

if (debug_resto){
	printf("Dato %s PERIODO_MICROSEGUNDOS %d\\n", dato, PERIODO_MICROSEGUNDOS);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Servicio Técnico */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la variable de servicio técnico */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ServicioTecnico = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (desactivado)
if ((ServicioTecnico != 0) && (ServicioTecnico != 1)) {ServicioTecnico = 0;}

if (debug_resto){
	printf("Dato %s ServicioTecnico %d\\n", dato, ServicioTecnico);
}

/* Lee la línea con un comentario: IDIOMA */
fgets(record, sizeof(record), fichero);

/* Lee el valor del idioma para el GUI */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Idioma = atoi(dato);

// por defecto en español
if ((Idioma < 0) || (Idioma > 2)) {Idioma = 0;}

if (debug_resto){
	printf("Dato %s Idioma %d\\n", dato, Idioma);
}

/* Lee la línea con un comentario: SPOT */
fgets(record, sizeof(record), fichero);

/* Lee el valor del tamaño del spot */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Spot = atoi(dato);

// si es 0 o un valor negativo se asigna a 250 micras por defecto
if (Spot <= 0) {Spot = 250;}

if (debug_resto){
	printf("Dato %s Spot %d\\n", dato, Spot);
}

/* Lee la línea con un comentario: ACTIVACION GALVOS */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para activar los galvos */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ValorActivacionGalvos = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0
if ((ValorActivacionGalvos != 0) && (ValorActivacionGalvos != 1)) {ValorActivacionGalvos = 0;}

if (debug_resto){
	printf("Dato %s ValorActivacionGalvos %d\\n", dato, ValorActivacionGalvos);
}

/* Lee la línea con un comentario: CONTROL PUERTO SERIE */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para saber si hay control por puerto serie */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
PuertoSerieActivo = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (desactivado)
if ((PuertoSerieActivo != 0) && (PuertoSerieActivo != 1)) {PuertoSerieActivo = 0;}

if (debug_resto){
	printf("Dato %s PuertoSerieActivo %d\\n", dato, PuertoSerieActivo);
}

/* Lee la línea con un comentario: CENTRADO */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para saber si la marca inicial está centrada */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Centrado = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (no centrado)
if ((Centrado != 0) && (Centrado != 1)) {Centrado = 0;}

if (debug_resto){
	printf("Dato %s Centrado %d\\n", dato, Centrado);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: TIPO DE DISPARO */
fgets(record, sizeof(record), fichero);

/* Lee el valor del tipo de disparo, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
TipoDisparo = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (externo) por defecto
if ((TipoDisparo != 0) && (TipoDisparo != 1)) {TipoDisparo = 0;}

if (debug_resto){
	printf("Dato %s TipoDisparo %d\\n", dato, TipoDisparo);
}  

/* Lee la línea con un comentario: RETARDO DE DISPARO */
fgets(record, sizeof(record), fichero);

/* Lee el valor del retardo tras el disparo de la fotocélula */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
RetardoDisparo_mm = atoi(dato);

// tiene que ser mayor que 0, si no se hace 0 por defecto
if (RetardoDisparo_mm < 0) {RetardoDisparo_mm = 0;}

if (debug_resto){
	printf("Dato %s RetardoDisparo_mm %d\\n", dato, RetardoDisparo_mm);
}  

/* Lee la línea con un comentario: LECTURAS CONSECUTIVAS */
fgets(record, sizeof(record), fichero);

/* Lee el valor del mínimo número de lecturas consecutivas del disparo de la fotocélula */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
MinimoLecturasConsecutivasDisparo = atoi(dato);

// tiene que ser mayor que 1, si no se hace 1 por defecto
if (MinimoLecturasConsecutivasDisparo < 1) {MinimoLecturasConsecutivasDisparo = 1;}

if (debug_resto){
	printf("Dato %s MinimoLecturasConsecutivasDisparo %d\\n", dato, MinimoLecturasConsecutivasDisparo);
}  

/* Lee la línea con un comentario: SEPARACIÓN ENTRE DISPAROS */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la Separacion Entre Disparos */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
SeparacionEntreDisparos_mm = atoi(dato);

// tiene que ser mayor que 1, si no se hace 1 por defecto
if (SeparacionEntreDisparos_mm < 1) {SeparacionEntreDisparos_mm = 1;}

if (debug_resto){
	printf("Dato %s SeparacionEntreDisparos_mm %d\\n", dato, SeparacionEntreDisparos_mm);
}    

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: REVERSO */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para saber si se imprime en el reverso (en espejo) */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Reverso = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0
if ((Reverso != 0)&&(Reverso != 1)) {Reverso = 0;}

if (debug_resto){
	printf("Dato %s Reverso %d\\n", dato, Reverso);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: ESTRATEGIA DE MARCAJE */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para saber que estrategia de marcaje se sigue */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Estrategia = atoi(dato);

// tiene que ser 0 (carácter), 1 (átomos) o 2 (átomos fuera de campo), si no se hace 0 (carácter)
if ((Estrategia != 0)&&(Estrategia != 1)&&(Estrategia != 2)&&(Estrategia!=3)) {Estrategia = 0;}

if (debug_resto){
	printf("Dato %s Estrategia %d\\n", dato, Estrategia);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: SISTEMA DE CONTROL */
fgets(record, sizeof(record), fichero);

/* Lee el valor que hay que escribir para saber que estrategia de marcaje se sigue */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
Control = atoi(dato);

// tiene que ser 0 (DAQ) o 1 (FPGA), si no se hace 0
if ((Control != 0)&&(Control != 1)) {Control = 0;}

if (debug_resto){
	printf("Dato %s Control %d\\n", dato, Estrategia);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL ERROR DE CAMPO */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la tensión de alimentación del galvo que produce un desplazamiento máximo */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ControlarErrorCampo = atoi(dato);

// tiene que ser 0 o 1, si no se hace 1 (activado)
if ((ControlarErrorCampo != 0) && (ControlarErrorCampo != 1)) {ControlarErrorCampo = 1;}

if (debug_resto){
	printf("Dato %s ControlarErrorCampo %d\\n", dato, ControlarErrorCampo);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: CONTROL ERROR DE GALVOS */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la tensión de alimentación del galvo que produce un desplazamiento máximo */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ControlarErrorGalvos = atoi(dato);

// tiene que ser 0 o 1, si no se hace 1 (activado)
if ((ControlarErrorGalvos != 0) && (ControlarErrorGalvos != 1)) {ControlarErrorGalvos = 1;}

if (debug_resto){
	printf("Dato %s ControlarErrorGalvos %d\\n", dato, ControlarErrorGalvos);
}

//////////////////////////////////////////////////////////////////////////////
// Lee la línea con un comentario: TURNOS
if (fgets(record, sizeof(record), fichero) != NULL) { // puede no existir, si es una actualización de una versión SW anterior

	// Lee los valores de los turnos separados por tabuladores
	for (i=0; i<NumeroTurnos; i++) {
		
		//printf("i=%d\\n", i);

		// Lee el valor de la tensión de alimentación del galvo que produce un desplazamiento máximo
		fgets(record, sizeof(record), fichero);
		dato = strtok(record, "\\t"); HoraInicioTurno[i] = atoi(dato);
		//printf("HoraInicioTurno[%d]:%d\\n", i, HoraInicioTurno[i]);
		dato = strtok(NULL, "\\t"); MinutoInicioTurno[i] = atoi(dato);
		//printf("MinutoInicioTurno[%d]:%d\\n", i, MinutoInicioTurno[i]);		
		dato = strtok(NULL, "\\t"); HoraFinTurno[i] = atoi(dato);
		//printf("HoraFinTurno[%d]:%d\\n", i, HoraFinTurno[i]);		
		dato = strtok(NULL, "\\t"); MinutoFinTurno[i] = atoi(dato);
		//printf("MinutoFinTurno[%d]:%d\\n", i, MinutoFinTurno[i]);		
		dato = strtok(NULL, "\\t\\n"); 
		//printf("TextoTurno[%d]:%s\\n", i, dato);		
		
		if (dato!=NULL) {
			//printf("dato:%s\\n", dato);
			strcpy(TextoTurno[i], dato);
		}
		else {
			strcpy (TextoTurno[i], "");
		}
		
		// Calculamos el minuto del día donde empieza y termina cada turno
		MinutoDiaInicioTurno[i] = (HoraInicioTurno[i]*60) + MinutoInicioTurno[i];
		MinutoDiaFinTurno[i] = (HoraFinTurno[i]*60) + MinutoFinTurno[i];
		
		if (debug_resto){
			printf("Turno %d - %d\\t%d\\t%d\\t%d\\%s\\n", i, HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
		}

	}

}

else {

	// Lee los valores de los turnos separados por tabuladores
	for (i=0; i<NumeroTurnos; i++) {

		HoraInicioTurno[i] = 0;
		MinutoInicioTurno[i] = 0;
		HoraFinTurno[i] = 0;
		MinutoFinTurno[i] = 0;
		strcpy (TextoTurno[i], "");
		
		// Calculamos el minuto del día donde empieza y termina cada turno
		MinutoDiaInicioTurno[i] = (HoraInicioTurno[i]*60) + MinutoInicioTurno[i];
		MinutoDiaFinTurno[i] = (HoraFinTurno[i]*60) + MinutoFinTurno[i];
		
		if (debug_resto){
			printf("Turno %d - %d\\t%d\\t%d\\t%d\\%s\\n", i, HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
		}	
	
	}
	
}

/* Lee la línea con un comentario: TIPO DE LASER */
fgets(record, sizeof(record), fichero);

/* Lee el valor de Tipo de Laser */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
TipoLaser = atoi(dato);

// tiene que ser 0 o , si no se hace 1 (CO2)
if ((TipoLaser != 0) && (TipoLaser != 1)) {TipoLaser = 0;}

if (debug_resto){
	printf("Dato %s TipoLaser %d\\n", dato, TipoLaser);
}

/* Lee la línea con un comentario: FICHERO CORRECCION ACTIVO */
fgets(record, sizeof(record), fichero);

/* Lee el valor de activacion del fichero de correccion */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
FicheroCorreccionActivo = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (desactivado)
if ((FicheroCorreccionActivo != 0) && (FicheroCorreccionActivo != 1)) {FicheroCorreccionActivo = 0;}

if (debug_resto){
	printf("Dato %s FicheroCorreccionActivo %d\\n", dato, FicheroCorreccionActivo);
}



/* cierra el archivo */
fclose(fichero);	

////////////////////////////////////////////////////////////////////////////////
// Abre ahora el fichero de la funcionalidad, que es binario
////////////////////////////////////////////////////////////////////////////////

fichero = fopen("funcionalidad.bin", "rb");		

if (fichero == NULL) {
	
	// Si el fichero no existe la funcionalidad es sólo texto
	Funcionalidad = SOLOTEXTO;
}

else {

	// Lee en binario el primer carácter
	caracter = fgetc(fichero);
	
	// Si es un 1 la funcionalidad es completa, si es un 2 hay bloques de datos en cada lÃ­nea de texto; en cualquier otro caso es sólo texto
	if (caracter == 1) {	
		Funcionalidad = COMPLETA;
	}

	else if (caracter == 2) {	
		Funcionalidad = BLOQUES;
	}

	else {
		Funcionalidad = SOLOTEXTO;
	}
	
	// cierra el archivo
	fclose(fichero);
	
	// si la funcionalidad no es de bloques se hace que el número de bloque por línea sea 1
	// de esta forma aunque haya datos definidos en itaca.dat para el resto de los bloques
	// no se leerán ni se usarán; pero si la funcionalidad vuelve a ser de bloques ahí estarán
	// los datos de nuevo
	
	if (Funcionalidad != BLOQUES) {
		NumeroBloques = 1;
	}
	
	else {
		NumeroBloques = 3;
	}

}

////////////////////////////////////////////////////////////////////////////////
// Abre ahora el fichero de control de acceso, que es binario
////////////////////////////////////////////////////////////////////////////////

fichero = fopen("acceso.bin", "rb");		

if (fichero == NULL) {
	
	// Si el fichero no existe el control está activado
	ControlAcceso = ON;
}

else {

	// Lee en binario el primer carácter
	caracter = fgetc(fichero);
	
	// Si es un 1 el control de acceso está desactivado, en cualquier otro caso está activado
	if (caracter == 1) {	
		ControlAcceso = OFF;
	}
	else {
		ControlAcceso = ON;
	}
	
	// cierra el archivo
	fclose(fichero);

}

////////////////////////////////////////////////////////////////////////////////
// Abre ahora el fichero de contraseña de usuario
////////////////////////////////////////////////////////////////////////////////

fichero = fopen("usuario.bin", "rb");		

if (fichero == NULL) {
	
	// Si el fichero no existe se usa la contraseña por defecto
	strcpy(PasswordUsuario, PASSWORD);
}

else {

	// Lee en la contraseña
	fgets(PasswordUsuario, sizeof(PasswordUsuario), fichero);
	
	// cierra el archivo
	fclose(fichero);

}

////////////////////////////////////////////////////////////////////////////////
// Abre ahora el fichero de control tablas y precorte, que es binario
////////////////////////////////////////////////////////////////////////////////

fichero = fopen("tablaprecorte.bin", "rb");		

if (fichero == NULL) {
	
	// Si el fichero no existe el control está desactivado
	ControlTablaPrecorte = OFF;
}

else {

	// Lee en binario el primer carácter
	caracter = fgetc(fichero);
	
	// Si es un 1 el control de tablas y precorte está activado, en cualquier otro caso está desactivado
	if (caracter == 1) {	
		ControlTablaPrecorte = ON;
	}
	else {
		ControlTablaPrecorte = OFF;
	}
	
	// cierra el archivo
	fclose(fichero);

}

return 0;} {}
} 

Function {Escribir_Configuracion()} {C return_type int
} {
  code {// función para escribir los datos de configuración del sistema

char record[256];		/* array to hold each "record" */ 
FILE *fichero;                  /* pointer to file */
int i;

/* open the file to write */
fichero = fopen("itaca.conf", "w");			

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL DE LÁSER\\n", fichero);

/* Escribe el valor del Periodo tren de pulsos */
sprintf(record, "%d		Periodo tren de pulsos	(1 - 100.000 microsegundos)\\n", PeriodoTrenPulsos);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor del Retardo Laser On */
sprintf(record, "%d		Retardo Laser On .	(0 - 100.000 microsegundos)\\n", RetardoLaserOn);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

/* Escribe el valor del Retardo Laser Off */
sprintf(record, "%d		Retardo Laser Off 	(0 - 100.000 microsegundos)\\n", RetardoLaserOff);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL DE SALTO\\n", fichero);

/* Escribe el valor de la Velocidad de salto */
sprintf(record, "%d		Velocidad de salto	(100 - 50.000 mm/s)\\n", VelocidadSalto);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor del Retardo Salto */
sprintf(record, "%d		Retardo Salto 		(0 - 100.000 microsegundos)\\n", RetardoSalto);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	RETARDOS POLÍGONO Y MARCAJE\\n", fichero);

/* Escribe el valor del Retardo de Polígono */
sprintf(record, "%d		Retardo Polígono 	(0 - 100.000 microsegundos)\\n", RetardoPoligono);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor del Retardo de Marcaje */
sprintf(record, "%d		Retardo Marcaje 	(0 - 100.000 microsegundos)\\n", RetardoMarcaje);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	FICHERO CORRECCIÓN\\n", fichero);

/* Escribe el valor de la calibración de la corrección */
sprintf(record, "%0.1f		Calibración corrección	(bits/mm)\\n", CalibracionCorreccion);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	ORIENTACIÓN Y AVANCE\\n", fichero);

/* Escribe el valor de la Orientacion */
sprintf(record, "%d		Orientación		0, 90, 180 o 270º\\n", Orientacion);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor del Avance */
sprintf(record, "%d		Avance			0, 90, 180 o 270º\\n", Avance);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	MARCAJE DINÁMICO\\n", fichero);

/* Escribe el valor del Marcaje Dinamico Activo */
sprintf(record, "%d		Activado		(0: desactivado 1:activado 2:velocidad constante)\\n", MarcajeDinamicoActivo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor de la Calibracion del Encoder */
sprintf(record, "%0.1f		Calibración encoder	(cuentas por milímetro)\\n", CalibracionEncoder);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

/* Escribe el valor de la Velocidad de Linea */
sprintf(record, "%0.1f		Velocidad línea		(metros/min)\\n", VelocidadLinea);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}
	
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL GALVOS\\n", fichero);

/* Escribe el valor de la tensión VGalvoRef_MaximoBits */
sprintf(record, "%0.1f		VGalvoRef_MaximoBits 	(V) Tensión en galvo para desplazarse al extremo del campo\\n", VGalvoRef_MaximoBits);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  	
	
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL EXTRACTOR\\n", fichero);

/* Escribe el valor del Extractor */
sprintf(record, "%d		Extractor Activado	(0: desactivado - 1: activado) Controla la activación del extractor\\n", ExtractorActivado);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL DISPARO FOTOCÉLULA\\n", fichero);

/* Escribe el valor del Valor de Disparo de la fotocéclula */
sprintf(record, "%d		Valor Disparo		(0 - 1) Controla qué valor digital de la fotocélula dispara la marca\\n", ValorDisparo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	PERIODO\\n", fichero);

/* Escribe el valor del PERIODO_MICROSEGUNDOS */
sprintf(record, "%d		Periodo Microsegundos	(10 - 1000) Periodo RT en microsegundos\\n", PERIODO_MICROSEGUNDOS);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	SERVICIO TÉCNICO\\n", fichero);

/* Escribe el valor del ServicioTecnico */
sprintf(record, "%d		ServicioTecnico		(0 - 1) Controla la activación del modo de servicio técnico\\n", ServicioTecnico);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	IDIOMA\\n", fichero);

/* Escribe el valor del Idioma */
sprintf(record, "%d		Idioma			Idioma del GUI: 0-español, 1-inglés, 2-italiano\\n", Idioma);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	SPOT\\n", fichero);

/* Escribe el valor del Spot */
sprintf(record, "%d		Spot			Tamaño del spot en micras (se usa en los códigos de barras)\\n", Spot);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	ACTIVACIÓN GALVOS\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		ValorActivacionGalvos	Valor digital (0/1) que hay que escribir para activar los galvos\\n", ValorActivacionGalvos);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL PUERTO SERIE\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		PuertoSerieActivo	(0 - 1) Activa o no el control por el puerto serie\\n", PuertoSerieActivo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CENTRADO\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Centrado		(0 - 1) Activa o no el centrado automáticamente en el inicio\\n", Centrado);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: TIPO DE DISPARO */
fputs("\#	TIPO DE DISPARO\\n", fichero);

/* Escribe el valor del tipo de disparo */
sprintf(record, "%d		TipoDisparo		(0 - 1) Disparo externo o interno\\n", TipoDisparo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: RETARDO DE DISPARO */
fputs("\#	RETARDO DE DISPARO\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Retardo Disparo 	(0 - 1000 milímetros) Retardo en milímetros tras el disparo de la fotocélula\\n", RetardoDisparo_mm);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  
 	
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: MÍNIMO DE LECTURAS CONSECUTIVAS */
fputs("\#	MÍNIMO DE LECTURAS CONSECUTIVAS\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		MinimoLecturasConsecutivas	(1 - 1000) Número mínimo de lecturas consecutivas de disparo de fotocélula\\n", MinimoLecturasConsecutivasDisparo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: SEPARACIÓN ENTRE DISPAROS */
fputs("\#	SEPARACIÓN ENTRE DISPAROS\\n", fichero);

/* Escribe el valor de la separación entre disparos */
sprintf(record, "%d		SeparacionEntreDisparos	(0 - 10000 mm) Separación entre disparos internos\\n", SeparacionEntreDisparos_mm);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	REVERSO\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Reverso			(0 - 1) Activa o no la impresión en el reverso del material (impresión en espejo)\\n", Reverso);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	ESTRATEGIA DE MARCAJE\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Estrategia de marcaje	0-carácter, 1-átomos, 2-átomos fuera de campo\\n", Estrategia);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	SISTEMA DE CONTROL\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Sistema de control	0-DAQ, 1-FPGA\\n", Control);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL ERROR DE CAMPO\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		ControlarErrorCampo\\n", ControlarErrorCampo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	CONTROL ERROR DE GALVOS\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		ControlarErrorGalvos\\n", ControlarErrorGalvos);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	TURNOS\\n", fichero);

// Escribe los valores de los turnos separados por tabuladores
for (i=0; i<NumeroTurnos; i++) {

	sprintf(record, "%d\\t%d\\t%d\\t%d\\t%s\\n", HoraInicioTurno[i], MinutoInicioTurno[i], HoraFinTurno[i], MinutoFinTurno[i], TextoTurno[i]);
	fputs(record, fichero);
	
	if (debug_resto){
		printf("Escribiendo: %s", record);
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	TIPO DE LASER\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Tipo de Laser	0-CO2, 1-Fibra,\\n", TipoLaser);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: */
fputs("\#	FICHERO CORRECCION ACTIVO\\n", fichero);

/* Escribe el valor */
sprintf(record, "%d		Fichero Correccion Activo	0-No Activo, 1-Activo\\n", FicheroCorreccionActivo);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 
 	 
//////////////////////////////////////////////////////////////////////////////
/* cierra el archivo */
fclose(fichero);	

return 0;} {}
} 

Function {Leer_DAT(char ArchivoDat[50])} {C return_type int
} {
  code {// función para leer los datos cargados en el sistema

char record[256], *dato;		/* array to hold each "record" */ 
FILE *fichero;                          /* pointer to input file */
int i, j;


/* open the file to read */
//fichero = fopen("itaca.dat", "r");
fichero = fopen(ArchivoDat, "r");		

if (fichero == NULL) {
	rt_printk("Error al abrir el fichero %s para lectura\\n", ArchivoDat);
	//rt_printk("Restaurando la configuración original de fábrica\\n");
	//system("cp /rootFLS/itaca/itaca.dat.ok itaca.dat");
	//rt_printk("SALIENDO DE LA APLICACIÓN - vuelva a arrancar la aplicación para aplicar los cambios\\n");
	//exit(0);
	return 1;
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: GUI */
fgets(record, sizeof(record), fichero);

/* Lee el valor de la Potencia Laser inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
PotenciaLaser = atoi(dato);

if (debug_resto){
	printf("Dato %s PotenciaLaser %d\\n", dato, PotenciaLaser);
}  

/* Lee el valor de la Velocidad de Marcaje inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
VelocidadMarcaje = atoi(dato);

if (debug_resto){
	printf("Dato %s VelocidadMarcaje %d\\n", dato, VelocidadMarcaje);
}  
  
/* Lee el valor del offset vertical inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
Vertical = atoi(dato);

yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits

if (debug_resto){
	printf("Dato %s Vertical %d\\n", dato, Vertical);
}    
  
/* Lee el valor del offset horizontal inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
Horizontal = atoi(dato);

xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion);	// en bits

if (debug_resto){
	printf("Dato %s Horizontal %d\\n", dato, Horizontal);
}      

/* Lee el valor de la fuente seleccionada, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
ValorFuente = atoi(dato);

if (debug_resto){
	printf("Dato %s ValorFuente %d\\n", dato, ValorFuente);
}  

/* Lee el valor de la justificación izquierda inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
JustificacionIzquierda = atoi(dato);

if (debug_resto){
	printf("Dato %s JustificacionIzquierda %d\\n", dato, JustificacionIzquierda);
}     
  
/* Lee el valor de la justificación centro inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
JustificacionCentro = atoi(dato);

if (debug_resto){
	printf("Dato %s JustificacionCentro %d\\n", dato, JustificacionCentro);
}    

/* Lee el valor de la justificación derecha inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
JustificacionDerecha = atoi(dato);

if (debug_resto){
	printf("Dato %s JustificacionDerecha %d\\n", dato, JustificacionDerecha);
}      
  
/* Lee el valor de la anchura inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
Anchura = atoi(dato);

if (debug_resto){
	printf("Dato %s Anchura %d\\n", dato, Anchura);
}     

/* Lee el valor del espaciado inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
Espaciado = atoi(dato);

if (debug_resto){
	printf("Dato %s Espaciado %d\\n", dato, Espaciado);
}    

/* Lee el valor de la separación entre líneas inicial, para cargar en el GUI */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
SeparacionLineas = atof(dato);

if (debug_resto){
	printf("Dato %s SeparacionLineas %f\\n", dato, SeparacionLineas);
}   

  
//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Línea 1 */
fgets(record, sizeof(record), fichero);

for (j=0; j<NumeroBloquesLinea; j++) {

	/* Lee el texto de la línea 1 */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

	// Copia el texto a la variable
	if (dato) {
		strcpy(LineaTexto1[j], dato);
	}
	else {	
		strcpy(LineaTexto1[j], "");
	}

	if (debug_resto){
		printf("LineaTexto1[%d]: %s\\n", j, LineaTexto1[j]);
	}

	/* Lee el valor de la altura de la línea */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
	AlturaLineaTexto1[j] = atof(dato);

	if (debug_resto){
		printf("Dato %s AlturaLineaTexto1[%d] %2.1f\\n", dato, j, AlturaLineaTexto1[j]);
	}
	
}	     

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Línea 2 */
fgets(record, sizeof(record), fichero);

for (j=0; j<NumeroBloquesLinea; j++) {

	/* Lee el texto de la línea 2 */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

	// Copia el texto a la variable
	if (dato) {
		strcpy(LineaTexto2[j], dato);
	}
	else {	
		strcpy(LineaTexto2[j], "");
	}

	if (debug_resto){
		printf("LineaTexto2[%d]: %s\\n", j, LineaTexto2[j]);
	}

	/* Lee el valor de la altura de la línea */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
	AlturaLineaTexto2[j] = atof(dato);

	if (debug_resto){
		printf("Dato %s AlturaLineaTexto2[%d] %2.1f\\n", dato, j, AlturaLineaTexto2[j]);
	}

}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Línea 3 */
fgets(record, sizeof(record), fichero);

for (j=0; j<NumeroBloquesLinea; j++) {

	/* Lee el texto de la línea 3 */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

	// Copia el texto a la variable
	if (dato) {
		strcpy(LineaTexto3[j], dato);
	}
	else {	
		strcpy(LineaTexto3[j], "");
	}

	if (debug_resto){
		printf("LineaTexto3[%d]: %s\\n", j, LineaTexto3[j]);
	}

	/* Lee el valor de la altura de la línea */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
	AlturaLineaTexto3[j] = atof(dato);

	if (debug_resto){
		printf("Dato %s AlturaLineaTexto3[%d] %2.1f\\n", dato, j, AlturaLineaTexto3[j]);
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Línea 4 */
fgets(record, sizeof(record), fichero);

for (j=0; j<NumeroBloquesLinea; j++) {

	/* Lee el texto de la línea 4 */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

	// Copia el texto a la variable
	if (dato) {
		strcpy(LineaTexto4[j], dato);
	}
	else {	
		strcpy(LineaTexto4[j], "");
	}

	if (debug_resto){
		printf("LineaTexto4[%d]: %s\\n", j, LineaTexto4[j]);
	}

	/* Lee el valor de la altura de la línea */
	fgets(record, sizeof(record), fichero);	/* Lee una línea */
	dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
	AlturaLineaTexto4[j] = atof(dato);

	if (debug_resto){
		printf("Dato %s AlturaLineaTexto4[%d] %2.1f\\n", dato, j, AlturaLineaTexto4[j]);
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Campos variables: Fecha  */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Lee el valor del status de fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		StatusFecha[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s StatusFecha[%d][%d] %d\\n", dato, i, j, StatusFecha[i][j]);
		}  

		/* Lee el orden de la fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		OrdenFecha[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s OrdenFecha[%d][%d] %d\\n", dato, i, j, OrdenFecha[i][j]);
		}  

		/* Lee el formato completo de la fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(FormatoCompletoFecha[i][j], dato);
		}	
		else {		
			strcpy(FormatoCompletoFecha[i][j], "");
		}

		if (debug_resto){
			printf("FormatoCompletoFecha[%d][%d]: %s\\n", i, j, FormatoCompletoFecha[i][j]);
		}

		/* Lee el texto anterior a la fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoanteriorfecha[i][j], dato);
		}	
		else {		
			strcpy(textoanteriorfecha[i][j], "");
		}

		if (debug_resto){
			printf("textoanteriorfecha[%d][%d]: %s\\n", i, j, textoanteriorfecha[i][j]);
		}

		/* Lee el texto posterior a la fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoposteriorfecha[i][j], dato);
		}
		else {	
			strcpy(textoposteriorfecha[i][j], "");
		}

		if (debug_resto){
			printf("textoposteriorfecha[%d][%d]: %s\\n", i, j, textoposteriorfecha[i][j]);
		}

		/* Lee el valor del formato de fecha 1 */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoFecha1[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoFecha1[%d][%d] %d\\n", dato, i, j, ValorFormatoFecha1[i][j]);
		}
	
		/* Lee el valor del formato de fecha 2 */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoFecha2[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoFecha2[%d][%d] %d\\n", dato, i, j, ValorFormatoFecha2[i][j]);
		}
	
		/* Lee el valor del formato de fecha 3 */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoFecha3[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoFecha3[%d][%d] %d\\n", dato, i, j, ValorFormatoFecha3[i][j]);
		}
	
		/* Lee el valor del separador de fecha */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorSeparadorFecha[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorSeparadorFecha[%d][%d] %d\\n", dato, i, j, ValorSeparadorFecha[i][j]);
		}

		/* Lee el valor de la caducidad, para cargar en el GUI */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		Caducidad[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s Caducidad[%d][%d] %d\\n", dato, i, j, Caducidad[i][j]);
		}  

	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Campos variables: Hora  */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
		/* Lee el valor del status de la hora */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		StatusHora[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s StatusHora[%d][%d] %d\\n", dato, i, j, StatusHora[i][j]);
		}  

		/* Lee el orden de la hora */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		OrdenHora[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s OrdenHora[%d][%d] %d\\n", dato, i, j, OrdenHora[i][j]);
		}    

		/* Lee el formato completo de la hora */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(FormatoCompletoHora[i][j], dato);
		}	
		else {		
			strcpy(FormatoCompletoHora[i][j], "");
		}

		if (debug_resto){
			printf("FormatoCompletoHora[%d][%d]: %s\\n", i, j, FormatoCompletoHora[i][j]);
		}
	
		/* Lee el texto anterior a la hora */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoanteriorhora[i][j], dato);
		}
		else {	
			strcpy(textoanteriorhora[i][j], "");
		}

		if (debug_resto){
			printf("textoanteriorhora[%d][%d]: %s\\n", i, j, textoanteriorhora[i][j]);
		}

		/* Lee el texto posterior a la hora */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoposteriorhora[i][j], dato);
		}
		else {	
			strcpy(textoposteriorhora[i][j], "");
		}

		if (debug_resto){
			printf("textoposteriorhora[%d][%d]: %s\\n", i, j, textoposteriorhora[i][j]);
		}
	
		/* Lee el valor del formato de hora 1, para cargar en el GUI */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoHora1[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoHora1[%d][%d] %d\\n", dato, i, j, ValorFormatoHora1[i][j]);
		}  
	
		/* Lee el valor del formato de hora 2, para cargar en el GUI */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoHora2[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoHora2[%d][%d] %d\\n", dato, i, j, ValorFormatoHora2[i][j]);
		}  
	
		/* Lee el valor del formato de hora 3, para cargar en el GUI */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorFormatoHora3[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorFormatoHora3[%d][%d] %d\\n", dato, i, j, ValorFormatoHora3[i][j]);
		}  
	
		/* Lee el valor del separador de hora, para cargar en el GUI */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorSeparadorHora[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorSeparadorHora[%d][%d] %d\\n", dato, i, j, ValorSeparadorHora[i][j]);
		}  

	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: Campos variables: Serie  */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
 		/* Lee el valor del status de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		StatusNumeroSerie[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s StatusNumeroSerie[%d][%d] %d\\n", dato, i, j, StatusNumeroSerie[i][j]);
		}
	
		/* Lee el orden del número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		OrdenNumeroSerie[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s OrdenNumeroSerie[%d][%d] %d\\n", dato, i, j, OrdenNumeroSerie[i][j]);
		} 
	
		/* Lee el string del número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(strNumeroSerie[i][j], dato);
		}
		else {	
			strcpy(strNumeroSerie[i][j], "");
		}

		if (debug_resto){
			printf("strNumeroSerie[%d][%d]: %s\\n", i, j, strNumeroSerie[i][j]);
		}
	
		/* Lee el texto anterior al número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoanteriorserie[i][j], dato);
		}
		else {	
			strcpy(textoanteriorserie[i][j], "");
		}

		if (debug_resto){
			printf("textoanteriorserie[%d][%d]: %s\\n", i, j, textoanteriorserie[i][j]);
		}

		/* Lee el texto posterior al número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(textoposteriorserie[i][j], dato);
		}
		else {	
			strcpy(textoposteriorserie[i][j], "");
		}

		if (debug_resto){
			printf("textoposteriorserie[%d][%d]: %s\\n", i, j, textoposteriorserie[i][j]);
		}	
	
		/* Lee el valor del número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroSerie[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s NumeroSerie[%d][%d] %ld\\n", dato, i, j, NumeroSerie[i][j]);
		}  

		/* Lee el valor del número dígitos del número de serie */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroDigitosNumeroSerie[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s NumeroDigitosNumeroSerie[%d][%d] %d\\n", dato, i, j, NumeroDigitosNumeroSerie[i][j]);
		}  	

		/* Lee el valor del número de serie inicial */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroSerieInicial[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s NumeroSerieInicial[%d][%d] %ld\\n", dato, i, j, NumeroSerieInicial[i][j]);
		}  

		/* Lee el valor del número de serie final */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroSerieFinal[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s NumeroSerieFinal[%d][%d] %ld\\n", dato, i, j, NumeroSerieFinal[i][j]);
		}  

		/* Lee el valor del número de unidades por lote */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroUnidadesLote[i][j] = atoi(dato);
	
		// debe ser 1 como mínimo
		if (NumeroUnidadesLote[i][j] == 0) {
			NumeroUnidadesLote[i][j] = 1;
		}

		if (debug_resto){
			printf("Dato %s NumeroUnidadesLote[%d][%d] %ld\\n", dato, i, j, NumeroUnidadesLote[i][j]);
		}  

		/* Lee el valor del número actual en el lote */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		NumeroUnidadesLoteActual[i][j] = atoi(dato);

		// debe ser 1 como mínimo
		if (NumeroUnidadesLoteActual[i][j] == 0) {
			NumeroUnidadesLoteActual[i][j] = 1;
		}
	
		if (debug_resto){
			printf("Dato %s NumeroUnidadesLoteActual[%d][%d] %ld\\n", dato, i, j, NumeroUnidadesLoteActual[i][j]);
		} 

	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: \#	Campos variables: textos */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Lee lineaanterior */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(lineaanterior[i][j], dato);
		}
		else {
			strcpy(lineaanterior[i][j], "");
		}

		if (debug_resto){
			printf("lineaanterior[%d][%d]: %s\\n", i, j, lineaanterior[i][j]);
		}

		/* Lee lineamedio */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(lineamedio[i][j], dato);
		}
		else {	
			strcpy(lineamedio[i][j], "");
		}

		if (debug_resto){
			printf("lineamedio[%d][%d]: %s\\n", i, j, lineamedio[i][j]);
		}

		/* Lee lineamedio2 */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(lineamedio2[i][j], dato);
		}
		else {	
			strcpy(lineamedio2[i][j], "");
		}

		if (debug_resto){
			printf("lineamedio2[%d][%d]: %s\\n", i, j, lineamedio2[i][j]);
		}

		/* Lee lineafinal */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(lineafinal[i][j], dato);
		}
		else {	
			strcpy(lineafinal[i][j], "");
		}

		if (debug_resto){
			printf("lineafinal[%d][%d]: %s\\n", i, j, lineafinal[i][j]);
		}
	
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: \#	Barcode */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {
        
        for (j=0; j<NumeroBloquesLinea; j++) {
        
		/* Lee el valor de ValorTipoLinea */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		ValorTipoLinea[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s ValorTipoLinea[%d][%d] %d\\n", dato, i, j, ValorTipoLinea[i][j]);
		}
	
		/* Lee el valor de InvertirBarcode */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		InvertirBarcode[i][j] = atoi(dato);

		if (debug_resto){
			printf("Dato %s InvertirBarcode[%d][%d] %d\\n", dato, i, j, InvertirBarcode[i][j]);
		}
	
		/* Lee el valor de EscalaBarcode */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		EscalaBarcode[i][j] = atoi(dato);
	
		if (EscalaBarcode[i][j] == 0) {EscalaBarcode[i][j]=100;}
	
		if (debug_resto){
			printf("Dato %s EscalaBarcode[%d][%d] %d\\n", dato, i, j, EscalaBarcode[i][j]);
		}   
	
		/* Lee el valor de SeparacionBarrasBarcode */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
		SeparacionBarrasBarcode[i][j] = atoi(dato);
	
		if (SeparacionBarrasBarcode[i][j] == 0) {SeparacionBarrasBarcode[i][j]=100;}

		if (debug_resto){
			printf("Dato %s SeparacionBarrasBarcode[%d][%d] %d\\n", dato, i, j, SeparacionBarrasBarcode[i][j]);
		}
	
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: \#	Gráficos */
fgets(record, sizeof(record), fichero);

for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Lee el nombre del archivo plt */
		fgets(record, sizeof(record), fichero);	/* Lee una línea */
		dato = strtok(record, "\\n");		/* lee hasta el fin de línea */

		// Copia el texto a la variable
		if (dato) {
			strcpy(NombreArchivoPlt[i][j], dato);
		}
		else {	
			strcpy(NombreArchivoPlt[i][j], "");
		}

		if (debug_resto){
			printf("NombreArchivoPlt[%d][%d]: %s\\n", i, j, NombreArchivoPlt[i][j]);
		}
      
	}
	
}


//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: \#	Repeticiones */
fgets(record, sizeof(record), fichero);
        
/* Lee el valor del Número de Filas */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
NumeroFilas = atoi(dato);

if (debug_resto){
	printf("Dato %s NumeroFilas %d\\n", dato, NumeroFilas);
}  

/* Lee el valor de la separación entre filas */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
SeparacionFilas = atof(dato);
ySeparacionFilas = (int)(SeparacionFilas * CalibracionCorreccion);	// en bits

if (debug_resto){
	printf("Dato %s SeparacionFilas %f\\n", dato, SeparacionFilas);
}   
        
/* Lee el valor del Número de Columnas */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
NumeroColumnas = atoi(dato);

/* Lee el valor de la separación entre columnas */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
SeparacionColumnas = atof(dato);
xSeparacionColumnas = (int)(SeparacionColumnas * CalibracionCorreccion);	// en bits

if (debug_resto){
	printf("Dato %s SeparacionColumnas %f\\n", dato, SeparacionColumnas);
}   

if (debug_resto){
	printf("Dato %s NumeroColumnas %d\\n", dato, NumeroColumnas);
}  

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: \#	Precorte */
fgets(record, sizeof(record), fichero);
        
/* Lee el valor del Precorte */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
Precorte = atoi(dato);

if (debug_resto){
	printf("Dato %s Precorte %d\\n", dato, Precorte);
}  

/* Lee el valor de la longitud del Precorte (%) */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
LongitudPrecorte = atoi(dato);

if (debug_resto){
	printf("Dato %s LongitudPrecorte %d\\n", dato, LongitudPrecorte);
}  

/* Lee el valor de la separación del Precorte */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
SeparacionPrecorte = atof(dato);
SeparacionPrecorteBits = (int)(SeparacionPrecorte * CalibracionCorreccion);	// en bits

if (debug_resto){
	printf("Dato %s SeparacionPrecorte %f\\n", dato, SeparacionPrecorte);
}   

/* Lee el valor de la velocidad del Precorte */
fgets(record, sizeof(record), fichero);	/* Lee una línea */
dato = strtok(record, "\\t"); 		/* lee hasta el primer tabulador */
VelocidadPrecorte = atoi(dato);

if (debug_resto){
	printf("Dato %s VelocidadPrecorte %d\\n", dato, VelocidadPrecorte);
}   

/* Lee la línea con un comentario: RESET SERIE POR CAMBIO DE FECHA */
fgets(record, sizeof(record), fichero);

/* Lee el valor de ResetSerieFecha */
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t");
ResetSerieFecha = atoi(dato);

// tiene que ser 0 o 1, si no se hace 0 (Desactivado)
if ((ResetSerieFecha != 0) && (ResetSerieFecha != 1)) {ResetSerieFecha = 0;}

if (debug_resto){
	printf("Dato %s ResetSerieFecha %d\\n", dato, ResetSerieFecha);
}

//////////////////////////////////////////////////////////////////////////////
/* Lee la línea con un comentario: VALORES X Y DEL TIPO DE LINEA */
fgets(record, sizeof(record), fichero);


for (i=0; i<NumeroLineasTexto; i++) {
	for (j=0; j<NumeroBloquesLinea;j++){
		/* Lee el valortipolinea*/ 
		fgets(record, sizeof(record),fichero);	
		dato = strtok(record, "\\t");
		ValorTipoLinea[i][j] =atoi(dato);
		//rt_printk("Valor Tipo Linea = %d \\n",ValorTipoLinea[i][j]);

		
		if (ValorTipoLinea[i][j] == TEXTO) {
			/* Lee el valor XMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinXTexto[i][j] =atof(dato);
			//rt_printk("MinXTexto = %f \\n",MinXTexto[i][j]);

			/* Lee el valor YMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinYTexto[i][j] =atof(dato);
		}
		else if (ValorTipoLinea[i][j] == GRAFICO) {
			/* Lee el valor XMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinXGrafico[i][j] =atof(dato);
			/* Lee el valor YMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinYGrafico[i][j] =atof(dato);
		}
		else if (ValorTipoLinea[i][j] == TEXTOCIRCULAR) {
			/* Lee el valor CentroX*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			CentroXTextoCircular[i][j] =atof(dato);
			/* Lee el valor CentroY*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			CentroYTextoCircular[i][j] =atof(dato);
			/* Lee el angulo*/
			fgets(record, sizeof(record),fichero);
			dato = strtok(record, "\\t");
			AnguloTextoCircular[i][j]=atof(dato);
			/* Lee el radio*/
			fgets(record, sizeof(record),fichero);
			dato = strtok(record, "\\t");
			RadioTextoCircular[i][j]=atof(dato);			
		}
		else {
			/* Lee el valor XMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinXBarcode[i][j] =atof(dato);
			/* Lee el valor YMin*/ 
			fgets(record, sizeof(record),fichero);	
			dato = strtok(record, "\\t");
			MinYBarcode[i][j] =atof(dato);
		}

				
	}
}
        
//////////////////////////////////////////////////////////////////////////////
/* cierra el archivo */
fclose(fichero);	

return 0;} {}
} 

Function {Escribir_DAT(char ArchivoDat[50])} {C return_type int
} {
  code {// función para escribir los datos de configuración de la marca reflejados en el GUI

char record[256];		/* array to hold each "record" */ 
FILE *fichero;                          /* pointer to file */
int i, j;

//rt_printk("Escribir DAT: %s\\n", ArchivoDat);

/* open the file to write */
fichero = fopen(ArchivoDat, "w");		

if (fichero == NULL) {
	rt_printk("Error al abrir el fichero %s para escritura\\n", ArchivoDat);
	//rt_printk("Restaurando la configuración original de fábrica\\n");
	//system("cp /rootFLS/itaca/itaca.dat.ok itaca.dat");
	//rt_printk("SALIENDO DE LA APLICACIÓN - vuelva a arrancar la aplicación para aplicar los cambios\\n");
	//exit(0);
	return 1;
}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Global */
fputs("\#	Global\\n", fichero);

/* Escribe el valor de la Potencia Laser */
sprintf(record, "%d		Potencia Láser		(0 - 100)\\n", PotenciaLaser);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}  

/* Escribe el valor de la Velocidad de Marcaje */
sprintf(record, "%d		Velocidad Marcaje	(100 - 20.000 mm/s)\\n", VelocidadMarcaje);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

/* Escribe el valor del Offset Vertical */
sprintf(record, "%d		Vertical		(-semicampo mm a +semicampo mm)\\n", Vertical);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

/* Escribe el valor del Offset Horizontal */
sprintf(record, "%d		Horizontal		(-semicampo mm a +semicampo mm)\\n", Horizontal);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}   

/* Escribe el valor de la fuente */
sprintf(record, "%d		Valor Fuente\\n", ValorFuente);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo Valor Fuente: %s", record);
} 

/* Escribe el valor de la Justificación Izquierda */
sprintf(record, "%d		JustificacionIzquierda	(0 - 1)\\n", JustificacionIzquierda);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}      

/* Escribe el valor de la Justificación Centro */
sprintf(record, "%d		JustificacionCentro	(0 - 1)\\n", JustificacionCentro);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}      

/* Escribe el valor de la Justificación Derecha */
sprintf(record, "%d		JustificacionDerecha	(0 - 1)\\n", JustificacionDerecha);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}      

/* Escribe el valor de la Anchura */
sprintf(record, "%d		Anchura			(10 - 200)\\n", Anchura);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
}      

/* Escribe el valor del Espaciado */
sprintf(record, "%d		Espaciado		(10 - 200)\\n", Espaciado);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 
 
/* Escribe el valor de la Separación entre líneas */
sprintf(record, "%2.1f		Separación Líneas	(0.1 - 5 mm)\\n", SeparacionLineas);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 
 
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Texto Línea 1: */
fputs("\#	Texto Línea 1:\\n", fichero);

for (j=0; j<NumeroBloquesLinea; j++) {
 
	/* Escribe el texto de la Línea 1 */
	sprintf(record, "%s\\n", LineaTexto1[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo Línea 1 Bloque %d: %s", j, record);
	} 

	/* Escribe el valor de la Altura de la línea 1 */
	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\\n", AlturaLineaTexto1[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo: %s", record);
	}
	
} 
   
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Texto Línea 2: */
fputs("\#	Texto Línea 2:\\n", fichero);
 
for (j=0; j<NumeroBloquesLinea; j++) {
 
	/* Escribe el texto de la Línea 2 */
	sprintf(record, "%s\\n", LineaTexto2[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo Línea 2 Bloque %d: %s", j, record);
	} 

	/* Escribe el valor de la Altura de la línea 2 */
	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\\n", AlturaLineaTexto2[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo: %s", record);
	}
	
} 
   
//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Texto Línea 3: */
fputs("\#	Texto Línea 3:\\n", fichero);

for (j=0; j<NumeroBloquesLinea; j++) {
 
	/* Escribe el texto de la Línea 1 */
	sprintf(record, "%s\\n", LineaTexto3[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo Línea 3 Bloque %d: %s", j, record);
	} 

	/* Escribe el valor de la Altura de la línea 3 */
	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\\n", AlturaLineaTexto3[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo: %s", record);
	}
	
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Texto Línea 4: */
fputs("\#	Texto Línea 4:\\n", fichero);

for (j=0; j<NumeroBloquesLinea; j++) {
 
	/* Escribe el texto de la Línea 4 */
	sprintf(record, "%s\\n", LineaTexto4[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo Línea 4 Bloque %d: %s", j, record);
	} 

	/* Escribe el valor de la Altura de la línea 4 */
	sprintf(record, "%2.1f		Altura			(1 - 5 mm)\\n", AlturaLineaTexto4[j]);
	fputs(record, fichero);

	if (debug_resto){
		printf("Escribiendo: %s", record);
	}
	
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Campos variables: Fecha */
fputs("\#	Campos variables: Fecha \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Escribe el status de la fecha */
		sprintf(record, "%d		StatusFecha[%d][%d]\\n", StatusFecha[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo StatusFecha[%d][%d]: %s", i, j, record);
		} 
 
	 	/* Escribe el orden de la fecha */
		sprintf(record, "%d		OrdenFecha[%d][%d]\\n", OrdenFecha[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo OrdenFecha[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del formato completo de la fecha */
		sprintf(record, "%s\\n", FormatoCompletoFecha[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo FormatoCompletoFecha[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el texto anterior a la fecha */
		sprintf(record, "%s\\n", textoanteriorfecha[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoanteriorfecha[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe el texto posterior a la fecha */
		sprintf(record, "%s\\n", textoposteriorfecha[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoposteriorfecha[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del formato de la fecha 1 */
		sprintf(record, "%d		ValorFormatoFecha1[%d][%d]\\n", ValorFormatoFecha1[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoFecha1[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del formato de la fecha 2 */
		sprintf(record, "%d		ValorFormatoFecha2[%d][%d]\\n", ValorFormatoFecha2[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoFecha2[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del formato de la fecha 3 */
		sprintf(record, "%d		ValorFormatoFecha3[%d][%d]\\n", ValorFormatoFecha3[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoFecha3[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del separador de la fecha */
		sprintf(record, "%d		ValorSeparadorFecha[%d][%d]\\n", ValorSeparadorFecha[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorSeparadorFecha[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor de la caducidad */
		sprintf(record, "%d		Caducidad[%d][%d]\\n", Caducidad[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo Caducidad[%d][%d]: %s", i, j, record);
		} 

	}

}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Campos variables: Hora */
fputs("\#	Campos variables: Hora \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
		/* Escribe el status de la hora */
		sprintf(record, "%d		StatusHora[%d][%d]\\n", StatusHora[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo StatusHora[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el orden de la hora */
		sprintf(record, "%d		OrdenHora[%d][%d]\\n", OrdenHora[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo OrdenHora[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del formato completo de la hora */
		sprintf(record, "%s\\n", FormatoCompletoHora[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo FormatoCompletoHora[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el texto anterior a la hora */
		sprintf(record, "%s\\n", textoanteriorhora[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoanteriorhora[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe el texto posterior a la hora */
		sprintf(record, "%s\\n", textoposteriorhora[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoposteriorhora[%d][%d]: %s", i, j, record);
		} 
		
		/* Escribe el valor del formato de la hora 1 */
		sprintf(record, "%d		ValorFormatoHora1[%d][%d]\\n", ValorFormatoHora1[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoHora1[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del formato de la hora 2 */
		sprintf(record, "%d		ValorFormatoHora2[%d][%d]\\n", ValorFormatoHora2[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoHora2[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del formato de la hora 3 */
		sprintf(record, "%d		ValorFormatoHora3[%d][%d]\\n", ValorFormatoHora3[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorFormatoHora3[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el valor del separador de la hora */
		sprintf(record, "%d		ValorSeparadorHora[%d][%d]\\n", ValorSeparadorHora[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorSeparadorHora[%d][%d]: %s", i, j, record);
		} 

	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Campos variables: Serie */
fputs("\#	Campos variables: Serie \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 
	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Escribe el status del número de serie */
		sprintf(record, "%d		StatusNúmeroSerie[%d][%d]\\n", StatusNumeroSerie[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo StatusNúmeroSerie[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el orden del número de serie */
		sprintf(record, "%d		OrdenNumeroSerie[%d][%d]\\n", OrdenNumeroSerie[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo OrdenNumeroSerie[%d][%d]: %s", i, j, record);
		} 
	
		/* Escribe el string del número de serie */
		sprintf(record, "%s\\n", strNumeroSerie[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo strNumeroSerie[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el texto anterior al número de serie */
		sprintf(record, "%s\\n", textoanteriorserie[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoanteriorserie[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe el texto posterior al número de serie */
		sprintf(record, "%s\\n", textoposteriorserie[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo textoposteriorserie[%d][%d]: %s", i, j, record);
		} 
		
		/* Escribe el valor del número de serie */
		sprintf(record, "%ld		NúmeroSerie[%d][%d]\\n", NumeroSerie[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroSerie[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del número de dígitos del número de serie */
		sprintf(record, "%d		NúmeroDígitosNúmeroSerie[%d][%d]\\n", NumeroDigitosNumeroSerie[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroDígitosNúmeroSerie[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del número de serie inicial */
		sprintf(record, "%ld		NúmeroSerieInicial[%d][%d]\\n", NumeroSerieInicial[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroSerieInicial[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del número de serie final */
		sprintf(record, "%ld		NúmeroSerieFinal[%d][%d]\\n", NumeroSerieFinal[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroSerieFinal[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del número de unidades por lote */
		sprintf(record, "%ld		NúmeroUnidadesLote[%d][%d]\\n", NumeroUnidadesLote[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroUnidadesLote[%d][%d]: %s", i, j, record);
		} 

		/* Escribe el valor del número actual en el lote */
		sprintf(record, "%ld		NúmeroUnidadesLoteActual[%d][%d]\\n", NumeroUnidadesLoteActual[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NúmeroUnidadesLoteActual[%d][%d]: %s", i, j, record);
		} 

	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Campos variables: textos */
fputs("\#	Campos variables: textos \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		/* Escribe lineaanterior */
		sprintf(record, "%s\\n", lineaanterior[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo lineaanterior[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe lineamedio */
		sprintf(record, "%s\\n", lineamedio[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo lineamedio[%d][%d]: %s", i, j, record);
		}

		/* Escribe lineamedio2 */
		sprintf(record, "%s\\n", lineamedio2[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo lineamedio2[%d][%d]: %s", i, j, record);
		} 

		/* Escribe lineafinal */
		sprintf(record, "%s\\n", lineafinal[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo lineafinal[%d][%d]: %s", i, j, record);
		} 

	}
	
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Barcode */
fputs("\#	Barcode \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 	
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
	 	/* Escribe ValorTipoBarcode */
		sprintf(record, "%d		ValorTipoLinea[%d][%d]\\n", ValorTipoLinea[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorTipoLinea[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe InvertirBarcode */
		sprintf(record, "%d		InvertirBarcode[%d][%d]\\n", InvertirBarcode[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo InvertirBarcode[%d][%d]: %s", i, j, record);
		} 

		/* Escribe EscalaBarcode */
		sprintf(record, "%d		EscalaBarcode[%d][%d]\\n", EscalaBarcode[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo DensidadBarcode[%d][%d]: %s", i, j, record);
		}
	
		/* Escribe SeparacionBarrasBarcode */
		sprintf(record, "%d		SeparacionBarrasBarcode[%d][%d]\\n", SeparacionBarrasBarcode[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo SeparacionBarrasBarcode[%d][%d]: %s", i, j, record);
		} 
	
	}
	
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Gráficos */
fputs("\#	Gráficos\\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 	
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
 		/* Escribe el nombre del archivo plt */
		sprintf(record, "%s\\n", NombreArchivoPlt[i][j]);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo NombreArchivoPlt[%d][%d]: %s", i, j, record);
		} 
	
	}
	
}

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Repeticiones */
fputs("\#	Repeticiones\\n", fichero);

/* Escribe el valor del Número de Filas */
sprintf(record, "%d		Numero de Filas		(1 - 20)\\n", NumeroFilas);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor de la Separación entre Filas */
sprintf(record, "%2.1f		Separación Filas	(-100 +100 mm)\\n", SeparacionFilas);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor del Número de Columnas */
sprintf(record, "%d		Numero de Columnas	(1 - 20)\\n", NumeroColumnas);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor de la Separación entre Columnas */
sprintf(record, "%2.1f		Separación Columnas	(-100 +100 mm)\\n", SeparacionColumnas);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Precorte */
fputs("\#	Precorte\\n", fichero);

/* Escribe el valor del Precorte */
sprintf(record, "%d		Precorte		(0 - 1)\\n", Precorte);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor de la longitud del Precorte (en %) */
sprintf(record, "%d		Longitud Precorte	(10 - 200)\\n", LongitudPrecorte);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor de la Separación del Precorte */
sprintf(record, "%2.1f		Separación Precorte	(-100 +100 mm)\\n", SeparacionPrecorte);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe el valor de la velocidad del Precorte (en %) */
sprintf(record, "%d		Velocidad Precorte	(10 - 1000)\\n", VelocidadPrecorte);
fputs(record, fichero);

if (debug_resto){
	printf("Escribiendo: %s", record);
} 

/* Escribe la línea con un comentario: Reset Serie Fecha */
fputs("\#	ResetSerieFecha\\n", fichero);

/* Escribe el valor del ResetSerieFecha */
sprintf(record, "%d		ResetSerieFecha		(0 - 1)\\n", ResetSerieFecha);
fputs(record, fichero);

//////////////////////////////////////////////////////////////////////////////
/* Escribe la línea con un comentario: Valores X, Y, del tipo de linea */
fputs("\#	Valores tipo linea de X Y \\n", fichero);

for (i=0; i<NumeroLineasTexto; i++) {
 	
 	for (j=0; j<NumeroBloquesLinea; j++) {
 	
	 	/* Escribe ValorTipoBarcode */
		sprintf(record, "%d		ValorTipoLinea[%d][%d]\\n", ValorTipoLinea[i][j], i, j);
		fputs(record, fichero);

		if (debug_resto){
			printf("Escribiendo ValorTipoLinea[%d][%d]: %s", i, j, record);
		} 
 
		/* Escribe Valores Tipo Texto */
		if (ValorTipoLinea[i][j]==TEXTO){
			sprintf(record, "%f		MinXTexto[%d][%d]\\n", MinXTexto[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		MinYTexto[%d][%d]\\n", MinYTexto[i][j], i, j);
			fputs(record, fichero);
			}
		/* Escribe Valores Tipo Grafico */
		else if (ValorTipoLinea[i][j]==GRAFICO){
			sprintf(record, "%f		MinXGrafico[%d][%d]\\n", MinXGrafico[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		MinYGrafico[%d][%d]\\n", MinYGrafico[i][j], i, j);
			fputs(record, fichero);
			}
		/* Escribe Valores Tipo Texto Circular */
		else if (ValorTipoLinea[i][j]==TEXTOCIRCULAR){
			sprintf(record, "%f		CentroXTextoCircular[%d][%d]\\n", CentroXTextoCircular[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		CentroYTextoCircular[%d][%d]\\n", CentroYTextoCircular[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		AnguloTextoCircular[%d][%d]\\n", AnguloTextoCircular[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		RadioTextoCircular[%d][%d]\\n", RadioTextoCircular[i][j], i, j);
			fputs(record, fichero);
			}
		else {
			sprintf(record, "%f		MinXBarcode[%d][%d]\\n", MinXBarcode[i][j], i, j);
			fputs(record, fichero);
			sprintf(record, "%f		MinYBarcode[%d][%d]\\n", MinYBarcode[i][j], i, j);
			fputs(record, fichero);
		}

	
	}
	
} 



if (debug_resto){
	printf("Escribiendo: %s", record);
} 


 	 
//////////////////////////////////////////////////////////////////////////////
/* cierra el archivo */
fclose(fichero);

//system("mount / -o rw,remount");
//system("cp itaca.dat /rootFLS/itaca/itaca.dat");
//system("mount / -o ro,remount");

return 0;} {}
} 

Function {Inicializar_Marcaje()} {C return_type void
} {
  code {//////////////////////////////////////////////////////////////////////////////
// INICIALIZA PARÁMETROS RELACIONADOS CON EL MARCAJE (MATRIZ, LISTAS, ETC)

// Los siguientes parámetros sólo se recalculan si no se está marcando:

if (!EnEjecucion) {

	// Semicampo en mm
	Semicampo = (float) (MaximoBits/CalibracionCorreccion);

	// Inicializa lista 0
	Lista0_Open = false;
	Lista0_Exe = false;
	Lista0_NumeroMicroVectores = 0;

	// Inicializa lista 1
	Lista1_Open = false;
	Lista1_Exe = false;
	Lista1_NumeroMicroVectores = 0;

	// Inicializa lista 2
	Lista2_Open = false;
	Lista2_Exe = false;
	Lista2_NumeroMicroVectores = 0;

	//////////////////////////////////////////////////////////////////////////////

	// Calcula el Mark Step Size
	CalcularMarkStepSize();

	// Calcula el Jump Step Size
	CalcularJumpStepSize();

	// LaserOn: calcula el número de periodos que dura el retardo de LaserOn
	PeriodosRetardoLaserOn = (unsigned int) floor((float)RetardoLaserOn/(float)PERIODO_MICROSEGUNDOS);

	// LaserOff: calcula el número de periodos que dura el retardo de LaserOff
	PeriodosRetardoLaserOff = (unsigned int) floor((float)RetardoLaserOff/(float)PERIODO_MICROSEGUNDOS);

	// Retardo de marcaje: calcula el número de periodos que dura el retardo de marcaje
	PeriodosRetardoMarcaje = (unsigned int) floor((float)RetardoMarcaje/(float)PERIODO_MICROSEGUNDOS);

	// Retardo de polígono: calcula el número de periodos que dura el retardo de polígono
	PeriodosRetardoPoligono = (unsigned int) floor((float)RetardoPoligono/(float)PERIODO_MICROSEGUNDOS);

	// Retardo de salto: calcula el número de periodos que dura el retardo de salto
	PeriodosRetardoSalto = (unsigned int) floor((float)RetardoSalto/(float)PERIODO_MICROSEGUNDOS);

	if (debug_resto) {

		rt_printk("PeriodosRetardoLaserOn: %d\\n", PeriodosRetardoLaserOn);
		rt_printk("PeriodosRetardoLaserOff: %d\\n", PeriodosRetardoLaserOff);
		rt_printk("PeriodosRetardoMarcaje: %d\\n", PeriodosRetardoMarcaje);
		rt_printk("PeriodosRetardoPoligono: %d\\n", PeriodosRetardoPoligono);
		rt_printk("PeriodosRetardoSalto: %d\\n", PeriodosRetardoSalto);

	}

	//////////////////////////////////////////////////////////////////////////////

	// Línea 1:
	AnchuraLineaTexto1 = 0;

	// Línea 2:
	AnchuraLineaTexto2 = 0;

	// Línea 3
	AnchuraLineaTexto3 = 0;
	
	// Línea 4
	AnchuraLineaTexto4 = 0;

	// Estado
	EstadoLaser = OFF;
	Actualizar = false;
	//Contador = 0;
	EnEjecucion = false;
	MarcajeOk = true;

	// Fuentes
	ArchivoFuentesAbierto = false;
	AnchuraCaracterAnterior = 0;
	xMaxFont = 0;
	yMaxFont = 0;

	// Cálculo de constantes de conversión, incorporando la proporción de VGalvoRef frente a los 10V max
	Kx_Bits_a_Voltios = -(double)(VGalvoRef_MaximoBits)/(double)(MaximoBits); // geométricamente requiere la inversión
	Ky_Bits_a_Voltios = (double)(VGalvoRef_MaximoBits)/(double)(MaximoBits);
	
	if (debug_resto){
		rt_printk("Kx_Bits_a_Voltios:%f   Ky_Bits_a_Voltios:%f \\n", Kx_Bits_a_Voltios, Ky_Bits_a_Voltios);
	}
	
}


// Los siguientes parámetros se pueden recalcular aunque se esté marcando, porque se hayan cambiado la
// calibración del encoder o la velocidad de línea

switch (Avance) {
                
case 0:
	
	if (MarcajeDinamicoActivo < 2) {	//estático o velocidad variable
		Kx_Cuentas_a_Bits = (double)CalibracionCorreccion/(double)CalibracionEncoder;
	}
	
	else {	//velocidad constante
		Kx_Cuentas_a_Bits = (double)CalibracionCorreccion/25.0;
	}
	
	Ky_Cuentas_a_Bits = 0;
	
	// El cálculo del umbral se hará sobre las x
	Ku_Cuentas_a_Bits = Kx_Cuentas_a_Bits;
	
	break;
        
case 90:
	
	Kx_Cuentas_a_Bits = 0;
	
	if (MarcajeDinamicoActivo < 2) {	//estático o velocidad variable
		Ky_Cuentas_a_Bits = (double)CalibracionCorreccion/(double)CalibracionEncoder;
	}
	
	else {	//velocidad constante
		Ky_Cuentas_a_Bits = (double)CalibracionCorreccion/25.0;
	}
	
	// El cálculo del umbral se hará sobre las y
	Ku_Cuentas_a_Bits = Ky_Cuentas_a_Bits;
	
	break;
            
case 180:
		
	if (MarcajeDinamicoActivo < 2) {	//estático o velocidad variable
		Kx_Cuentas_a_Bits = -(double)CalibracionCorreccion/(double)CalibracionEncoder;
	}
	
	else {	//velocidad constante
		Kx_Cuentas_a_Bits = -(double)CalibracionCorreccion/25.0;
	}
	
	Ky_Cuentas_a_Bits = 0;
	
	// El cálculo del umbral se hará sobre las x
	Ku_Cuentas_a_Bits = Kx_Cuentas_a_Bits;
	
	break;
	
case 270:
	
	Kx_Cuentas_a_Bits = 0;
	
	if (MarcajeDinamicoActivo < 2) {	//estático o velocidad variable
		Ky_Cuentas_a_Bits = -(double)CalibracionCorreccion/(double)CalibracionEncoder;
	}
	
	else {	//velocidad constante
		Ky_Cuentas_a_Bits = -(double)CalibracionCorreccion/25.0;
	}
	
	// El cálculo del umbral se hará sobre las y
	Ku_Cuentas_a_Bits = Ky_Cuentas_a_Bits;
	
	break;

}

if (debug_resto){
	rt_printk("Kx_Cuentas_a_Bits:%f   Ky_Cuentas_a_Bits:%f \\n", Kx_Cuentas_a_Bits, Ky_Cuentas_a_Bits);
}

// Cálculo del incremento de cuentas para el caso de velocidad de línea constante
if (MarcajeDinamicoActivo == 2) {

	// Se utiliza 25 como calibración del encoder para calcular el incremento de cuentas en un periodo
	//IncrementoCuentasPeriodo = (float) (VelocidadLinea * CalibracionEncoder * PERIODO_MICROSEGUNDOS / 60000.0);
	IncrementoCuentasPeriodo = (float) (VelocidadLinea * 25.0 * PERIODO_MICROSEGUNDOS / 60000.0);
	
	if (debug_resto){
		rt_printk("IncrementoCuentasPeriodo:%f \\n", IncrementoCuentasPeriodo);
	}
	
}

// Cálculo del retardo de disparo en cuentas
if (RetardoDisparo_mm == 0) {

	RetardoDisparo_cuentas = 0;
}

else {

	// Marcaje estático
	if (MarcajeDinamicoActivo == 0) {
	
		RetardoDisparo_cuentas = 0;
		
	}
	
	// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
	else if (MarcajeDinamicoActivo == 1) {
	
		RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * CalibracionEncoder);
		
	}
	
	// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
	else if (MarcajeDinamicoActivo == 2) {
	
		//RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * CalibracionEncoder);
		RetardoDisparo_cuentas = (int)(RetardoDisparo_mm * 25.0);
		
	}
	
}

if (debug_resto) {
	rt_printk("RetardoDisparo_mm: %d, RetardoDisparo_cuentas: %d\\n", RetardoDisparo_mm, RetardoDisparo_cuentas);
}

// Cálculo del tamaño del spot real en bits
SpotBits = (int) ( (double)CalibracionCorreccion * ((double)Spot/1000.0) ) ;

// Cálculo de la modificación de tamaño del spot producida por la variable DensidadBarcode,  en bits
//SpotBits = (int) ((double)Spot_bits *  100.0 / (double)DensidadBarcode[LineaCalcular - 1] ) ;

// Disparo interno
if (TipoDisparo == DISPAROINTERNO) {

	// Marcaje estático
	if (MarcajeDinamicoActivo == 0) {
	
		SeparacionEntreDisparos_cuentas = 0;
		
	}
	
	// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
	else if (MarcajeDinamicoActivo == 1) {
	
		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
		
	}
	
	// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
	else if (MarcajeDinamicoActivo == 2) {
	
		//SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * 25.0);
		
	}
	
	//printf("SeparacionEntreDisparos_mm:%d SeparacionEntreDisparos_cuentas:%ld\\n", SeparacionEntreDisparos_mm, SeparacionEntreDisparos_cuentas);

}

if (debug_resto) {
	rt_printk("SpotBits: %d\\n", SpotBits);
}} {}
} 

Function {Inicializar_Control()} {C return_type int
} {
  code {// inicializa el sistema de control
switch (Control) {

case DAQ:
	
	Clock_Period_ns = 50;	// 20MHz NI 6221 clock
	Inicializar_DAQ_comedi();
	break;

case FPGA:

	Clock_Period_ns = 25;	// 40MHz FPGA clock
	Inicializar_FPGA();	
	break;
	
} 
	   	
return 0;} {}
} 

Function {Inicializar_DAQ_comedi()} {C return_type int
} {
  code {// inicializa la DAQ y configura los canales para la tarjeta NI pci 6221
// si el conector es de 37 pines o de 68 se gestiona con \#ifdef 68pines

int error = 0;

if (debug_resto){
	printf("Entrando-----------------Inicializar_DAQ_comedi\\n");
}

// Cargar el driver
system("modprobe ni_pcimio");

//=============================================================================================
// Abre el dispositivo
//=============================================================================================

comedi_device = comedi_open("/dev/comedi16");

if(comedi_device == NULL) {
	rt_printk("ERROR comedi_open\\n");
	ErrorDAQ = ON;
	return ErrorDAQ;
}


//=============================================================================================
// ENTRADA DIGITAL FOTOCÉLULA: 
//=============================================================================================

// Disparo de fotocélula
error = comedi_dio_config(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, COMEDI_INPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config INPUT canal %d\\n", comedi_canalDI_Fotocelula);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

//=============================================================================================
// ENTRADAS DIGITALES NORMALES: 
//=============================================================================================

// Laser Ok
error = comedi_dio_config(comedi_device, comedi_subdevice_LaserOk, comedi_canalDI_LaserOk, COMEDI_INPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config INPUT canal %d\\n", comedi_canalDI_LaserOk);
	ErrorDAQ = ON;
	ProcesarError();
}

// Extractor Ok
error = comedi_dio_config(comedi_device, comedi_subdevice_ExtractorOk, comedi_canalDI_ExtractorOk, COMEDI_INPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config INPUT canal %d\\n", comedi_canalDI_ExtractorOk);
	ErrorDAQ = ON;
	return ErrorDAQ;
}


//=============================================================================================
// SALIDAS DIGITALES: 
//=============================================================================================

// Laser Enable

// Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
\#ifndef _68pines

	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, NI_PFI_OUTPUT_PFI_DO);
	if (error < 0){
		rt_printk("ERROR %d comedi_set_routing\\n", error);
		ErrorDAQ = ON;
		return ErrorDAQ;
	}

\#endif

// Configurar el puerto como salida
error = comedi_dio_config(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, COMEDI_OUTPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\\n", comedi_canalDO_LaserEnable);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

// Control de línea

// No hace falta enrutar la salida porque no es un puerto PFI
error = comedi_dio_config(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, COMEDI_OUTPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\\n", comedi_canalDO_ControlEnable);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

// Mark in Progress

// Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
\#ifndef _68pines

	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, NI_PFI_OUTPUT_PFI_DO);
	if (error < 0){
		rt_printk("ERROR %d comedi_set_routing\\n", error);
		ErrorDAQ = ON;
		return ErrorDAQ;
	}
	
\#endif

// Configurar el puerto como salida
error = comedi_dio_config(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, COMEDI_OUTPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\\n", comedi_canalDO_MarkInProgress);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

// Activación de extractor

// Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
\#ifndef _68pines

	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, NI_PFI_OUTPUT_PFI_DO);
	if (error < 0){
		rt_printk("ERROR %d comedi_set_routing\\n", error);
		ErrorDAQ = ON;
		return ErrorDAQ;
	}

\#endif

// Configurar el puerto como salida
error = comedi_dio_config(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, COMEDI_OUTPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\\n", comedi_canalDO_ExtractorEnable);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

// Señal de alimentación de galvos

// Si es la tarjeta de 37 pines hay que enrutar la salida digital PFI
\#ifndef _68pines

	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, NI_PFI_OUTPUT_PFI_DO);
	if (error < 0){
		rt_printk("ERROR %d comedi_set_routing\\n", error);
		ErrorDAQ = ON;
		return ErrorDAQ;
	}

\#endif

// Configurar el puerto como salida
error = comedi_dio_config(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, COMEDI_OUTPUT);
if(error < 0){
	rt_printk("ERROR comedi_dio_config OUTPUT canal %d\\n", comedi_canalDO_ActivacionGalvos);
	ErrorDAQ = ON;
	return ErrorDAQ;
}

//=============================================================================================
// ENTRADAS ANALOGICAS 
//=============================================================================================
// Canales analógicos para leer la posición de los galvos

// Obtiene el máximo
MaxdataAI = comedi_get_maxdata(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionX);

// Obtiene el rango
//RangoAI = comedi_get_range(comedi_device, comedi_subdevice_AI, comedi_PosicionX_canalAI, 0);

//=============================================================================================
// SALIDAS ANALOGICAS
//=============================================================================================
// Canales analógicos para escribir la posición en los galvos

// Obtiene el máximo
MaxdataAO = comedi_get_maxdata(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX);

// Calcula la constante para pasar los valores de voltios a enteros que se escriban en la tarjeta
kFromPhysAO = (double) MaxdataAO / 2.0;

// Obtiene el rango
//RangoAO = comedi_get_range(comedi_device, comedi_subdevice_AO, comedi_GalvoX_canalAO, 0);

if (debug_resto){
	printf("Saliendo-----------------Inicializar_DAQ_comedi\\n");
}
	   	
return 0;} {}
} 

Function {Desactivar_DAQ_comedi()} {C return_type int
} {
  code {//=============================================================================================
// Cierra el dispositivo
//=============================================================================================

int error = 0;

// Si estaba activo el marcaje dinámico desactivar el encoder
//if (MarcajeDinamicoActivo == 1) {
//	Desactivar_Encoder();
//}

// Escribe en la salida digital la señal de desactivación de galvos
error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);	
if(error < 0){
	rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos OFF \\n",error);
	ErrorDAQ = ON;
	ProcesarError();
}

// Cierra el dispositivo comedi
error = comedi_close(comedi_device);
if (error < 0) {
	rt_printk("ERROR comedi_close\\n");
	ErrorDAQ = ON;
	ProcesarError();
}

//system("/usr/local/sbin/comedi_config -r /dev/comedi0 ni_pcimio");

return 0;} {}
} 

Function {Inicializar_FPGA()} {C return_type int
} {
  code {// Inicializa la FPGA

if (debug_resto){
	printf("Entrando-----------------Inicializar_FPGA\\n");
}

// Otorga permisos de acceso a los puertos
if (iopl(3)) {

	rt_printk("Error al conseguir permisos de acceso a los puertos\\n");
	ErrorFPGA = ON;
	//ProcesarError();
	
}

// Descarga el firmware en la FPGA
if (DescargarFirmwareFPGA()) {

	rt_printk("Error al cargar el firmware en la FPGA\\n");
	ErrorFPGA = ON;
	//ProcesarError();
	
}

// Calcula la constante para pasar los valores de voltios a enteros que se escriban en la tarjeta
// Se usan 12 bits, así que el máximo es 2^12 = 4096, entre el rango máximo de voltios 
//kFromPhysFPGA = (double) (4095.0 / (2.0*VGalvoRef_MaximoBits));

// Hay que usar +/-10V de rango; luego en FPGAfromPhys, si se ha usado un rango menor en los galvos
// el sistema recortará los voltios a costa de perder resolución, claro
kFromPhysFPGA = (double) (4095.0 / (2.0*10.0));


if (debug_resto){
	printf("Saliendo-----------------Inicializar_FPGA\\n");
}
	   	
return 0;} {}
} 

Function {DescargarFirmwareFPGA()} {C return_type int
} {
  code {const int SZ=19895; // Pluto-P (EP1K10) .rbf size
FILE *f;
unsigned char buf[SZ];
int byte, bit;

// Primero se manda un comando de unconfigure, para poder cargar la FPGA de nuevo en caso de que se
// hubiera cargado antes y se haya salido de forma irregular
outb((COMANDO_ADMIN_FPGA|ARG_UNCONFIGURE_FPGA), REGISTRO_ADDR);
byte = inb(REGISTRO_STATUS);

rt_printk("Status: %d\\n", byte);

if (byte & MASCARA_EPP_TIME_OUT) {

	rt_printk("Error: no hay FPGA\\n");
	return 1;

}

// Abre el archivo del firmware
f = fopen("firmwareFPGA_0_8_1.rbf", "rb");

if(!f) { 
	rt_printk("Error: no se ha podido cargar el firmware de la FPGA\\n");
	return 1;
}

fread(buf, SZ, 1, f);

if(iopl(3) < 0) { 
	rt_printk("Error: no se ha podido obtener privilegios para acceder al puerto paralelo\\n");
	return 1;
}

for(byte = 0; byte < SZ; byte++) {
	
	for(bit = 0; bit < 8; bit++) {
		
		int v = buf[byte] & (1<<bit);
	    	
	    	if(v) outb(0xff, BASE_ADDRESS_PUERTO_PARALELO); else outb(0, BASE_ADDRESS_PUERTO_PARALELO);
	    	
	    	outb(1, BASE_ADDRESS_PUERTO_PARALELO+2);
	    	outb(0, BASE_ADDRESS_PUERTO_PARALELO+2);
	
	}
    
}


rt_printk("Cargado el firmware en la FPGA\\n");

return 0;} {}
} 

Function {Desactivar_FPGA()} {C return_type int
} {
  code {// Pone a 0 todas las salidas de la FPGA
outb((COMANDO_ADMIN_FPGA|ARG_RESET_IO), REGISTRO_ADDR);

return 0;} {}
} 

Function {Inicializar_Galvos()} {C return_type int
} {
  code {// inicializa los galvos en el origen
int error = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////
// ACTIVACIÓN GALVOS
//////////////////////////////////////////////////////////////////////////////////////////////////////

// debug
if (debug_resto){
	printf("Entrando-----------------Inicializar_Galvos\\n");
}


// inicializa el sistema de control
switch (Control) {

case DAQ:
	switch(TipoLaser){
	
	case 0: //laser de CO2. SI el laser es de fibra usamos la señal de activación en Inicializar_laser para activar el oscilador
	
	// Escribe en la salida digital la señal de activación de galvos
	error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, ValorActivacionGalvos);	
	if(error < 0){
		rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \\n",error);
		ErrorDAQ = ON;
		ProcesarError();
	}
	
	}

	break;

case FPGA:

	// Escribe la señal de activación de los galvos
	outb((COMANDO_GALVOS|0x01), REGISTRO_ADDR);
	
	break;
	
} 

// Duerme 1 segundos, para que los galvos terminen su inicialización
sleep(1);
	
// debug
if (debug_resto){
	printf("Saliendo-----------------Inicializar_Galvos\\n");
}

return error;} {}
} 

Function {Inicializar_RTAI()} {C return_type int
} {
  code {// debug
if (debug_resto){
	printf("Entrando-----------------Inicializar RTAI\\n");
}

// Crea la tarea "buddy" en el espacio del kernel
if (!(maint = rt_task_init(nam2num("MAIN"), 1, 0, 0))) {
	rt_printk("CANNOT INIT TASK > MAIN <\\n");
	ErrorRTAI = ON;
	ProcesarError();
	exit (-1);
}

// se pone a OFF tras entrar en RT (ejecutar rt_make_hard_real_time en timer_handler)
endthread = ON;
endhandler = ON;

// Crea el thread del timer
if (!(timerthread = rt_thread_create((void *)timer_handler, NULL, 10000))) {  // create thread
	rt_printk("CANNOT INIT TIMERTHREAD\\n");
	ErrorRTAI = ON;
	ProcesarError();
	exit (-1);
}
	
// espera hasta que se haya destruido el handler para proseguir
while (!endhandler) {   	
	usleep(10000);
}	

// debug
if (debug_resto){
	printf("Saliendo-----------------Inicializar RTAI\\n");
}

return 0;} {}
} 

Function {Desactivar_RTAI()} {C return_type void
} {
  code {// termina el bucle de RTAI:
endthread = ON;
	
// espera hasta que se haya destruido el handler para proseguir
while (!endhandler) {   	
	usleep(10000);
}	

// destruye el thread
rt_thread_join(timerthread);

// elimina la tarea principal
rt_task_delete(maint);} {}
} 

Function {Inicializar_thread_estado()} {C return_type int
} {
  code {// Crea el thread del timer de estado
if (pthread_create(&id_thread_timer_estado, NULL, timer_estado, NULL) != 0) {  // create pthread
	rt_printk("CANNOT INIT THREAD ESTADO\\n");
	ErrorTimerEstado = ON;
	ProcesarError();
	return -1;
}

return 0;} {}
} 

Function {*timer_estado(void *)} {C return_type void
} {
  code {// Función para comprobar el estado de Laser OK, Temperatura OK, extractor (si está activado) 
// patear el Watchdog y calcular y presentar la velocidad de línea
int error = false;
int dummy;
unsigned long long contadorantiguo = 0; // va guardando los valores del contador de disparos 
int incrementodisparos = 0;	// cuenta el incremento de disparos

// Variables para la lectura de las cuentas del encoder
//static lsampl_t ValorCuentasActual_Estado, ValorCuentasAnterior_Estado;
//static float IncrementoCuentas_Estado;

// Guarda el tiempo en el que terminó el ciclo anterior
static RTIME tAnterior;

// Para obtener el tiempo y poder calcular la duración de los bucles
static RTIME tActual; 

// debug
if (debug_resto){
	printf("Entrando-----------------Thread estado\\n");
}

///////////////////////////////////////////////////////////////////////////////
// INICIALIZACIÓN

// abre el archivo de watchdog
fd_watchdog = open("/dev/watchdog", O_WRONLY);
	
if (fd_watchdog == -1) {
	rt_printk("Error opening /dev/watchdog \\n");
	ErrorWatchdog = ON;
	ProcesarError();
}

// flag que controla que el programa está en ejecución
Apagar = false;

tAnterior = rt_get_time_ns();

// Esta función se ejecuta todo el tiempo, desde el inicio hasta el final del programa
while (Apagar == false) {

	if (debug_testado) {
		printf("\\n--------TIMER--------\\n");
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// WATCHDOG
	
	// Patea el watchdog
	ioctl(fd_watchdog, WDIOC_KEEPALIVE, &dummy);
	
	//////////////////////////////////////////////////////////////////////////////
	// LASER OK
	
	// Lee la señal de Laser OK
	switch (Control) {

	case DAQ:
	
		error = comedi_dio_read(comedi_device, comedi_subdevice_LaserOk, comedi_canalDI_LaserOk, &LaserOkDIValue);	
		if (error < 0) {
			rt_printk("comedi_dio_read LaserOk error = %d\\n",error);
			//ErrorDAQ = ON;
			//ProcesarError();
		}
		
		break;

	case FPGA:

		outb((COMANDO_LEER_DI|ARG_LEER_LASER_OK), REGISTRO_ADDR);
		LaserOkDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;	
		
		break;
	
	} 
	
	//printf("LaserOkDIValue:%d\\n", LaserOkDIValue);
	//debug: luego quitar
	LaserOkDIValue = HIGH;
		
	// Si no está HIGH activa el error (active high - láser Coherent)
	if (LaserOkDIValue == LOW) {
		ErroresConsecutivosLaserOk++;
	}
	else {
		ErroresConsecutivosLaserOk = 0;
	}	
	
	if (ErroresConsecutivosLaserOk >= MaximoErroresConsecutivosLaserOk) {
		ErrorLaserOk = true;
	}
	else {
		ErrorLaserOk = false;
	}
	
	
	//////////////////////////////////////////////////////////////////////////////
	// TEMPERATURA 
	
	/*
	
	// Lee la señal de Temperatura OK
	switch (Control) {

	case DAQ:
	
		error = comedi_dio_read(comedi_device, comedi_subdevice_DI, comedi_Temperatura_canalDI, &TemperaturaDIValue);	
		if (error < 0) {
			printf("comedi_dio_read Temperatura error = %d\\n",error);
			ErrorDAQ = ON;
			ProcesarError();
		}
		
		break;

	case FPGA:

		outb((COMANDO_LEER_DI|ARG_LEER_TEMPERATURA_OK), REGISTRO_ADDR);
		TemperaturaDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;	
		
		break;
	
	} 
	
	//printf("TemperaturaDIValue:%d\\n", TemperaturaDIValue);
	
	// Si no está HIGH activa el error (active high - láser Coherent)
	if (TemperaturaDIValue == LOW) {
		ErroresConsecutivosTemperatura++;
	}
	else {
		ErroresConsecutivosTemperatura = 0;
	}	
	
	if (ErroresConsecutivosTemperatura >= MaximoErroresConsecutivosTemperatura) {
		ErrorTemperatura = true;
	}
	else {
		ErrorTemperatura = false;
	}
	
	*/
	
	//////////////////////////////////////////////////////////////////////////////
	// EXTRACTOR
	
	// Lee la señal de extractor, si está activo y el sistema está marcando
	if (ExtractorActivado == true) {
	
		// Lee la señal del extractor
		switch (Control) {

		case DAQ:
	
			error = comedi_dio_read(comedi_device, comedi_subdevice_ExtractorOk, comedi_canalDI_ExtractorOk, &ExtractorDIValue);	
			if (error < 0) {
				rt_printk("comedi_dio_read Extractor error = %d\\n",error);
				//ErrorDAQ = ON;
				//ProcesarError();
			}
		
			break;

		case FPGA:

			outb((COMANDO_LEER_DI|ARG_LEER_EXTRACTOR_OK), REGISTRO_ADDR);
			ExtractorDIValue = inb(REGISTRO_STATUS) & MASCARA_ENTRADAS_DIGITALES;
	
			break;
	
		} 
		
		

		// Si no está HIGH activa el error (active high - láser Coherent)
		if ((ExtractorDIValue == LOW) && (EnEjecucion == true)) {
			ErroresConsecutivosExtractor++;
		}
		else {
			ErroresConsecutivosExtractor = 0;
		}	
	
		if (ErroresConsecutivosExtractor >= MaximoErroresConsecutivosExtractor) {
			ErrorExtractor = true;
		}
		else {
			ErrorExtractor = false;
		}	
	
	}
	
	
	//////////////////////////////////////////////////////////////////////////////
	// SISTEMA OK
	
	if ( (ErrorLaserOk) || (ErrorTemperatura) || ((ExtractorActivado) && (ErrorExtractor)) || (ErrorEncoder) || (ErrorCampo)) {
	
		// Hay algún error:
		SistemaOk = false;
		ProcesarError();
		
		// Si estaba en ejecución o el láser encendido (botón prueba o láser) hay que detenerlo todo
		if ((EnEjecucion == true) || (EstadoLaser == ON)) {

			StopEjecucion();
			rt_printk("\# Error Sistema No OK - Deteniendo la ejecución\\n");
			
		}
		
	}
	
	else {	
		
		// Si previamente había algún error de estado, resetea el led de estado
		if (SistemaOk == false) {
		
			// Vuelve a poner el Led en verde
			LedEstado->color((Fl_Color)2); 	// Led verde
			LedEstado->redraw();		// Marca el Led para redraw
	
			// Actualiza el mensaje
			// Actualiza el mensaje
			switch (Idioma) {
			
				case ESP:
				LedEstado->label("Sistema OK");
				break; 
			
				case ING:
				LedEstado->label("System OK");
				break;
			
				case ITA:
				LedEstado->label("Sistema OK");
				break;
			
			}
	  
			// Vuelve a activar los botones
			BotonMarcar->activate();
			BotonPrueba->activate();
			
			if (ServicioTecnico) {
				BotonCampo->activate();
				BotonLaser->activate();
			}	
	
		}
		
		// No hay errores de estado
		SistemaOk = true;
	
	}

	
	//////////////////////////////////////////////////////////////////////////////
	// Espera el periodo de estado antes de continuar
	usleep(PERIODO_ESTADO);
	
	
	//////////////////////////////////////////////////////////////////////////////
	// VELOCIDAD DE LÍNEA VARIABLE
	
	if (MarcajeDinamicoActivo == 1) {
	
		tActual = rt_get_time_ns();
		
		// Si no está en ejecución hay que leer las cuentas del encoder
		//if (!EnEjecucion) {
		
			// Leer las cuentas del encoder
			//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual_Estado);
			//if (error < 0) {
			//	rt_printk("ESTADO: LEER ENCODER comedi_data_read = %d\\n",error);
			//	ErrorDAQ = ON;
			//	ProcesarError();
			//}
			
		//}
		
		// Si está en ejecución se usará la última lectura
		//else {
		
			ValorCuentasActual_Estado = ValorCuentasActual;
		//}
		
		// Calcular el incremento de cuentas
		if (ValorCuentasActual_Estado >= ValorCuentasAnterior_Estado) {
			IncrementoCuentas_Estado = (float)(ValorCuentasActual_Estado - ValorCuentasAnterior_Estado);
		}
		else { 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
			IncrementoCuentas_Estado = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Estado) + ValorCuentasActual_Estado);
			//StopEjecucion();
			//LedEstado->label("Encoder overflow");
			//rt_printk("ESTADO: OVERFLOW MV %ld Actual:%d INCR:%f\\n", MicroVector, ValorCuentasActual_Estado, IncrementoCuentas_Estado);
		}
	
		// Guardar el valor leido para la próxima iteración
		ValorCuentasAnterior_Estado = ValorCuentasActual_Estado;
		
		// Calcula la velocidad 
		VelocidadLinea = (IncrementoCuentas_Estado * 6E7) / (float)((tActual - tAnterior) * CalibracionEncoder);
		
		// Presenta el resultado en el interfaz
		CuadroTextoVLinea->value(VelocidadLinea);
		
		tAnterior = tActual;
		
		//printf("Actual:%d Anterior:%d Velocidad:%f\\n", ValorCuentasActual_Estado, ValorCuentasAnterior_Estado, VelocidadLinea);	
		
		// A ver si hay error de encoder: más de 10 disparos consecutivos con el encoder parado
		incrementodisparos = Contador - contadorantiguo;
		contadorantiguo = Contador;
		
		if (IncrementoCuentas_Estado == 0) { // encoder parado
			
			ContadorDisparosParado += incrementodisparos;
		}
		
		else {
		
			ContadorDisparosParado = 0;
		}
		
		if (ContadorDisparosParado >= MaximoDisparosParado) {
	
			ErrorEncoder = true; // Saltará el error en la próxima entrada en este ciclo
	
		}
		
	}
	
}

// debug
if (debug_resto){
	printf("Saliendo-----------------Thread estado\\n");
}

return 0;} {}
} 

Function {Desactivar_thread_estado()} {C return_type int
} {
  code {// Crea el thread del timer de estado
if (pthread_join(id_thread_timer_estado, NULL) != 0) {  // create pthread
	rt_printk("CANNOT JOIN THREAD ESTADO\\n");
	ErrorTimerEstado = ON;
	ProcesarError();
	return -1;
}

return 0;} {}
} 

Function {Inicializar_PuertoSerie()} {C return_type int
} {
  code {struct termios options;

// debug
if (debug_resto) {
	printf("Entrando-----------------Thread puerto serie\\n");
}

///////////////////////////////////////////////////////////////////////////////
// INICIALIZACIÓN
ErrorPuertoSerie = OFF;

// Hay que poner el puerto serie en modo raw, para no requerir CR para leer el puerto
//system("stty -F /dev/ttyS1 raw");

// Abrir el puerto
fd_puertoserie = open("/dev/ttyS1", O_RDWR | O_NOCTTY | O_NDELAY);

if (fd_puertoserie == -1) {
	
	rt_printk("Puerto Serie: open_port: Unable to open /dev/ttyS1 - ");
	ErrorPuertoSerie = ON;
	//return -1;
	
} 

else {
	fcntl(fd_puertoserie, F_SETFL, 0);
}

// Get the current options for the port...
tcgetattr(fd_puertoserie, &options);

// Set the baud rates to 9600
cfsetispeed(&options, B9600);
cfsetospeed(&options, B9600);

// Enable the receiver and set local mode...
// c_cflag describe el hardware control del terminal
options.c_cflag |= (CLOCAL | CREAD);	// local (ignora señales de control) y modo receiver
options.c_cflag &= ~PARENB;		// sin paridad
options.c_cflag &= ~CSTOPB;		// un bit de parada; si se activara serían 2 bits
options.c_cflag &= ~CSIZE;		
options.c_cflag |= CS8;			// 8 bits de datos

options.c_oflag = 0;			// salida en bruto		

options.c_iflag = ~IGNCR;		// evita el mapeo de CR a NL		
options.c_iflag &= ICRNL;
options.c_iflag &= INLCR;

options.c_lflag = 0;			// entrada no canónica, sin eco

options.c_cc[VTIME] = 0;		// no usa el temporizador
options.c_cc[VMIN] = 3; 		// espera hasta tener al menos 3 caracteres

// Set the new options for the port...
tcsetattr(fd_puertoserie, TCSANOW, &options);

// don't block serial read
fcntl(fd_puertoserie, F_SETFL, FNDELAY); 

return 0;} {}
} 

Function {ControlPuertoSerie(void *)} {open C return_type void
} {
  code {// Función para gestionar el puerto serie: inicializa el puerto y se queda en un bucle escuchando
int error = false;
int i,j;
int numbytes=0;
char str_result[NumeroMaximoCaracteresLinea];
char caracter;
		
// Inicialización: se inicializa el segundo elemento del array porque, al inicializarse todos los elementos
// del array a 0x00, con enviar el carácter 0x1b se interpretaba mensaje de status 0x1b 0x00 0x00
// al inicializar el segundo elemento a 0x01 ya hay que mandar los 3 caracteres de forma correcta
str_result[1]=0x01;

//////////////////////////////////////////////////////////////////////////////
// Lee el puerto
numbytes = read(fd_puertoserie, str_result, NumeroMaximoCaracteresLinea);

// Vacía el buffer
//tcflush(fd_puertoserie, TCIOFLUSH);
	
// Si ha leido algo veamos qué es
if (numbytes > 0) {
	
	if (debug_puertoserie) {
			
		rt_printk("\\nRecepción Puerto Serie:");
			
		// imprime los caracteres en hexadecimal
		for (i=0;i<numbytes;i++) {
			rt_printk("%x", str_result[i]);
		}
			
		rt_printk("\\n");
		
	}
	
	// Si había un mensaje parcial concatena
	if (strlen(StrParcial) > 0) {
	
		//if (debug_puertoserie) {
			rt_printk("Recomposición de mensaje:\\n");
			rt_printk("- Periodo anterior:%s\\n", StrParcial);
			rt_printk("- Periodo actual:%s\\n", str_result);

		//}
		
		j=strlen(StrParcial);
		for (i=0;i<numbytes;i++) {
			StrParcial[j+i]=str_result[i];
		}
		
		for (i=0;i<j+numbytes;i++) {
			str_result[i]=StrParcial[i];
		}
		
		//strcat(StrParcial, str_result);
		//strcpy(str_result, StrParcial);
		
		
		//if (debug_puertoserie) {
			rt_printk("- Mensaje compuesto:%s\\n", str_result);
			
			// imprime los caracteres en hexadecimal
			for (i=0;i<j+numbytes;i++) {
				rt_printk("%x", str_result[i]);
			}
		
			rt_printk("\\n");
		//}
		
		strcpy(StrParcial,"");
		numbytes = numbytes + j;
		
	}
		
	//////////////////////////////////////////////////////////////////////////////
	// Print On: 1Bh 01h 09h = 27 1 9
	if ( (str_result[0]==27) && (str_result[1]==1) && (str_result[2]==9) ) {
					
		// Pone el equipo en modo de impresión = apretar el botón Marcar y Aceptar
		// en la ventana emergente
		if (EnEjecucion == false) {
			
			// Pone el flag para evitar ventanas emergentes al calcular la matriz
			ModoImpresionSerie = true;
					
			// Arranca si no hay error de algo en el sistema
			if (!((ErrorGalvos)||(ErrorDAQ)||(ErrorFPGA)||(ErrorRTAI)||(ErrorLaserOk)||(ErrorTemperatura)||(ErrorExtractor)||(ErrorVectores)||(ErrorWatchdog)||(ErrorCampo))) {
				
				// Calcula la matriz para comprobar que no hay problemas
				if (CalcularMatriz() != NoError) {
					
					rt_printk("ControlPuertoSerie: problema al CalcularMatriz\\n");
					ErrorEjecucionListas = true;	
					
				}
				
				else {
					ErrorEjecucionListas = false;
					StartEjecucion();	
			
				}
				
			}
			
			else {
			
				ErrorEjecucionListas = true;
			}
		
		}
						
		if (ErrorEjecucionListas == false) {
							
			write(fd_puertoserie, Str_Modoimpresion, 4);
				
			if (debug_puertoserie) {
				rt_printk("Inicio OK - Modo de Impresión\\n");
			}
			
		}
			
		else {
			
			write(fd_puertoserie, Str_Modoreposo, 4);
		
			if (debug_puertoserie) {
				rt_printk("Inicio NOK - Modo de Reposo\\n");
			}
				
		}
			
	}
	

	
	//////////////////////////////////////////////////////////////////////////////
	// Print Off: 1Bh 01h 0Ah = 27 1 10
	else if ( (str_result[0]==27) && (str_result[1]==1) && (str_result[2]==10) ) {
		
		if (debug_puertoserie) {
			rt_printk("Stop OK - Modo de Reposo\\n");
		}
		
		// Detiene la ejecución
		error = StopEjecucion();
					
		write(fd_puertoserie, Str_Modoreposo, 4);
		
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// Print Status: 1Bh 00h 00h = 27 0 0
	else if ( (str_result[0]==27) && (str_result[1]==0) && (str_result[2]==0) ) {
		
		// Devuelve el modo actual: si está marcando estará activado el flag EnEjecucion
		if (EnEjecucion == true) {
							
			write(fd_puertoserie, Str_Modoimpresion, 4);
			
			if (debug_puertoserie) {
				rt_printk("Status OK - Modo de Impresión\\n");
			}
			
		}
			
		else {
								
			write(fd_puertoserie, Str_Modoreposo, 4);
			
			if (debug_puertoserie) {
				rt_printk("Status OK - Modo de Reposo\\n");
			}	
		}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// Actualizar Línea 1: trama de caracteres terminada en Retorno de Carro 0Dh=13d y 01h=1d
	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==1)) {
							
		// Línea actual: sólo el primer bloque
		LineaCalcular = 1;
		BloqueCalcular = 1;
		
		// Si la línea tiene un plt no se actualiza
		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
		
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 1: no es posible en líneas con gráficos\\n", LineaTexto1);
			}
			
		}
		
		else {
			
			// Carga el formulario
			CargarVentanaModificarTexto();
	
			// Borra la línea actual: sólo el primer bloque
			for (i=0; i<(int)strlen(LineaTexto1[BloqueCalcular - 1]); i++) {
		
				// emula el botón de borrar
				cb_BotonBorrar(BotonBorrar, NULL);
			
			}
		
			//sustituye el CR por una terminación de string correcta		 
			str_result[numbytes-2]=0x00;
				
			// Procesa los caracteres
			for (i=0; i<(int)strlen(str_result); i++) {
		
				caracter = str_result[i];
				
				// Procesa el carácter
				if (CaracterValido(caracter)) {
				
					ProcesarCaracter(&caracter);
					
				}
				
			}
			
			// Emula el click en el botón de aceptar la modificación de texto
			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
				
			// y marca para actualizar si se está marcando
			if (ModoImpresionSerie == true) {
				
				ActualizarPuertoSerie = true;
			
			}
			
			//escribimos secuencia recibida
			
			write(fd_puertoserie, Str_Linea1recibida, 4);
			
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 1: %s\\n", LineaTexto1);
			}
			
		}
	
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// Actualizar Línea 2: trama de caracteres terminada en Retorno de Carro 0Dh=13d y 02h=2d
	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==2)) {
					
		// Línea actual: sólo el primer bloque
		LineaCalcular = 2;
		BloqueCalcular = 1;
		
		// Si la línea tiene un plt no se actualiza
		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
		
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 2: no es posible en líneas con gráficos\\n", LineaTexto1);
			}
			
		}
		
		else {
			
			// Carga el formulario
			CargarVentanaModificarTexto();

			// Borra la línea actual
			for (i=0; i<(int)strlen(LineaTexto2[BloqueCalcular - 1]); i++) {
		
				// emula el botón de borrar
				cb_BotonBorrar(BotonBorrar, NULL);
			
			}
		
			//sustituye el CR por una terminación de string correcta		 
			str_result[numbytes-2]=0x00;
				
			// Procesa los caracteres
			for (i=0; i<(int)strlen(str_result); i++) {
		
				caracter = str_result[i];
				
				// Procesa el carácter
				if (CaracterValido(caracter)) {
				
					ProcesarCaracter(&caracter);
					
				}
				
			}
			
			// Emula el click en el botón de aceptar la modificación de texto
			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
				
			// y marca para actualizar si se está marcando
			if (ModoImpresionSerie == true) {
				
				ActualizarPuertoSerie = true;
			
			}
			
			//escribimos secuencia recibida
			
			write(fd_puertoserie, Str_Linea2recibida, 4);
			
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 2: %s\\n", LineaTexto2);
			}
			
		}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// Actualizar Línea 3: trama de caracteres terminada en Retorno de Carro 0Dh=13d y 03h=3d
	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==3)) {
					
		// Línea actual: sólo el primer bloque
		LineaCalcular = 3;
		BloqueCalcular = 1;
		
		// Si la línea tiene un plt no se actualiza
		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
		
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 3: no es posible en líneas con gráficos\\n", LineaTexto1);
			}
			
		}
		
		else {
			
			// Carga el formulario
			CargarVentanaModificarTexto();

			// Borra la línea actual
			for (i=0; i<(int)strlen(LineaTexto3[BloqueCalcular - 1]); i++) {
		
				// emula el botón de borrar
				cb_BotonBorrar(BotonBorrar, NULL);
			
			}
		
			//sustituye el CR por una terminación de string correcta		 
			str_result[numbytes-2]=0x00;
				
			// Procesa los caracteres
			for (i=0; i<(int)strlen(str_result); i++) {
		
				caracter = str_result[i];
				
				// Procesa el carácter
				if (CaracterValido(caracter)) {
				
					ProcesarCaracter(&caracter);
					
				}
				
			}
			
			// Emula el click en el botón de aceptar la modificación de texto
			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
				
			// y marca para actualizar si se está marcando
			if (ModoImpresionSerie == true) {
				
				ActualizarPuertoSerie = true;
			
			}
			
			//escribimos secuencia recibida
			
			write(fd_puertoserie, Str_Linea3recibida, 4);
			
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 3: %s\\n", LineaTexto3);
			}
		
		}
			
	}
	
	//////////////////////////////////////////////////////////////////////////////
	// Actualizar Línea 4: trama de caracteres terminada en Retorno de Carro 0Dh=13d y 04h=4d
	else if ((str_result[numbytes-2]==13) && (str_result[numbytes-1]==4)) {
					
		// Línea actual: sólo el primer bloque
		LineaCalcular = 4;
		BloqueCalcular = 1;
		
		// Si la línea tiene un plt no se actualiza
		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
		
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 4: no es posible en líneas con gráficos\\n", LineaTexto1);
			}
			
		}
		
		else {
			
			// Carga el formulario
			CargarVentanaModificarTexto();

			// Borra la línea actual
			for (i=0; i<(int)strlen(LineaTexto4[BloqueCalcular - 1]); i++) {
		
				// emula el botón de borrar
				cb_BotonBorrar(BotonBorrar, NULL);
			
			}
		
			//sustituye el CR por una terminación de string correcta		 
			str_result[numbytes-2]=0x00;
				
			// Procesa los caracteres
			for (i=0; i<(int)strlen(str_result); i++) {
		
				caracter = str_result[i];
				
				// Procesa el carácter
				if (CaracterValido(caracter)) {
				
					ProcesarCaracter(&caracter);
					
				}
				
			}
			
			// Emula el click en el botón de aceptar la modificación de texto
			cb_Aceptar_VentanaModificarTexto(Aceptar_VentanaModificarTexto, NULL);
				
			// y marca para actualizar si se está marcando
			if (ModoImpresionSerie == true) {
				
				ActualizarPuertoSerie = true;
			
			}
			//escribimos secuencia recibida
			
			write(fd_puertoserie, Str_Linea4recibida, 4);
			
			//debug
			if (debug_puertoserie) {
				rt_printk("Actualización de línea 4: %s\\n", LineaTexto4);
			}
			
		}
		
	}
	
	// si no es ninguno de los casos anteriores se ha recibido algo extraño...
	else {
			
		strcpy (StrParcial, str_result);
		
		if (debug_puertoserie) {
			rt_printk("Lectura del puerto serie incompleta:%s\\n", StrParcial);
		}
		
	
	}
		
}
	
//////////////////////////////////////////////////////////////////////////////
// Programa la siguiente ejecución del timer
Fl::repeat_timeout(PERIODO_PUERTOSERIE, ControlPuertoSerie);

return;} {selected
  }
} 

Function {CaracterValido(int num)} {C return_type bool
} {
  code {// Recibe el equivalente decimal de un código ascci y devuelve 
// True cuando es un carácter que el sistema puede procesar con sus fonts
// False cuando no es así

//printf("caracter: %d\\n", num);

// 0-9
if ((num >=48) && (num<=57)) {return true;}

// A-Z
else if ((num >= 65) && (num <= 90)) {return true;}

// + , .- . /
else if ((num >= 43) && (num <= 47)) {return true;}

// espacio
else if (num == 32) {return true;}

// :
else if (num == 58) {return true;}

// no es válido
else return false;} {}
} 

Function {Desactivar_PuertoSerie()} {C return_type int
} {
  code {// cierra el puerto y sale
close(fd_puertoserie);

// debug
if (debug_resto){
	
	printf("Saliendo-----------------Thread puerto serie\\n");

}

return 0;} {}
} 

Function {ProcesarError()} {C return_type void
} {
  code {////////////////////////////////////////////////////////////////////////////////////////////////////

if ((ErrorGalvos)
||(ErrorDAQ)
||(ErrorFPGA)
||(ErrorRTAI)
||(ErrorLaserOk)
||(ErrorTemperatura)
||(ErrorExtractor)
||(ErrorVectores)
||(ErrorWatchdog)
||(ErrorCampo)
||(ErrorEncoder)) {

	// Si estaba marcando detiene la ejecución, si el error es distinto del error de galvos
	if ((EnEjecucion) && (ErrorGalvos == false)) {
		
		StopEjecucion();
	
	}
	
	//Actualiza el Led de estado
	LedEstado->color((Fl_Color)1); 	// Led rojo
	LedEstado->redraw();		// Marca el Led para redraw

	// No permite marcar mientras esté activo el error (a no ser que estemos en desarrollo)
	//if (!ENDESARROLLO) {
		
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		
		if (ServicioTecnico) {
			BotonCampo->deactivate();
			BotonLaser->deactivate();
		}
			
	//}
	
	// Mensaje
	if (ErrorGalvos == ON) {
	
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Escáner");
			break; 
			
		case ING:
			LedEstado->label("Scanner");
			break;
			
		case ITA:
			LedEstado->label("Scanner");
			break;
			
		}
		
		// resetea el error
		ErrorGalvos = OFF;
	
	}	
		
	else if (ErrorDAQ == ON) {
	
		LedEstado->label("DAQ");
		//LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de DAQ
		
		// resetea el error
		ErrorDAQ = OFF;
	}	
	
	else if (ErrorFPGA == ON) {
	
		LedEstado->label("FPGA");
		//LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de DAQ
		
		// resetea el error
		ErrorFPGA = OFF;
	}
		
	else if (ErrorRTAI == ON) {
	
		LedEstado->label("RTAI");
		LedEstado->deactivate();// Desactiva el led, ya que no se puede recuperar de un error de RTAI
		
		// resetea el error
		ErrorRTAI = OFF;	
	}
		
	else if (ErrorLaserOk == ON) {
		
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Láser");
			break; 
			
		case ING:
			LedEstado->label("Laser");
			break;
			
		case ITA:
			LedEstado->label("Laser");
			break;
			
		}
		
		// resetea el error
		ErrorLaserOk = OFF;
	}
		
	else if (ErrorTemperatura == ON) {
		
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Temperatura");
			break; 
			
		case ING:
			LedEstado->label("Temperature");
			break;
			
		case ITA:
			LedEstado->label("Temperatura");
			break;
			
		}
		
		// resetea el error
		ErrorTemperatura = OFF;
	}
		
	else if (ErrorExtractor == ON) {
		
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Extractor");
			break; 
			
		case ING:
			LedEstado->label("Extractor");
			break;
			
		case ITA:
			LedEstado->label("Estrattore");
			break;
			
		}
		
		// resetea el error
		ErrorExtractor = OFF;
	}	

	else if (ErrorVectores == ON) {
		
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Vectores");
			break; 
			
		case ING:
			LedEstado->label("Vectors");
			break;
			
		case ITA:
			LedEstado->label("Vettori");
			break;
			
		}
		
		// resetea el error
		ErrorVectores = OFF;
	}

	else if (ErrorWatchdog == ON) {
		
		LedEstado->label("Watchdog");
		
		// resetea el error
		ErrorWatchdog = OFF;
	}	

	else if (ErrorCampo == ON) {
		
		switch (Idioma) {
			
		case ESP:
			LedEstado->label("Campo");
			break; 
			
		case ING:
			LedEstado->label("Field");
			break;
			
		case ITA:
			LedEstado->label("Campo");
			break;
			
		}
		
		// resetea el error
		//ErrorCampo = OFF;
	}

	else if (ErrorEncoder == ON) {
	
		LedEstado->label("Encoder");
		
		// resetea el error
		//ErrorEncoder = OFF;
	}
	
	// Redraw all
	//Fl::flush		

}

else if (ErrorValidacion) {

	//Actualiza el Led de estado
	LedEstado->color(FL_YELLOW); 	// Led amarillo
	LedEstado->redraw();		// Marca el Led para redraw

	// No permite marcar mientras esté activo el error (a no ser que estemos en desarrollo)
	if (!ENDESARROLLO) {
		
		BotonMarcar->deactivate();
			
	}
	
	//Actualiza el Led de estado
	switch (Idioma) {
	
	case ESP:
		LedEstado->label("Validación");
		break; 
			
	case ING:
		LedEstado->label("Validation");
		break; 
			
	case ITA:
		LedEstado->label("Convalida");
		break;
	
	}
	
}} {}
} 

Function {*timer_handler(void *args)} {C return_type {static void}
} {
  code {//==============================================================================
// TIMER EN TIEMPO REAL (RTAI)
// Crea el timer y mantiene el bucle de control del programa, llamando al algoritmo
// de control de la DAQ o a las rutinas de error de obturador/galvos cuando es necesario
//==============================================================================

int error = false;

// contador de ciclos
static long long ContadorCiclos = 0;

// Contador de ciclos que "llegaron tarde"
static long overrun = 0;
static long ov_RTE_UNBLKD = 0;
static long ov_RTE_TMROVRN = 0;
		
// Guarda el tiempo en el que terminó el ciclo anterior
static RTIME tAnterior;

// Guarda el tiempo en el que terminó el proceso del ciclo
static RTIME tProceso;

// Para obtener el tiempo y poder calcular la duración de los bucles
static RTIME tActual; 

// Variables para almacenar los valores de duración de ciclos
static double duracionCiclo = 0;
static double duracionCicloMax = 0;
static double duracionCicloMin = 1000000000;
static double duracionCicloPromedio = 0;

// histograma de duración de ciclos
static long long duracionCiclo_hist[7];
static float umbral_duracionCiclo[6];	//hay 6 umbrales para 7 rangos

// Variables para almacenar los valores de tiempo de proceso de ciclos
static double duracionProceso = 0;
static double duracionProcesoMax = 0;
static double duracionProcesoMin = 1000000000;
static double duracionProcesoPromedio = 0;

// histograma de duración de proceso
static long long duracionProceso_hist[7];
static float umbral_duracionProceso[6];	//hay 6 umbrales para 7 rangos

// Variables para almacenar los valores de tiempo de espera desde que termina el proceso hasta que empieza el siguiente ciclo
static double duracionEspera = 0;
static double duracionEsperaMax = 0;
static double duracionEsperaMin = 1000000000;
static double duracionEsperaPromedio = 0;

// histograma de duración de proceso
static long long duracionEspera_hist[7];
static float umbral_duracionEspera[6];	//hay 6 umbrales para 7 rangos

// Para leer el registro de status del puerto paralelo
static BYTE inbyte; 

// Control de tipos de bucles
static signed int result_wait;

// debug
if (debug_resto){
	printf("Entrando-----------------Thread RTAI\\n");
}

//rt_printk("EWOULDBLOCK=%d EINTR=%d ETIMEDOUT=%d EPERM=%d\\n",EWOULDBLOCK, EINTR, ETIMEDOUT, EPERM);

//rt_printk("RTE_UNBLKD=%d RTE_TMROVRN=%d\\n",RTE_UNBLKD, RTE_TMROVRN);

//ESTADISTICAS del tiempo de los ciclos: cálculo de umbrales de duración de ciclos
if (debug_ciclos) {

	umbral_duracionCiclo[0] = 0.5 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
	umbral_duracionCiclo[1] = 1.0 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
	umbral_duracionCiclo[2] = 1.5 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
	umbral_duracionCiclo[3] = 2.0 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
	umbral_duracionCiclo[4] = 2.5 * PERIODO_MICROSEGUNDOS * 1000; //250% del periodo en ns
	umbral_duracionCiclo[5] = 3.0 * PERIODO_MICROSEGUNDOS * 1000; //300% del periodo en ns
	
	umbral_duracionProceso[0] = 0.25 * PERIODO_MICROSEGUNDOS * 1000; //25% del periodo en ns
	umbral_duracionProceso[1] = 0.50 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
	umbral_duracionProceso[2] = 0.75 * PERIODO_MICROSEGUNDOS * 1000; //75% del periodo en ns
	umbral_duracionProceso[3] = 1.00 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
	umbral_duracionProceso[4] = 1.50 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
	umbral_duracionProceso[5] = 2.00 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
	
	umbral_duracionEspera[0] = 0.25 * PERIODO_MICROSEGUNDOS * 1000; //25% del periodo en ns
	umbral_duracionEspera[1] = 0.50 * PERIODO_MICROSEGUNDOS * 1000; //50% del periodo en ns
	umbral_duracionEspera[2] = 0.75 * PERIODO_MICROSEGUNDOS * 1000; //75% del periodo en ns
	umbral_duracionEspera[3] = 1.00 * PERIODO_MICROSEGUNDOS * 1000; //100% del periodo en ns
	umbral_duracionEspera[4] = 1.50 * PERIODO_MICROSEGUNDOS * 1000; //150% del periodo en ns
	umbral_duracionEspera[5] = 2.00 * PERIODO_MICROSEGUNDOS * 1000; //200% del periodo en ns
		
}
		
//static RT_TASK *timer_task_handler;
//static RTIME period;

if (!(timer_task_handler = rt_task_init(nam2num("TIMER"), 1, 0, 0))) {
	rt_printk("CANNOT INIT TASK > TIMER <\\n");
	ErrorRTAI = ON;
	ProcesarError();
}
	
// permite acceso a los recursos io
rt_allow_nonroot_hrt();
	
// se fija en memoria para evitar swap
mlockall(MCL_CURRENT | MCL_FUTURE);

// Modo periodico:
rt_set_periodic_mode();
//rt_set_oneshot_mode();

// Inicia el timer
Periodo = start_rt_timer(nano2count(PERIODO_MICROSEGUNDOS*1000));
 	
// HARD RT /////////////////////////////////////////////////////////////
rt_make_hard_real_time();

// Control del bucle while y sincronismo
endthread = OFF;
endhandler = OFF;
		
// Fija el inicio y el periodo de la tarea
rt_task_make_periodic(timer_task_handler, rt_get_time() + Periodo, Periodo);

//////////////////////////////////////////////////////////////////////////////////////////////////
// BUCLE DE CONTROL DEL PROGRAMA: ESTA ACTIVO DURANTE TODA LA VIDA DEL MISMO, MANTENIENDO EL TIMER
//////////////////////////////////////////////////////////////////////////////////////////////////

tAnterior = rt_get_cpu_time_ns();

while ( !endthread ) {
	
	// Lee las cuentas del encoder
	// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
	// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
	
	if (MarcajeDinamicoActivo == 1) {

		switch (Control) {

		case DAQ:
	
			// Leer las cuentas del encoder
			error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual);
			if (error < 0) {
				rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
				ErrorDAQ = ON;
				//ProcesarError();
			}
		
			break;

		case FPGA:

			// Leer las cuentas del encoder
			ValorCuentasActual = LeerCuentasEncoder_FPGA();
		
			break;	
	
		} 
		
	}
	
	///////////////////////////////////////////////////////////////////
	// EJECUCIÓN DE LISTAS
	///////////////////////////////////////////////////////////////////
	
	// Si las dos listas están en ejecución imprime un error:
	if ( (Lista1_Exe == true) && (Lista2_Exe == true) && (SistemaOk == true) ) {
		rt_printk("ERROR DE EJECUCIÓN SIMULTÁNEA DE LISTAS\\n"); 
	}
	
	// Ejecución Lista 0 para la rutina MoverGalvos
	else if ((Lista0_Exe == true) && (SistemaOk == true)) {
	
		//rt_printk("L0:%d L1:%d L2:%d\\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
		
		MarcajeOk = EjecutarMicrovector(0); // lista 0
	
	}
	
	// Ejecución Lista 1
	else if ((Lista1_Exe == true) && (SistemaOk == true) && (MarcajeOk == true)) {
		
		//rt_printk("L0:%d L1:%d L2:%d\\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
		
		// Espera fotocélula - sólo cuando no es prueba de marcaje y el disparo es externo
		if ((TipoDisparo == DISPAROEXTERNO) && (EsperaFotocelula == true) && (PruebaMarcaje == false)) {
		
			// Lee la señal de la fotocélula
			switch (Control) {

			case DAQ:
	
				error = comedi_dio_read(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, &FotocelulaDIValue);	
				if (error < 0) {
					rt_printk("comedi_dio_read Fotocelula error=%d Valor=%d\\n", error, FotocelulaDIValue);
					ErrorDAQ = ON;
					//StopEjecucion();
				}
		
				break;

			case FPGA:

				// Lee la señal de la fotocélula
				inbyte = inb(REGISTRO_STATUS);
			
				// En la fotocélula se lee -con la máscara- 32 cuando está conectada a tierra, 
				// y 0 cuando está conectada a 5V
				if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {FotocelulaDIValue = 0;}
				else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {FotocelulaDIValue = 1;}
				else FotocelulaDIValue = -1; // error
		
				break;	
	
			} 
			
			// DEBUG
			if (debug_fotocelula) {
				rt_printk("FotoCelula:%d\\n",FotocelulaDIValue);
			}
			
			// Si tiene el valor de disparo 
			if (FotocelulaDIValue == ValorDisparo) {
				LecturasConsecutivasDisparo++;
				//printf("%d\\n", LecturasConsecutivasDisparo);
			}
			else {
				LecturasConsecutivasDisparo=0;
			}
					
			// Si tiene el valor de disparo 
			if ((LecturasConsecutivasDisparo>=MinimoLecturasConsecutivasDisparo) && (FotocelulaDIValue == ValorDisparo)) {
			
				// Si ha cambiado antes de valor, es que ya se ha disparado
				if (CambioFotocelula == true) {
			
					EsperaFotocelula = false;
					CambioFotocelula = false;
					
					// Inicializa el encoder, si hay marcaje dinámico
					if (MarcajeDinamicoActivo == 1) {
						
						// Leer las cuentas del encoder en la variable "Anterior"
						//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
						//if (error < 0) {
						//	rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
						//	ErrorDAQ = ON;
						//	StopEjecucion();
						//}
					
						IncrementoAcumulado = 0;
						ValorCuentasAnterior = ValorCuentasActual;
					}
					
					// Actualiza la señal de MarkInProgress y el Led del láser
					ControlMarkInProgress(ON);
					
				}
	
			}
			
			// Si no tiene el valor de disparo el valor de la fotocélula ha cambiado
			else {
			
				// Resetea el flag
				CambioFotocelula = true;
				
			}	
	
		}
		
		// Disparo interno: comprueba si hay que seguir esperando
		else if ((TipoDisparo == DISPAROINTERNO) && (EsperaSeparacionEntreDisparos) && (PruebaMarcaje == false)) {
		
			// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
			// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
			if (MarcajeDinamicoActivo == 1) {
		
				ValorCuentasActual_Espera = ValorCuentasActual;
				
				// Calcular el incremento de cuentas
				if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
					IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
				}
				else { 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
					IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
					//StopEjecucion();
					//LedEstado->label("Encoder: overflow");
					rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
					return false;
				}
	
				// debug excesos del encoder
				if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
			
					//StopEjecucion();
			
					LedEstado->label("Encoder: incremento");
					rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
					return false;
		
				}
	
				// Guardar el valor leido para la próxima iteración
				ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
	
			}
	
			// Acumula las cuentas del periodo
			IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
	
			// Mira a ver si se ha sobrepasado ya las cuentas de espera
			if (IncrementoAcumulado_Espera >= SeparacionEntreDisparos_cuentas) {
			
				// ya no hay que entrar aquí hasta que se haya terminado la marca
				EsperaSeparacionEntreDisparos = false;
				
				// y vuelve a empezar a contar para la siguiente marca
				IncrementoAcumulado_Espera = 0;
				
				// Inicializa el encoder, si hay marcaje dinámico
				if (MarcajeDinamicoActivo == 1) {
						
					// Leer las cuentas del encoder en la variable "Anterior"
					//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
					//if (error < 0) {
					//	rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
					//	ErrorDAQ = ON;
					//	StopEjecucion();
					//}
					
					IncrementoAcumulado = 0;
					ValorCuentasAnterior = ValorCuentasActual;
				}
				
				// Actualiza la señal de MarkInProgress y el Led del láser
				ControlMarkInProgress(ON);
				
			}
			
			//DEBUG
			if (debug_espera == true) {
				rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
			}
	
		}
		
		// Si ya se ha disparado o es Prueba de Marcaje sigue con la ejecución de microvectores de la lista 1
		else {
			
			MarcajeOk = EjecutarMicrovector(1); // lista 1
			
			// Si hay disparo interno hay que seguir leyendo las cuentas
			if (TipoDisparo == DISPAROINTERNO) {
		
				// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
				// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
				if (MarcajeDinamicoActivo == 1) {
		
					ValorCuentasActual_Espera = ValorCuentasActual;
				
					// Calcular el incremento de cuentas
					if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
						IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
					}
					
					else { 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
						IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
						//StopEjecucion();
						//LedEstado->label("Encoder: overflow");
						rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
						return false;
					}
	
					// debug excesos del encoder
					if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
			
						//StopEjecucion();
			
						LedEstado->label("Encoder: incremento");
						rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
						return false;
		
					}
	
					// Guardar el valor leido para la próxima iteración
					ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
	
				}
	
				// Acumula las cuentas del periodo
				IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
			
			}
			
			//DEBUG
			if (debug_espera == true) {
				rt_printk("MV - Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
			}
			
		}
		
	}
	
	// Ejecución Lista 2
	else if ((Lista2_Exe == true) && (SistemaOk == true) && (MarcajeOk == true)) {
		
		//rt_printk("L0:%d L1:%d L2:%d\\n", Lista0_Exe, Lista1_Exe, Lista2_Exe);
		
		// Espera fotocélula - sólo cuando no es prueba de marcaje y el disparo es externo
		if ((TipoDisparo == DISPAROEXTERNO) && (EsperaFotocelula == true) && (PruebaMarcaje == false)) {
		
			// Lee la señal de la fotocélula
			switch (Control) {

			case DAQ:
	
				error = comedi_dio_read(comedi_device, comedi_subdevice_Fotocelula, comedi_canalDI_Fotocelula, &FotocelulaDIValue);	
				if (error < 0) {
					rt_printk("comedi_dio_read Fotocelula error=%d Valor=%d\\n", error, FotocelulaDIValue);
					ErrorDAQ = ON;
					//StopEjecucion();
				}
		
				break;

			case FPGA:

				// Lee la señal de la fotocélula
				inbyte = inb(REGISTRO_STATUS);
			
				// En la fotocélula se lee -con la máscara- 32 cuando está conectada a tierra, 
				// y 0 cuando está conectada a 5V
				if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 32) {FotocelulaDIValue = 0;}
				else if ((inbyte & MASCARA_ENTRADA_FOTOCELULA) == 0) {FotocelulaDIValue = 1;}
				else FotocelulaDIValue = -1; // error
		
				break;	
	
			} 
			
			// DEBUG
			if (debug_fotocelula) {
				rt_printk("FotoCelula:%d\\n",FotocelulaDIValue);
			}
			
			// Si tiene el valor de disparo 
			if (FotocelulaDIValue == ValorDisparo) {
				LecturasConsecutivasDisparo++;
				//printf("%d\\n", LecturasConsecutivasDisparo);
			}
			else {
				LecturasConsecutivasDisparo=0;
			}
					
			// Si tiene el valor de disparo 
			if ((LecturasConsecutivasDisparo>=MinimoLecturasConsecutivasDisparo) && (FotocelulaDIValue == ValorDisparo)) {
			
				// Si ha cambiado antes de valor, es que ya se ha disparado
				if (CambioFotocelula == true) {
					
					EsperaFotocelula = false;
					CambioFotocelula = false;
			
					// Inicializa el encoder, si hay marcaje dinámico
					if (MarcajeDinamicoActivo == 1) {
						
						// Leer las cuentas del encoder en la variable "Anterior"
						//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
						//if (error < 0) {
						//	rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
						//	ErrorDAQ = ON;
						//	StopEjecucion();
						//}
						
						IncrementoAcumulado = 0;
						ValorCuentasAnterior = ValorCuentasActual;
					}
					
					// Actualiza la señal de MarkInProgress y el Led del láser
					ControlMarkInProgress(ON);
					
				}
	
			}
			
			// Si no tiene el valor de disparo el valor de la fotocélula ha cambiado
			else {
			
				// Resetea el flag
				CambioFotocelula = true;
				
			}	
	
		}
		
		// Disparo interno: comprueba si hay que seguir esperando
		else if ((TipoDisparo == DISPAROINTERNO) && (EsperaSeparacionEntreDisparos) && (PruebaMarcaje == false)) {
		
			// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
			// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
			if (MarcajeDinamicoActivo == 1) {
		
				ValorCuentasActual_Espera = ValorCuentasActual;
				
				// Calcular el incremento de cuentas
				if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
					IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
				}
				else { 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
					IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
					//StopEjecucion();
					//LedEstado->label("Encoder: overflow");
					rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
					return false;
				}
	
				// debug excesos del encoder
				if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
			
					//StopEjecucion();
			
					LedEstado->label("Encoder: incremento");
					rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
					return false;
		
				}
	
				// Guardar el valor leido para la próxima iteración
				ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
	
			}
	
			// Acumula las cuentas del periodo
			IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
	
			// Mira a ver si se ha sobrepasado ya las cuentas de espera
			if (IncrementoAcumulado_Espera >= SeparacionEntreDisparos_cuentas) {
			
				// ya no hay que entrar aquí hasta que se haya terminado la marca
				EsperaSeparacionEntreDisparos = false;
				
				// y vuelve a empezar a contar para la siguiente marca
				IncrementoAcumulado_Espera = 0;
				
				// Inicializa el encoder, si hay marcaje dinámico
				if (MarcajeDinamicoActivo == 1) {
						
					// Leer las cuentas del encoder en la variable "Anterior"
					//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior);
					//if (error < 0) {
					//	rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
					//	ErrorDAQ = ON;
					//	StopEjecucion();
					//}
					
					IncrementoAcumulado = 0;
					ValorCuentasAnterior = ValorCuentasActual;
				}
				
				// Actualiza la señal de MarkInProgress y el Led del láser
				ControlMarkInProgress(ON);
							
			}
			
			//DEBUG
			if (debug_espera == true) {
				rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
			}
	
		}
		
		// Si ya se ha disparado o es Prueba de Marcaje sigue con la ejecución de microvectores de la lista 2
		else {
			
			MarcajeOk = EjecutarMicrovector(2); // lista 2	
			
			// Si hay disparo interno hay que seguir leyendo las cuentas
			if (TipoDisparo == DISPAROINTERNO) {
		
				// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
				// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
				if (MarcajeDinamicoActivo == 1) {
		
					ValorCuentasActual_Espera = ValorCuentasActual;
				
					// Calcular el incremento de cuentas
					if (ValorCuentasActual_Espera >= ValorCuentasAnterior_Espera) {
						IncrementoCuentasPeriodo = (float)(ValorCuentasActual_Espera - ValorCuentasAnterior_Espera);
					}
					
					else { 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
						IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior_Espera) + ValorCuentasActual_Espera);
						//StopEjecucion();
						//LedEstado->label("Encoder: overflow");
						rt_printk("OVERFLOW Actual:%d INCR:%f ACUM:%d\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
						return false;
					}
	
					// debug excesos del encoder
					if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado_Espera<0))) {
			
						//StopEjecucion();
			
						LedEstado->label("Encoder: incremento");
						rt_printk("Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual_Espera, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
						return false;
		
					}
	
					// Guardar el valor leido para la próxima iteración
					ValorCuentasAnterior_Espera = ValorCuentasActual_Espera;
	
				}
	
				// Acumula las cuentas del periodo
				IncrementoAcumulado_Espera += IncrementoCuentasPeriodo;
			
			}
			
			//DEBUG
			if (debug_espera == true) {
				rt_printk("MV - Actual:%d INCR:%f ACUM:%f\\n", ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado_Espera);
			}
					
		}
		
	}
	
	// Si se ha salido por algun problema de estado detener el proceso
	//if ( (SistemaOk == false) && ((EnEjecucion) || (PruebaMarcaje)) ) {
		
	//	rt_printk("SistemaOk: %d\\n", SistemaOk);
		//StopEjecucion();

	//}

	//if ((MarcajeOk == false) && ((EnEjecucion) || (PruebaMarcaje)) ){
	//	rt_printk("MarcajeOk: %d\\n", MarcajeOk);
		
		// Guarda el tiempo de fin de la marca si el marcaje se ha interrumpido por algún problema
	//	tFinMarca = rt_get_time_ns();
	
	//	StopEjecucion();
		//ProcesarError();
		//error = false;
	//}
		
	//ESTADISTICAS del tiempo de los ciclos
	if (debug_ciclos) {
		
		// Guarda el tiempo del término del proceso
		tProceso = rt_get_cpu_time_ns();
		
	}
	
	//////////////////////////////////////////////////////////////////
	//ESPERA EL TIEMPO CORRESPONDIENTE A UN PERIODO
	result_wait = rt_task_wait_period();
	  
	if (result_wait && debug_ciclos) {
		
		overrun++;
		
		//rt_printk("overrun=%ld result_wait=%ld\\n",overrun,result_wait);
		
		if (result_wait == RTE_UNBLKD) {ov_RTE_UNBLKD++;}
		else if (result_wait == RTE_TMROVRN) {ov_RTE_TMROVRN++;}
		
	}
	
	//////////////////////////////////////////////////////////////////		
	//ESTADISTICAS del tiempo de los ciclos
	if (debug_ciclos) {
		
		// Calcula la duración del ciclo
		tActual = rt_get_cpu_time_ns();
		
		// Actualiza el contador de iteraciones
		ContadorCiclos++;
		
		// Duraciones
		duracionCiclo = (double)(tActual - tAnterior);
		duracionProceso = (double)(tProceso - tAnterior);
		duracionEspera = (double)(tActual - tProceso);
		
		// Promedios, máximos y mínimos
		duracionCicloPromedio += duracionCiclo;
		duracionProcesoPromedio += duracionProceso;
		duracionEsperaPromedio += duracionEspera;
			
		// detecta máximo y mínimo
		if (duracionCiclo > duracionCicloMax) duracionCicloMax = duracionCiclo;
		if (duracionCiclo < duracionCicloMin) duracionCicloMin = duracionCiclo;
		
		if (duracionProceso > duracionProcesoMax) duracionProcesoMax = duracionProceso;
		if (duracionProceso < duracionProcesoMin) duracionProcesoMin = duracionProceso;
		
		if (duracionEspera > duracionEsperaMax) duracionEsperaMax = duracionEspera;
		if (duracionEspera < duracionEsperaMin) duracionEsperaMin = duracionEspera;
		
		// Histogramas
		// duración de ciclos:
		if (duracionCiclo <= umbral_duracionCiclo[0]) {duracionCiclo_hist[0]++;}
		else if (duracionCiclo <= umbral_duracionCiclo[1]) {duracionCiclo_hist[1]++;}
		else if (duracionCiclo <= umbral_duracionCiclo[2]) {duracionCiclo_hist[2]++;}
		else if (duracionCiclo <= umbral_duracionCiclo[3]) {duracionCiclo_hist[3]++;}
		else if (duracionCiclo <= umbral_duracionCiclo[4]) {duracionCiclo_hist[4]++;}
		else if (duracionCiclo <= umbral_duracionCiclo[5]) {duracionCiclo_hist[5]++;}
		else {duracionCiclo_hist[6]++;}
		
		// duración de proceso:
		if (duracionProceso <= umbral_duracionProceso[0]) {duracionProceso_hist[0]++;}
		else if (duracionProceso <= umbral_duracionProceso[1]) {duracionProceso_hist[1]++;}
		else if (duracionProceso <= umbral_duracionProceso[2]) {duracionProceso_hist[2]++;}
		else if (duracionProceso <= umbral_duracionProceso[3]) {duracionProceso_hist[3]++;}
		else if (duracionProceso <= umbral_duracionProceso[4]) {duracionProceso_hist[4]++;}
		else if (duracionProceso <= umbral_duracionProceso[5]) {duracionProceso_hist[5]++;}
		else {duracionProceso_hist[6]++;}

		// duración de espera:
		if (duracionEspera <= umbral_duracionCiclo[0]) {duracionEspera_hist[0]++;}
		else if (duracionEspera <= umbral_duracionEspera[1]) {duracionEspera_hist[1]++;}
		else if (duracionEspera <= umbral_duracionEspera[2]) {duracionEspera_hist[2]++;}
		else if (duracionEspera <= umbral_duracionEspera[3]) {duracionEspera_hist[3]++;}
		else if (duracionEspera <= umbral_duracionEspera[4]) {duracionEspera_hist[4]++;}
		else if (duracionEspera <= umbral_duracionEspera[5]) {duracionEspera_hist[5]++;}
		else {duracionEspera_hist[6]++;}
							
		// Guarda el tiempo de inicio del siguiente ciclo			
		tAnterior = tActual;
		//tAnterior = rt_get_cpu_time_ns();
		
	}
		
}

// Detiene el timer
stop_rt_timer();
	
// SOFT RT /////////////////////////////////////////////////////////////
rt_make_soft_real_time();
rt_task_delete(timer_task_handler);
endhandler = ON;
	
//ESTADISTICAS del tiempo de los ciclos
if (debug_ciclos) {
	rt_printk("\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\n");
	rt_printk("Ciclos:%lld Overrun:%ld(%.2f) RTE_UNBLKD:%ld RTE_TMROVRN:%ld\\n", ContadorCiclos, overrun, (float)overrun/(float)ContadorCiclos, ov_RTE_UNBLKD, ov_RTE_TMROVRN);
	
	rt_printk("\\nDuración Ciclos (ns): Promedio:%f Max:%f Min:%f\\n", duracionCicloPromedio/ContadorCiclos, duracionCicloMax, duracionCicloMin);
	rt_printk("Duración inferior a un porcentaje del periodo (%):\\n");
	rt_printk("<50:%lld(%.2f) <100:%lld(%.2f) <150:%lld(%.2f) <200:%lld(%.2f) \\n<250:%lld(%.2f) <300:%lld(%.2f) >300:%lld(%.2f)\\n", duracionCiclo_hist[0], (float)duracionCiclo_hist[0]/ContadorCiclos, duracionCiclo_hist[1], (float)duracionCiclo_hist[1]/ContadorCiclos, duracionCiclo_hist[2], (float)duracionCiclo_hist[2]/ContadorCiclos, duracionCiclo_hist[3], (float)duracionCiclo_hist[3]/ContadorCiclos, duracionCiclo_hist[4], (float)duracionCiclo_hist[4]/ContadorCiclos, duracionCiclo_hist[5], (float)duracionCiclo_hist[5]/ContadorCiclos, duracionCiclo_hist[6], (float)duracionCiclo_hist[6]/ContadorCiclos);
	
	rt_printk("\\nDuración Proceso (ns): Promedio:%f Max:%f Min:%f\\n", duracionProcesoPromedio/ContadorCiclos, duracionProcesoMax, duracionProcesoMin);
	rt_printk("Duración inferior a un porcentaje del periodo (%):\\n");
	rt_printk("<25:%lld(%.2f) <50:%lld(%.2f) <75:%lld(%.2f) <100:%lld(%.2f) \\n<150:%lld(%.2f) <200:%lld(%.2f) >200:%lld(%.2f)\\n", duracionProceso_hist[0], (float)duracionProceso_hist[0]/ContadorCiclos, duracionProceso_hist[1], (float)duracionProceso_hist[1]/ContadorCiclos, duracionProceso_hist[2], (float)duracionProceso_hist[2]/ContadorCiclos, duracionProceso_hist[3], (float)duracionProceso_hist[3]/ContadorCiclos, duracionProceso_hist[4], (float)duracionProceso_hist[4]/ContadorCiclos, duracionProceso_hist[5], (float)duracionProceso_hist[5]/ContadorCiclos, duracionProceso_hist[6], (float)duracionProceso_hist[6]/ContadorCiclos);
	
	rt_printk("\\nDuración Espera (ns): Promedio:%f Max:%f Min:%f\\n", duracionEsperaPromedio/ContadorCiclos, duracionEsperaMax, duracionEsperaMin);
	rt_printk("Duración inferior a un porcentaje del periodo (%):\\n");
	rt_printk("<25:%lld(%.2f) <50:%lld(%.2f) <75:%lld(%.2f) <100:%lld(%.2f) \\n<150:%lld(%.2f) <200:%lld(%.2f) >200:%lld(%.2f)\\n", duracionEspera_hist[0], (float)duracionEspera_hist[0]/ContadorCiclos, duracionEspera_hist[1], (float)duracionEspera_hist[1]/ContadorCiclos, duracionEspera_hist[2], (float)duracionEspera_hist[2]/ContadorCiclos, duracionEspera_hist[3], (float)duracionEspera_hist[3]/ContadorCiclos, duracionEspera_hist[4], (float)duracionEspera_hist[4]/ContadorCiclos, duracionEspera_hist[5], (float)duracionEspera_hist[5]/ContadorCiclos, duracionEspera_hist[6], (float)duracionEspera_hist[6]/ContadorCiclos);
	
	rt_printk("\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\n");
}	

return 0;} {}
} 

Function {Inicializar_Laser()} {C return_type int
} {
  code {int error = false;

// debug
if (debug_resto)\{
	printf("Entrando-----------------Inicializar_laser\\n");
\}

// Calcula los ticks del tren de pulsos: sólo dependen de la frecuencia del reloj de la DAQ/FPGA, que se
// ha definido al inicializar el control
Laser_Up_Ticks = (unsigned short int)((PeriodoTrenPulsos*10*PotenciaLaser) + Clock_Period_ns / 2) / Clock_Period_ns;
Laser_Down_Ticks = (unsigned short int)((PeriodoTrenPulsos*1000) + Clock_Period_ns / 2) / Clock_Period_ns - Laser_Up_Ticks;

switch (Control) \{

case DAQ:
	
	// Escribe en la salida digital la señal de Laser Enable
	error = comedi_dio_write(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, ON);	
	if (error < 0) \{
		rt_printk("comedi_dio_write error = %d - Laser Enable ON\\n",error);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	// Resetea el contador
	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
	if (error < 0)\{
		rt_printk("ERROR comedi_reset comedi_subdevice_ContadorLaser\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	/*
	
	// configura la señal gate
	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
	if (error < 0)\{
		rt_printk("ERROR comedi_set_gate_source 0\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}
	
	*/

	// configuración del contador
	Counter_Mode = NI_GPCT_COUNTING_MODE_NORMAL_BITS;

	// toggle output on terminal count
	Counter_Mode |= NI_GPCT_OUTPUT_TC_TOGGLE_BITS;

	// load on terminal count
	Counter_Mode |= NI_GPCT_LOADING_ON_TC_BIT;

	// alternate the reload source between the load a and load b registers
	Counter_Mode |= NI_GPCT_RELOAD_SOURCE_SWITCHING_BITS;

	// count down
	Counter_Mode |= NI_GPCT_COUNTING_DIRECTION_DOWN_BITS;

	// initialize load source as load b register
	Counter_Mode |= NI_GPCT_LOAD_B_SELECT_BIT;

	// don't stop on terminal count
	Counter_Mode |= NI_GPCT_STOP_ON_GATE_BITS;

	// don't disarm on terminal count or gate signal
	Counter_Mode |= NI_GPCT_NO_HARDWARE_DISARM_BITS;


	/*

	// configura el modo del contador
	error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
	if (error < 0)\{
		rt_printk("ERROR comedi_set_counter_mode\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	*/

	// Hay que enrutar la salida del contador
	error = itaca_comedi_set_routing(comedi_device, comedi_subdevice_ContadorLaser_DO, comedi_canalDO_ContadorLaser, comedi_ContadorLaser_Routing);
	if (error < 0)\{
		rt_printk("ERROR %d comedi_set_routing\\n", error);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	// y configurar el canal digital de salida
	error = comedi_dio_config(comedi_device, comedi_subdevice_ContadorLaser_DO, comedi_canalDO_ContadorLaser, COMEDI_OUTPUT);
	if(error < 0)\{
		rt_printk("ERROR comedi_dio_config OUTPUT canal contador %d\\n", comedi_canalDO_ContadorLaser);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	/*

	// asigna el reloj: 20MHz clock
	error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
	if (error < 0)\{
		rt_printk("ERROR comedi_set_clock_source\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
	if (Laser_Down_Ticks == 0) \{Laser_Down_Ticks=1;\}

	printf("=========Laser counter: up_ticks=%d	down_ticks=%d\\n", laser_up_ticks, laser_down_ticks);

	// set initial counter value by writing to channel 0
	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, laser_down_ticks);
	if (error < 0)\{
		rt_printk("ERROR comedi_data_write down_ticks inicial\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	// set "load a" register to the number of clock ticks the counter output should remain low
	// by writing to channel 1.
	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, laser_down_ticks);
	if (error < 0)\{
		rt_printk("ERROR comedi_data_write down_ticks load a\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	// set "load b" register to the number of clock ticks the counter output should remain high
	//by writing to channel 2
	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, laser_up_ticks);
	if (error < 0)\{
		rt_printk("ERROR comedi_data_write up_ticks load b\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}

	error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
	if (error < 0)\{
		printf("ERROR comedi_arm\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	\}
	// Si el láser es de fibra usamos la señal de activación de galvos para activar el oscilador
	// Escribe en la salida digital la señal de activación de galvos, primero Desactiva y luego Activa

	//if (TipoLaser==2)\{ //laser de fibra

		error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, LOW);//ValorActivacionGalvos);	
		sleep(1);
	
		error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);//ValorActivacionGalvos);	
	
		if(error < 0)\{
			rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \\n",error);
			ErrorDAQ = ON;
			ProcesarError();
		return -1;
		\}
	*/	
	break;

case FPGA:

	// Asegura que el láser está apagado
	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);

	// Escribe la señal de Laser Enable
	outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);

	//rt_printk("Laser_Up_Ticks=%d	Laser_Down_Ticks=%d\\n", Laser_Up_Ticks, Laser_Down_Ticks);

	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
	// if (laser_down_ticks == 0) \{laser_down_ticks=1;\}

	// Envía los datos de los ticks del tren de pulsos

	// Ticks Laser Up:

	// Byte menos significativo (LSB)
	outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);

	// comando LSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);

	// Byte más significativo (MSB)
	outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

	// comando MSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);

	// Ticks Laser Down:

	// Byte menos significativo (LSB)
	outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);

	// comando LSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);

	// Byte más significativo (MSB)
	outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

	// comando MSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);
	
	break;
	
\} 



// debug
if (debug_resto)\{
	printf("Saliendo-----------------Inicializar_laser\\n");
\}

return error;} {}
} 

Function {Desactivar_Laser()} {C return_type int
} {
  code {int error = false;

switch (Control) {

case DAQ:
	
	// Escribe en la salida digital la señal de Laser Enable
	error = comedi_dio_write(comedi_device, comedi_subdevice_LaserEnable, comedi_canalDO_LaserEnable, OFF);	
	if (error < 0) {
		rt_printk("comedi_dio_write error = %d\\n - Laser Enable OFF",error);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
	if (error < 0){
		rt_printk("ERROR comedi_reset laser\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	break;

case FPGA:

	// Asegura que el láser está apagado
	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);

	// Escribe la señal de Laser Enable
	outb((COMANDO_LASER_ENABLE|0x00), REGISTRO_ADDR);
	
	break;
	
} 

return error;} {}
} 

Function {Control_Laser(int OnOff)} {open C return_type int
} {
  code {int error = false;

// Enciende o apaga el láser, en función del valor del parámetro de entrada OnOff

switch (Control) {

case DAQ:
	
	switch (OnOff) {

	case ON: 
		
		switch(TipoLaser){
		
		case 0: 
			// configura la señal gate
			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
			if (error < 0){
				rt_printk("ERROR comedi_set_gate_source 0 laser\\n");
				error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);		
				if (error<0){
					rt_printk("ERROR comedi_set_gate_source 0 laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}
	
			// configura el modo del contador
			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
			if (error < 0){
				rt_printk("ERROR comedi_set_counter_mode laser\\n");
				error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);				
				if (error<0){
					rt_printk("ERROR comedi_set_counter_mode laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}

			// asigna el reloj: 20MHz clock
			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
			if (error < 0){
				rt_printk("ERROR comedi_set_clock_source laser\\n");
				error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
				if (error<0){
					rt_printk("ERROR comedi_set_clock_source laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}

			// set initial counter value by writing to channel 0
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks inicial laser\\n");
				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
				ErrorDAQ = ON;
				if (error<0){
					rt_printk("ERROR comedi_data_write down_ticks inicial laser consecutivo\\n");
					ErrorDAQ=ON;
					ProcesarError();
					return -1;
				}
			}

			// set "load a" register to the number of clock ticks the counter output should remain low
			// by writing to channel 1.
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks load a laser\\n");
				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
				if (error<0){
					rt_printk("ERROR comedi_data_write down_ticks load a laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}

			// set "load b" register to the number of clock ticks the counter output should remain high
			//by writing to channel 2
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write up_ticks load b laser\\n");
				error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
				if (error<0){
					rt_printk("ERROR comedi_data_write up_ticks load b laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}
	
			// arma el contador
			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
			if (error < 0){
				rt_printk("ERROR comedi_arm laser\\n");
				error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
				if (error<0){
					rt_printk("ERROR comedi_arm laser consecutivo\\n");
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}
			break;
				
			case 1:
			
		
			// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - Mark In Progress On\\n",error);
			// Volvemos a intentarlo si hay error
				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
				if (error < 0) {
					rt_printk("comedi_dio_write error = %d - Mark In Progress On consecutivo\\n",error);	
			// Y todavia una tercera vez
					error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);
					if (error<0){
						ErrorDAQ = ON;
						ProcesarError();
						//return -1;
					}
				}
			}

			// Actualiza el Led del láser a rojo
			//LedLaser->color(FL_RED);	// Led rojo
		
		
			break;
		
		}
	
		break;	
	
	case OFF:
		
		switch(TipoLaser){
			case 0:
			
			// Resetea el contador
			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
			if (error < 0){
				rt_printk("ERROR comedi_reset laser %d\\n", error);
				error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
				if (error<0){
					rt_printk("ERROR comedi_reset laser consecutivo %d\\n", error);
					ErrorDAQ = ON;
					ProcesarError();
					return -1;
				}
			}
			break;
			
			case 1:
		
			
			// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - Mark In Progress Off\\n",error);
				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
				if (error < 0) {
					rt_printk("comedi_dio_write error = %d - Mark In Progress Off\\n",error);
					error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);
					if (error<0){
						rt_printk("comedi_dio_write error = %d - Mark In Progress Off\\n",error);
						ErrorDAQ = ON;
						ProcesarError();
						//return -1;
					}
				}
			}
		
			// Actualiza el Led del láser a verde
			//LedLaser->color(FL_GREEN);	// Led verde
		
		
			break;
		}
	
		break;
	}
	
	break;

case FPGA:

	switch (OnOff) {

	case ON: 

		// Enciende el láser
		outb((COMANDO_LASER|0x01), REGISTRO_ADDR);
		break;
	
	case OFF:
	
		// Apaga el láser
		outb((COMANDO_LASER|0x00), REGISTRO_ADDR);
		break;
	
	}

	break;
	
} 	

// DEBUG
if (debug_Mvectores) {
	rt_printk("Control_Laser::MV %ld OnOff:%d EstadoLaser:%d \\n", MicroVector, OnOff, EstadoLaser);
}

// Actualiza el estado
EstadoLaser = OnOff;
	
return error;} {}
} 

Function {Inicializar_Encoder()} {C return_type int
} {
  code {int error = false;
lsampl_t counter_mode;
static const unsigned initial_count = 0;

// debug
if (debug_resto){
	printf("Entrando-----------------Inicializar_Encoder\\n");
}

// Inicializa las variables para la lectura de las cuentas del encoder
ValorCuentasActual = 0;
ValorCuentasAnterior = 0;
IncrementoAcumulado = 0;
	
switch (Control) {

case DAQ:
	
	// Resetea el contador
	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorEncoder);
	if (error < 0){
		rt_printk("ERROR comedi_reset inicializar encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	// Obtiene el máximo
	MaxdataContadorEncoder = comedi_get_maxdata(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal);

	// Conexión de los pulsos del encoder
	error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorEncoder, NI_GPCT_PFI_CLOCK_SRC_BITS(SOURCE_PFI_CHANNEL), 0);
	if (error < 0){
		rt_printk("ERROR comedi_set_clock_source encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	// Y configurar el canal de entrada
	error = comedi_dio_config(comedi_device, comedi_subdevice_ContadorEncoder_DI, comedi_canalDI_ContadorEncoder, COMEDI_INPUT);
	if(error < 0){
		rt_printk("ERROR comedi_dio_config INPUT canal encoder %d\\n", comedi_canalDI_ContadorEncoder);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	//error = comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, NI_GPCT_GATE_PIN_GATE_SELECT(0) /* NI_GPCT_GATE_PIN_i_GATE_SELECT *//*| CR_EDGE*/);
	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
	if (error < 0){
		rt_printk("ERROR comedi_set_gate_source 0 encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}
		
	error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorEncoder, 0, 1, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
	if (error < 0){
		rt_printk("ERROR comedi_set_gate_source 1 encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	// configuración del contador
	counter_mode = NI_GPCT_COUNTING_MODE_NORMAL_BITS;

	// output pulse on terminal count (doesn't really matter for this application)
	counter_mode |= NI_GPCT_OUTPUT_TC_PULSE_BITS;

	// Don't alternate the reload source between the load a and load b registers.

	// Doesn't really matter here, since we aren't going to be reloading the counter.
	counter_mode |= NI_GPCT_RELOAD_SOURCE_FIXED_BITS;

	// count up
	counter_mode |= NI_GPCT_COUNTING_DIRECTION_UP_BITS;

	// don't stop on terminal count
	counter_mode |= NI_GPCT_STOP_ON_GATE_BITS;

	// don't disarm on terminal count or gate signal
	counter_mode |= NI_GPCT_NO_HARDWARE_DISARM_BITS;

	error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorEncoder, 0, counter_mode);
	if (error < 0){
		rt_printk("ERROR comedi_set_counter_mode encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	/* set initial counter value by writing to channel 0.  The "load a" and "load b" registers can be
	set by writing to channels 1 and 2 respectively. */
	error = comedi_data_write(comedi_device, comedi_subdevice_ContadorEncoder, 0, 0, 0, initial_count);

	error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorEncoder, NI_GPCT_ARM_IMMEDIATE);
	if (error < 0){
 		rt_printk("ERROR itaca_comedi_arm encoder\\n");
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}
	
	break;

case FPGA:

	// Inicializa el encoder
	outb((COMANDO_ENCODER|0x01), REGISTRO_ADDR);

	break;
	
} 



// debug
if (debug_resto){
	printf("Saliendo-----------------Inicializar_Encoder\\n");
}

return error;} {}
} 

Function {Desactivar_Encoder()} {C return_type int
} {
  code {int error = false;

switch (Control) {

case DAQ:
	
	error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorEncoder);
	if (error < 0){
		rt_printk("ERROR comedi_reset desactivar encoder %d\\n", error);
		ErrorDAQ = ON;
		ProcesarError();
		return -1;
	}

	break;

case FPGA:

	// Inicializa el encoder
	outb((COMANDO_ENCODER|0x00), REGISTRO_ADDR);
	
	break;
	
} 


return error;} {}
} 

Function {CalcularMatriz()} {C return_type int
} {
  code {// Selecciona la rutina de calcular matriz adecuada, en función de la estrategia de marcaje
int retval;

// Abre y lee el archivo de fuentes si no se había hecho antes
if (ArchivoFuentesAbierto == false) {
    
    // Se rellenan el array ArchivoFuentes y las variables xMaxFont e yMaxFont
    LeerArchivoFuentes();
    ArchivoFuentesAbierto = true;

}

switch (Estrategia) {
        
        case 0:	// Carácter
        	
        	retval = CalcularMatrizCaracter();
        	break;
        	
        case 1:	// Átomos
        	
        	retval = CalcularMatrizAtomos();
        	break;
        	
        case 2:	// Átomos fuera de campo
        	
        	retval = CalcularMatrizFueraCampo();
        	break;	
        	
        case 3:	// Componer        	
        	retval = CalcularMatrizComponer();
        	break;		
}

// Si ha habido un error calculando la matriz detiene llama a Stop
if (retval) {

	StopEjecucion();

}

return retval;} {}
} 

Function {CalcularMatrizCaracter()} {C return_type int
} {
  code {// Calcula la matriz incluyendo códigos de barras y archivos .plt

unsigned long i,k;			// variable para indexar las líneas de texto
int j;					// variable para indexar los caracteres de una línea
int b;					// variable para indexar los bloques de una línea
char caracter;				// variables de proceso
float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
double orientacion_radianes, seno, coseno, x, y;
bool primero_polilinea, ultimo_polilinea; // para empezar la línea por el final, si cabe
int fila, columna, offsetvectores;
unsigned int NumeroVectoresCelda;
int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;

// Inicialización
NumeroVectores = 0;
AnchuraLineaTexto = 0;
AnchuraLineaTextoMaxima = 0;
AlturaLineaTexto = 0;
AlturaLineaTextoMaxima = 0;
AlturaTotalMarca = 0;
AlturaTextoAcumulada = 0;
FueraLimites = false;
tempValuesLinea1 = 0;
tempValuesLinea2 = 0;
tempValuesLinea3 = 0;
tempValuesLinea4 = 0;
tempvalueslinea_inicio = 0;
tempvalueslinea_fin = 0;
xoffset = 0;
yoffset = 0;
pltDemasiadoGrande = false;
pltIncorrecto = false;

// Proceso de cada línea
for (i=1; i<=NumeroLineasTexto; i++) {
	           
	// Inicialización
	AnchuraCaracterAnterior = 0;
        
	// Almacena el número de la línea que se está calculando
        LineaCalcular = i;
     
     	// Proceso de cada bloque
	for (b=1; b<=NumeroBloques; b++) {
	                  
	        // Almacena el número del bloque que se está calculando
        	BloqueCalcular = b;
        	
        	if (debug_vectores) {
        		printf("CalcularMatrizCaracter - NumeroLineasTexto:%d  Línea:%ld Bloque:%d\\n", NumeroLineasTexto, i, b);
        	}
        	
	        ///////////////////////////////////////////////////////////////////////////////////
		// Cálculo de los vectores de los caracteres
	        ///////////////////////////////////////////////////////////////////////////////////
        	switch (LineaCalcular) {
        
	        case 1:	// Línea 1
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
        	
        		break;
        	
	        case 2:	// Línea 2
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
        	
        		break;
        	
	        case 3:	// Línea 3
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
        	
        		break;	
        		
        	case 4:	// Línea 4
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
        	
        		break;	
        	
	        } //del switch que asigna variables de proceso
                
        	// Procesa la línea
        
	       	if (debug_vectores) {
       			printf("LineaTexto:%s  AlturaLineaTexto:%f \\n", LineaTexto, AlturaLineaTexto);
       		}
        	
	       	// Tipo de línea: texto
       		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
        	
       			if (strlen(LineaTexto) > 0) {
        		
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
			
       				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       	        			// Encuentra los parámetros del carácter
	        	        	caracter = LineaTexto[j];
       		        		EncontrarParametros (caracter);
        	        		
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            	
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        		
        		}
        		
        		else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
	        		AlturaLineaTexto = 0;
        		}
        		
	        }
        	
        	// Tipo de línea: gráfico
	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
        	
        		// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
			}
			
        		EncontrarParametrosPlt();
        		AnchuraLineaTexto = AnchuraCaracterAnterior;
        		
	        }
        	
        	// Tipo de línea: texto circular
       		else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {
        	
       			if (strlen(LineaTexto) > 0) {
        		
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
			
       				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       	        			// Encuentra los parámetros del carácter
	        	        	caracter = LineaTexto[j];
       		        		EncontrarParametros (caracter);
        	        		
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            	
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        		
        		}
        		
        		else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
	        		AlturaLineaTexto = 0;
        		}
        		
	        }

        		
        	// Tipo de línea: código de barras
	        else {
        		
        		if (strlen(LineaTexto) > 0) {
        		
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
        			EncontrarParametrosBarcode();
              			AnchuraLineaTexto = AnchuraCaracterAnterior; 
       			
	      		}
       			
       			else {
       			
       				//AnchuraLineaTexto = AnchuraLineaTexto;
      				AlturaLineaTexto = 0;
       			}
       				
        	}
       
	       	
        
        } // Siguiente bloque
        
        // Procesa la línea formada por los 3 bloques
        
        // Guarda la anchura de la línea y el índice del último vector
        switch (LineaCalcular) {
        
	case 1:	// Línea 1
        	
        	// Guarda la anchura y altura de la línea
	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
	   
	        // la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                }
                else {
                	alturalineatexto1 = AlturaLineaTexto1[0];
                }
                
                AlturaLineaTexto = alturalineatexto1;

        	// Y guarda el valor del último vector de la línea
            	if (NumeroVectores > 0) {
		       	tempValuesLinea1 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea1 = -1;
        	}
        	    	            	
	        break;
        
        case 2:	// Línea 2
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto2 = AnchuraLineaTexto;
            	
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                }
                else {
                	alturalineatexto2 = AlturaLineaTexto2[0];
                }
                
                AlturaLineaTexto = alturalineatexto2;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea2 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea2 = -1;
        	}
        	    	            	
	        break;
        
        case 3:	// Línea 3
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto3 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                }
                else {
                	alturalineatexto3 = AlturaLineaTexto3[0];
                }
                
                AlturaLineaTexto = alturalineatexto3;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea3 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea3 = -1;
        	}
        	    	            	
	        break;
	        
	case 4:	// Línea 4
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto4 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                }
                else {
                	alturalineatexto4 = AlturaLineaTexto4[0];
                }
                
                AlturaLineaTexto = alturalineatexto4;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea4 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea4 = -1;
        	}
        	    	            	
	        break;
            
        }
        
        // Guarda la altura total de la marca hasta ahora
       	// Si hay Anchura es que hay datos en la línea
	if (AnchuraLineaTexto) {
       		
       		if (LineaCalcular > 1) {
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
		}
	
		else {	// para la línea 1 no se suma la separación entre líneas
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
		}
		
	}
	
        // Guarda la anchura de linea máxima
	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
        	
        	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
        
	}
        
        // Guarda la altura de linea máxima
	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
        
        	AlturaLineaTextoMaxima = AlturaLineaTexto;
        
        }
        
} // Siguiente línea

// Guardamos los valores de la celda
XMaxCelda = (int)AnchuraLineaTextoMaxima;
YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
//printf("XMaxCelda:%d YMaxCelda:%d\\n", XMaxCelda, YMaxCelda);
  
// Si no hay vectores y no es un plt incorrecto devuelve un valor y presenta mensajes de error:
if ((NumeroVectores == 0) && (!pltIncorrecto)){

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("No hay datos para marcar");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("There is no data to mark");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Nessun dato per stampare");
			break;
			
		}

		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

///////////////////////////////////////////////////////////////////////////////////
// Cálculo de offsets
///////////////////////////////////////////////////////////////////////////////////
for (i=1; i<=NumeroLineasTexto; i++) {

        // Prepara los valores necesarios para el cálculo del offset   
	switch (i) {
        
        case 1:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto1;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
            	
            	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto1;
	    	
            }
            
            else {
           
            	AlturaLineaTexto = 0;
           
            }
                
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = 0;
            tempvalueslinea_fin = tempValuesLinea1;
                        
            break;
        
        case 2:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto2;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto2;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea1 + 1;
            tempvalueslinea_fin = tempValuesLinea2;
                        
            break;
        
        case 3:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto3;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto3;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea2 + 1;
            tempvalueslinea_fin = tempValuesLinea3;
                        
            break;
        
        case 4:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto4;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto4;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea3 + 1;
            tempvalueslinea_fin = tempValuesLinea4;
                        
            break;
                
        }
        
        //printf("OFFSET: Línea=%ld Anchura=%f Altura=%f Altura Acumulada=%f\\n", i, AnchuraLineaTexto, AlturaLineaTexto, AlturaTextoAcumulada);
        
        //Centrado = true;
        
	// Calcula el offset x e y
	// Si está activado el centrado de la marca:
	if (Centrado) {
		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
		
		if (Reverso) {
		
			xoffset = -xoffset;
			//yoffset = -yoffset;
			
		}
		
		//printf("------ xoffset:%d yoffset:%d\\n", xoffset,yoffset);
	}
	
	
	// Si no está activo hay que desplazar la marca al borde correspondiente en función de la orientación y el avance
	else {

		switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
		case -180:
		case 180:
		
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la izquierda
            		if (xOffsetPantalla < 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                 		
      			break;
       
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		case 0:
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la derecha
            		if (xOffsetPantalla > 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
            		
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
		case -270:
		case 90:
			if (JustificacionIzquierda == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
            		
            		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
            		 
            		// Se pueden desplazar verticalmente hacia abajo
            		if (yOffsetPantalla < 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		case -90:
		case 270:
			if (JustificacionIzquierda == true) {				  
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
             		
             		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);

			// Se pueden desplazar verticalmente hacia arriba
            		if (yOffsetPantalla > 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;

        	}
        
	}
    	    	
    	if (debug_vectores) {	
		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \\n", Orientacion, Avance, xoffset, yoffset);
	}
	
	// Actualiza las coordenadas de los vectores de la línea con los offset calculados
	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
		
		// Si está activado el reverso hay que invertir las coordenadas en X
		// El offset en X ya está calculado de acuerdo a si hay o no reverso
		if (Reverso) {
		
			xValues[j] = -xValues[j] + xoffset;
		
		}
		
		else {
		
			xValues[j] = xValues[j] + xoffset;
		
		}
		
		// La coordenada Y no depende del efecto reverso
		yValues[j] = yValues[j] + yoffset;
		
		// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        		FueraLimites = true;
        		
			rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

		}

	}
    
} // Fin del bucle For, para cada linea de texto

///////////////////////////////////////////////////////////////////////////////////
// GENERACIÓN DE TABLA
///////////////////////////////////////////////////////////////////////////////////

// Sólo se hace si está activado el control de tablas y si hay más de una fila o una columna
if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {

	// primero copia la celda original
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// Guarda el número de vectores de cada celda
	NumeroVectoresCelda = NumeroVectores;

	// Actualiza el número de vectores global
	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);

	// Repite la matriz según el número de filas y columnas

	// Primero añade tantas celdas con la matriz como sea necesario
	for (fila = 1; fila <= NumeroFilas; fila++) {

		for (columna = 1; columna <= NumeroColumnas; columna++) {

			// La primera celda no hay que repetirla
			if ((fila == 1) && (columna == 1)) {continue;}
		
			// Offset de la celda en número de vectores
			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
		
			for (i = 0; i < NumeroVectoresCelda; i++) {
	
				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
				xValues[i+offsetvectores] = xValues[i];	
				yValues[i+offsetvectores] = yValues[i];
	
			}

		}

	}

	// Inicializa los valores para calcular los límites de la tabla
	xMinTabla = MaximoBits;
	xMaxTabla = -MaximoBits;
	yMinTabla = MaximoBits;
	yMaxTabla = -MaximoBits;

	// Calcula los offsets para cada celda en función de la orientación y avance
	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
			
				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {
	
			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

} // de la generación de tabla

// Si hay precorte añade la línea de precorte en el centro del campo y desplaza la tabla
if ((ControlTablaPrecorte) && (Precorte)) {

	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		// Hay que desplazar toda la marca medio campo hacia la derecha, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		
	}
	
	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		// Hay que desplazar toda la marca medio campo hacia la izquierda, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
	
	}
	
	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		// Hay que desplazar toda la marca medio campo hacia arriba, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
		
		}
		
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		// Hay que desplazar toda la marca medio campo hacia abajo, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
			
		}
	
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

}


////////////////////////////////////////////////////////////////////////////////
// Orientación: transformación de las coordenadas
///////////////////////////////////////////////////////////////////////////////////

switch (Orientacion) {

case 0:
	orientacion_radianes = 0;
	break;

case 90:
	orientacion_radianes = M_PI / 2.0;
	break;

case 180:
	orientacion_radianes = M_PI;
	break;

case 270:
	orientacion_radianes = M_PI / 2.0 * 3.0;
	break;

}

seno = sin(orientacion_radianes);
coseno = cos(orientacion_radianes);

if (debug_vectores) {	
	printf("Orientacion radianes:%f seno:%f coseno:%f\\n", orientacion_radianes, seno, coseno);
}

// Actualiza las coordenadas de los vectores de la línea para la orientación dada
for (i=0; i<NumeroVectores; i++) {
	
	x = xValues[i];
	y = yValues[i];
	
	xValues[i] = (int)((x * coseno) + (-y * seno));
	yValues[i] = (int)((x * seno) + (y * coseno));
		
	// Si alguna coordenada se sale del campo levanta el flag correspondiente
   	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
        		
        	FueraLimites = true;
        	
		rt_printk("Fuera límites Orientacion - Vector:%d x:%d y:%d\\n", j, xValues[j], yValues[j] );
		
	}

}

///////////////////////////////////////////////////////////////////////////////////
// ORDENACIÓN
///////////////////////////////////////////////////////////////////////////////////

// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha y no hay reverso,
// o están pegadas a la derecha porque "avanzan" hacia la izquierda y sí hay reverso
// o están pegadas arriba porque "avanzan" hacia abajo, hay que reordenar la matriz 
// para empezar a marcar por el final de la matriz

if ( (((Orientacion - Avance) == 0) && (!Reverso)) 
   || (((Orientacion - Avance) == 180) && (Reverso))
   || (((Orientacion - Avance) == -180) && (Reverso))
   || ((Orientacion - Avance) == -270) 
   || ((Orientacion - Avance) == 90) ) {

	// primero copia la matriz
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// y luego copia los valores de forma invertida
	for (j=NumeroVectores-1; j>=0; j--) {
	
		//printf("j:%d NumeroVectores:%ld\\n",j, NumeroVectores);
		
		primero_polilinea = false;
		ultimo_polilinea = false;
		
		// índice del nuevo array
		k = NumeroVectores - j - 1;
		
		// las coordenadas no hay que modificarlas
		xValues[k] = xValues_tmp[j];	
		yValues[k] = yValues_tmp[j];
		
		// pero el tipo de vector sí:
		if (j==0) {
			primero_polilinea = false;
			ultimo_polilinea = true;
		}
		
		else if (j==((int)NumeroVectores - 1)) {
			primero_polilinea = true;
			ultimo_polilinea = false;
		}
		
		else if ( (j>0) && (j<((int)NumeroVectores-1)) ) {
			
			if (strstr(TipoMarcaje_tmp[j],"PU")) {
				primero_polilinea = false;
				ultimo_polilinea = true;
			}
						
			if ((strstr(TipoMarcaje_tmp[j],"PD")) && (strstr(TipoMarcaje_tmp[j+1],"PU"))) {
				primero_polilinea = true;
				ultimo_polilinea = false;
			}
						
		}
				
		if (primero_polilinea) {
			strcpy(TipoMarcaje[k], "PU");
		}
		
		else if (ultimo_polilinea) {
			strcpy(TipoMarcaje[k], "PD");
		}
		
		else {
			strcpy(TipoMarcaje[k], TipoMarcaje_tmp[j]);
		}
				
	}
	
}

///////////////////////////////////////////////////////////////////////////////////
// Variables de estado:
///////////////////////////////////////////////////////////////////////////////////

ActualizarPuertoSerie = false;

///////////////////////////////////////////////////////////////////////////////////
// Debug y Control
///////////////////////////////////////////////////////////////////////////////////
    
/*if (debug_vectores) {	
	printf("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
	for (i=0; i<NumeroVectores; i++) {	
		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
	}
}
*/
// Devuelve un valor y presenta mensajes de error:
if (FueraLimites == true) {
	
	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Marca fuera de límites");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Mark is out of bounds");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Stampa fuori dai limiti");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltDemasiadoGrande == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico demasiado grande");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Graphic file too big");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine troppo grande");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltIncorrecto == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico incorrecto");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Bad graphic file");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine sbagliato");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else {
	// Todo OK
	return 0;
}} {}
} 

Function {CalcularMatrizAtomos()} {C return_type int
} {
  code {// Calcula la matriz incluyendo códigos de barras y archivos .plt

unsigned long i,k;			// variable para indexar las líneas de texto
int j, vector;				// variable para indexar los caracteres de una línea
int b;					// variable para indexar los bloques de una línea
char caracter;				// variables de proceso
float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
double orientacion_radianes, seno, coseno, x, y;
int numatomos;	// para la reordenación de átomos con la misma coordenada
int fila, columna, offsetvectores;
unsigned int NumeroVectoresCelda;
int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;

// Inicialización
NumeroVectores = 0;
AnchuraLineaTexto = 0;
AnchuraLineaTextoMaxima = 0;
AlturaLineaTexto = 0;
AlturaLineaTextoMaxima = 0;
AlturaTotalMarca = 0;
AlturaTextoAcumulada = 0;
FueraLimites = false;
tempValuesLinea1 = 0;
tempValuesLinea2 = 0;
tempValuesLinea3 = 0;
tempValuesLinea4 = 0;
tempvalueslinea_inicio = 0;
tempvalueslinea_fin = 0;
xoffset = 0;
yoffset = 0;
pltDemasiadoGrande = false;
pltIncorrecto = false;
NumeroAtomos = -1;

// Proceso de cada línea
for (i=1; i<=NumeroLineasTexto; i++) {
                          
	// Inicialización
	AnchuraCaracterAnterior = 0;
        
        // Almacena el número de la línea que se está calculando
        LineaCalcular = i;
     
     	// Proceso de cada bloque
	for (b=1; b<=NumeroBloques; b++) {
	                  
	        // Almacena el número del bloque que se está calculando
        	BloqueCalcular = b;
        	
        	if (debug_vectores) {
        		printf("CalcularMatrizAtomos - NumeroLineasTexto:%d  Línea:%ld Bloque:%d\\n", NumeroLineasTexto, i, b);
        	}
        
	        ///////////////////////////////////////////////////////////////////////////////////
		// Cálculo de los vectores de los caracteres
	        ///////////////////////////////////////////////////////////////////////////////////
        	switch (LineaCalcular) {
        
	        case 1:	// Línea 1
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
        	
        		break;
        	
	        case 2:	// Línea 2
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
        	
        		break;
        	
	        case 3:	// Línea 3
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
        	
        		break;
        		
        	case 4:	// Línea 4
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
        	
        		break;	
        	
	        } //del switch que asigna variables de proceso
                
        	// Procesa la línea
        
	       	if (debug_vectores) {
       			printf("LineaTexto:%s  AlturaLineaTexto:%f \\n", LineaTexto, AlturaLineaTexto);
       		}
                        
	       	// Tipo de línea: texto
       		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
        	
       			if (strlen(LineaTexto) > 0) {
        		
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
       				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       	        			// Encuentra los parámetros del carácter
	        	        	caracter = LineaTexto[j];
       		        		EncontrarParametros (caracter);
        	        		
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            	
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        		
	        	}
        		
        		else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
        			AlturaLineaTexto = 0;
        		}
        			
	        }
        	
        	// Tipo de línea: gráfico
	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
        	
        		// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
			}
				
        		EncontrarParametrosPlt();
        		AnchuraLineaTexto = AnchuraCaracterAnterior;
        		
        	}
        		
	        // Tipo de línea: código de barras
        	else {
        		
        		if (strlen(LineaTexto) > 0) {
        		
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
        			EncontrarParametrosBarcode();
	              		AnchuraLineaTexto = AnchuraCaracterAnterior; 
       			
      			}
       			
       			else {
       			
       				//AnchuraLineaTexto = AnchuraLineaTexto;
	      			AlturaLineaTexto = 0;
       			}
       				
	        }
        
        } // Siguiente bloque
        
        // Procesa la línea formada por los 3 bloques
        
        // Guarda la anchura de la línea y el índice del último vector
        switch (LineaCalcular) {
        
	case 1:	// Línea 1
        	
        	// Guarda la anchura y altura de la línea
	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
	   
	        // la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                }
                else {
                	alturalineatexto1 = AlturaLineaTexto1[0];
                }
                
                AlturaLineaTexto = alturalineatexto1;
                        	
        	// Y guarda el valor del último vector de la línea
            	if (NumeroVectores > 0) {
		       	tempValuesLinea1 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea1 = -1;
        	}
        	    	            	
	        break;
        
        case 2:	// Línea 2
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto2 = AnchuraLineaTexto;
            	
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                }
                else {
                	alturalineatexto2 = AlturaLineaTexto2[0];
                }
                
                AlturaLineaTexto = alturalineatexto2;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea2 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea2 = -1;
        	}
        	    	            	
	        break;
        
        case 3:	// Línea 3
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto3 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                }
                else {
                	alturalineatexto3 = AlturaLineaTexto3[0];
                }
                
                AlturaLineaTexto = alturalineatexto3;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea3 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea3 = -1;
        	}
        	    	            	
	        break;
	        
	case 4:	// Línea 4
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto4 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                }
                else {
                	alturalineatexto4 = AlturaLineaTexto4[0];
                }
                
                AlturaLineaTexto = alturalineatexto4;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea4 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea4 = -1;
        	}
        	    	            	
	        break;
            
        }
        
        // Guarda la altura total de la marca hasta ahora
       	// Si hay Anchura es que hay datos en la línea
	if (AnchuraLineaTexto) {
       		
       		if (LineaCalcular > 1) {
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
		}
	
		else {	// para la línea 1 no se suma la separación entre líneas
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
		}
		
	}
	
        // Guarda la anchura de linea máxima
	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
        	
        	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
        
	}
        
        // Guarda la altura de linea máxima
	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
        
        	AlturaLineaTextoMaxima = AlturaLineaTexto;
        
        }
        
} // Siguiente línea
    
// Guardamos los valores de la celda
XMaxCelda = (int)AnchuraLineaTextoMaxima;
YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
//printf("XMaxCelda:%d YMaxCelda:%d\\n", XMaxCelda, YMaxCelda);

// Si no hay vectores y no hay un plt incorrecto no seguir    
if ((NumeroVectores == 0) && (!pltIncorrecto)){

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("No hay datos para marcar");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("There is no data to mark");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Nessun dato per stampare");
			break;
			
		}

		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

///////////////////////////////////////////////////////////////////////////////////
// Cálculo de offsets
///////////////////////////////////////////////////////////////////////////////////
for (i=1; i<=NumeroLineasTexto; i++) {

        // Prepara los valores necesarios para el cálculo del offset   
	switch (i) {
        
        case 1:
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto1;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
            	
            	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto1;
	    	
            }
            
            else {
           
            	AlturaLineaTexto = 0;
           
            }
                
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = 0;
            tempvalueslinea_fin = tempValuesLinea1;
                        
            break;
        
        case 2:
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto2;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto2;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea1 + 1;
            tempvalueslinea_fin = tempValuesLinea2;
                        
            break;
        
        case 3:
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto3;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto3;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea2 + 1;
            tempvalueslinea_fin = tempValuesLinea3;
                        
            break;
            
        case 4:
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto4;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto4;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea3 + 1;
            tempvalueslinea_fin = tempValuesLinea4;
                        
            break;
            
        }
        
        //Centrado = true;
        
	// Calcula el offset x e y
	// Si está activado el centrado de la marca:
	if (Centrado) {
		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
		
		if (Reverso) {
		
			xoffset = -xoffset;
			//yoffset = -yoffset;
			
		}
		
		//printf("------ xoffset:%d yoffset:%d\\n", xoffset,yoffset);
	}
	
	
	// Si no está activo hay que desplazar la marca al borde correspondiente en función de la orientación y el avance
	else {

		switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
		case -180:
		case 180:
		
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la izquierda
            		if (xOffsetPantalla < 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                 		
      			break;
       
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		case 0:
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la derecha
            		if (xOffsetPantalla > 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
            		
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
		case -270:
		case 90:
			if (JustificacionIzquierda == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
            		
            		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
            		 
            		// Se pueden desplazar verticalmente hacia abajo
            		if (yOffsetPantalla < 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		case -90:
		case 270:
			if (JustificacionIzquierda == true) {				  
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
             		
             		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);

			// Se pueden desplazar verticalmente hacia arriba
            		if (yOffsetPantalla > 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;

        	}
        
	}
    	    	
    	if (debug_vectores) {	
		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \\n", Orientacion, Avance, xoffset, yoffset);
	}
	
	// Actualiza las coordenadas de los vectores de la línea con los offset calculados
	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
		
		// Si está activado el reverso hay que invertir las coordenadas en X
		// El offset en X ya está calculado de acuerdo a si hay o no reverso
		if (Reverso) {
		
			xValues[j] = -xValues[j] + xoffset;
		
		}
		
		else {
		
			xValues[j] = xValues[j] + xoffset;
		
		}
		
		// La coordenada Y no depende del efecto reverso
		yValues[j] = yValues[j] + yoffset;
		
		// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        		FueraLimites = true;
        		
			rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

		}

	}
    
} // Fin del bucle For, para cada linea de texto

///////////////////////////////////////////////////////////////////////////////////
// GENERACIÓN DE TABLA
///////////////////////////////////////////////////////////////////////////////////

// Sólo se hace si está activado el control de tablas y si hay más de una fila o una columna
if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {

	// primero copia la celda original
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// Guarda el número de vectores de cada celda
	NumeroVectoresCelda = NumeroVectores;

	// Actualiza el número de vectores global
	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);

	// Repite la matriz según el número de filas y columnas

	// Primero añade tantas celdas con la matriz como sea necesario
	for (fila = 1; fila <= NumeroFilas; fila++) {

		for (columna = 1; columna <= NumeroColumnas; columna++) {

			// La primera celda no hay que repetirla
			if ((fila == 1) && (columna == 1)) {continue;}
		
			// Offset de la celda en número de vectores
			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
		
			for (i = 0; i < NumeroVectoresCelda; i++) {
	
				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
				xValues[i+offsetvectores] = xValues[i];	
				yValues[i+offsetvectores] = yValues[i];
	
			}

		}

	}

	// Inicializa los valores para calcular los límites de la tabla
	xMinTabla = MaximoBits;
	xMaxTabla = -MaximoBits;
	yMinTabla = MaximoBits;
	yMaxTabla = -MaximoBits;

	// Calcula los offsets para cada celda en función de la orientación y avance
	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
			
				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {
	
			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

} // de la generación de tabla

// Si hay precorte añade la línea de precorte en el centro del campo y desplaza la tabla
if ((ControlTablaPrecorte) && (Precorte)) {

	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		// Hay que desplazar toda la marca medio campo hacia la derecha, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		
	}
	
	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		// Hay que desplazar toda la marca medio campo hacia la izquierda, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
	
	}
	
	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		// Hay que desplazar toda la marca medio campo hacia arriba, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
		
		}
		
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		// Hay que desplazar toda la marca medio campo hacia abajo, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
			
		}
	
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

}

///////////////////////////////////////////////////////////////////////////////////
// ORDENACIÓN
///////////////////////////////////////////////////////////////////////////////////

// Crea los atomos
for (i=0; i<NumeroVectores; i++) {
	
	//printf("Vector:%ld Tipo:%s X:%d Y:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i]);
	
	// Átomos:
	if ((strstr(TipoMarcaje[i], "PU")) && (!SaltoDentroAtomo[i])) {
	
		// Nuevo átomo
		NumeroAtomos++;
		Atomos[NumeroAtomos].Inicio = i;
		Atomos[NumeroAtomos].Longitud = 0;
		Atomos[NumeroAtomos].Xmax = xValues[i];	
		Atomos[NumeroAtomos].Xmin = xValues[i];	
		Atomos[NumeroAtomos].Ymax = yValues[i];	
		Atomos[NumeroAtomos].Ymin = yValues[i];	
		
	}
	
	else {
	
		// Incrementa la longitud
		Atomos[NumeroAtomos].Longitud++;
		
		// Guarda máximos y mínimos
		if (xValues[i] > Atomos[NumeroAtomos].Xmax) {Atomos[NumeroAtomos].Xmax = xValues[i];}
		if (xValues[i] < Atomos[NumeroAtomos].Xmin) {Atomos[NumeroAtomos].Xmin = xValues[i];}
		if (yValues[i] > Atomos[NumeroAtomos].Ymax) {Atomos[NumeroAtomos].Ymax = yValues[i];}
		if (yValues[i] < Atomos[NumeroAtomos].Ymin) {Atomos[NumeroAtomos].Ymin = yValues[i];}
		
	}

}

// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
// hay que ordenar los átomos por Xmax decreciente
if ((Orientacion - Avance) == 0) {

	OrdenarAtomos(Atomos, XMAX, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Xmax para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Xmax=%d\\n", i, Atomos[i].Xmax);
		
		if (Atomos[i].Xmax == Atomos[i+1].Xmax) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomos(Atomos, YMAX, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomos(Atomos, YMAX, i-numatomos+1, i);
	}
	
}

// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
// hay que ordenar los átomos por Xmin creciente
else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

	OrdenarAtomos(Atomos, XMIN, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Xmin para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Xmin=%d\\n", i, Atomos[i].Xmin);
		
		if (Atomos[i].Xmin == Atomos[i+1].Xmin) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomos(Atomos, YMIN, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomos(Atomos, YMIN, i-numatomos+1, i);
	}
	
}

// Si las letras están pegadas abajo porque "avanzan" hacia arriba
// hay que ordenar los átomos por Ymax decreciente
else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

	OrdenarAtomos(Atomos, YMAX, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Ymax para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Ymax=%d\\n", i, Atomos[i].Ymax);
		
		if (Atomos[i].Ymax == Atomos[i+1].Ymax) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomos(Atomos, XMAX, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomos(Atomos, XMAX, i-numatomos+1, i);
	}
	
}

// Si las letras están pegadas arriba porque "avanzan" hacia abajo
// hay que ordenar los átomos por Ymin creciente
else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

	OrdenarAtomos(Atomos, YMIN, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Ymin para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Ymin=%d\\n", i, Atomos[i].Ymin);
		
		if (Atomos[i].Ymin == Atomos[i+1].Ymin) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomos(Atomos, XMIN, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomos(Atomos, XMIN, i-numatomos+1, i);
	}
	
}

// Ahora hay que reordenar la matriz de acuerdo al orden de los átomos
// primero copia la matriz
for (i=0; i<NumeroVectores; i++) {
	
	strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
	xValues_tmp[i] = xValues[i];	
	yValues_tmp[i] = yValues[i];
	
}

// Y vuelve a generarla, según el orden de los átomos
vector=0;
for (i=0; i<=NumeroAtomos; i++) {

	//printf("Atomo:%ld	Inicio:%d Longitud:%d\\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
	
	for (k=0; k<=Atomos[i].Longitud; k++) {
	
		// índice del átomo original
		j = Atomos[i].Inicio + k;
		
		// rellena los datos
		strcpy(TipoMarcaje[vector], TipoMarcaje_tmp[j]);
		xValues[vector] = xValues_tmp[j];
		yValues[vector] = yValues_tmp[j];
		
		//printf("Vector:%ld Tipo:%s X:%d Y:%d\\n", i+k, TipoMarcaje[i+k], xValues[i+k], yValues[i+k]);
	
		vector++;
		
	}

}


///////////////////////////////////////////////////////////////////////////////////
// Orientación: transformación de las coordenadas
///////////////////////////////////////////////////////////////////////////////////

switch (Orientacion) {

case 0:
	orientacion_radianes = 0;
	break;

case 90:
	orientacion_radianes = M_PI / 2.0;
	break;

case 180:
	orientacion_radianes = M_PI;
	break;

case 270:
	orientacion_radianes = M_PI / 2.0 * 3.0;
	break;

}

seno = sin(orientacion_radianes);
coseno = cos(orientacion_radianes);

if (debug_vectores) {	
	printf("Orientacion radianes:%f seno:%f coseno:%f\\n", orientacion_radianes, seno, coseno);
}

// Actualiza las coordenadas de los vectores de la línea para la orientación dada
for (i=0; i<NumeroVectores; i++) {
	
	x = xValues[i];
	y = yValues[i];
	
	xValues[i] = (int)((x * coseno) + (-y * seno));
	yValues[i] = (int)((x * seno) + (y * coseno));
		
	// Si alguna coordenada se sale del campo levanta el flag correspondiente
   	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
        		
        	FueraLimites = true;
        	
		rt_printk("Fuera límites Orientacion - Vector:%d x:%d y:%d\\n", j, xValues[j], yValues[j] );
		
	}

}


///////////////////////////////////////////////////////////////////////////////////
// Variables de estado:
///////////////////////////////////////////////////////////////////////////////////
Actualizar=false;
ActualizarPuertoSerie=false;

///////////////////////////////////////////////////////////////////////////////////
// Debug y Control
///////////////////////////////////////////////////////////////////////////////////
    
if (debug_vectores) {	
	printf("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
	for (i=0; i<NumeroVectores; i++) {	
		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
	}
}

// Devuelve un valor y presenta mensajes de error:
if (FueraLimites == true) {
	
	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Marca fuera de límites");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Mark is out of bounds");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Stampa fuori dai limiti");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltDemasiadoGrande == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico demasiado grande");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Graphic file too big");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine troppo grande");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltIncorrecto == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico incorrecto");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Bad graphic file");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine sbagliato");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else {
	// Todo OK
	return 0;
}} {}
} 

Function {CalcularMatrizFueraCampo()} {C return_type int
} {
  code {// Calcula la matriz incluyendo códigos de barras y archivos .plt

unsigned long i,k;			// variable para indexar las líneas de texto
int j, vector;				// variable para indexar los caracteres de una línea
int b;					// variable para indexar los bloques de una línea
char caracter;				// variables de proceso
float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
double orientacion_radianes, seno, coseno, x, y, u;
int factorUmbral;
int numatomos;	// para la reordenación de átomos con la misma coordenada
int fila, columna, offsetvectores;
unsigned int NumeroVectoresCelda;
int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;

// Inicialización
NumeroVectores = 0;
AnchuraLineaTexto = 0;
AnchuraLineaTextoMaxima = 0;
AlturaLineaTexto = 0;
AlturaLineaTextoMaxima = 0;
AlturaTotalMarca = 0;
AlturaTextoAcumulada = 0;
FueraLimites = false;
tempValuesLinea1 = 0;
tempValuesLinea2 = 0;
tempValuesLinea3 = 0;
tempValuesLinea4 = 0;
tempvalueslinea_inicio = 0;
tempvalueslinea_fin = 0;
xoffset = 0;
yoffset = 0;
pltDemasiadoGrande = false;
pltIncorrecto = false;
NumeroAtomos = -1;

xValuesMax = -3276800;
xValuesMin = 3276800;
yValuesMax = -3276800;
yValuesMin = 3276800;

RetardoDisparo_cuentas_adicional = 0;

// Proceso de cada línea
for (i=1; i<=NumeroLineasTexto; i++) {
        
        // Inicialización
	AnchuraCaracterAnterior = 0;
        
        // Almacena el número de la línea que se está calculando
        LineaCalcular = i;
     
     	// Proceso de cada bloque
	for (b=1; b<=NumeroBloques; b++) {
	                  
	        // Almacena el número del bloque que se está calculando
        	BloqueCalcular = b;
        	
        	if (debug_vectores) {
        		printf("CalcularMatrizFueraCampo - NumeroLineasTexto:%d  Línea:%ld Bloque:%d\\n", NumeroLineasTexto, i, b);
        	}
        
	        ///////////////////////////////////////////////////////////////////////////////////
		// Cálculo de los vectores de los caracteres
	        ///////////////////////////////////////////////////////////////////////////////////
        	switch (LineaCalcular) {
        
	        case 1:	// Línea 1
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
        	
        		break;
        	
	        case 2:	// Línea 2
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
        	
        		break;
        	
	        case 3:	// Línea 3
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
        	
        		break;
        		
        	case 4:	// Línea 4
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
        	
        		break;	
        	
	        } //del switch que asigna variables de proceso
                
        	// Procesa la línea
        
       		if (debug_vectores) {
       			printf("LineaTexto: %s  AlturaLineaTexto: %f \\n", LineaTexto, AlturaLineaTexto);
       		}
        	
	       	// Tipo de línea: texto
       		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
        	
       			if (strlen(LineaTexto) > 0) {
        			
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
	       			for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       		        		// Encuentra los parámetros del carácter
        		        	caracter = LineaTexto[j];
       	        			EncontrarParametros (caracter);
        	        		
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            	
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        		
        		}
        		
	        	else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
        			AlturaLineaTexto = 0;
        		}
        			
	        }
        	
        	// Tipo de línea: gráfico
	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
        	
        		// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
			}
				
        		EncontrarParametrosPlt();
        		AnchuraLineaTexto = AnchuraCaracterAnterior;
        		
	        }
        		
        	// Tipo de línea: código de barras
	        else {
        		
        		if (strlen(LineaTexto) > 0) {
        			
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
        			EncontrarParametrosBarcode();
              			AnchuraLineaTexto = AnchuraCaracterAnterior; 
       			
	      		}
       			
       			else {
       			
       				//AnchuraLineaTexto = AnchuraLineaTexto;
      				AlturaLineaTexto = 0;
       			}
       				
	        }
        
        } // Siguiente bloque
        
        // Procesa la línea formada por los 3 bloques
        
        // Guarda la anchura de la línea y el índice del último vector
        switch (LineaCalcular) {
        
	case 1:	// Línea 1
        	
        	// Guarda la anchura y altura de la línea
	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
	   
	        // la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                }
                else {
                	alturalineatexto1 = AlturaLineaTexto1[0];
                }
                
                AlturaLineaTexto = alturalineatexto1;

        	// Y guarda el valor del último vector de la línea
            	if (NumeroVectores > 0) {
		       	tempValuesLinea1 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea1 = -1;
        	}
        	    	            	
	        break;
        
        case 2:	// Línea 2
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto2 = AnchuraLineaTexto;
            	
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                }
                else {
                	alturalineatexto2 = AlturaLineaTexto2[0];
                }
                
                AlturaLineaTexto = alturalineatexto2;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea2 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea2 = -1;
        	}
        	    	            	
	        break;
        
        case 3:	// Línea 3
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto3 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                }
                else {
                	alturalineatexto3 = AlturaLineaTexto3[0];
                }
                
                AlturaLineaTexto = alturalineatexto3;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea3 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea3 = -1;
        	}
        	    	            	
	        break;
        
        case 4:	// Línea 4
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto4 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                }
                else {
                	alturalineatexto4 = AlturaLineaTexto4[0];
                }
                
                AlturaLineaTexto = alturalineatexto4;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea4 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea4 = -1;
        	}
        	    	            	
	        break;
            
        }
        
        // Guarda la altura total de la marca hasta ahora
       	// Si hay Anchura es que hay datos en la línea
	if (AnchuraLineaTexto) {
       		
       		if (LineaCalcular > 1) {
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
		}
	
		else {	// para la línea 1 no se suma la separación entre líneas
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
		}
		
	}
	
        // Guarda la anchura de linea máxima
	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
        	
        	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
        
	}
        
        // Guarda la altura de linea máxima
	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
        
        	AlturaLineaTextoMaxima = AlturaLineaTexto;
        
        }
        
} // Siguiente línea

// Guardamos los valores de la celda
XMaxCelda = (int)AnchuraLineaTextoMaxima;
YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
    
// Si no hay vectores y no hay un plt incorrecto no seguir    
if ((NumeroVectores == 0) && (!pltIncorrecto)){

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("No hay datos para marcar");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("There is no data to mark");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Nessun dato per stampare");
			break;
			
		}

		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

///////////////////////////////////////////////////////////////////////////////////
// Cálculo de offsets
///////////////////////////////////////////////////////////////////////////////////
for (i=1; i<=NumeroLineasTexto; i++) {

        // Prepara los valores necesarios para el cálculo del offset   
	switch (i) {
        
        case 1:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto1;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
            	
            	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto1;
	    	
            }
            
            else {
           
            	AlturaLineaTexto = 0;
           
            }
                
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = 0;
            tempvalueslinea_fin = tempValuesLinea1;
                        
            break;
        
        case 2:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto2;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto2;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea1 + 1;
            tempvalueslinea_fin = tempValuesLinea2;
                        
            break;
        
        case 3:
        
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto3;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto3;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea2 + 1;
            tempvalueslinea_fin = tempValuesLinea3;
                        
            break;
        
        case 4:
        
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto4;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto4;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea3 + 1;
            tempvalueslinea_fin = tempValuesLinea4;
                        
            break;
                
        }
        
        //Centrado = true;
        
	// Calcula el offset x e y
	// Si está activado el centrado de la marca:
	if (Centrado) {
		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
		
		if (Reverso) {
		
			xoffset = -xoffset;
			//yoffset = -yoffset;
			
		}
		
		//printf("------ xoffset:%d yoffset:%d\\n", xoffset,yoffset);
	}
	
	
	// Si no está activo hay que desplazar la marca al borde correspondiente en función de la orientación y el avance
	else {

		switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
		case -180:
		case 180:
		
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
            		
            		}
            		
            		// Si el marcaje es estático se suma el offset horizontal
			if ((MarcajeDinamicoActivo == 0) || (PruebaMarcaje)) {
			
            			if (xOffsetPantalla < 0){
            				xoffset = xoffset + xOffsetPantalla;
            			}
            		
            		}
            		
            		// pero si es dinámico se suma al retardo
            		// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
			else if (MarcajeDinamicoActivo == 1) {
	
				RetardoDisparo_cuentas_adicional = (int)((double)xOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
		
			}
	
			// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
			else if (MarcajeDinamicoActivo == 2) {
	
				RetardoDisparo_cuentas_adicional = (int)((double)xOffsetPantalla / CalibracionCorreccion * 25.0);
		
			}
            		            		
            		// el offset vertical se suma siempre
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                 		
      			break;
       
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		case 0:
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
            		
            		}
            		
            		// Si el marcaje es estático se suma el offset horizontal
			if (MarcajeDinamicoActivo == 0) {
			
            			if (xOffsetPantalla > 0){
            				xoffset = xoffset + xOffsetPantalla;
            			}
            		
            		}
            		
            		// pero si es dinámico se suma al retardo
            		// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
			else if (MarcajeDinamicoActivo == 1) {
	
				RetardoDisparo_cuentas_adicional = -(int)((double)xOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
		
			}
	
			// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
			else if (MarcajeDinamicoActivo == 2) {
	
				RetardoDisparo_cuentas_adicional = -(int)((double)xOffsetPantalla / CalibracionCorreccion * 25.0);
		
			}
            		
            		// el offset vertical se suma siempre
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
            		
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
		case -270:
		case 90:
			if (JustificacionIzquierda == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
            		
            		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
            		 
            		// Si el marcaje es estático se suma el offset vertical
			if (MarcajeDinamicoActivo == 0) {
			
            			// Se pueden desplazar verticalmente hacia abajo
            			if (yOffsetPantalla < 0){
            				yoffset = yoffset + yOffsetPantalla;
            			}
            		
            		}
            		
            		// pero si es dinámico se suma al retardo
            		// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
			else if (MarcajeDinamicoActivo == 1) {
	
				RetardoDisparo_cuentas_adicional = (int)((double)yOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
		
			}
	
			// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
			else if (MarcajeDinamicoActivo == 2) {
	
				RetardoDisparo_cuentas_adicional = (int)((double)yOffsetPantalla / CalibracionCorreccion * 25.0);
		
			}
			
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		case -90:
		case 270:
			if (JustificacionIzquierda == true) {				  
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
             		
             		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);
            		
            		// Si el marcaje es estático se suma el offset vertical
			if (MarcajeDinamicoActivo == 0) {
			
            			// Se pueden desplazar verticalmente hacia arriba
            			if (yOffsetPantalla > 0){
            				yoffset = yoffset + yOffsetPantalla;
            			}
            		
            		}
            		
            		// pero si es dinámico se suma al retardo
            		// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
			else if (MarcajeDinamicoActivo == 1) {
	
				RetardoDisparo_cuentas_adicional = -(int)((double)yOffsetPantalla / CalibracionCorreccion * CalibracionEncoder);
		
			}
	
			// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
			else if (MarcajeDinamicoActivo == 2) {
	
				RetardoDisparo_cuentas_adicional = -(int)((double)yOffsetPantalla / CalibracionCorreccion * 25.0);
		
			}
			
			break;

        	}
        
	}
    	    	
    	if (debug_vectores) {	
		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \\n", Orientacion, Avance, xoffset, yoffset);
	}
	
	// Actualiza las coordenadas de los vectores de la línea con los offset calculados
	// Y controla el tamaño máximo
	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
		
		// Si está activado el reverso hay que invertir las coordenadas en X
		// El offset en X ya está calculado de acuerdo a si hay o no reverso
		if (Reverso) {
		
			xValues[j] = -xValues[j] + xoffset;
		
		}
		
		else {
		
			xValues[j] = xValues[j] + xoffset;
		
		}
		
		// La coordenada Y no depende del efecto reverso
		yValues[j] = yValues[j] + yoffset;
		
		// Hay que controlar el tamaño según haya o no marcaje dinámico
		if (MarcajeDinamicoActivo == 0) { //marcaje estático
		
			// Si alguna coordenada se sale del campo levanta el flag correspondiente
	   		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        			FueraLimites = true;
        		
				rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

			}
		
		}
		
		else { //marcaje dinámico activado
		
			// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
			if ((Orientacion - Avance) == 0) {
	
				// Sólo hay que controlar el tamaño en Y
				if (fabs(yValues[j]) > MaximoBits) {
        		
        				FueraLimites = true;
        		
					rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

				}
		
			}

			// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
			else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
	
				// Sólo hay que controlar el tamaño en Y
				if (fabs(yValues[j]) > MaximoBits) {
        		
        				FueraLimites = true;
        		
					rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

				}
	
			}

			// Si las letras están pegadas abajo porque "avanzan" hacia arriba
			else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

				// Sólo hay que controlar el tamaño en X
				if (fabs(xValues[j]) > MaximoBits) {
        		
        				FueraLimites = true;
        		
					rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

				}
				
			}

			// Si las letras están pegadas arriba porque "avanzan" hacia abajo
			else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

				// Sólo hay que controlar el tamaño en X
				if (fabs(xValues[j]) > MaximoBits) {
        		
        				FueraLimites = true;
        		
					rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

				}
	
			}
		
		}

	}
    
} // Fin del bucle For, para cada linea de texto

///////////////////////////////////////////////////////////////////////////////////
// GENERACIÓN DE TABLA
///////////////////////////////////////////////////////////////////////////////////

// Sólo se hace si está activado el control de tablas y si hay más de una fila o una columna
if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {

	// primero copia la celda original
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// Guarda el número de vectores de cada celda
	NumeroVectoresCelda = NumeroVectores;

	// Actualiza el número de vectores global
	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);

	// Repite la matriz según el número de filas y columnas

	// Primero añade tantas celdas con la matriz como sea necesario
	for (fila = 1; fila <= NumeroFilas; fila++) {

		for (columna = 1; columna <= NumeroColumnas; columna++) {

			// La primera celda no hay que repetirla
			if ((fila == 1) && (columna == 1)) {continue;}
		
			// Offset de la celda en número de vectores
			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
		
			for (i = 0; i < NumeroVectoresCelda; i++) {
	
				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
				xValues[i+offsetvectores] = xValues[i];	
				yValues[i+offsetvectores] = yValues[i];
	
			}

		}

	}

	// Inicializa los valores para calcular los límites de la tabla
	xMinTabla = MaximoBits;
	xMaxTabla = -MaximoBits;
	yMinTabla = MaximoBits;
	yMaxTabla = -MaximoBits;

	// Calcula los offsets para cada celda en función de la orientación y avance
	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
			
				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
					
					// Hay que controlar el tamaño según haya o no marcaje dinámico
					if (MarcajeDinamicoActivo == 0) { //marcaje estático
		
						// Si alguna coordenada se sale del campo levanta el flag correspondiente
	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	
	
						}
		
					}
		
					else { //marcaje dinámico activado
		
						// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
						// Sólo hay que controlar el tamaño en Y
						if (fabs(yValues[i+offsetvectores]) > MaximoBits) {
        				
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	

						}
		
					}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
					
					// Hay que controlar el tamaño según haya o no marcaje dinámico
					if (MarcajeDinamicoActivo == 0) { //marcaje estático
		
						// Si alguna coordenada se sale del campo levanta el flag correspondiente
	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	
	
						}
		
					}
		
					else { //marcaje dinámico activado
		
						// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
						// Sólo hay que controlar el tamaño en Y
						if (fabs(yValues[i+offsetvectores]) > MaximoBits) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	

						}
		
					}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
					
					// Hay que controlar el tamaño según haya o no marcaje dinámico
					if (MarcajeDinamicoActivo == 0) { //marcaje estático
		
						// Si alguna coordenada se sale del campo levanta el flag correspondiente
	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	
		
						}
		
					}
		
					else { //marcaje dinámico activado
		
						// Si las letras están pegadas abajo porque "avanzan" hacia arriba
						// Sólo hay que controlar el tamaño en X
						if (fabs(xValues[i+offsetvectores]) > MaximoBits) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	

						}
		
					}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {
	
			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
					
					// Hay que controlar el tamaño según haya o no marcaje dinámico
					if (MarcajeDinamicoActivo == 0) { //marcaje estático
		
						// Si alguna coordenada se sale del campo levanta el flag correspondiente
	   					if ((fabs(xValues[i+offsetvectores]) > MaximoBits) || (fabs(yValues[i+offsetvectores]) > MaximoBits)) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	
	
						}
		
					}
		
					else { //marcaje dinámico activado
		
						// Si las letras están pegadas arriba porque "avanzan" hacia abajo
						// Sólo hay que controlar el tamaño en X
						if (fabs(xValues[i+offsetvectores]) > MaximoBits) {
        		
        						FueraLimites = true;
							rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", i+offsetvectores, xValues[i+offsetvectores], yValues[i+offsetvectores], xoffset, yoffset );	

						}
		
					}
				
				}

			}

		}
	
	}

} // de la generación de tabla

// Si hay precorte añade la línea de precorte en el centro del campo y desplaza la tabla
if ((ControlTablaPrecorte) && (Precorte)) {

	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		// Hay que desplazar toda la marca medio campo hacia la derecha, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		
	}
	
	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		// Hay que desplazar toda la marca medio campo hacia la izquierda, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
	
	}
	
	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		// Hay que desplazar toda la marca medio campo hacia arriba, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
		
		}
		
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		// Hay que desplazar toda la marca medio campo hacia abajo, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
			
		}
	
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

}

///////////////////////////////////////////////////////////////////////////////////
// ORDENACIÓN
///////////////////////////////////////////////////////////////////////////////////

// Crea los atomos y guarda los máximos y mínimos de la matriz
for (i=0; i<NumeroVectores; i++) {
	
	//printf("Vector:%ld Tipo:%s X:%d Y:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i]);
	
	// Átomos:
	if ((strstr(TipoMarcaje[i], "PU")) && (!SaltoDentroAtomo[i])) {
	
		// Nuevo átomo
		NumeroAtomos++;
		Atomos[NumeroAtomos].Inicio = i;
		Atomos[NumeroAtomos].Longitud = 0;
		Atomos[NumeroAtomos].Xmax = xValues[i];	
		Atomos[NumeroAtomos].Xmin = xValues[i];	
		Atomos[NumeroAtomos].Ymax = yValues[i];	
		Atomos[NumeroAtomos].Ymin = yValues[i];	
		
	}
	
	else {
	
		// Incrementa la longitud
		Atomos[NumeroAtomos].Longitud++;
		
		// Guarda máximos y mínimos
		if (xValues[i] > Atomos[NumeroAtomos].Xmax) {Atomos[NumeroAtomos].Xmax = xValues[i];}
		if (xValues[i] < Atomos[NumeroAtomos].Xmin) {Atomos[NumeroAtomos].Xmin = xValues[i];}
		if (yValues[i] > Atomos[NumeroAtomos].Ymax) {Atomos[NumeroAtomos].Ymax = yValues[i];}
		if (yValues[i] < Atomos[NumeroAtomos].Ymin) {Atomos[NumeroAtomos].Ymin = yValues[i];}
		
	}
	
	// Máximos y mínimos globales en la matriz
	if (xValues[i] > xValuesMax) {xValuesMax = xValues[i];}
	if (xValues[i] < xValuesMin) {xValuesMin = xValues[i];}
	if (yValues[i] > yValuesMax) {yValuesMax = yValues[i];}
	if (yValues[i] < yValuesMin) {yValuesMin = yValues[i];}

}

//printf("xValuesMax:%ld xValuesMin:%ld yValuesMax:%ld yValuesMin:%ld\\n",xValuesMax, xValuesMin, yValuesMax, yValuesMin);

// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
if ((Orientacion - Avance) == 0) {
	
	// hay que ordenar los átomos por Xmin decreciente
	OrdenarAtomosFueraCampo(Atomos, XMIN, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Xmin para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Xmin=%d\\n", i, Atomos[i].Xmin);
		
		if (Atomos[i].Xmin == Atomos[i+1].Xmin) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
	}
	
	// y hay que desplazar el siguiente offset dinámico en bits
	xOffsetDinamico = -(xValuesMax + MaximoBits);
	yOffsetDinamico = 0;
	
}

// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
	
	// hay que ordenar los átomos por Xmax creciente
	OrdenarAtomosFueraCampo(Atomos, XMAX, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Xmax para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Xmax=%d\\n", i, Atomos[i].Xmax);
		
		if (Atomos[i].Xmax == Atomos[i+1].Xmax) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomosFueraCampo(Atomos, YMIN, i-numatomos+1, i);
	}
	
	// y hay que desplazar el siguiente offset dinámico en bits
	xOffsetDinamico = -xValuesMin + MaximoBits;
	yOffsetDinamico = 0;
	
}

// Si las letras están pegadas abajo porque "avanzan" hacia arriba
else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

	// hay que ordenar los átomos por Ymin decreciente
	OrdenarAtomosFueraCampo(Atomos, YMIN, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Ymin para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Ymin=%d\\n", i, Atomos[i].Ymin);
		
		if (Atomos[i].Ymin == Atomos[i+1].Ymin) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomosFueraCampo(Atomos, XMAX, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomosFueraCampo(Atomos, XMAX, i-numatomos+1, i);
	}
	
	// y hay que desplazar el siguiente offset dinámico en bits
	xOffsetDinamico = 0;
	yOffsetDinamico = -(yValuesMax + MaximoBits);
	
}

// Si las letras están pegadas arriba porque "avanzan" hacia abajo
else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

	// hay que ordenar los átomos por Ymax creciente
	OrdenarAtomosFueraCampo(Atomos, YMAX, 0, NumeroAtomos);
	
	// Ahora hay que ordenar los que tienen la misma Ymax para minimizar saltos
	numatomos=1;
	for (i=0; i<NumeroAtomos; i++) {
	
		//rt_printk("i=%d Atomos[i].Ymax=%d\\n", i, Atomos[i].Ymax);
		
		if (Atomos[i].Ymax == Atomos[i+1].Ymax) {
			numatomos++;
		}
		
		else {
			if (numatomos > 1) {
				OrdenarAtomosFueraCampo(Atomos, XMIN, i-numatomos+1, i);
			}
			
			numatomos = 1;
		}
	}
	
	if (numatomos > 1) {
		OrdenarAtomosFueraCampo(Atomos, XMIN, i-numatomos+1, i);
	}
	
	// y hay que desplazar el siguiente offset dinámico en bits
	xOffsetDinamico = 0;
	yOffsetDinamico = -yValuesMin + MaximoBits;
	
}

// Ahora hay que reordenar la matriz de acuerdo al orden de los átomos
// primero copia la matriz
for (i=0; i<NumeroVectores; i++) {
	
	strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
	xValues_tmp[i] = xValues[i];	
	yValues_tmp[i] = yValues[i];
	
}

// Y vuelve a generarla, según el orden de los átomos
vector=0;
for (i=0; i<=NumeroAtomos; i++) {

	//rt_printk("Atomo:%ld	Inicio:%d Longitud:%d\\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
	
	// Si es una prueba de marcaje no considerar los átomos que salgan del campo
	if (PruebaMarcaje) {
	
		// Si alguna coordenada del átomose sale del campo pasa al siguiente átomo
	   	if (  (abs(Atomos[i].Xmin) > MaximoBits) 
	   	   || (abs(Atomos[i].Xmax) > MaximoBits) 
	   	   || (abs(Atomos[i].Ymin) > MaximoBits)
	   	   || (abs(Atomos[i].Ymax) > MaximoBits) ){
        		
        		//rt_printk("Atomo Saltado:%ld	Inicio:%d Longitud:%d\\n", i, Atomos[i].Inicio, Atomos[i].Longitud);
        		
        		continue;
        		
		}
		
	}
	
	// Guarda el umbral correspondiente a cada átomo

	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {
	
		// el umbral para determinar si el átomo está en el campo viene dado por Xmin
		Atomos[i].Umbral = Atomos[i].Xmin;
	
	}

	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
	
		// el umbral para determinar si el átomo está en el campo viene dado por Xmax
		Atomos[i].Umbral = Atomos[i].Xmax;
	
	}

	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		// el umbral para determinar si el átomo está en el campo viene dado por Ymin
		Atomos[i].Umbral = Atomos[i].Ymin;

	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		// el umbral para determinar si el átomo está en el campo viene dado por Ymax
		Atomos[i].Umbral = Atomos[i].Ymax;
	
	}
	
	// Recompone la matriz
	for (k=0; k<=Atomos[i].Longitud; k++) {
		
		// índice del átomo original
		j = Atomos[i].Inicio + k;
		
		// rellena los datos
		strcpy(TipoMarcaje[vector], TipoMarcaje_tmp[j]);
		xValues[vector] = xValues_tmp[j];
		yValues[vector] = yValues_tmp[j];
		uValues[vector] = Atomos[i].Umbral; // todos los vectores del átomo tienen el mismo umbral
		
		//printf("Vector:%ld Tipo:%s X:%d Y:%d\\n", i+k, TipoMarcaje[i+k], xValues[i+k], yValues[i+k]);
	
		vector++;
		
	}
	
	//rt_printk("Atomo:%ld	Inicio:%d Longitud:%d Umbral:%d\\n", i, Atomos[i].Inicio, Atomos[i].Longitud, Atomos[i].Umbral);

}

// Si es prueba de marcaje actualiza el número final de vectores, porque se han podido saltar átomos
if (PruebaMarcaje) {

	NumeroVectores = vector;

}
	
///////////////////////////////////////////////////////////////////////////////////
// Orientación: transformación de las coordenadas
///////////////////////////////////////////////////////////////////////////////////

switch (Orientacion) {

case 0:
	orientacion_radianes = 0;
	break;

case 90:
	orientacion_radianes = M_PI / 2.0;
	break;

case 180:
	orientacion_radianes = M_PI;
	break;

case 270:
	orientacion_radianes = M_PI / 2.0 * 3.0;
	break;

}

seno = sin(orientacion_radianes);
coseno = cos(orientacion_radianes);

if (debug_vectores) {	
	printf("Orientacion radianes:%f seno:%f coseno:%f\\n", orientacion_radianes, seno, coseno);
}

// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
if ((Orientacion - Avance) == 0) {
			
	// ajusta el umbral en x
	factorUmbral = ((int)coseno + (int)seno);
			
}

// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {
	
	// ajusta el umbral en x
	factorUmbral = ((int)coseno + (int)seno);
			
}

// Si las letras están pegadas abajo porque "avanzan" hacia arriba
else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {
			
	// ajusta el umbral en y
	factorUmbral = ((int)coseno - (int)seno);
										
}

// Si las letras están pegadas arriba porque "avanzan" hacia abajo
else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {
			
	// ajusta el umbral en y
	factorUmbral = ((int)coseno - (int)seno);
			
}
			
// Actualiza las coordenadas de los vectores de la línea para la orientación dada y los umbrales
for (i=0; i<NumeroVectores; i++) {
	
	x = (double)xValues[i];
	y = (double)yValues[i];
	u = (double)uValues[i];
	
	xValues[i] = (int)((x * coseno) + (-y * seno));
	yValues[i] = (int)((x * seno) + (y * coseno));
	uValues[i] = (int)(factorUmbral * u);

}

// Hay que ajustar los umbrales a la orientación dada
x = (double)xOffsetDinamico;
y = (double)yOffsetDinamico;

xOffsetDinamico = (long)((x * coseno) + (-y * seno));
yOffsetDinamico = (long)((x * seno) + (y * coseno));

if (xOffsetDinamico) {
	uOffsetDinamico = xOffsetDinamico;
}

else {
	uOffsetDinamico = yOffsetDinamico;
}

//rt_printk("xOffsetDinamico:%ld yOffsetDinamico:%ld uOffsetDinamico:%ld\\n", xOffsetDinamico, yOffsetDinamico, uOffsetDinamico);

///////////////////////////////////////////////////////////////////////////////////
// Variables de estado:
///////////////////////////////////////////////////////////////////////////////////
Actualizar=false;
ActualizarPuertoSerie=false;

///////////////////////////////////////////////////////////////////////////////////
// Debug y Control
///////////////////////////////////////////////////////////////////////////////////
    
if (debug_vectores) {	
	rt_printk("\# CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
	for (i=0; i<NumeroVectores; i++) {	
		rt_printk(" Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
	}
}

// Devuelve un valor y presenta mensajes de error:
if (FueraLimites == true) {
	
	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Marca fuera de límites");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Mark is out of bounds");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Stampa fuori dai limiti");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltDemasiadoGrande == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico demasiado grande");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Graphic file too big");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine troppo grande");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltIncorrecto == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico incorrecto");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Bad graphic file");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine sbagliato");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else {
	// Todo OK
	return 0;
}} {}
} 

Function {CalcularMatrizComponer()} {open C return_type int
} {
  code {// Calcula la matriz incluyendo códigos de barras y archivos .plt

unsigned long i,k;			// variable para indexar las líneas de texto
int j;					// variable para indexar los caracteres de una línea
int b;					// variable para indexar los bloques de una línea
//int c;					// variable para indexar los vectores que se calculan
char caracter;				// variables de proceso
float AlturaLineaTexto, AnchuraLineaTexto, AnchuraLineaTextoMaxima, AlturaLineaTextoMaxima, AlturaTotalMarca, AlturaTextoAcumulada;	
float alturalineatexto1, alturalineatexto2, alturalineatexto3, alturalineatexto4;
int xoffset, yoffset, tempValuesLinea1, tempValuesLinea2, tempValuesLinea3, tempValuesLinea4, tempvalueslinea_inicio, tempvalueslinea_fin;
int xoffsetbloque, yoffsetbloque, tempValuesBloque;
double AnguloInicialTextoCircular;
double AnguloFinalTextoCircular;
double ModuloVectorPolar;
int AnchuraInicialBloque;
double orientacion_radianes, seno, coseno, x, y;
bool primero_polilinea, ultimo_polilinea; // para empezar la línea por el final, si cabe
int fila, columna, offsetvectores;
unsigned int NumeroVectoresCelda;
int XMaxCelda, YMaxCelda, xMinTabla, xMaxTabla, yMinTabla, yMaxTabla;

// Inicializacion
NumeroVectores = 0;
AnchuraLineaTexto = 0;
AnchuraLineaTextoMaxima = 0;
AlturaLineaTexto = 0;
AlturaLineaTextoMaxima = 0;
AlturaTotalMarca = 0;
AlturaTextoAcumulada = 0;
FueraLimites = false;
tempValuesLinea1 = 0;
tempValuesLinea2 = 0;
tempValuesLinea3 = 0;
tempValuesLinea4 = 0;
tempvalueslinea_inicio = 0;
tempvalueslinea_fin = 0;
xoffset = 0;
yoffset = 0;
xoffsetbloque=0;
yoffsetbloque=0;
tempValuesBloque=0;
pltDemasiadoGrande = false;
pltIncorrecto = false;

// Proceso de cada línea
for (i=1; i<=NumeroLineasTexto; i++) {
	           
	// Inicializacion
	AnchuraCaracterAnterior = 0;
        
	// Almacena el número de la línea que se está calculando
        LineaCalcular = i;
     
     	// Proceso de cada bloque
	for (b=1; b<=NumeroBloques; b++) {
	                  
	        // Almacena el número del bloque que se está calculando
        	BloqueCalcular = b;
        	
        	if (debug_vectores) {
        		printf("CalcularMatrizComponer - NumeroLineasTexto:%d  Línea:%ld Bloque:%d\\n", NumeroLineasTexto, i, b);
        	}
        	
	        ///////////////////////////////////////////////////////////////////////////////////
		// Cálculo de los vectores de los caracteres
	        ///////////////////////////////////////////////////////////////////////////////////
        	switch (LineaCalcular) {
        
	        case 1:	// Línea 1
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto1[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto1[BloqueCalcular - 1];
        	
        		break;
        	
	        case 2:	// Línea 2
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto2[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto2[BloqueCalcular - 1];
        	
        		break;
        	
	        case 3:	// Línea 3
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto3[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto3[BloqueCalcular - 1];
        	
        		break;	
        		
        	case 4:	// Línea 4
        	
        		// Asigna las variables de proceso
        		strcpy(LineaTexto, LineaTexto4[BloqueCalcular - 1]);
	        	AlturaLineaTexto = AlturaLineaTexto4[BloqueCalcular - 1];
        	
        		break;	
        	
	        } //del switch que asigna variables de proceso
                
        	// Procesa la línea
        
	       	if (debug_vectores) {
       			printf("LineaTexto:%s  AlturaLineaTexto:%f \\n", LineaTexto, AlturaLineaTexto);
       		}
        	
	       	// Tipo de línea: texto
       		if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTO) {
        	
       			if (strlen(LineaTexto) > 0) {
        			//Guardamos el vector inicial
        			tempValuesBloque=NumeroVectores;
        			AnchuraInicialBloque=AnchuraCaracterAnterior;

        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
			
       				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       	        			// Encuentra los parámetros del carácter
	        	        	caracter = LineaTexto[j];
       		        		EncontrarParametros (caracter);
        	        		
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            	
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        		
        			//Ahora introducimos el offset de la posición inicial
        			//El offset en el eje x es la mitad de la anchura de la linea que ya está en bits + el offset de la posicion del centro
        			
        			xoffsetbloque= int(MinXTexto [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			//El offset en el eje Y es el radio + el offset de la posicion del centro
        			
        			yoffsetbloque= int(MinYTexto[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			//Ahora recalculamos la matrix con estos offsets
        	
        			for (j = tempValuesBloque; j <= NumeroVectores; j++) {

				xValues[j] = xValues[j] + xoffsetbloque;
		
				yValues[j] = yValues[j] + yoffsetbloque;
				
				}
				// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        			FueraLimites = true;
        		
				rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	
		
        			}

        		}
        		
        		else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
	        		AlturaLineaTexto = 0;
        		}
        		
	        }
        	
        	// Tipo de línea: gráfico
	        else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == GRAFICO) {
        	
        			//Guardamos el vector inicial
        			tempValuesBloque=NumeroVectores;
        			AnchuraInicialBloque=AnchuraCaracterAnterior;

        		
        		// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        		if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        		AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
			}
			
        		EncontrarParametrosPlt();
        		AnchuraLineaTexto = AnchuraCaracterAnterior;
        		
        		//Ahora introducimos el offset de la posición inicial
        		//El offset en el eje x es la mitad de la anchura de la linea que ya está en bits + el offset de la posicion del centro
        			
        		xoffsetbloque= int(MinXGrafico [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        		//El offset en el eje Y es el radio + el offset de la posicion del centro
        			
        		yoffsetbloque= int(MinYGrafico[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
			//Ahora recalculamos la matrix con estos offsets
        	
        		for (j=tempValuesBloque; j<=NumeroVectores; j++) {
			xValues[j] = xValues[j] + xoffsetbloque;
		
			yValues[j] = yValues[j] + yoffsetbloque;
				
			}
			// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   			if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        		FueraLimites = true;
        		
			rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	
		
        		}


	        }
        	
        	// Tipo de línea: texto circular
       		else if (ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1] == TEXTOCIRCULAR) {
        	
       			if (strlen(LineaTexto) > 0) {
        		
        			//Guardamos el vector inicial
        			tempValuesBloque=NumeroVectores;
        			AnchuraInicialBloque=AnchuraCaracterAnterior;
        			
        			
        			//Esto ya no tiene sentido
        			/*
        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				*/
			
       				for (j=0; j < (int)(strlen(LineaTexto)); j++) {
        	        
       	        			// Encuentra los parámetros del carácter
	        	        	caracter = LineaTexto[j];
       		        		EncontrarParametros (caracter);
        	        			
       	        			//printf("j:%d total:%d\\n", j, strlen(LineaTexto));
        	        
          			}
            			
            			//Esto ya no tiene sentido AnchuraCaracterAnterior es la anchura del bloque de texto
            			/*
	            		// Hay que restar el espacio entre letras tras la última letra de la línea
		            	AnchuraLineaTexto = (AnchuraCaracterAnterior - (int)((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion * xMaxFont / yMaxFont));
        			*/
        			AnchuraLineaTexto = (AnchuraCaracterAnterior-AnchuraInicialBloque);
        			
        			// Para el caso especial de una línea con sólo una "I"
        			if (AnchuraLineaTexto == 0) {AnchuraLineaTexto = 0.001;}
        			
        			//Ahora introducimos el offset de la posición inicial
        			//El offset en el eje x es la mitad de la anchura de la linea que ya está en bits + el offset de la posicion del centro
        			
        			xoffsetbloque= int(CentroXTextoCircular [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			//El offset en el eje Y es el radio + el offset de la posicion del centro
        			
        			yoffsetbloque= int(CentroYTextoCircular[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			//Angulo Inicial Texto Circular para que quede centrado en radianes
        			AnguloInicialTextoCircular = (AnchuraLineaTexto/2/(RadioTextoCircular[LineaCalcular-1][BloqueCalcular-1]*CalibracionCorreccion));
        			
        			//Ahora recalculamos la matrix con estos offsets
        	
        			for (j=tempValuesBloque; j<=NumeroVectores; j++) {

				AnguloFinalTextoCircular = ((3.14159/2)-(xValues[j]/RadioTextoCircular [LineaCalcular-1][BloqueCalcular-1]/CalibracionCorreccion)+AnguloInicialTextoCircular+(AnguloTextoCircular[LineaCalcular-1][BloqueCalcular-1]*2*3.14159/(360)));
				ModuloVectorPolar= RadioTextoCircular [LineaCalcular-1][BloqueCalcular-1]*CalibracionCorreccion+ double(yValues[j]);

				xValues[j] = int(ModuloVectorPolar)*cos(AnguloFinalTextoCircular);
				yValues[j] = int(ModuloVectorPolar)*sin(AnguloFinalTextoCircular);				

		
				xValues[j] = xValues[j] + xoffsetbloque;
		
				yValues[j] = yValues[j] + yoffsetbloque;
				
				}
				// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        			FueraLimites = true;
        		
				rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	
		
        			}
        		}
        		
        		else {
        		
        			//AnchuraLineaTexto = AnchuraLineaTexto;
	        		AlturaLineaTexto = 0;
        		}
        		
	        }

        		
        	// Tipo de línea: código de barras
	        else {
        		
        		if (strlen(LineaTexto) > 0) {
        		
        			//Guardamos el vector inicial
        			tempValuesBloque=NumeroVectores;
        			AnchuraInicialBloque=AnchuraCaracterAnterior;

        			// Añade un espaciado antes del bloque si no es el primer bloque y había algo antes
        			if ((BloqueCalcular > 1) && (AnchuraCaracterAnterior > 0)) {
	        			AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * AlturaLineaTexto * CalibracionCorreccion / yMaxFont * xMaxFont));
				}
				
        			EncontrarParametrosBarcode();
              			AnchuraLineaTexto = AnchuraCaracterAnterior; 
              			
              			//Ahora introducimos el offset de la posición inicial
        			//El offset en el eje x es la mitad de la anchura de la linea que ya está en bits + el offset de la posicion del centro
        			
        			xoffsetbloque= int(MinXBarcode [LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			//El offset en el eje Y es el radio + el offset de la posicion del centro
        			
        			yoffsetbloque= int(MinYBarcode[LineaCalcular-1][BloqueCalcular-1] * CalibracionCorreccion);
        			
        			
        			//Ahora recalculamos la matrix con estos offsets
        	
        			for (j=tempValuesBloque; j<=NumeroVectores; j++) {

					
				xValues[j] = xValues[j] + xoffsetbloque;
		
				yValues[j] = yValues[j] + yoffsetbloque;
				
				}
				// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   				if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        			FueraLimites = true;
        		
				rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	
		
        			}

       			
	      		}
       			
       			else {
       			
       				//AnchuraLineaTexto = AnchuraLineaTexto;
      				AlturaLineaTexto = 0;
       			}
       				
        	}
       
	       	
        
        } // Siguiente bloque
        
        
/*        
        // Procesa la línea formada por los 3 bloques
        
        // Guarda la anchura de la línea y el índice del último vector
        switch (LineaCalcular) {
        
	case 1:	// Línea 1
        	
        	// Guarda la anchura y altura de la línea
	       	AnchuraLineaTexto1 = AnchuraLineaTexto;
	   
	        // la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto1 = Maximo(AlturaLineaTexto1[0], AlturaLineaTexto1[1], AlturaLineaTexto1[2]);
                }
                else {
                	alturalineatexto1 = AlturaLineaTexto1[0];
                }
                
                AlturaLineaTexto = alturalineatexto1;

        	// Y guarda el valor del último vector de la línea
            	if (NumeroVectores > 0) {
		       	tempValuesLinea1 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea1 = -1;
        	}
        	    	            	
	        break;
        
        case 2:	// Línea 2
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto2 = AnchuraLineaTexto;
            	
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto2 = Maximo(AlturaLineaTexto2[0], AlturaLineaTexto2[1], AlturaLineaTexto2[2]);
                }
                else {
                	alturalineatexto2 = AlturaLineaTexto2[0];
                }
                
                AlturaLineaTexto = alturalineatexto2;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea2 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea2 = -1;
        	}
        	    	            	
	        break;
        
        case 3:	// Línea 3
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto3 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto3 = Maximo(AlturaLineaTexto3[0], AlturaLineaTexto3[1], AlturaLineaTexto3[2]);
                }
                else {
                	alturalineatexto3 = AlturaLineaTexto3[0];
                }
                
                AlturaLineaTexto = alturalineatexto3;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea3 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea3 = -1;
        	}
        	    	            	
	        break;
	        
	case 4:	// Línea 4
        	
        	// Guarda la anchura y altura de la línea
	        AnchuraLineaTexto4 = AnchuraLineaTexto;
        
            	// la altura que cuenta es la máxima de los 3 bloques si están todos activos
	        if (NumeroBloques > 1) {
	    		alturalineatexto4 = Maximo(AlturaLineaTexto4[0], AlturaLineaTexto4[1], AlturaLineaTexto4[2]);
                }
                else {
                	alturalineatexto4 = AlturaLineaTexto4[0];
                }
                
                AlturaLineaTexto = alturalineatexto4;

           	// Y guarda el valor del último vector de la línea
	        if (NumeroVectores > 0) {
		        tempValuesLinea4 = NumeroVectores -1;
        	}
	        else {
        		tempValuesLinea4 = -1;
        	}
        	    	            	
	        break;
            
        }
        
        // Guarda la altura total de la marca hasta ahora
       	// Si hay Anchura es que hay datos en la línea
	if (AnchuraLineaTexto) {
       		
       		if (LineaCalcular > 1) {
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto + SeparacionLineas;
		}
	
		else {	// para la línea 1 no se suma la separación entre líneas
			AlturaTotalMarca = AlturaTotalMarca + AlturaLineaTexto;
		}
		
	}
	
        // Guarda la anchura de linea máxima
	if (AnchuraLineaTexto > AnchuraLineaTextoMaxima) {
        	
        	AnchuraLineaTextoMaxima = AnchuraLineaTexto;
        
	}
        
        // Guarda la altura de linea máxima
	if (AlturaLineaTexto > AlturaLineaTextoMaxima) {
        
        	AlturaLineaTextoMaxima = AlturaLineaTexto;
        
        }
*/        
} // Siguiente línea


/*
// Guardamos los valores de la celda
XMaxCelda = (int)AnchuraLineaTextoMaxima;
YMaxCelda = (int)(AlturaTotalMarca * CalibracionCorreccion);
//printf("XMaxCelda:%d YMaxCelda:%d\\n", XMaxCelda, YMaxCelda);

*/





  
// Si no hay vectores y no es un plt incorrecto devuelve un valor y presenta mensajes de error:
if ((NumeroVectores == 0) && (!pltIncorrecto)){

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("No hay datos para marcar");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("There is no data to mark");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Nessun dato per stampare");
			break;
			
		}

		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}


//Cancelamos este calculo de offsets
/*


///////////////////////////////////////////////////////////////////////////////////
// Cálculo de offsets
///////////////////////////////////////////////////////////////////////////////////
for (i=1; i<=NumeroLineasTexto; i++) {

        // Prepara los valores necesarios para el cálculo del offset   
	switch (i) {
        
        case 1:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto1;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
            	
            	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto1;
	    	
            }
            
            else {
           
            	AlturaLineaTexto = 0;
           
            }
                
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = 0;
            tempvalueslinea_fin = tempValuesLinea1;
                        
            break;
        
        case 2:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto2;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto2;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea1 + 1;
            tempvalueslinea_fin = tempValuesLinea2;
                        
            break;
        
        case 3:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto3;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto3;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea2 + 1;
            tempvalueslinea_fin = tempValuesLinea3;
                        
            break;
        
        case 4:
            
            // Anchura y altura de la línea correspondiente
            AnchuraLineaTexto = AnchuraLineaTexto4;
            
            // Si no hay anchura de texto es que no hay nada en la línea, la altura debe ser 0
            if (AnchuraLineaTexto > 0) {
	    	
	    	// la altura que cuenta para el offset es la máxima de los 3 bloques
	    	AlturaLineaTexto = alturalineatexto4;
	    	
            }
           
            else {
           
            	AlturaLineaTexto = 0;
           
            }
            
            // Altura acumulada del texto
            if (AlturaLineaTexto > 0) {
            	AlturaTextoAcumulada = AlturaTextoAcumulada + AlturaLineaTexto + SeparacionLineas;
            }
            
            // índices de comienzo y fin de los vectores
            tempvalueslinea_inicio = tempValuesLinea3 + 1;
            tempvalueslinea_fin = tempValuesLinea4;
                        
            break;
                
        }
        
        //printf("OFFSET: Línea=%ld Anchura=%f Altura=%f Altura Acumulada=%f\\n", i, AnchuraLineaTexto, AlturaLineaTexto, AlturaTextoAcumulada);
        
        //Centrado = true;
        
	// Calcula el offset x e y
	// Si está activado el centrado de la marca:
	if (Centrado) {
		xoffset = (int) (xOffsetPantalla - AnchuraLineaTexto / 2) ;
		yoffset = (int) (yOffsetPantalla - (((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion));
		
		if (Reverso) {
		
			xoffset = -xoffset;
			//yoffset = -yoffset;
			
		}
		
		//printf("------ xoffset:%d yoffset:%d\\n", xoffset,yoffset);
	}
	
	
	// Si no está activo hay que desplazar la marca al borde correspondiente en función de la orientación y el avance
	else {

		switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
		case -180:
		case 180:
		
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la izquierda
            		if (xOffsetPantalla < 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
                 		
      			break;
       
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		case 0:
			// Con reverso:
			if (Reverso) {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)(-AnchuraLineaTextoMaxima + (MaximoBits-1));
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-AnchuraLineaTexto + (MaximoBits-1)); 
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-AnchuraLineaTexto - ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2) + (MaximoBits-1));
				}
			
				xoffset = -xoffset;
				
			}
			
			// Sin reverso:
			else {
			
				if (JustificacionIzquierda == true) {
					xoffset = (int)-MaximoBits;
				}
				else if (JustificacionDerecha == true) {
					xoffset = (int)(-MaximoBits + AnchuraLineaTextoMaxima - AnchuraLineaTexto);
				}
				else if (JustificacionCentro == true) {
					xoffset = (int)(-MaximoBits + ((AnchuraLineaTextoMaxima - AnchuraLineaTexto) / 2));
            			}
            		
            		}
            		
            		// Se pueden desplazar horizontalmente a la derecha
            		if (xOffsetPantalla > 0){
            			xoffset = xoffset + xOffsetPantalla;
            		}
            		
			yoffset = (int)(yOffsetPantalla - ((AlturaTextoAcumulada - (AlturaTotalMarca / 2))) * CalibracionCorreccion);
            		
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
		case -270:
		case 90:
			if (JustificacionIzquierda == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
            		
            		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (MaximoBits - (int)(AlturaTextoAcumulada * CalibracionCorreccion));
            		 
            		// Se pueden desplazar verticalmente hacia abajo
            		if (yOffsetPantalla < 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		case -90:
		case 270:
			if (JustificacionIzquierda == true) {				  
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto - (AnchuraLineaTextoMaxima / 2 - AnchuraLineaTexto));
			}
			else if (JustificacionDerecha == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + (AnchuraLineaTextoMaxima / 2));
			}
			else if (JustificacionCentro == true) {
				xoffset = (int)(xOffsetPantalla - AnchuraLineaTexto + AnchuraLineaTexto / 2);
			}
             		
             		// Si se imprime en el reverso hay que cambiar el signo del offset en la coordenada X
            		if (Reverso) {xoffset = -xoffset;}
            		
			yoffset = (int)((-Semicampo + ((AlturaTotalMarca - AlturaLineaTexto) - (AlturaTextoAcumulada - AlturaLineaTexto))) * CalibracionCorreccion);

			// Se pueden desplazar verticalmente hacia arriba
            		if (yOffsetPantalla > 0){
            			yoffset = yoffset + yOffsetPantalla;
            		}
            		
			break;

        	}
        
	}
    	    	
    	if (debug_vectores) {	
		printf("Orientacion:%d   Avance:%d   xoffset:%d   yoffset:%d \\n", Orientacion, Avance, xoffset, yoffset);
	}
	
	// Actualiza las coordenadas de los vectores de la línea con los offset calculados
	for (j=tempvalueslinea_inicio; j<=tempvalueslinea_fin; j++) {
		
		// Si está activado el reverso hay que invertir las coordenadas en X
		// El offset en X ya está calculado de acuerdo a si hay o no reverso
		if (Reverso) {
		
			xValues[j] = -xValues[j] + xoffset;
		
		}
		
		else {
		
			xValues[j] = xValues[j] + xoffset;
		
		}
		
		// La coordenada Y no depende del efecto reverso
		yValues[j] = yValues[j] + yoffset;
		
		// Si alguna coordenada se sale del campo levanta el flag correspondiente
   		
   		if ((fabs(xValues[j]) > MaximoBits) || (fabs(yValues[j]) > MaximoBits)) {
        		
        		FueraLimites = true;
        		
			rt_printk("Fuera límites Offset - Vector:%d x:%d y:%d xoffset:%d yoffset:%d\\n", j, xValues[j], yValues[j], xoffset, yoffset );	

		}

	}
    
} // Fin del bucle For, para cada linea de texto

*/


///////////////////////////////////////////////////////////////////////////////////
// GENERACIÓN DE TABLA
///////////////////////////////////////////////////////////////////////////////////

// Sólo se hace si está activado el control de tablas y si hay más de una fila o una columna
if ((ControlTablaPrecorte) && ((NumeroFilas >1) || (NumeroColumnas > 1))) {

	// primero copia la celda original
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// Guarda el número de vectores de cada celda
	NumeroVectoresCelda = NumeroVectores;

	// Actualiza el número de vectores global
	NumeroVectores = NumeroVectoresCelda * (NumeroFilas * NumeroColumnas);

	// Repite la matriz según el número de filas y columnas

	// Primero añade tantas celdas con la matriz como sea necesario
	for (fila = 1; fila <= NumeroFilas; fila++) {

		for (columna = 1; columna <= NumeroColumnas; columna++) {

			// La primera celda no hay que repetirla
			if ((fila == 1) && (columna == 1)) {continue;}
		
			// Offset de la celda en número de vectores
			offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
		
			for (i = 0; i < NumeroVectoresCelda; i++) {
	
				// Copia el tipo PU/PD y las coordenadas x e y de la primera celda
				strcpy(TipoMarcaje[i+offsetvectores], TipoMarcaje[i]);
				xValues[i+offsetvectores] = xValues[i];	
				yValues[i+offsetvectores] = yValues[i];
	
			}

		}

	}

	// Inicializa los valores para calcular los límites de la tabla
	xMinTabla = MaximoBits;
	xMaxTabla = -MaximoBits;
	yMinTabla = MaximoBits;
	yMaxTabla = -MaximoBits;

	// Calcula los offsets para cada celda en función de la orientación y avance
	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la izquierda
				xoffset = (int) ((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la derecha
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));
			
				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que subirla arriba a la derecha
				xoffset = (int) -((columna - 1) * (XMaxCelda + xSeparacionColumnas)); // se desarrolla hacia la izquierda
				yoffset = (int) (((NumeroFilas - 1) - 2*(fila - 1)) * ((YMaxCelda/2.0) + (ySeparacionFilas/2.0)));

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {

			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) (((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) ((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		for (fila = 1; fila <= NumeroFilas; fila++) {
	
			for (columna = 1; columna <= NumeroColumnas; columna++) {
		
				// Offset de la celda en número de vectores
				offsetvectores = NumeroVectoresCelda * ((fila-1)*NumeroColumnas + (columna-1));
			
				// Offset de la celda en coordenadas x e y: la primera celda hay que llevarla a la izquierda
				xoffset = (int) -(((NumeroColumnas - 1) - 2*(columna - 1)) * ((XMaxCelda/2.0) + (xSeparacionColumnas/2.0)));
				yoffset = (int) -((fila - 1) * (YMaxCelda + ySeparacionFilas)); // se desarrolla hacia la derecha

				for (i = 0; i < NumeroVectoresCelda; i++) {
	
					// Copia las coordenadas x e y de la primera celda
					xValues[i+offsetvectores] = xValues_tmp[i] + xoffset;	
					yValues[i+offsetvectores] = yValues_tmp[i] + yoffset;
				
					// Guarda máximos y mínimos
					if (xValues[i+offsetvectores] > xMaxTabla) {xMaxTabla = xValues[i+offsetvectores];}
					if (xValues[i+offsetvectores] < xMinTabla) {xMinTabla = xValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] > yMaxTabla) {yMaxTabla = yValues[i+offsetvectores];}
					if (yValues[i+offsetvectores] < yMinTabla) {yMinTabla = yValues[i+offsetvectores];}
				
				}

			}

		}
	
	}

} // de la generación de tabla

// Si hay precorte añade la línea de precorte en el centro del campo y desplaza la tabla
if ((ControlTablaPrecorte) && (Precorte)) {

	// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha
	if ((Orientacion - Avance) == 0) {

		// Hay que desplazar toda la marca medio campo hacia la derecha, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] + MaximoBits + SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		
	}
	
	// Si las letras están pegadas a la derecha porque "avanzan" hacia la izquierda
	else if (((Orientacion - Avance) == -180) || ((Orientacion - Avance) == 180)) {

		// Hay que desplazar toda la marca medio campo hacia la izquierda, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {
	
			// en la coordenada x
			xValues[i] = xValues[i] - MaximoBits - SeparacionPrecorteBits;	
				
		}
		
		// Añade el precorte: una línea vertical en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = 0;	
		yValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));
		NumeroVectores++;
	
	}
	
	// Si las letras están pegadas abajo porque "avanzan" hacia arriba
	else if (((Orientacion - Avance) == -90) || ((Orientacion - Avance) == 270)) {

		// Hay que desplazar toda la marca medio campo hacia arriba, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] + MaximoBits + SeparacionPrecorteBits;	
		
		}
		
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

	// Si las letras están pegadas arriba porque "avanzan" hacia abajo
	else if (((Orientacion - Avance) == -270) || ((Orientacion - Avance) == 90)) {

		// Hay que desplazar toda la marca medio campo hacia abajo, más la separación de
		// la línea de precorte
		for (i = 0; i < NumeroVectores; i++) {

			// en la coordenada y
			yValues[i] = yValues[i] - MaximoBits - SeparacionPrecorteBits;	
			
		}
	
		// Añade el precorte: una línea horizontal en el centro
		strcpy(TipoMarcaje[NumeroVectores], "PU");
		xValues[NumeroVectores] = (int) (-MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
		strcpy(TipoMarcaje[NumeroVectores], "PS"); // en lugar de PD, para poder variar la velocidad del precorte
		xValues[NumeroVectores] = (int) (MaximoBits * (LongitudPrecorte/100.0));	
		yValues[NumeroVectores] = 0;
		NumeroVectores++;
	
	}

}


////////////////////////////////////////////////////////////////////////////////
// Orientación: transformación de las coordenadas
///////////////////////////////////////////////////////////////////////////////////

switch (Orientacion) {

case 0:
	orientacion_radianes = 0;
	break;

case 90:
	orientacion_radianes = M_PI / 2.0;
	break;

case 180:
	orientacion_radianes = M_PI;
	break;

case 270:
	orientacion_radianes = M_PI / 2.0 * 3.0;
	break;

}

seno = sin(orientacion_radianes);
coseno = cos(orientacion_radianes);

if (debug_vectores) {	
	printf("Orientacion radianes:%f seno:%f coseno:%f\\n", orientacion_radianes, seno, coseno);
}

// Actualiza las coordenadas de los vectores de la línea para la orientación dada
for (i=0; i<NumeroVectores; i++) {
	
	x = xValues[i];
	y = yValues[i];
	
	xValues[i] = (int)((x * coseno) + (-y * seno));
	yValues[i] = (int)((x * seno) + (y * coseno));
		
	// Si alguna coordenada se sale del campo levanta el flag correspondiente
   	if ((fabs(xValues[i]) > MaximoBits) || (fabs(yValues[i]) > MaximoBits)) {
        		
        	FueraLimites = true;
        	
		rt_printk("Fuera límites Orientacion - Vector:%d x:%d y:%d\\n", j, xValues[j], yValues[j] );
		
	}

}

//Cancelamos la ordenacion
/*

///////////////////////////////////////////////////////////////////////////////////
// ORDENACIÓN
///////////////////////////////////////////////////////////////////////////////////

// Si las letras están pegadas a la izquierda porque "avanzan" hacia la derecha y no hay reverso,
// o están pegadas a la derecha porque "avanzan" hacia la izquierda y sí hay reverso
// o están pegadas arriba porque "avanzan" hacia abajo, hay que reordenar la matriz 
// para empezar a marcar por el final de la matriz

if ( (((Orientacion - Avance) == 0) && (!Reverso)) 
   || (((Orientacion - Avance) == 180) && (Reverso))
   || (((Orientacion - Avance) == -180) && (Reverso))
   || ((Orientacion - Avance) == -270) 
   || ((Orientacion - Avance) == 90) ) {

	// primero copia la matriz
	for (i=0; i<NumeroVectores; i++) {
	
		strcpy(TipoMarcaje_tmp[i], TipoMarcaje[i]);
		xValues_tmp[i] = xValues[i];	
		yValues_tmp[i] = yValues[i];
	
	}
	
	// y luego copia los valores de forma invertida
	for (j=NumeroVectores-1; j>=0; j--) {
	
		//printf("j:%d NumeroVectores:%ld\\n",j, NumeroVectores);
		
		primero_polilinea = false;
		ultimo_polilinea = false;
		
		// índice del nuevo array
		k = NumeroVectores - j - 1;
		
		// las coordenadas no hay que modificarlas
		xValues[k] = xValues_tmp[j];	
		yValues[k] = yValues_tmp[j];
		
		// pero el tipo de vector sí:
		if (j==0) {
			primero_polilinea = false;
			ultimo_polilinea = true;
		}
		
		else if (j==((int)NumeroVectores - 1)) {
			primero_polilinea = true;
			ultimo_polilinea = false;
		}
		
		else if ( (j>0) && (j<((int)NumeroVectores-1)) ) {
			
			if (strstr(TipoMarcaje_tmp[j],"PU")) {
				primero_polilinea = false;
				ultimo_polilinea = true;
			}
						
			if ((strstr(TipoMarcaje_tmp[j],"PD")) && (strstr(TipoMarcaje_tmp[j+1],"PU"))) {
				primero_polilinea = true;
				ultimo_polilinea = false;
			}
						
		}
				
		if (primero_polilinea) {
			strcpy(TipoMarcaje[k], "PU");
		}
		
		else if (ultimo_polilinea) {
			strcpy(TipoMarcaje[k], "PD");
		}
		
		else {
			strcpy(TipoMarcaje[k], TipoMarcaje_tmp[j]);
		}
				
	}
	
}

*/

///////////////////////////////////////////////////////////////////////////////////
// Variables de estado:
///////////////////////////////////////////////////////////////////////////////////

ActualizarPuertoSerie = false;

///////////////////////////////////////////////////////////////////////////////////
// Debug y Control
///////////////////////////////////////////////////////////////////////////////////
    
/*if (debug_vectores) {	
	printf("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
	for (i=0; i<NumeroVectores; i++) {	
		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d U:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i], uValues[i]);	
	}
}
*/
// Devuelve un valor y presenta mensajes de error:
if (FueraLimites == true) {
	
	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Marca fuera de límites");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Mark is out of bounds");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("Stampa fuori dai limiti");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltDemasiadoGrande == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico demasiado grande");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Graphic file too big");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine troppo grande");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else if (pltIncorrecto == true) {

	// Saca la ventana emergente si no se ha activado la impresión por el puerto serie
	if (ModoImpresionSerie == false) {
	
		// Asigna el mensaje
		switch (Idioma) {
			
			case ESP:
			BoxVentanaMensaje->label("Archivo gráfico incorrecto");
			break; 
			
			case ING:
			BoxVentanaMensaje->label("Bad graphic file");
			break; 
			
			case ITA:
			BoxVentanaMensaje->label("File di immagine sbagliato");
			break;
			
		}
	
		// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
		VentanaPrincipal->deactivate();
	
		// Presenta la ventana con el mensaje emergente
		VentanaMensaje->show();
	
	}
	
	return -1;

}

else {
	// Todo OK
	return 0;
}} {}
} 

Function {OrdenarAtomos(tipo_atomo atomos[], int tipo, int inicio, int fin)} {C return_type void
} {
  code {// Ordena el array de átomos en función de unos de los componentes: Xmax, Xmin, Ymax o Ymin
// según sean orientación y avance

tipo_atomo pivote, tmp;

int l,r,p;

if (debug_vectores) {
	rt_printk("atomos:%ld tipo:%d inicio:%d fin:%d\\n", NumeroAtomos, tipo, inicio, fin);
}
        	
while (inicio < fin) {

	l=inicio;
	p=(inicio+fin)/2;
	r=fin;
	
	pivote = atomos[p];
	
	while (1) {
	
		switch (tipo) {
		
			case XMAX:
			while ( (l<=r) && (atomos[l].Xmax >= pivote.Xmax) ) l++;
			while ( (l<=r) && (atomos[r].Xmax < pivote.Xmax) ) r--;
			break;
			
			case XMIN:
			while ( (l<=r) && (atomos[l].Xmin <= pivote.Xmin) ) l++;
			while ( (l<=r) && (atomos[r].Xmin > pivote.Xmin) ) r--;
			break;
			
			case YMAX:
			while ( (l<=r) && (atomos[l].Ymax >= pivote.Ymax) ) l++;
			while ( (l<=r) && (atomos[r].Ymax < pivote.Ymax) ) r--;
			break;
			
			case YMIN:
			while ( (l<=r) && (atomos[l].Ymin <= pivote.Ymin) ) l++;
			while ( (l<=r) && (atomos[r].Ymin > pivote.Ymin) ) r--;
			break;
			
		}
		
		if (l>r) break;
		
		tmp = atomos[l];
		atomos[l] = atomos[r];
		atomos[r] = tmp;
	
		if (p==r) p=l;
			
		l++; 
		r--;
	
	}

	atomos[p] = atomos[r];
	atomos[r] = pivote;
	r--;
	
	// recursión en el lado corto y loop con índices nuevos en el largo
	if ((r-inicio) < (fin-l)) {
	
		OrdenarAtomos(atomos, tipo, inicio, r);
		inicio = l;
	
	}
	
	else {
	
		OrdenarAtomos(atomos, tipo, l, fin);
		fin = r;
	
	}
	
}} {}
} 

Function {OrdenarAtomosFueraCampo(tipo_atomo atomos[], int tipo, int inicio, int fin)} {C return_type void
} {
  code {// Ordena el array de átomos en función de unos de los componentes: Xmax, Xmin, Ymax o Ymin
// según sean orientación y avance

tipo_atomo pivote, tmp;

int l,r,p;

if (debug_vectores) {
	rt_printk("atomos:%ld tipo:%d inicio:%d fin:%d\\n", NumeroAtomos, tipo, inicio, fin);
}
 
while (inicio < fin) {

	l=inicio;
	p=(inicio+fin)/2;
	r=fin;
	
	pivote = atomos[p];
	
	while (1) {
	
		switch (tipo) {
		
			case XMAX: // crecientes
			while ( (l<=r) && (atomos[l].Xmax <= pivote.Xmax) ) l++;
			while ( (l<=r) && (atomos[r].Xmax > pivote.Xmax) ) r--;
			break;
			
			case XMIN: // decrecientes
			while ( (l<=r) && (atomos[l].Xmin >= pivote.Xmin) ) l++;
			while ( (l<=r) && (atomos[r].Xmin < pivote.Xmin) ) r--;
			break;
			
			case YMAX: // crecientes
			while ( (l<=r) && (atomos[l].Ymax <= pivote.Ymax) ) l++;
			while ( (l<=r) && (atomos[r].Ymax > pivote.Ymax) ) r--;
			break;
			
			case YMIN: // decrecientes
			while ( (l<=r) && (atomos[l].Ymin >= pivote.Ymin) ) l++;
			while ( (l<=r) && (atomos[r].Ymin < pivote.Ymin) ) r--;
			break;
			
		}
		
		if (l>r) break;
		
		tmp = atomos[l];
		atomos[l] = atomos[r];
		atomos[r] = tmp;
	
		if (p==r) p=l;
			
		l++; 
		r--;
	
	}

	atomos[p] = atomos[r];
	atomos[r] = pivote;
	r--;
	
	// recursión en el lado corto y loop con índices nuevos en el largo
	if ((r-inicio) < (fin-l)) {
	
		OrdenarAtomosFueraCampo(atomos, tipo, inicio, r);
		inicio = l;
	
	}
	
	else {
	
		OrdenarAtomosFueraCampo(atomos, tipo, l, fin);
		fin = r;
	
	}
	
}} {}
} 

Function {EncontrarParametros(char caracter)} {C return_type int
} {
  code {int x, y, linea, tempxmax, lineainicial;
float factorajuste, alturalineatexto;
bool caracterencontrado;
char lineavector[50], *xchar, *ychar, lineacaracter[11]="CARACTER  ";

if (debug_vectores) {
	printf("EncontrarParametros Caracter:%c LineaCalcular:%d BloqueCalcular:%d\\n", caracter, LineaCalcular, BloqueCalcular);
}

// Inicialización
caracterencontrado = false;
linea = 0;
tempxmax = 0;
lineacaracter[9] = caracter;
lineainicial = 999999;

//obtiene la altura de texto correspondiente a la línea    
switch (LineaCalcular) {

	case 1:
	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
	break;

	case 2:
	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
	break;
    
	case 3:
    	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
	break;
	
	case 4:
    	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
	break;
   
}

// Calcula el factor de ajuste
factorajuste = alturalineatexto * CalibracionCorreccion / yMaxFont;

//printf("Altura Linea:%f factorajuste:%f\\n", alturalineatexto,factorajuste);

// Busca el carácter en el archivo de fuentes
while ( !(caracterencontrado) && strlen(ArchivoFuentes[linea]) ){
	
	if ( strstr(ArchivoFuentes[linea], lineacaracter) ) {
		caracterencontrado = true;
		lineainicial = linea + 1; 	// los vectores empiezan en la línea siguiente
	}
	
	linea++;
}

// Si no se ha encontrado el carácter devuelve un error y retorna
//if (!caracterencontrado) { 
//	return -1;
//}

// Procesa las líneas hasta la siguiente que empiece por CARACTER
while (!strstr(ArchivoFuentes[linea],"CARACTER") && caracterencontrado && (linea < NumeroLineasArchivoFuentes)) {
	
	// Si la línea empieza por PU o por PD
	if ( (strstr(ArchivoFuentes[linea], "PU") == ArchivoFuentes[linea]) || (strstr(ArchivoFuentes[linea], "PD") == ArchivoFuentes[linea]) ) {
	
		// Hay que ver si es un salto dentro de un carácter, si la estrategia es de átomos o fuera de campo
		if (Estrategia > 0) {
		
			if ((strstr(ArchivoFuentes[linea], "PU")) && (linea > lineainicial)){
		
				SaltoDentroAtomo[NumeroVectores] = 1;
			}
		
			else {
		
				SaltoDentroAtomo[NumeroVectores] = 0;
			
			}
		
			//rt_printk("linea:%d SaltoDentroAtomo[linea]:%d\\n", linea, SaltoDentroAtomo[NumeroVectores]);
			
		}
		
		// Copia el string de la línea para poder realizar strtok en él
		//lineavector = strdup (ArchivoFuentes[linea]); 
		strcpy(lineavector, ArchivoFuentes[linea]);
		
		//printf("--- lineavector: %s\\n", lineavector);
		
		// Guarda el tipo de vector - los dos primeros caracteres de la línea (no se escribe NULL al final!)
		strncpy (TipoMarcaje[NumeroVectores], lineavector, 2);
		
		//printf("--- TipoMarcaje[NumeroVectores]: %s\\n", TipoMarcaje[NumeroVectores]);
		
		// String con los números de la coordenada X
		xchar = strtok (lineavector, "PUD ;");
	
		// String con los números de la coordenada Y
	     	ychar = strtok (NULL, "PUD ;");
		
		//printf("--- xchar: %s   ychar: %s\\n", xchar, ychar);
		
		// Coordenada X:
		x = atoi(xchar);
		xValues[NumeroVectores] = (int)(x * factorajuste * (Anchura / 100.0) + AnchuraCaracterAnterior);
    
		if (x > tempxmax) {
        		tempxmax = x;
    		}
		
		// Coordenada Y:
		y = atoi(ychar);
		yValues[NumeroVectores] = (int)(y * factorajuste);
    		
    		//printf("--- x:%d   y:%d  tempxmax:%d \\n", x, y, tempxmax);
    		
		// Incrementa el contador de número de vectores
		NumeroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (NumeroVectores > NumeroMaximoVectores) {
			StopEjecucion();
			rt_printk("EncontrarParametros ERROR DE NÚMERO DE VECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
		
	}
	
	//printf("linea:%d\\n", linea);
	
	// Incrementa la línea del archivo de fuentes
	linea++;
	
}
        
// Actualiza la anchura del caracter anterior
AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + tempxmax * factorajuste * Anchura / 100.0);

// Añade el espaciado con el siguiente carácter
AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * xMaxFont));

// Si el caracter era un espacio añade un espaciado
if (isspace(caracter)) {	
	
	AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + (Espaciado / 300.0) * factorajuste * xMaxFont);
}

if (debug_vectores) {
	printf("--- AnchuraCaracterAnterior:%d Anchura:%d Espaciado:%d tempxmax:%d xMaxFont:%d\\n", AnchuraCaracterAnterior, Anchura, Espaciado, tempxmax, xMaxFont);
}

return 0;} {}
} 

Function {LeerArchivoFuentes()} {C return_type int
} {
  code {// Lee el archivo de fuentes la matriz ArchivoFuentes y asigna las variables globales xMaxFont e yMaxFont

int linea;					// para indexar las líneas del archivo
char record[50], *dato, nombrearchivo[50];	// array to hold each "record"
FILE *fin;                      		// pointer to input file

// Inicialización
linea = 0;
//for (i=0; i<3000; i++) {ArchivoFuentes[i][0]=0x00;}

// nombre del archivo: 
switch (ValorFuente) {

	case 0:
	strcpy(nombrearchivo, "arial.font");
	break;
	
	case 1:
	strcpy(nombrearchivo, "book_antigua.font");
	break;
	
	case 2:
	strcpy(nombrearchivo, "courier.font");
	break;
	
	case 3:
	strcpy(nombrearchivo, "palatino.font");
	break;
	
	case 4:
	strcpy(nombrearchivo, "rapida.font");
	break;
	
	case 5:
	strcpy(nombrearchivo, "rapida_doble.font");
	break;
	
	case 6:
	strcpy(nombrearchivo, "rapida_pet.font");
	break;
	
	case 7:
	strcpy(nombrearchivo, "sencilla.font");
	break;
	
	case 8:
	strcpy(nombrearchivo, "times_new_roman.font");
	break;
	
	case 9:
	strcpy(nombrearchivo, "india.font");
	break;
	
}

//printf("Leer archivo fuentes: %s\\n", nombrearchivo);

// Abre el archivo
fin = fopen(nombrearchivo, "r");	

if (fin == NULL) {
	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n");
	rt_printk("Error al abrir el fichero de fuentes\\n");
	rt_printk("Restaurando la configuración original de fábrica\\n");
	system("cp /rootFLS/itaca/*.font .");
	rt_printk("SALIENDO DE LA APLICACIÓN - vuelva a arrancar la aplicación para aplicar los cambios\\n");
	
	// sale del programa	
	ExitOrdenadamente();
	
}

while (!feof(fin)) {	// mientras no se haya llegado al final del archivo de fuentes

	fgets(record, sizeof(record), fin);	/* Lee una línea */
	dato = strtok(record, "\\n"); 		/* lee hasta el final de la línea */

	// Si la línea no está vacía 
	if (strlen(dato)>0) {
		
		strcpy(ArchivoFuentes[linea], dato);	
		//printf("linea:%d - %s\\n", linea, ArchivoFuentes[linea]);
		
		linea++;
	
	}

}

// Guarda el número de líneas del archivo de fuentes
NumeroLineasArchivoFuentes = linea;

// máxima coordenada x del archivo de fuentes: tiene que estar en la penúltima línea del fichero
xMaxFont = atoi(ArchivoFuentes[linea-2]);
    
// máxima coordenada y del archivo de fuentes: tiene que estar en la última línea del fichero
yMaxFont = atoi(ArchivoFuentes[linea-1]);

//printf("xMaxFont:%d yMaxFont:%d\\n",xMaxFont, yMaxFont);

// cierra el archivo
fclose(fin);	

return 0;} {}
} 

Function {EncontrarParametrosBarcode()} {C return_type int
} {
  code {int error, tempxmax;		
float alturalineatexto;
int incrementoX, incrementoY;
int fila, numfilas, columna, numcolumnas;	// para recorrer el bitmap con el código de barras
int bitmap_red, bitmap_red_anterior;		// sólo vamos a usar un color para determinar si es blanco o negro
unsigned int i, numerovectoreslaterales;
bool vectoreslaterales;
int spot, spots, spotbitsmodificado, tempymin, vectorinicial;		// para datamatrix

if (debug_vectores) {
	printf("EncontrarParametrosBarcode: LineaCalcular:%d BloqueCalcular:%d\\n", LineaCalcular, BloqueCalcular);
}

// Inicialización
tempxmax = 0;
numerovectoreslaterales = 0;
vectoreslaterales = false;

// obtiene la altura de texto correspondiente a la línea    
switch (LineaCalcular) {

	case 1:
	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
	break;

	case 2:
	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
	break;
    
	case 3:
    	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
	break;
	
	case 4:
    	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
	break;
   
}

// Hay que ver si se añaden vectores laterales: cuando el código está invertido y no es Datamatrix
if ((InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) && (numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]] != 71)) {

	vectoreslaterales = true;
	numerovectoreslaterales = 5;
	
}

// Calcula el factor de ajuste
//factorajuste = alturalineatexto * CalibracionCorreccion / alturalineatexto;
	
// Crea el código de barras de nuevo, para evitar stacked symbols
error = CrearBarcode(LineaCalcular-1, BloqueCalcular-1);

// Chequea posibles errores
if(error != 0) {
             
        /* some error occurred */
        rt_printk("%s\\n", BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->errtxt);
        
}
        
if(error > WARN_INVALID_OPTION) {
                
        /* stop now */
        //ZBarcode_Delete(my_symbol);
        return 1;
        
}

// obtiene el ancho y el alto del código en píxels
numfilas = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap_height;	// alto del código en píxels
numcolumnas = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap_width;	// ancho del código en píxels

if (debug_barcode) {
	printf("numfilas:%d   numcolumnas:%d	SpotBits:%d\\n", numfilas, numcolumnas, SpotBits);		
}

// procesa los datos del bitmap para generar los vectores
bitmap_red_anterior = 1;	// Inicialización

// Calcula los vectores dependiendo del tipo de código de barras:
switch(numTiposLinea[ValorTipoLinea[LineaCalcular - 1][BloqueCalcular - 1]]) {

	// Datamatrix: hay que recorrer filas y columnas, sin vectores laterales
	// El incremento en Y es negativo, porque el origen del png es arriba a la izquierda
	case 71:
	incrementoX = (int)(alturalineatexto * CalibracionCorreccion / numcolumnas); 	//bits
	incrementoY = (int)(-alturalineatexto * CalibracionCorreccion / numfilas);	//bits
	
	// hay que calcular cuantos spots caben en un incrementoX
	spotbitsmodificado = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
	spots = (int)((double)incrementoX / (double)spotbitsmodificado);
	
	// como mínimo debe haber un spot, porque si no no marcaría nada
	if (spots == 0) { spots = 1;}
	
	if (debug_barcode) {
		printf("Datamatrix: IncrementoX:%d IncrementoY:%d spotbitsmodificado:%d spots:%d\\n", incrementoX, incrementoY, spotbitsmodificado, spots);
	}
	
	// inicialización de datamatrix
	vectorinicial = NumeroVectores;
	tempymin = 0;
	
	// Para cada columna
	for (columna = 0; columna < numcolumnas; columna++) {
	
		// Para cada spot
		for (spot=0; spot < spots; spot++) {
		
			// Para cada fila
			for (fila = 0; fila < numfilas; fila++) {

				bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
		
				if (debug_barcode) {
					printf("Columna:%d   Fila:%d   bitmap:%d\\n", columna, fila, bitmap_red);		
				}
		
				//if (InvertirBarcode[LineaCalcular - 1] == ON) {
				//	if (bitmap_red == 0) {bitmap_red = 1;}
				//	else {bitmap_red = 0;}
				//}
		
				switch (bitmap_red) {
		
					case 0:		//negro
			
					// si es al principio de una columna (fila = 0) o el bit anterior no era negro
					// empieza un vector
					if ((fila == 0) || (bitmap_red_anterior != 0)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
	
						// Inicio del vector
						strcpy (TipoMarcaje[NumeroVectores], "PU");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)(fila * incrementoY);
				
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
			        			tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}
	
						// Incrementa el contador de número de vectores
						NumeroVectores++;
		
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					// si es al final de una columna (fila = height) termina un vector
					if (fila == (numfilas - 1)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
						
						// Fin del vector
						strcpy (TipoMarcaje[NumeroVectores], "PD");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)((fila+1) * incrementoY);
					
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
			        			tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}

						// Incrementa el contador de número de vectores
						NumeroVectores++;
		
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					break;
			
					default:	//cualquier otro valor indica que es blanco
			
					// si el bit anterior era negro y no es el principio de una columna termina un vector
					if ((bitmap_red_anterior == 0) && (fila>0)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
						
						// Inicio del vector
						strcpy (TipoMarcaje[NumeroVectores], "PD");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)((fila) * incrementoY);
				
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
		        				tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}
	
						// Incrementa el contador de número de vectores
						NumeroVectores++;
			
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					break;
			
				}
    	
				// guarda el valor del bit para la siguiente iteración
				bitmap_red_anterior = bitmap_red;
			
			}
		
		}
	
	} 
	
	// El código se ha desarrollado hacia abajo, hay que desplazarlo hacia arriba 
	// para que el origen esté en 0,0 y quede bien alineado con las líneas restantes
	for (i=vectorinicial; i<NumeroVectores; i++) {
		
		yValues[i] = yValues[i] - tempymin;
	
	}
	
	break;
	
	case 58:
	incrementoX = (int)(alturalineatexto * CalibracionCorreccion / numcolumnas); 	//bits
	incrementoY = (int)(-alturalineatexto * CalibracionCorreccion / numfilas);	//bits
	
	// hay que calcular cuantos spots caben en un incrementoX
	spotbitsmodificado = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
	spots = (int)((double)incrementoX / (double)spotbitsmodificado);
	
	// como mínimo debe haber un spot, porque si no no marcaría nada
	if (spots == 0) { spots = 1;}
	
	if (debug_barcode) {
		printf("QR: IncrementoX:%d IncrementoY:%d spotbitsmodificado:%d spots:%d\\n", incrementoX, incrementoY, spotbitsmodificado, spots);
	}
	
	// inicialización de datamatrix
	vectorinicial = NumeroVectores;
	tempymin = 0;
	
	// Para cada columna
	for (columna = 0; columna < numcolumnas; columna++) {
	
		// Para cada spot
		for (spot=0; spot < spots; spot++) {
		
			// Para cada fila
			for (fila = 0; fila < numfilas; fila++) {

				bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
		
				if (debug_barcode) {
					printf("Columna:%d   Fila:%d   bitmap:%d\\n", columna, fila, bitmap_red);		
				}
		
				//if (InvertirBarcode[LineaCalcular - 1] == ON) {
				//	if (bitmap_red == 0) {bitmap_red = 1;}
				//	else {bitmap_red = 0;}
				//}
		
				switch (bitmap_red) {
		
					case 0:		//negro
			
					// si es al principio de una columna (fila = 0) o el bit anterior no era negro
					// empieza un vector
					if ((fila == 0) || (bitmap_red_anterior != 0)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
	
						// Inicio del vector
						strcpy (TipoMarcaje[NumeroVectores], "PU");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)(fila * incrementoY);
				
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
			        			tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}
	
						// Incrementa el contador de número de vectores
						NumeroVectores++;
		
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					// si es al final de una columna (fila = height) termina un vector
					if (fila == (numfilas - 1)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
						
						// Fin del vector
						strcpy (TipoMarcaje[NumeroVectores], "PD");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)((fila+1) * incrementoY);
					
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
			        			tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}

						// Incrementa el contador de número de vectores
						NumeroVectores++;
		
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					break;
			
					default:	//cualquier otro valor indica que es blanco
			
					// si el bit anterior era negro y no es el principio de una columna termina un vector
					if ((bitmap_red_anterior == 0) && (fila>0)) {
				
						// Todos los saltos son fuera del átomo
						SaltoDentroAtomo[NumeroVectores] = 0;
						
						// Inicio del vector
						strcpy (TipoMarcaje[NumeroVectores], "PD");
						xValues[NumeroVectores] = (int)((columna * incrementoX) + (spot * spotbitsmodificado)) + AnchuraCaracterAnterior;	
						yValues[NumeroVectores] = (int)((fila) * incrementoY);
				
						// hay que guardar el ancho...
						if (xValues[NumeroVectores] > tempxmax) {
		        				tempxmax = xValues[NumeroVectores];
    						}
    						
    						// hay que guardar el alto también
						if (yValues[NumeroVectores] < tempymin) {
			        			tempymin = yValues[NumeroVectores];
    						}
    						
						if (debug_vectores) {
							printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
						}
	
						// Incrementa el contador de número de vectores
						NumeroVectores++;
			
						// Controla que no se sobrepase el máximo número de vectores
						if (NumeroVectores > NumeroMaximoVectores) {
							StopEjecucion();
							rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
							ErrorVectores = ON;
							ProcesarError();
							return -1;
						}
				
					}
			
					break;
			
				}
    	
				// guarda el valor del bit para la siguiente iteración
				bitmap_red_anterior = bitmap_red;
			
			}
		
		}
	
	} 
	
	// El código se ha desarrollado hacia abajo, hay que desplazarlo hacia arriba 
	// para que el origen esté en 0,0 y quede bien alineado con las líneas restantes
	for (i=vectorinicial; i<NumeroVectores; i++) {
		
		yValues[i] = yValues[i] - tempymin;
	
	}
	
	break;
		
	
	
	// ITF-14: hay que recorrer filas y columnas, con vectores laterales
	case 89:
	incrementoX = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
	incrementoY = (int)(alturalineatexto * CalibracionCorreccion / numfilas);
	
	//printf("ITF-14: IncrementoX:%d IncrementoY:%d\\n", incrementoX, incrementoY);

	// añade los vectores al principio, si están activados
	if (vectoreslaterales) {
	
		for (i=0; i<numerovectoreslaterales; i++) {
			
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
						
			strcpy (TipoMarcaje[NumeroVectores], "PU");
			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = 0;
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
			
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PD");
			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
    		
		}
	
	}

	// Para cada columna
	for (columna = 0; columna < numcolumnas; columna++) {

		// Para cada fila
		for (fila = 0; fila < numfilas; fila++) {

			bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
		
			//if (debug_barcode) {
			//	printf("Columna:%d   Fila:%d   bitmap:%d\\n", columna, fila, bitmap_red);		
			//}
		
			if (InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) {
				if (bitmap_red == 0) {bitmap_red = 1;}
				else {bitmap_red = 0;}
			}
		
			switch (bitmap_red) {
		
				case 0:		//negro
			
				// si es al principio de una columna (fila = 0) o el bit anterior no era negro
				// empieza un vector
				if ((fila == 0) || (bitmap_red_anterior != 0)) {
				
					// Todos los saltos son fuera del átomo
					SaltoDentroAtomo[NumeroVectores] = 0;
		
					// Inicio del vector
					strcpy (TipoMarcaje[NumeroVectores], "PU");
					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
					yValues[NumeroVectores] = (int)(fila * incrementoY);
				
					// hay que guardar el ancho...
					if (xValues[NumeroVectores] > tempxmax) {
			        		tempxmax = xValues[NumeroVectores];
    					}
    		
					if (debug_vectores) {
						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
					}

					// Incrementa el contador de número de vectores
					NumeroVectores++;
		
					// Controla que no se sobrepase el máximo número de vectores
					if (NumeroVectores > NumeroMaximoVectores) {
						StopEjecucion();
						rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
						ErrorVectores = ON;
						ProcesarError();
						return -1;
					}
				
				}
			
				// si es al final de una columna (fila = height) termina un vector
				else if (fila == (numfilas - 1)) {
				
					// Todos los saltos son fuera del átomo
					SaltoDentroAtomo[NumeroVectores] = 0;
			
					// Inicio del vector
					strcpy (TipoMarcaje[NumeroVectores], "PD");
					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
					yValues[NumeroVectores] = (int)(fila * incrementoY);
					
					// hay que guardar el ancho...
					if (xValues[NumeroVectores] > tempxmax) {
		        			tempxmax = xValues[NumeroVectores];
    					}
    		
					if (debug_vectores) {
						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
					}

					// Incrementa el contador de número de vectores
					NumeroVectores++;
		
					// Controla que no se sobrepase el máximo número de vectores
					if (NumeroVectores > NumeroMaximoVectores) {
						StopEjecucion();
						rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
						ErrorVectores = ON;
						ProcesarError();
						return -1;
					}
				
				}
						
				break;
			
				default:	//cualquier otro valor indica que es blanco
			
				// si el bit anterior era negro y no es el principio de una columna termina un vector
				if ((bitmap_red_anterior == 0) && (fila>0)) {
				
					// Todos los saltos son fuera del átomo
					SaltoDentroAtomo[NumeroVectores] = 0;
			
					// Inicio del vector
					strcpy (TipoMarcaje[NumeroVectores], "PD");
					xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
					yValues[NumeroVectores] = (int)(fila * incrementoY);
				
					// hay que guardar el ancho...
					if (xValues[NumeroVectores] > tempxmax) {
		        			tempxmax = xValues[NumeroVectores];
    					}
    		
					if (debug_vectores) {
						printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
					}
	
					// Incrementa el contador de número de vectores
					NumeroVectores++;
			
					// Controla que no se sobrepase el máximo número de vectores
					if (NumeroVectores > NumeroMaximoVectores) {
						StopEjecucion();
						rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
						ErrorVectores = ON;
						ProcesarError();
						return -1;
					}
				
				}
			
				break;
			
			}
    	
			// guarda el valor del bit para la siguiente iteración
			bitmap_red_anterior = bitmap_red;
		
		}
	
	} 

	// añade los vectores al final, si están activados
	if (vectoreslaterales) {

		for (i=0; i<numerovectoreslaterales; i++) {
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PU");
			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = 0;
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PD");
			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}

		}

	}
	
	break;
	
	// Resto de códigos de barras lineales:
	default:
	incrementoX = (int)(SpotBits * (SeparacionBarrasBarcode[LineaCalcular - 1][BloqueCalcular - 1] / 100.0));
	incrementoY = (int)(alturalineatexto * CalibracionCorreccion / numfilas);
	
	//printf("Resto - IncrementoX:%d IncrementoY:%d\\n", incrementoX, incrementoY);

	// añade los vectores al principio, si están activados
	if (vectoreslaterales) {
	
		for (i=0; i<numerovectoreslaterales; i++) {
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PU");
			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = 0;
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
			
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PD");
			xValues[NumeroVectores] = i*incrementoX + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
    		
		}
	
	}

	for (columna = 0; columna < numcolumnas; columna++) {

		//for (fila = 0; fila < numfilas; fila++) {

		// en los códigos lineales basta con ver el bit inicial de la última fila
		fila = numfilas - 1;
		
		bitmap_red = BarcodeSymbol[LineaCalcular - 1][BloqueCalcular - 1]->bitmap[3 * ((fila*numcolumnas) + columna)];
		
		//if (debug_barcode) {
		//	printf("Columna:%d   Fila:%d   bitmap:%d\\n", columna, fila, bitmap_red);		
		//}
		
		if (InvertirBarcode[LineaCalcular - 1][BloqueCalcular - 1] == ON) {
			if (bitmap_red == 0) {bitmap_red = 1;}
			else {bitmap_red = 0;}
		}
		
		switch (bitmap_red) {
		
			case 0:		//negro	
			
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
				
			// Inicio del vector
			strcpy (TipoMarcaje[NumeroVectores], "PU");
			xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = 0;
				
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
		        	tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
			
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
				
			// Fin del vector
			strcpy (TipoMarcaje[NumeroVectores], "PD");
			xValues[NumeroVectores] = (int)((columna+numerovectoreslaterales) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = (int)((numfilas - 1) * incrementoY);
				
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
		       		tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
			
			break;
			
			default:	//cualquier otro valor indica que es blanco, no se hace nada
			break;
			
		}
    	
		// guarda el valor del bit para la siguiente iteración
		bitmap_red_anterior = bitmap_red;
		
		//}
	} 

	// añade los vectores al final, si están activados
	if (vectoreslaterales) {

		for (i=0; i<numerovectoreslaterales; i++) {
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PU");
			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = 0;
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}
	
			// Todos los saltos son fuera del átomo
			SaltoDentroAtomo[NumeroVectores] = 0;
			
			strcpy (TipoMarcaje[NumeroVectores], "PD");
			xValues[NumeroVectores] = (int)((numcolumnas+numerovectoreslaterales+i) * incrementoX) + AnchuraCaracterAnterior;	
			yValues[NumeroVectores] = (int)((numfilas-1) * incrementoY);
		
			// hay que guardar el ancho...
			if (xValues[NumeroVectores] > tempxmax) {
        			tempxmax = xValues[NumeroVectores];
    			}
    		
			if (debug_vectores) {
				printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
			}

			// Incrementa el contador de número de vectores
			NumeroVectores++;
		
			// Controla que no se sobrepase el máximo número de vectores
			if (NumeroVectores > NumeroMaximoVectores) {
				StopEjecucion();
				rt_printk("EncontrarParametrosBarcode ERROR DE NÚMERO DE VECTORES\\n"); 
				ErrorVectores = ON;
				ProcesarError();
				return -1;
			}

		}

	}

	break;
	
}
		
// Calcula el factor de ajuste
//factorajuste = alturalineatexto * CalibracionCorreccion / height;

//if (debug_vectores) {
//	printf("Altura Linea:%f factorajuste:%f AnchuraBarcode[LineaCalcular - 1]:%d\\n", alturalineatexto, factorajuste, AnchuraBarcode[LineaCalcular - 1]);
//}

// Actualiza la anchura del caracter anterior
AnchuraCaracterAnterior = (int)(tempxmax);

// Añade el espaciado con el siguiente carácter
//AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * tempxmax));

if (debug_vectores) {
	printf("EncontrarParametrosBarcode terminado\\n");
}
		
return 0;} {}
} 

Function {EncontrarParametrosPlt()} {C return_type int
} {
  code {int x, y, tempxmax;		// coordenadas x, y, tempxmax
int xoffsetlogo, yoffsetlogo;
long linea, lineasplt;
float factorajuste, alturalineatexto;
char *str;
char ArchivoPlt[MaximoLineasArchivoPlt][50]; // 30.000 líneas de hasta 50 caracteres cada una

if (debug_vectores) {
	
	printf("EncontrarParametrosPlt: LineaCalcular:%d BloqueCalcular:%d\\n", LineaCalcular, BloqueCalcular);
	
}

// Inicialización
tempxmax = 0;

// Se rellena el array ArchivoPlt y las variables globales xMaxPlt, yMaxPlt, xMinPlt, yMinPlt
lineasplt = LeerArchivoPlt(ArchivoPlt);

// Si el Plt es demasiado grande o no tiene dimensión en Y (altura = 0) vuelve
if ((pltDemasiadoGrande) || (pltIncorrecto)) {

	return 1;

}

//obtiene la altura de texto correspondiente a la línea    
switch (LineaCalcular) {

	case 1:
	alturalineatexto = AlturaLineaTexto1[BloqueCalcular - 1];
	break;

	case 2:
	alturalineatexto = AlturaLineaTexto2[BloqueCalcular - 1];
	break;
    
	case 3:
    	alturalineatexto = AlturaLineaTexto3[BloqueCalcular - 1];
	break;
	
	case 4:
    	alturalineatexto = AlturaLineaTexto4[BloqueCalcular - 1];
	break;
   
}

// Calcula el factor de ajuste
factorajuste = alturalineatexto * CalibracionCorreccion / (yMaxPlt - yMinPlt);

if (debug_plt) {

	printf("Altura Linea gráfico:%f factorajuste:%f \\n", alturalineatexto, factorajuste);

}

// Va leyendo el tipo PU o PD y las coordenadas x e y del archivo plt

// Inicializa la lectura de las líneas
linea = 0;

// offsets del logo: origen en 0,0 como los caracteres
xoffsetlogo = xMinPlt;
yoffsetlogo = yMinPlt;

//xoffsetlogo = (xMaxPlt - xMinPlt) / 2;
//yoffsetlogo = (yMaxPlt - yMinPlt) / 2;

while ( (linea < lineasplt) && (strlen(ArchivoPlt[linea]) > 0) ) {

	//printf("\\nArchivoPlt[%ld]:%s\\n", linea, ArchivoPlt[linea]);
	
	// Todos los saltos son fuera del átomo
	SaltoDentroAtomo[NumeroVectores] = 0;
	
	// Inicio del vector
	strncpy (TipoMarcaje[NumeroVectores], ArchivoPlt[linea], 2);
	TipoMarcaje[NumeroVectores][2] = '\\0';
	
	// coordenada x
	str = strtok (ArchivoPlt[linea], " PUD;");
	x = atoi(str) - xoffsetlogo;	// origen del plt en 0,0
	xValues[NumeroVectores] = (int)(x * factorajuste) + AnchuraCaracterAnterior;
	
	//printf("str:(%s) x:%d\\n", str, x);

	// hay que guardar el ancho...
	if (x > tempxmax) {
        	tempxmax = x;
    	}
    	
	// coordenada y
	str = strtok (NULL, " PUD;");
	y = atoi(str) - yoffsetlogo;	// origen del plt en 0,0
	yValues[NumeroVectores] = (int)(y * factorajuste);
	
	//printf("str:(%s) y:%d\\n", str, y);

	if (debug_vectores) {
		printf("--- TipoMarcaje:%s xValues:%d yValues:%d NumeroVectores:%ld\\n", TipoMarcaje[NumeroVectores], xValues[NumeroVectores], yValues[NumeroVectores], NumeroVectores);
	}

	// Incrementa el contador de número de vectores
	NumeroVectores++;
	
	// Controla que no se sobrepase el máximo número de vectores
	if (NumeroVectores > NumeroMaximoVectores) {
		StopEjecucion();
		rt_printk("EncontrarParametrosPlt ERROR DE NÚMERO DE VECTORES\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}	

	// se pasa a la siguiente línea
	linea ++;
	
}

// Actualiza la anchura del caracter anterior
AnchuraCaracterAnterior = AnchuraCaracterAnterior + (int)(tempxmax * factorajuste);

// Añade el espaciado con el siguiente carácter
//AnchuraCaracterAnterior = (int)(AnchuraCaracterAnterior + ((Espaciado / 300.0) * factorajuste * tempxmax));

if (debug_vectores) {
	printf("EncontrarParametrosPlt terminado - líneas: %ld\\n", linea);
}
		
return 0;} {}
} 

Function {LeerArchivoPlt(char ArchivoPlt[MaximoLineasArchivoPlt][50])} {C return_type int
} {
  code {// Lee el archivo plt
char tmpArchivoPlt[MaximoLineasArchivoPlt][50]; // copia local del archivo, previa a la optimización
int linea, nuevalinea;
int x, y, i, x2, y2;			
FILE *fichero;                  // pointer to input file
long lSize;			// tamaño del fichero
char *buffer;			// buffer donde se va a leer el archivo
char *indice;
size_t result;
char strtmp[50], *dato, *nuevodato;	// array to hold each "record"

// Inicialización
linea = 0;
xMaxPlt = -32768;
yMaxPlt = -32768;
xMinPlt = 32768;
yMinPlt = 32768;
pltIncorrecto = false;
pltDemasiadoGrande = false;

// Abre el archivo
//printf("Linea:%d Bloque:%d NombreArchivoPlt:%s\\n", LineaCalcular, BloqueCalcular,NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1]); 
fichero = fopen(NombreArchivoPlt[LineaCalcular - 1][BloqueCalcular - 1], "r");	

if (fichero == NULL) {
	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n");
	rt_printk("Error al abrir el fichero plt\\n");
	rt_printk("Restaurando la última configuración de archivos plt\\n");
	system("cp /rootFLS/itaca/*.plt .");
	rt_printk("SALIENDO DE LA APLICACIÓN - vuelva a arrancar la aplicación para aplicar los cambios\\n");
	exit(1);
}

// Lee el archivo entero en memoria:
// Obtiene el tamaño del fichero
fseek(fichero, 0, SEEK_END);
lSize = ftell(fichero);

// rebobina al principio del fichero
rewind(fichero);

// Reserva memoria para guardar todo el fichero en un buffer
buffer = (char*) malloc (sizeof(char)*lSize);
if (buffer == NULL) {
	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n");
	rt_printk("Error de memoria al leer el archivo plt\\n");
}

// Lee el fichero en el buffer
result = fread (buffer, 1, lSize, fichero);
if ((long)result != lSize) {
	rt_printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n");
	rt_printk("Error de lectura al leer el archivo plt\\n");
}

// cierra el archivo
fclose(fichero);	

// debug
if (debug_plt) {
	
	printf("Cerrado archivo plt\\n");

}

// Lee hasta el primer retorno de carro o punto y coma
indice = buffer;

//printf("---buffer:%d\\n", (int)buffer);

dato = strtok(indice, ";\\n"); 

// avanza el cursor	
indice = indice + strlen(dato) + 1;

// Si hay varios separadores seguidos hay que adelantar el puntero
while( (*indice == '\\0') && (indice < (buffer+lSize) )) {indice ++;}
	
//printf("indice:%d strlen(dato):%d dato:%s\\n", (int)indice, strlen(dato), dato);

// mientras no se haya llegado al final del buffer ni se haya sobrepasado el número máximo de líneas
while ((indice < (buffer+lSize)) && (linea < MaximoLineasArchivoPlt)) {	

	//printf("línea:%d dato: %s\\n", linea, dato);
	
	//////////////////////////////////////////////////////////////////////////////////////////////////
	// PLTs tradicionales de Corel

	// Si el "trozo" tiene un espacio entre medias y una PU o PD se trata de una línea de un plt "normal"
	if ( ((strstr(dato,"PU"))||(strstr(dato,"PD"))) && (strstr(dato," "))) {
			
		// guarda la coordenada en el array tmpArchivoPlt
		strcpy(tmpArchivoPlt[linea], dato);		
		
		// debug
		if (debug_plt) {
			printf("PUD - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
		}
		
		// incrementa el contador de la línea	
		linea++;
			
		// saca la coordenada x
		x = atoi(strtok(dato, " PUD;"));
			
		// calcula xMaxPlt y xMinPlt
		if (x > xMaxPlt) {xMaxPlt = x;}
		if (x < xMinPlt) {xMinPlt = x;}
			
		// y ahora la y
		y = atoi(strtok(NULL, " PUD;"));
						
		// calcula yMaxPlt e yMinPlt
		if (y > yMaxPlt) {yMaxPlt = y;}
		if (y < yMinPlt) {yMinPlt = y;}
				
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////
	// PLTs de Autocad
	
	// Si es "PUPA" lo siguiente tienen que ser coordenadas
	else if (strstr(dato,"PUPA")) {
	
		// debug
		//if (debug_plt) {
		//	printf("\#PU línea:%d dato:%s\\n", linea, dato);
		//}
			
		// avanza 4 posiciones para evitar el PUPA
		dato +=4;
			
		do {
					
			// Obtiene las coordenadas x e y
			nuevodato = strtok(dato, ",;");
			dato = dato + strlen(nuevodato) + 1;
			x = atoi(nuevodato);
			
			nuevodato = strtok(dato, ",;");
			dato = dato + strlen(nuevodato) + 1;
			y = atoi(nuevodato);
			
			// calcula xMaxPlt y xMinPlt
			if (x > xMaxPlt) {xMaxPlt = x;}
			if (x < xMinPlt) {xMinPlt = x;}
			
			// calcula yMaxPlt e yMinPlt
			if (y > yMaxPlt) {yMaxPlt = y;}
			if (y < yMinPlt) {yMinPlt = y;}

			// guarda la coordenada en el array ArchivoPlt
			sprintf(strtmp,"%s%d %d", "PU", x, y);
			strcpy(tmpArchivoPlt[linea], strtmp);		
				
			// debug
			if (debug_plt) {
				printf("	PUPA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
			}
				
			// incrementa el contador de la línea	
			linea++;
			
		} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0));
		// repite el proceso hasta que el siguiente carácter no es un número o "-"
	
	}
	
	// Si es "PDPA" lo siguiente tienen que ser coordenadas
	else if (strstr(dato,"PDPA")) {
	
		// debug
		//if (debug_plt) {
		//	printf("\#PU línea:%d dato:%s\\n", linea, dato);
		//}
			
		// avanza 4 posiciones para evitar el PDPA
		dato +=4;
			
		do {
					
			// Obtiene las coordenadas x e y
			nuevodato = strtok(dato, ",;");
			dato = dato + strlen(nuevodato) + 1;
			x = atoi(nuevodato);
			
			nuevodato = strtok(dato, ",;");
			dato = dato + strlen(nuevodato) + 1;
			y = atoi(nuevodato);
			
			// calcula xMaxPlt y xMinPlt
			if (x > xMaxPlt) {xMaxPlt = x;}
			if (x < xMinPlt) {xMinPlt = x;}
			
			// calcula yMaxPlt e yMinPlt
			if (y > yMaxPlt) {yMaxPlt = y;}
			if (y < yMinPlt) {yMinPlt = y;}

			// guarda la coordenada en el array ArchivoPlt
			sprintf(strtmp,"%s%d %d", "PD", x, y);
			strcpy(tmpArchivoPlt[linea], strtmp);		
				
			// debug
			if (debug_plt) {
				printf("	PDPA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
			}
				
			// incrementa el contador de la línea	
			linea++;
						
		} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
		// repite el proceso hasta que el siguiente carácter no es un número o "-"
		
	}
	
	// Si el "trozo" tiene sólo PA vamos a suponer que es un PU
	else if (strstr(dato,"PA")) { 
			
		// saca la coordenada x
		x = atoi(strtok(dato, " PA;,"));
			
		// calcula xMaxPlt y xMinPlt
		if (x > xMaxPlt) {xMaxPlt = x;}
		if (x < xMinPlt) {xMinPlt = x;}
			
		// y ahora la y
		y = atoi(strtok(NULL, " PA;,"));
						
		// calcula yMaxPlt e yMinPlt
		if (y > yMaxPlt) {yMaxPlt = y;}
		if (y < yMinPlt) {yMinPlt = y;}
		
		// guarda la coordenada en el array ArchivoPlt
		sprintf(strtmp,"%s%d %d", "PU", x, y);
		strcpy(tmpArchivoPlt[linea], strtmp);		
				
		// debug
		if (debug_plt) {
			printf("	PA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
		}
				
		// incrementa el contador de la línea	
		linea++;
					
	}
	
	// Si el "trozo" tiene una coma entre medias y una PU o PD se trata de una línea de un plt autocad "normal"
	else if ( ((strstr(dato,"PU"))||(strstr(dato,"PD"))) && (strstr(dato,","))) {
					
		// saca la coordenada x
		x = atoi(strtok(dato, ",PUD;"));
			
		// calcula xMaxPlt y xMinPlt
		if (x > xMaxPlt) {xMaxPlt = x;}
		if (x < xMinPlt) {xMinPlt = x;}
			
		// y ahora la y
		y = atoi(strtok(NULL, ",PUD;"));
						
		// calcula yMaxPlt e yMinPlt
		if (y > yMaxPlt) {yMaxPlt = y;}
		if (y < yMinPlt) {yMinPlt = y;}
		
		// guarda la coordenada en el array ArchivoPlt
		if (strstr(dato,"PU")) {
			sprintf(strtmp,"%s%d %d", "PU", x, y);
		}
		else if (strstr(dato,"PD")) {
			sprintf(strtmp,"%s%d %d", "PD", x, y);
		}
			
		strcpy(tmpArchivoPlt[linea], strtmp);		
				
		// debug
		if (debug_plt) {
			printf("	PUPA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
		}
				
		// incrementa el contador de la línea	
		linea++;
				
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////
	// PLTs de Scaps
	// Si es "PU;" lo siguiente tiene que ser un PA con coordenadas
	else if (strstr(dato,"PU")) {
	
		// lee hasta el siguiente retorno de carro o punto y coma
		dato = strtok(indice, "\\n;");
		indice = indice + strlen(dato) + 1;
		
		// debug
		//if (debug_plt) {
		//	printf("\#PU línea:%d dato:%s\\n", linea, dato);
		//}
		
		// comprueba que es un trozo de PA
		if (strstr(dato,"PA")) {
			
			// avanza 2 posiciones para evitar el PA
			dato +=2;
			
			do {
								
				// Obtiene las coordenadas x e y
				nuevodato = strtok(dato, ",;");
				dato = dato + strlen(nuevodato) + 1;
				x = atoi(nuevodato);
			
				nuevodato = strtok(dato, ",;");
				dato = dato + strlen(nuevodato) + 1;
				y = atoi(nuevodato);
			
				// calcula xMaxPlt y xMinPlt
				if (x > xMaxPlt) {xMaxPlt = x;}
				if (x < xMinPlt) {xMinPlt = x;}
			
				// calcula yMaxPlt e yMinPlt
				if (y > yMaxPlt) {yMaxPlt = y;}
				if (y < yMinPlt) {yMinPlt = y;}

				// guarda la coordenada en el array ArchivoPlt
				sprintf(strtmp,"%s%d %d", "PU", x, y);
				strcpy(tmpArchivoPlt[linea], strtmp);		
				
				// debug
				if (debug_plt) {
					printf("	PU;PA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);				
				}
				
				// incrementa el contador de la línea	
				linea++;
			
			} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
			// repite el proceso hasta que el siguiente carácter no es un número o "-"
					
		}
		
	}

	// Si es "PD;" lo siguiente tiene que ser un PA con coordenadas
	else if (strstr(dato,"PD")) {
	
		// lee hasta el siguiente retorno de carro o punto y coma
		dato = strtok(indice, "\\n;");
		indice = indice + strlen(dato) + 1;
		
		// debug
		//if (debug_plt) {
		//	printf("\#PD línea:%d dato:%s\\n", linea, dato);
		//}
			
		// comprueba que es un trozo de PA
		if (strstr(dato,"PA")) {
			
			// avanza 2 posiciones para evitar el PA
			dato +=2;
			
			do {
					
				// Obtiene las coordenadas x e y
				nuevodato = strtok(dato, ",;");
				dato = dato + strlen(nuevodato) + 1;
				x = atoi(nuevodato);
			
				nuevodato = strtok(dato, ",;");
				dato = dato + strlen(nuevodato) + 1;
				y = atoi(nuevodato);
			
				// calcula xMaxPlt y xMinPlt
				if (x > xMaxPlt) {xMaxPlt = x;}
				if (x < xMinPlt) {xMinPlt = x;}
			
				// calcula yMaxPlt e yMinPlt
				if (y > yMaxPlt) {yMaxPlt = y;}
				if (y < yMinPlt) {yMinPlt = y;}

				// guarda la coordenada en el array ArchivoPlt
				sprintf(strtmp,"%s%d %d", "PD", x, y);
				strcpy(tmpArchivoPlt[linea], strtmp);		
				
				// debug
				if (debug_plt) {
					printf("	PD;PA - linea:%d %s\\n", linea, tmpArchivoPlt[linea]);
				}
						
				// incrementa el contador de la línea	
				linea++;
			
			} while ((strlen(dato)) && (strcspn(dato,"-0123456789") == 0)); 
			// repite el proceso hasta que el siguiente carácter no es un número o "-"
						
		}
		
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////
	// SIGUE.... 
	
	//printf("indice:%d strlen(indice):%d\\n", (int)indice, strlen(indice));
	
	// Lee hasta el siguiente retorno de carro o punto y coma
	if (strlen(indice)) {
		dato = strtok(indice, ";\\n"); 	
		indice = indice + strlen(dato) + 1;
	}
			
	// Si hay varios separadores seguidos hay que adelantar el puntero
	while( (*indice == '\\0') && (indice < (buffer+lSize) )) {indice ++;}
	
	//printf("indice:%d strlen(dato):%d dato:%s\\n", (int)indice, strlen(dato), dato);
	
}

// libera la memoria donde se ha leido el archivo
free (buffer);

// Si se ha salido del bucle por demasiadas líneas activa el flag
if (linea >= MaximoLineasArchivoPlt) {

	pltDemasiadoGrande = true;

}

// Si yMax e yMin son iguales no se puede procesar el archivo porque no tiene altura
if (yMaxPlt == yMinPlt) {

	pltIncorrecto = true;

}


// Si no hay problemas con el plt hay que optimizarlo
if ( (!pltDemasiadoGrande) && (!pltIncorrecto) ) {

	// debug
	if (debug_plt) {
		printf("\\nOPTIMIZACIÓN PLT\\n");
	}
					
	// Procesa las líneas
	nuevalinea = 0;
	
	// La primera línea se añade si la siguiente no es otro PU
	if (!strstr(tmpArchivoPlt[nuevalinea+1], "PU")) {
		
		strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[0]);
		nuevalinea++;
		
		// debug
		if (debug_plt) {
			printf("nuevalinea:%d %s\\n", nuevalinea, ArchivoPlt[nuevalinea]);
		}				
		
	}
	
	for (i=1; i<linea-1; i++) {
	
		///*
		
		// líneas con PU
		if (strstr(tmpArchivoPlt[i], "PU")) {
		
			
			// Si el siguiente es otro PU se salta a la siguiente iteración
			if (strstr(tmpArchivoPlt[i+1], "PU")) {continue;}
			
			// Si el vector anterior tenía las mismas coordenadas, saltar
			//strcpy(strtmp, tmpArchivoPlt[i]);
			//x = atoi(strtok(strtmp, " PUD;"));
			//y = atoi(strtok(NULL, " PUD;"));
				
			//strcpy(strtmp, tmpArchivoPlt[i-1]);
			//x2 = atoi(strtok(strtmp, " PUD;"));
			//y2 = atoi(strtok(NULL, " PUD;"));
				
			//printf("x=%d y=%d x2=%d y2=%d\\n", x,y,x2,y2);
				
			//if ((x==x2) && (y==y2)) {continue;}
			
			// Si el vector siguiente es PD y tiene las mismas coordenadas, saltar
			//if (strstr(tmpArchivoPlt[i+1], "PD")) {

			//strcpy(strtmp, tmpArchivoPlt[i+1]);
			//x2 = atoi(strtok(strtmp, " PUD;"));
			//y2 = atoi(strtok(NULL, " PUD;"));
				
			//printf("x=%d y=%d x2=%d y2=%d\\n", x,y,x2,y2);
				
			//if ((x==x2) && (y==y2)) {continue;}
			
			//}
						
		}
		
		// líneas con PD
		else if (strstr(tmpArchivoPlt[i], "PD")) {
		
			// Coordenadas actuales
			strcpy(strtmp, tmpArchivoPlt[i]);
			x = atoi(strtok(strtmp, " PUD;"));
			y = atoi(strtok(NULL, " PUD;"));
				
			// Si el siguiente es otro PD con las mismas coordenadas 
			// se salta a la siguiente iteración
			if (strstr(tmpArchivoPlt[i+1], "PD")) {
			
				strcpy(strtmp, tmpArchivoPlt[i+1]);
				x2 = atoi(strtok(strtmp, " PUD;"));
				y2 = atoi(strtok(NULL, " PUD;"));
				
				//printf("x=%d y=%d x2=%d y2=%d\\n", x,y,x2,y2);
				
				if ((x==x2) && (y==y2)) {continue;}
			
			}
			
			// Si el anterior es un PU con las mismas coordenadas 
			// se salta a la siguiente iteración
			//if (strstr(tmpArchivoPlt[i-1], "PU")) {
			
			//	strcpy(strtmp, tmpArchivoPlt[i-1]);
			//	x2 = atoi(strtok(strtmp, " PUD;"));
			//	y2 = atoi(strtok(NULL, " PUD;"));
				
				//printf("x=%d y=%d x2=%d y2=%d\\n", x,y,x2,y2);
				
			//	if ((x==x2) && (y==y2)) {continue;}
			
			//}
			
		}
		
		//*/
		
		// Si ha llegado hasta aquí, copia la línea
		strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[i]);
				
		// debug
		if (debug_plt) {
			printf("nuevalinea:%d %s\\n", nuevalinea, ArchivoPlt[nuevalinea]);
		}
					
		nuevalinea++;
	
	}
	
	// La última línea siempre se añade
	strcpy(ArchivoPlt[nuevalinea], tmpArchivoPlt[i]);
	
	// debug
	if (debug_plt) {
		printf("nuevalinea:%d %s\\n", nuevalinea, ArchivoPlt[nuevalinea]);
	}
					
	nuevalinea++; 

}

// Comprobación tras la optimización:
// Un Plt correcto debe tener al menos 2 líneas válidas, la primera con PU y la segunda con PD
if (nuevalinea > 1) {

	if ( !((strstr(ArchivoPlt[0],"PU")) && (strstr(ArchivoPlt[1],"PD"))) ){

		pltIncorrecto = true;

	}
	
}

else {

	pltIncorrecto = true;
	
}

// debug
if (debug_plt) {

	printf("xMaxPlt:%d xMinPlt:%d yMaxPlt:%d yMinPlt:%d\\n", xMaxPlt, xMinPlt, yMaxPlt, yMinPlt);

}
	
return nuevalinea;} {}
} 

Function {CalcularMatrizCampo()} {C return_type int
} {
  code {unsigned long i;

NumeroVectores = 0;

// Vector 0
strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
xValues[NumeroVectores] = MaximoBits;
yValues[NumeroVectores] = MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 1
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = MaximoBits;
yValues[NumeroVectores] = -MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 2
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = -MaximoBits;
yValues[NumeroVectores] = -MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 3
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = -MaximoBits;
yValues[NumeroVectores] = MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 4
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = MaximoBits;
yValues[NumeroVectores] = MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;


// Vector 5
strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
xValues[NumeroVectores] = MaximoBits;
yValues[NumeroVectores] = 0;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 6
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = -MaximoBits;
yValues[NumeroVectores] = 0;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 7
strncpy(TipoMarcaje[NumeroVectores], "PU", 2);
xValues[NumeroVectores] = 0;
yValues[NumeroVectores] = MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

// Vector 8
strncpy(TipoMarcaje[NumeroVectores], "PD", 2);
xValues[NumeroVectores] = 0;
yValues[NumeroVectores] = -MaximoBits;
uValues[NumeroVectores] = 0;
NumeroVectores++;

///////////////////////////////////////////////////////////////////////////////////
// Debug y Control
///////////////////////////////////////////////////////////////////////////////////
    
if (debug_vectores) {	
	printf("CalcularMatrizCampo - Vectores: %ld\\n", NumeroVectores);
	for (i=0; i<NumeroVectores; i++) {	
		printf("Vector:%ld TipoMarcaje:%s X:%d Y:%d\\n", i, TipoMarcaje[i], xValues[i], yValues[i]);	
	}
}

return 0;} {}
} 

Function {DescargarLista(int lista)} {C return_type void
} {
  code {unsigned long j; 
int result;
    
// Si la estrategia es de marcar átomos fuera de campo (2) y
// si está en ejecución -marcar, no prueba de marcaje- y el marcaje es dinámico
// hay que desplazar el Offset Dinámico
if ((Estrategia == 2) && (EnEjecucion) && (MarcajeDinamicoActivo > 0)) {
	
	// Actualiza las coordenadas de los vectores de la línea para la orientación dada
	for (j=0; j<NumeroVectores; j++) {
	
		xValues[j] = xValues[j] + xOffsetDinamico;
		yValues[j] = yValues[j] + yOffsetDinamico;
		uValues[j] = uValues[j] + uOffsetDinamico;
	
	}

}

// Inicia la lista
result = Set_Start_List(lista);

//calcula la correccion de la posicion de los vectores por fichero de correccion
/*for (j=0; j<NumeroVectores; j++) {
	if (FicheroCorreccionActivo == 1){
		result = CalcularCorreccionVector (xValues[j],yValues[j]);
		xValues[j]=xcorregido;
		yValues[j]=ycorregido;		
	}
}*/


//descarga la lista:
for (j=0; j<NumeroVectores; j++) {
    	
        if (strstr(TipoMarcaje[j],"PU")) {
	
		// guarda el umbral actual ahora, al principio de cada átomo, para todo el resto del átomo
		UmbralActual = uValues[j];
		
		//rt_printk("Iniciamos el Jump\\n");
		// calcula los microvectores del salto
        	result = Jump(xValues[j], yValues[j]);
		//rt_printk("Acabamos el Jump\\n");
	}
	   
        else { //es decir, TipoMarcaje(j)="PD" o "PS" para precorte
        
        	if (j < (NumeroVectores-1)) { //es decir, no estamos en el último vector
                
                	if (strstr(TipoMarcaje[j + 1],"PU")) { //es decir, el siguiente es un salto
                    
                    		if (strstr(TipoMarcaje[j - 1],"PU")) { //es decir el anterior también es un salto
                        		
                        		if (strstr(TipoMarcaje[j],"PS")) { // Precorte
                        			result = MarkPrecorte(xValues[j], yValues[j]);
                        		}
                        		else {
                        			//rt_printk("Iniciamos el Mark\\n");
                        			result = Mark(xValues[j], yValues[j]);
                        			//rt_printk("Acabamos el Mark\\n");

                        		}
                        		
                        	}
                        	                       
                    		else {	//el anterior no es un salto
                        		//rt_printk("Iniciamos el PolC\\n");
                        		result = PolC(xValues[j], yValues[j]);
                         		//rt_printk("Acabamos el PolC\\n");
                    		}
                    
                	}
                	
                	else {	//el siguiente no es un salto
                    
                    		if (strstr(TipoMarcaje[j - 1],"PD")) { //el anterior no es un salto
                          		//rt_printk("Iniciamos el PolB\\n");                      
                        		result = PolB(xValues[j], yValues[j]);
                                        //rt_printk("Acabamos el PolB\\n");
                    		}
                    		
                    		else {	//el anterior debe ser un salto
                          		//rt_printk("Iniciamos el PolA\\n");                     
                        		result = PolA(xValues[j], yValues[j]);
                           		//rt_printk("Acabamos el PolA\\n");
                    		}
                
                	}
            
            	}
            	
            	else {	//estamos en el último vector
                
                	if (strstr(TipoMarcaje[j - 1],"PU")) { //el anterior era un salto
                    		
                    		if (strstr(TipoMarcaje[j],"PS")) { // Precorte
                        		result = MarkPrecorte(xValues[j], yValues[j]);
                        	}
                        	else {
                          		//rt_printk("Iniciamos el Mark ultimo vector\\n");                      	
                        		result = Mark(xValues[j], yValues[j]);
                          		//rt_printk("Acabamos el Mark ultimo vector\\n");                      	
                        	}
                    	
                    	}
                	
                	else {	//el anterior no era un salto
                    		
                    		result = PolC(xValues[j], yValues[j]);
                    
                	}
                   
         	}
    
    	}
    	
}

result = Set_End_Of_List(lista); //Close the list    

//DEBUG
if (debug_listas) {

	switch(lista) {
	
	case 0:
		rt_printk("LISTA 0 Descargada: %ld mVectores\\n", Lista0_NumeroMicroVectores-1);
		break;
		
	case 1:
		rt_printk("LISTA 1 Descargada: %ld mVectores\\n", Lista1_NumeroMicroVectores-1);
		break;
	
	case 2:
		rt_printk("LISTA 2 Descargada: %ld mVectores\\n", Lista2_NumeroMicroVectores-1);
		break;
	}

}} {}
} 

Function {EjecutarLista(short lista)} {C return_type int
} {
  code {int error = false;

// Hay que empezar la ejecución desde el primer microvector
MicroVector = 0;

switch (lista) {
	
case 1:
	// La lista 2 no debe estar ejecutándose
	if ((Lista2_Exe == false) && ((Lista1_NumeroMicroVectores-1) > 0)) {
		
		Lista1_Exe = true;
		
		if (debug_Mvectores) {
			rt_printk("\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# InicioEjecucion Lista 1\\n");
		}
	
	}
	
	else {
	
		error = true;
	
	}
	
	break;
	
case 2:
	// La lista 1 no debe estar ejecutándose
	if ((Lista1_Exe == false) && ((Lista2_NumeroMicroVectores-1) > 0)) {
	
		Lista2_Exe = true;
		
		if (debug_Mvectores) {
			rt_printk("\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# InicioEjecucion Lista 2\\n");
		}
		
	}
	
	else {
	
		error = true;
	
	}
	
	break;
	
default:

	rt_printk("EjecutarLista ERROR DE EJECUCIÓN DE LISTAS\\n"); 
	error = true;
	ErrorVectores = ON;
	ProcesarError();

	break;

}

if ((debug_listas) && (error == false)) {
	
	switch (lista) {
	
	case 1:
		rt_printk(">>>>>>>>>>>>INICIO EJECUCIÓN LISTA %d con %ld MVectores\\n", lista, Lista1_NumeroMicroVectores -1);
		break;
	
	case 2:
		rt_printk(">>>>>>>>>>>>INICIO EJECUCIÓN LISTA %d con %ld MVectores\\n", lista, Lista2_NumeroMicroVectores -1);
		break;
	}
	
}

if (error == true) {
	
	switch (lista) {
	
	case 1:
		rt_printk("ERROR AL INICIAR LA EJECUCIÓN DE LA LISTA %d con %ld MVectores\\n", lista, Lista1_NumeroMicroVectores -1);
		break;
	
	case 2:
		rt_printk("ERROR AL INICIAR LA EJECUCIÓN DE LA LISTA %d con %ld MVectores\\n", lista, Lista2_NumeroMicroVectores -1);
		break;
	}
	
	ErrorVectores = ON;
	ProcesarError();

}

return error;} {}
} 

Function {Set_Start_List(int lista)} {C return_type int
} {
  code {int error = false;
//int result;
//double x;
//double y;


//xValuesOrigenMV = xValuesPosicion;
//yValuesOrigenMV = yValuesPosicion;

switch (lista) {

/*
case 0:
	// La otras dos listas deben estar cerradas
	if ((Lista1_Open == false) && (Lista2_Open == false)) {
		
		Lista0_NumeroMicroVectores = 0;
		Lista0_Open = true;
		
		xValuesOrigenMV = xValuesPosicion;
		yValuesOrigenMV = yValuesPosicion;

	}
	
	else {	
		rt_printk("Set_Start_Lista %d::ERROR DE EJECUCIÓN DE LISTAS\\n", lista); 
		error = true;
		ErrorVectores = ON;
		ProcesarError();
	}
	
	break;
*/
	
case 1:
	
	// La otras dos listas deben estar cerradas
	if ((Lista0_Open == false) && (Lista2_Open == false)) {
		
		Lista1_NumeroMicroVectores = 0;
		Lista1_Open = true;
	
	/*if (FicheroCorreccionActivo == 1){
		x = (double)xValues[0];
		y = (double)yValues[0];
		result = CalcularCorreccionMicrovector (x, y);
		xValuesOrigenMV=(int)xcorregidoMV;
		yValuesOrigenMV=(int)ycorregidoMV;		
	}	
	else {*/
		xValuesOrigenMV = xValues[0];
		yValuesOrigenMV = yValues[0];
	//}
		//rt_printk("xvaluesorigenMV= %d yvaluesorigenMV= %d \\n", xValuesOrigenMV , yValuesOrigenMV);
	
}
	else {	
		rt_printk("Set_Start_Lista %d::ERROR DE EJECUCIÓN DE LISTAS\\n", lista); 
		error = true;
		ErrorVectores = ON;
		ProcesarError();
	}
	
	break;
	
case 2:
	// La otras dos listas deben estar cerradas
	if ((Lista0_Open == false) && (Lista1_Open == false)) {
		
		Lista2_NumeroMicroVectores = 0;
		Lista2_Open = true;
		
		xValuesOrigenMV = xValues[0];
		yValuesOrigenMV = yValues[0];
	}
	
	else {
		rt_printk("Set_Start_Lista %d::ERROR DE EJECUCIÓN DE LISTAS\\n", lista); 
		error = true;
		ErrorVectores = ON;
		ProcesarError();
	}
	
	break;
	
default:
	
	rt_printk("Set_Start_Lista::ERROR DE EJECUCIÓN DE LISTAS\\n"); 
	error = true;
	ErrorVectores = ON;
	ProcesarError();

	break;

}

if ((debug_listas) && (error == true)) {
	rt_printk("Set_Start_Lista ERROR AL ABRIR LA LISTA %d\\n", lista);
}

if (debug_posicion) {
	rt_printk("SetStartList %d::OrigenMV=%ld,%ld\\n", lista, xValuesOrigenMV, yValuesOrigenMV);
}

return error;} {}
} 

Function {Set_End_Of_List(int lista)} {C return_type int
} {
  code {int error = false;
unsigned int i;

switch (lista) {
	
case 1:
	Lista1_Open = false;
	
	// DEBUG
	if (debug_Mvectores) {
		
		rt_printk("Set_End_Of_List::Lista1_NumeroMicroVectores: %ld\\n", Lista1_NumeroMicroVectores);
		
		for (i=0; i<Lista1_NumeroMicroVectores; i++) {
			rt_printk("MV:%d	x:%d	y:%d	Laser:%d\\n", i, Lista1_xBits[i], Lista1_yBits[i], Lista1_EstadoLaser[i]);
		}
		
	}
	
	break;
	
case 2:
	Lista2_Open = false;
	
	// DEBUG
	if (debug_Mvectores) {
		
		rt_printk("Set_End_Of_List::Lista2_NumeroMicroVectores: %ld\\n", Lista2_NumeroMicroVectores);
		
		for (i=0; i<Lista2_NumeroMicroVectores; i++) {
			rt_printk("MV:%d	x:%d	y:%d	Laser:%d\\n", i, Lista2_xBits[i], Lista2_yBits[i], Lista2_EstadoLaser[i]);
		}
		
	}
	
	break;
	
default:
	rt_printk("Set_End_Of_List::ERROR DE EJECUCIÓN DE LISTAS\\n"); 	
	error = true;
	ErrorVectores = ON;
	ProcesarError();

	break;

}

if ((debug_listas) && (error == true)) {
	rt_printk("Set_End_Of_List::ERROR AL CERRAR LA LISTA %d\\n", lista);
}

return error;} {}
} 

Function {Mark(int xdestino, int ydestino)} {C return_type int
} {
  code {double angulo, distancia;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc, ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
int result;

////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("MARK::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("MARK::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("MARK	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////


	
// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);

//rt_printk("xdestinomark:%d ydestinomark:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 

if (debug_Mvectores) {
	rt_printk("MARK::Microvectores Mark:%d \\n", numeromicrovectores);
}

// Si el microvector en el que habrá que encender el láser es mayor que el total de microvectores
// hay que devolver un error retornar
if (PeriodosRetardoLaserOn > numeromicrovectores) {
	//StopEjecucion();
	rt_printk("MARK::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\\n", numeromicrovectores, PeriodosRetardoLaserOn); 
	//ErrorVectores = ON;
	//ProcesarError();
	//return -1;
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
		
	}
	
	// Si no es el último, incrementar el valor de Mark Step Size	
	else {
		
		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	//printf("i:%d x:%f y:%f\\n", i, x, y);
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el comando Mark el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el comando Mark el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("MARK::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}

} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE MARCAJE
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si el microvector en el que habrá que apagar el láser es mayor que el total de microvectores
// es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
// vendrá dado por el retardo de Laser Off, en caso contrario será el retardo de marcaje
if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
	numeromicrovectores = PeriodosRetardoLaserOff;
}
else {
	numeromicrovectores = PeriodosRetardoMarcaje;
}

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=numeromicrovectores; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
		
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("MARK::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}


// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("MARK::lista1:%ld 	lista2:%ld\\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {MarkPrecorte(int xdestino, int ydestino)} {C return_type int
} {
  code {double angulo, distancia;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc,ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
double MarkStepSizePrecorte;
int result;

// El precorte requiere un stepsize distinto
MarkStepSizePrecorte = (unsigned int) ceil(VelocidadMarcaje * VelocidadPrecorte/100.0 * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);

////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("MARK::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("MARK::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("MARK	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////


// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSizePrecorte);

//printf("distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", distancia, angulo, MarkStepSize, numeromicrovectores); 

if (debug_Mvectores) {
	rt_printk("MARK::Microvectores Mark:%d \\n", numeromicrovectores);
}

// Si el microvector en el que habrá que encender el láser es mayor que el total de microvectores
// hay que devolver un error retornar
if (PeriodosRetardoLaserOn > numeromicrovectores) {
	//StopEjecucion();
	rt_printk("MARK::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\\n", numeromicrovectores, PeriodosRetardoLaserOn); 
	//ErrorVectores = ON;
	//ProcesarError();
	//return -1;
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Si no es el último, incrementar el valor de Mark Step Size	
	else {
		
		
		xsinc = xsinc + ((double)MarkStepSizePrecorte * cos(angulo));
		ysinc = ysinc + ((double)MarkStepSizePrecorte * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	//printf("i:%d x:%f y:%f\\n", i, x, y);
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el comando Mark el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el comando Mark el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("MARK::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}

} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE MARCAJE
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si el microvector en el que habrá que apagar el láser es mayor que el total de microvectores
// es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
// vendrá dado por el retardo de Laser Off, en caso contrario será el retardo de marcaje
if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
	numeromicrovectores = PeriodosRetardoLaserOff;
}
else {
	numeromicrovectores = PeriodosRetardoMarcaje;
}

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=numeromicrovectores; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
		
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("MARK::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("MARK::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}


// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("MARK::lista1:%ld 	lista2:%ld\\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {Jump(int xdestino, int ydestino)} {C return_type int
} {
  code {double distancia, angulo;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc,ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
int result;


////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("JUMP::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("JUMP::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("JUMP	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////



// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

//rt_printk("xdestinojump:%f ydestinojump:%f xValuesOrigenMV:%d yValuesOrigenMV:%d \\n", xsinc ,ysinc, xValuesOrigenMV, yValuesOrigenMV);

// Si ya estábamos en el punto porque se hubieran movido los galvos al inicio, volver sin hacer nada
if ( (xsinc == 0) && (ysinc == 0)){ 	
	return 0;
}

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)JumpStepSize);

//rt_printk("xdestinojump:%d ydestinojump:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f JumpStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, JumpStepSize, numeromicrovectores); 
if (debug_Mvectores) {
	rt_printk("JUMP::Microvectores Salto:%d \\n", numeromicrovectores);
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Si no es el último, incrementar el valor de Jump Step Size	
	else {
		
		
		xsinc = xsinc + ((double)JumpStepSize * cos(angulo));
		ysinc = ysinc + ((double)JumpStepSize * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el salto el láser está apagado
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("JUMP::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
				
		// Durante el salto el láser está apagado
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("JUMP::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	
	
	// Error de listas
	else {
		StopEjecucion();
		rt_printk("JUMP::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}

} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE SALTO
////////////////////////////////////////////////////////////////////////////////////////////////////

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=PeriodosRetardoSalto; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el salto el láser está apagado
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("JUMP::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el salto el láser está apagado
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("JUMP::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	
	// Error de listas
	else {
		StopEjecucion();
		rt_printk("JUMP::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}


// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("JUMP::lista1:%ld lista2:%ld \\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {PolA(int xdestino, int ydestino)} {C return_type int
} {
  code {double distancia, angulo;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc,ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
int result;


////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("PolA::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("PolA::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("PolA	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////


// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);

//rt_printk("xdestinopola:%d ydestinopola:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 

if (debug_Mvectores) {
	rt_printk("PolA::Microvectores PolA:%d \\n", numeromicrovectores);
}

// Si el microvector en el que habrá que encender el láser es mayor que el total de microvectores
// hay que devolver un error retornar
if (PeriodosRetardoLaserOn > numeromicrovectores) {
	//StopEjecucion();
	rt_printk("PolA::AVISO DE RETARDO DE LASER ON - Microvectores:%d Retardo:%d\\n", numeromicrovectores, PeriodosRetardoLaserOn); 
	//ErrorVectores = ON;
	//ProcesarError();
	//return -1;
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Si no es el último, incrementar el valor de Mark Step Size	
	else {
		
		
		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono A el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolA::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono A el láser está apagado hasta que termina el retardo de Laser On
		if (i <= PeriodosRetardoLaserOn) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolA::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolA::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}

} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE POLÍGONO
////////////////////////////////////////////////////////////////////////////////////////////////////

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=PeriodosRetardoPoligono; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Al terminar el polígono A el láser sigue encendido
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolA::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Al terminar el polígono A el láser sigue encendido
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolA::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolA::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}


// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("PolA::lista1:%ld 	lista2:%ld\\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {PolB(int xdestino, int ydestino)} {C return_type int
} {
  code {double distancia, angulo;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc,ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
int result;

////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("PolB::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("PolB::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("PolB	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////

	
// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);

//rt_printk("xdestinopolb:%d ydestinopolb:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 

if (debug_Mvectores) {
	rt_printk("PolB::Microvectores PolB:%d \\n", numeromicrovectores);
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Si no es el último, incrementar el valor de Mark Step Size	
	else {
		
		
		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono B el láser está encendido
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolB::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono B el láser está encendido
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolB::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolB::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE POLÍGONO
////////////////////////////////////////////////////////////////////////////////////////////////////

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=PeriodosRetardoPoligono; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono B el láser está encendido
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolB::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono B el láser está encendido
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolB::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolB::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}


// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("PolB::lista1:%ld 	lista2:%ld\\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {PolC(int xdestino, int ydestino)} {C return_type int
} {
  code {double distancia, angulo;	// variable para conocer el ángulo de la recta
double x, y;
double xsinc,ysinc;			// cálculos con coordenadas
unsigned int numeromicrovectores, i;
int result;

////////////////////////////////////////////////////////////////////////////////////////////////////
// CONTROL DE LISTAS
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si ambas listas están abiertas devuelve un error y retorna:
if ((Lista1_Open == ON) && (Lista2_Open == ON)) {
	StopEjecucion();
	rt_printk("PolC::ERROR DE LISTAS ABIERTAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

// Si ambas listas están cerradas devuelve un error y retorna:
if ((Lista1_Open == OFF) && (Lista2_Open == OFF)) {
	StopEjecucion();
	rt_printk("PolC::ERROR DE LISTAS CERRADAS\\n"); 
	ErrorVectores = ON;
	ProcesarError();
	return -1;
}

//if (debug_vectores) {
//       	printf("PolC	xOrigen:%d	yOrigen:%d	xDestino:%d	yDestino:%d \\n", xValuesOrigen, yValuesOrigen, xdestino, ydestino);
//}

////////////////////////////////////////////////////////////////////////////////////////////////////
// COORDENADAS
////////////////////////////////////////////////////////////////////////////////////////////////////

	
// Calcula el incremento en bits de cada coordenada
xsinc = xdestino - xValuesOrigenMV;
ysinc = ydestino - yValuesOrigenMV;

// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(xsinc,2) + pow(ysinc,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(ysinc,xsinc);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)MarkStepSize);

//rt_printk("xdestinopolc:%d ydestinopolc:%d xValuesOrigenMV:%d yValuesOrigenMV:%d distancia:%f angulo:%f MarkStepSize:%d numeromicrovectores:%d", xdestino, ydestino, xValuesOrigenMV, yValuesOrigenMV, distancia, angulo, MarkStepSize, numeromicrovectores); 

if (debug_Mvectores) {
	rt_printk("PolC::Microvectores PolC:%d \\n", numeromicrovectores);
}

// Incialización del cálculo de los microvectores
xsinc = xValuesOrigenMV;
ysinc = yValuesOrigenMV;

// Calcula las coordenadas los microvectores
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		xsinc = xdestino;
		ysinc = ydestino;
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Si no es el último, incrementar el valor de Mark Step Size	
	else {
		
		
		xsinc = xsinc + ((double)MarkStepSize * cos(angulo));
		ysinc = ysinc + ((double)MarkStepSize * sin(angulo));
		
		if (FicheroCorreccionActivo == 1) {
		result = CalcularCorreccionMicrovector (xsinc,ysinc);
		x=xcorregidoMV;
		y=ycorregidoMV;		
		}
		else {
		x=xsinc;
		y=ysinc;
		}
	}
	
	// Almacenar los valores en la lista que se está procesando

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono C el láser está encendido
		Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolC::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el polígono C el láser está encendido
		Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolC::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolC::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}

} 


////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE MARCAJE
////////////////////////////////////////////////////////////////////////////////////////////////////

// Si el microvector en el que habrá que apagar el láser es mayor que el total de microvectores
// es porque el retardo de LaserOff es mayor que el de marcaje, por tanto el numero de microvectores
// vendrá dado por el retardo de Laser Off, en caso contrario será el retardo de marcaje
if (PeriodosRetardoLaserOff > PeriodosRetardoMarcaje) {
	numeromicrovectores = PeriodosRetardoLaserOff;
}
else {
	numeromicrovectores = PeriodosRetardoMarcaje;
}

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=numeromicrovectores; i++) {

	// Lista 1
	if (Lista1_Open == ON) {
	
		// Guarda los valores
		Lista1_xBits[Lista1_NumeroMicroVectores] = (int)x;
		Lista1_yBits[Lista1_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista1_EstadoLaser[Lista1_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista1_Umbral[Lista1_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista1_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista1_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolC::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}

	// Lista 2
	else if (Lista2_Open == ON) {
	
		// Guarda los valores
		Lista2_xBits[Lista2_NumeroMicroVectores] = (int)x;
		Lista2_yBits[Lista2_NumeroMicroVectores] = (int)y;
		
		// Durante el retardo de marcaje el láser está encendido hasta que termina 
		// el retardo de Laser Off, a no ser que sea el último microvector
		if ((i<=PeriodosRetardoLaserOff) && (i<numeromicrovectores)) {
		
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = ON;
		}
		
		else {
			Lista2_EstadoLaser[Lista2_NumeroMicroVectores] = OFF;
		}
		
		// Guarda el umbral asociado a estos microvectores
		Lista2_Umbral[Lista2_NumeroMicroVectores] = UmbralActual;
		
		// Incrementa el índice para el siguiente microvector
		Lista2_NumeroMicroVectores++;
		
		// Controla que no se sobrepase el máximo
		if (Lista2_NumeroMicroVectores > NumeroMaximoMicroVectores) {
			StopEjecucion();
			rt_printk("PolC::ERROR DE NÚMERO DE MICROVECTORES\\n"); 
			ErrorVectores = ON;
			ProcesarError();
			return -1;
		}
	
	}	

	// Error de listas
	else {
		StopEjecucion();
		rt_printk("PolC::ERROR DE LISTAS\\n"); 
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}

// Guarda el valor de las coordenadas de destino en bits para la ejecución del siguiente comando de lista
xValuesOrigenMV = xdestino;
yValuesOrigenMV = ydestino;

if (debug_Mvectores) {
       	rt_printk("PolC::lista1:%ld 	lista2:%ld\\n", Lista1_NumeroMicroVectores-1, Lista2_NumeroMicroVectores-1);
}

return 0;} {}
} 

Function {CalcularMarkStepSize()} {C return_type int
} {
  code {int err;

// Calcula el Mark Step Size en bits
MarkStepSize = (unsigned int) ceil(VelocidadMarcaje * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);

if (debug_step){
	rt_printk("Mark Step Size en bits: %d\\n", MarkStepSize);
}

return err;} {}
} 

Function {CalcularJumpStepSize()} {C return_type int
} {
  code {int err;

// Calcula el Jump Step Size en bits
JumpStepSize = (unsigned int) ceil(VelocidadSalto * CalibracionCorreccion * PERIODO_MICROSEGUNDOS * 1E-6);

if (debug_step){
	rt_printk("Jump Step Size en bits: %d\\n", JumpStepSize);
}

return err;} {}
} 

Function {StartEjecucion()} {C return_type int
} {
  code {int error = false;

rt_printk("\# Start Ejecución \#\\n");

// Disparo interno
if (TipoDisparo == DISPAROINTERNO) {

	// Marcaje estático
	if (MarcajeDinamicoActivo == 0) {
	
		SeparacionEntreDisparos_cuentas = 0;
		
	}
	
	// Marcaje dinámico con velocidad variable, depende de la calibración del encoder
	else if (MarcajeDinamicoActivo == 1) {
	
		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
		
	}
	
	// Marcaje dinámico con velocidad constante, se utiliza 25 como calibración del encoder
	else if (MarcajeDinamicoActivo == 2) {
	
		//SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * CalibracionEncoder);
		SeparacionEntreDisparos_cuentas = (int)(SeparacionEntreDisparos_mm * 25.0);
		
	}
	
	//printf("SeparacionEntreDisparos_mm:%d SeparacionEntreDisparos_cuentas:%ld\\n", SeparacionEntreDisparos_mm, SeparacionEntreDisparos_cuentas);

}

// Guarda los datos definidos en el interfaz; serán los que se cargarán en el próximo arranque de la máquina
Escribir_DAT("itaca.dat");

// Escribe las señales de control de línes y de extractor, si está activado
switch (Control) {

case DAQ:
	
	// Escribe en la salida digital la señal de Control de línea
	// Active High - las salidas están a 0V al inicializar
	error = comedi_dio_write(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, HIGH);	
	if(error < 0){
		rt_printk("comedi_dio_write = %d\\n - Control de Línea ON",error);
		ErrorDAQ = ON;
		ProcesarError();
	}

	// Arranca el extractor si está activo
	if (ExtractorActivado == true) {

		// Escribe en la salida digital
		// Active High - las salidas están a 0V al inicializar
		error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);	
		if (error < 0) {
			rt_printk("comedi_dio_write error = %d\\n - Control de Extractor ON",error);
			ErrorDAQ = ON;
			ProcesarError();
		}
	
		// Espera 3 segundos para dar tiempo al extractor a arrancar y generar la señal de activación
		//Fl::wait(3);
		sleep(3);

	}	
	
	break;

case FPGA:

	// Escribe en la salida digital la señal de Control de línea
	outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);

	// Arranca el extractor si está activo
	if (ExtractorActivado == true) {

		// Escribe en la salida digital
		outb((COMANDO_EXTRACTOR|0x01), REGISTRO_ADDR);
	
		// Espera 3 segundos para dar tiempo al extractor a arrancar y generar la señal de activación
		//Fl::wait(3);
		sleep(3);

	}	
		
	break;
	
} 

// Activa la ventana principal para desactivar sólo lo necesario
VentanaPrincipal->activate();

// Si está activado el modo de servicio técnico no desactiva los grupos de control de
// intensidad y marca, para permitir el ajuste dinámico de la marca
// Ni algunos campos del control de la marca

// Permite cambios "online" si está el servicio técnico activado
if (!ServicioTecnico) {
	GrupoControlTexto->deactivate();
	GrupoControlTextoBloques->deactivate();
	GrupoControlIntensidad->deactivate();
	GrupoControlMarca->deactivate();	
}

else {

	// No se puede cambiar online la fuente, el contenido de la línea y la justificación
	CuadroTextoLinea1->deactivate();
	CuadroTextoLinea2->deactivate();
	CuadroTextoLinea3->deactivate();
	CuadroTextoLinea4->deactivate();
	BotonDetallesLinea1->deactivate();
	BotonDetallesLinea2->deactivate();
	BotonDetallesLinea3->deactivate();
	BotonDetallesLinea4->deactivate();
	
	CuadroTextoLinea1Bloque1->deactivate();
	CuadroTextoLinea1Bloque2->deactivate();
	CuadroTextoLinea1Bloque3->deactivate();
	CuadroTextoLinea2Bloque1->deactivate();
	CuadroTextoLinea2Bloque2->deactivate();
	CuadroTextoLinea2Bloque3->deactivate();
	CuadroTextoLinea3Bloque1->deactivate();
	CuadroTextoLinea3Bloque2->deactivate();
	CuadroTextoLinea3Bloque3->deactivate();
	CuadroTextoLinea4Bloque1->deactivate();
	CuadroTextoLinea4Bloque2->deactivate();
	CuadroTextoLinea4Bloque3->deactivate();
	BotonDetallesLinea1Bloque1->deactivate();
	BotonDetallesLinea1Bloque2->deactivate();
	BotonDetallesLinea1Bloque3->deactivate();
	BotonDetallesLinea2Bloque1->deactivate();
	BotonDetallesLinea2Bloque2->deactivate();
	BotonDetallesLinea2Bloque3->deactivate();
	BotonDetallesLinea3Bloque1->deactivate();
	BotonDetallesLinea3Bloque2->deactivate();
	BotonDetallesLinea3Bloque3->deactivate();
	BotonDetallesLinea4Bloque1->deactivate();
	BotonDetallesLinea4Bloque2->deactivate();
	BotonDetallesLinea4Bloque3->deactivate();
	
	ChoiceFuente->deactivate();
	SubgrupoJustificacion->deactivate();
	
}

// Desactiva los botones de operaciones
BotonMarcar->deactivate();
BotonPrueba->deactivate();
BotonTrabajos->deactivate();
BotonTablaPrecorte->deactivate();
BotonLaser->deactivate();
BotonCampo->deactivate();
BotonApagar->deactivate();

// Activa el botón de stop
BotonStop->activate();

// Y el de la velocidad, si es preciso
if (MarcajeDinamicoActivo == 1) {

	CuadroTextoVLinea->activate();

}

// Actualiza el Led del láser a amarillo
LedLaser->color(FL_YELLOW);
LedLaser->redraw();	

// Fuerza la actualización del interfaz
//Fl::flush();

// Inicia el bucle de ejecución de listas
//error = ControlEjecucionListas();

// Se lanza como un thread independiente de FLTK para que al iniciar desde el puerto serie no se quede enganchado
// el thread y pueda seguir leyendo el puerto
// timeout 0 => inmediato

Fl::add_timeout(0,ControlEjecucionListas);

return error;} {}
} 

Function {StopEjecucion()} {C return_type int
} {
  code {int error = false;
int i, j;

rt_printk("\# Stop Ejecución \#\\n");

// Detiene la ejecución de las listas
Lista1_Exe = false;
Lista2_Exe = false;
	
// Desactiva el flag de en ejecución
EnEjecucion = false;

// Elimina el thread de control de ejecución de las listas
Fl::remove_timeout(ControlEjecucionListas);
				
// y ahora apaga el laser; no se debe apagar antes, ya que si las listas no se han detenido
// se puede volver a arrancar
//if (EstadoLaser == ON) \{
	
	Control_Laser(OFF);

//\}

// Desactiva la espera del disparo de la fotocélula
EsperaFotocelula = false;

// Desactiva la espera del retardo de disparo de la fotocélula
EsperaRetardoDisparo = false;

// Actualiza la señal de MarkInProgress y el Led del láser
ControlMarkInProgress(OFF);		

// Escribe las señales de control de línes y de extractor, si está activado
switch (Control) \{

case DAQ:
	
	// Escribe en la salida digital la señal de Control de línea
	// Active High - las salidas están a 0V al inicializar
	error = comedi_dio_write(comedi_device, comedi_subdevice_ControlEnable, comedi_canalDO_ControlEnable, OFF);	
	if (error < 0) \{
		rt_printk("comedi_dio_write error = %d - Control de Línea OFF\\n",error);
		ErrorDAQ = ON;
		ProcesarError();
	\}

	// Detiene el extractor si está activo
	if (ExtractorActivado == true) \{

		// Escribe en la salida digital
		// Active High - las salidas están a 0V al inicializar
		error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, OFF);	
		if (error < 0) \{
			rt_printk("comedi_dio_write error = %d\\n - Extractor OFF\\n",error);
			ErrorDAQ = ON;
			ProcesarError();
		\}
	
	\}	
	
	break;

case FPGA:

	// Escribe en la salida digital la señal de Control de línea
	outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);

	// Detiene el extractor si está activo
	if (ExtractorActivado == true) \{

		// Escribe en la salida digital
		outb((COMANDO_EXTRACTOR|0x00), REGISTRO_ADDR);
	
	\}	
		
	break;
	
\} 

// Mueve los galvos al inicio de la lista si no se ha detenido por error de campo u otro error del sistema
if ((FueraLimites == false) && (SistemaOk)) \{
	
	// Mueve los galvos al inicio de la lista si es necesario
	if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0)\{
//	if (CalcularMoverGalvos(xValuesPosicion, yValuesPosicion) > 0)\{
		MoverGalvos();
	\}
	
\}

// Reactiva los widgets en función del estado del servicio técnico o prueba de marcaje
if ((!ServicioTecnico) || (PruebaMarcaje)) \{
	GrupoControlIntensidad->activate();
	GrupoControlTexto->activate();
	GrupoControlTextoBloques->activate();
	GrupoControlMarca->activate();
\}

else \{

	// No se puede cambiar online la fuente, el contenido de la línea y la justificación
	if ( ValorTipoLinea[0][0] != GRAFICO) \{
		CuadroTextoLinea1->activate();
		CuadroTextoLinea1Bloque1->activate();
	\}
	
	if ( ValorTipoLinea[0][1] != GRAFICO) \{
		CuadroTextoLinea1Bloque2->activate();
	\}
	
	if ( ValorTipoLinea[0][2] != GRAFICO) \{
		CuadroTextoLinea1Bloque3->activate();
	\}
	
	if ( ValorTipoLinea[1][0] != GRAFICO) \{
		CuadroTextoLinea2->activate();
		CuadroTextoLinea2Bloque1->activate();
	\}
	
	if ( ValorTipoLinea[1][1] != GRAFICO) \{
		CuadroTextoLinea2Bloque2->activate();
	\}
	
	if ( ValorTipoLinea[1][2] != GRAFICO) \{
		CuadroTextoLinea2Bloque3->activate();
	\}
	
	if ( ValorTipoLinea[2][0] != GRAFICO) \{
		CuadroTextoLinea3->activate();
		CuadroTextoLinea3Bloque1->activate();
	\}
	
	if ( ValorTipoLinea[2][1] != GRAFICO) \{
		CuadroTextoLinea3Bloque2->activate();
	\}
	
	if ( ValorTipoLinea[2][2] != GRAFICO) \{
		CuadroTextoLinea3Bloque3->activate();
	\}
	
	if ( ValorTipoLinea[3][0] != GRAFICO) \{
		CuadroTextoLinea4->activate();
		CuadroTextoLinea4Bloque1->activate();
	\}
	
	if ( ValorTipoLinea[3][1] != GRAFICO) \{
		CuadroTextoLinea4Bloque2->activate();
	\}
	
	if ( ValorTipoLinea[3][2] != GRAFICO) \{
		CuadroTextoLinea4Bloque3->activate();
	\}
	
	BotonDetallesLinea1->activate();
	BotonDetallesLinea1Bloque1->activate();
	BotonDetallesLinea1Bloque2->activate();
	BotonDetallesLinea1Bloque3->activate();
	
	BotonDetallesLinea2->activate();
	BotonDetallesLinea2Bloque1->activate();
	BotonDetallesLinea2Bloque2->activate();
	BotonDetallesLinea2Bloque3->activate();
	
	BotonDetallesLinea3->activate();
	BotonDetallesLinea3Bloque1->activate();
	BotonDetallesLinea3Bloque2->activate();
	BotonDetallesLinea3Bloque3->activate();
	
	BotonDetallesLinea4->activate();
	BotonDetallesLinea4Bloque1->activate();
	BotonDetallesLinea4Bloque2->activate();
	BotonDetallesLinea4Bloque3->activate();
	
	ChoiceFuente->activate();
	SubgrupoJustificacion->activate();
	
\}

// Apaga los botones de prueba y marcar
BotonMarcar->value(OFF);
BotonPrueba->value(OFF);

// Apaga los botones de laser y campo
BotonLaser->value(OFF);
BotonCampo->value(OFF);

// Activa los botones de operaciones
if (!ErrorValidacion) \{
	BotonMarcar->activate();
\}

BotonPrueba->activate();
BotonTrabajos->activate();
BotonTablaPrecorte->activate();
CounterVelocidadLinea->activate();
CounterEncoder->activate();
BotonCampo->activate();
BotonLaser->activate();
BotonApagar->activate();

// Desactiva el botón de stop
BotonStop->deactivate();

// Actualiza el Led del láser a gris
LedLaser->color(FL_DARK3);
LedLaser->redraw();

// Actualiza el contador
CuadroTextoContador->value(Contador);

// Mira a ver si hay algún error
ProcesarError();

// Actualiza el número de serie - qué pasa con el número de unidades por lote...
for (i=0; i<NumeroLineasTexto; i++) \{
	
	for (j=0; j<NumeroBloquesLinea; j++) \{
	
		if ((StatusNumeroSerie[i][j]) && (PruebaMarcaje == false)) \{
			
			// actualiza el número de serie o el de unidades en el lote, el que corresponda
			if (NumeroUnidadesLote[i][j] >1) \{
				NumeroUnidadesLoteActual[i][j]--;
			\}
			else \{
				if (NumeroSerie[i][j] > 0) \{
					NumeroSerie[i][j]--;
				\}
			\}
	
			//actualizarserie = true;
		\}		
	\}
\}

// Actualizar fecha, hora y serie
ActualizarFechaHoraSerie();

// Actualiza las líneas
if ( ValorTipoLinea[0][0] != GRAFICO) \{
	CuadroTextoLinea1->value(LineaTexto1[0]);
	CuadroTextoLinea1Bloque1->value(LineaTexto1[0]);
\}
	
if ( ValorTipoLinea[0][1] != GRAFICO) \{
	CuadroTextoLinea1Bloque2->value(LineaTexto1[1]);
\}
	
if ( ValorTipoLinea[0][2] != GRAFICO) \{
	CuadroTextoLinea1Bloque3->value(LineaTexto1[2]);
\}
	
if ( ValorTipoLinea[1][0] != GRAFICO) \{
	CuadroTextoLinea2->value(LineaTexto2[0]);
	CuadroTextoLinea2Bloque1->value(LineaTexto2[0]);
\}
	
if ( ValorTipoLinea[1][1] != GRAFICO) \{
	CuadroTextoLinea2Bloque2->value(LineaTexto2[1]);
\}
	
if ( ValorTipoLinea[1][2] != GRAFICO) \{
	CuadroTextoLinea2Bloque3->value(LineaTexto2[2]);
\}
	
if ( ValorTipoLinea[2][0] != GRAFICO) \{
	CuadroTextoLinea3->value(LineaTexto3[0]);
	CuadroTextoLinea3Bloque1->value(LineaTexto3[0]);
\}
	
if ( ValorTipoLinea[2][1] != GRAFICO) \{
	CuadroTextoLinea3Bloque2->value(LineaTexto3[1]);
\}
	
if ( ValorTipoLinea[2][2] != GRAFICO) \{
	CuadroTextoLinea3Bloque3->value(LineaTexto3[2]);
\}

if ( ValorTipoLinea[3][0] != GRAFICO) \{
	CuadroTextoLinea4->value(LineaTexto4[0]);
	CuadroTextoLinea4Bloque1->value(LineaTexto4[0]);
\}
	
if ( ValorTipoLinea[3][1] != GRAFICO) \{
	CuadroTextoLinea4Bloque2->value(LineaTexto4[1]);
\}
	
if ( ValorTipoLinea[3][2] != GRAFICO) \{
	CuadroTextoLinea4Bloque3->value(LineaTexto4[2]);
\}

//Para Oscilador Fibra
switch(TipoLaser)\{
case 1:
Parar_Oscilador_Fibra();
break;
\}


// Guarda los datos actuales de la marca
Escribir_DAT("itaca.dat");

// Desactiva el flag de prueba de marcaje
PruebaMarcaje = false;

return error;} {}
} 

Function {ControlEjecucionListas(void*)} {open C return_type void
} {
  code {int listaorigen;
unsigned long long i=0;

// Inicialización
MarcajeOk = true;
EnEjecucion = true;
ErrorEjecucionListas = false;
listaorigen = 1;
ActualizarPuertoSerie=false;
ContadorDisparosParado = 0;

// Calcula la matriz
if (CalcularMatriz() != NoError) {
	
	rt_printk("ControlEjecucionListas: problema al CalcularMatriz\\n");
	StopEjecucion();
	ErrorEjecucionListas = true;
	return;
	//return -1;

}

// Disparo externo
if (TipoDisparo == DISPAROEXTERNO) {

	// Inicializa el flag de control de espera de la fotocélula
	EsperaFotocelula = false;	
	LecturasConsecutivasDisparo = 0;
	
	// Inicializa el flag de control de cambio del valor de la fotocélula
	CambioFotocelula = false;

}

// Disparo interno
else if (TipoDisparo == DISPAROINTERNO) {

	EsperaSeparacionEntreDisparos = false;	
	IncrementoAcumulado_Espera = 0;

}

// Inicializa el flag de control de salto dinámicamente al origen
ResetJumpList = false;
 		
// Descarga la lista 1
DescargarLista(listaorigen);

// DEBUG
if (debug_listas) {
	rt_printk("Entrando en bucle\\n");
}

// Inicializa las variables para la lectura de las cuentas del encoder
// si hay marcaje dinámico
if (MarcajeDinamicoActivo > 0) {
				
	IncrementoAcumulado = 0;
				
	// Hay que activar la siguiente espera de disparo
	EsperaRetardoDisparo = true;
				
}
		
// Mueve los galvos al inicio de la lista si es necesario
if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
	MoverGalvos();
}
	
// Bucle principal de marcaje
while ((EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
        
        // Comprueba la posición de los galvos al inicio de la lista si está activada la comprobación
        if (ControlarErrorGalvos) {
        
		ErrorGalvos = ComprobarPosicion(xValues[0],yValues[0]);
		
		if (ErrorGalvos) {
		
			ErroresConsecutivosGalvos++;
			
			if (ErroresConsecutivosGalvos >= MaximoErroresConsecutivosGalvos) {
				
				//El error de galvos no detiene la ejecución del programa, pero hay que avisar
				ProcesarError();
				
				rt_printk("ControlEjecucionListas: Error de galvos\\n");
				StopEjecucion();
    				return;
    			
    			}
    		
    		}
    			
    		else {
    		
    			ErroresConsecutivosGalvos = 0;
    		
    		}
	
	}
	
	// Disparo externo
	if (TipoDisparo == DISPAROEXTERNO) {
	
		// Activa la espera del disparo de la fotocélula
		EsperaFotocelula = true;
	
	}
	
	// Disparo interno
	else if (TipoDisparo == DISPAROINTERNO) {

		// Activa la espera de la separación entre disparos
		EsperaSeparacionEntreDisparos = true;	
		
	}
	
        // Ejecuta la lista actual
        EjecutarLista(listaorigen);
        
        // Comprueba si hay que hacer actualizaciones de los datos
    	//Actualizar = false;
    	
    	//if ((StatusFecha == true) || (StatusHora == true) || (StatusNumeroSerie == true)) {
        	ActualizarFechaHoraSerie();
	//}
        
        switch (listaorigen) {
        	
        case 1:
        	// Mientras se ejecuta la lista actual actualiza la otra lista, si es necesario
        	if (Actualizar || ActualizarPuertoSerie) {
        	
        		// Calcula la nueva matriz
			if (CalcularMatriz() != NoError) {
	
				rt_printk("ControlEjecucionListas: problema al CalcularMatriz\\n");
				StopEjecucion();
				ErrorEjecucionListas = true;
				//return -1;
				return;

			}
        		
        		// Descarga la lista 2
        		DescargarLista(2);
        		
        		// y actualiza la variable para que la próxima iteración se ejecute la lista 2	
        		listaorigen = 2;	
        		
        	}
        	
        	// Espera a que termine la ejecución de la lista actual, incluyendo volver a la posición inicial:
        	while ( ((Lista1_Exe) || (Lista0_Exe)) && (EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
        	
        		// Espera un periodo 
        		Fl::wait(PERIODO_WAIT);
        	
        	}
        	
        	break;
        	
        case 2:
        	// Mientras se ejecuta la lista actual actualiza la otra lista, si es necesario
        	if (Actualizar || ActualizarPuertoSerie) {
        	
        		// Calcula la nueva matriz
			if (CalcularMatriz() != NoError) {
	
				rt_printk("ControlEjecucionListas: problema al CalcularMatriz\\n");
				StopEjecucion();
				ErrorEjecucionListas = true;
				//return -1;
				return;

			}
        		
        		// Descarga la lista 1
        		DescargarLista(1);
        		
        		// y actualiza la variable para que la próxima iteración se ejecute la lista 2	
        		listaorigen = 1;	
        		
        	}
        	
        	// Espera a que termine la ejecución de la lista actual, incluyendo volver a la posición inicial:
        	while ( ((Lista2_Exe) || (Lista0_Exe)) && (EnEjecucion == true) && (SistemaOk == true) && (MarcajeOk == true)) {
        	
        		// Espera un periodo 
        		Fl::wait(PERIODO_WAIT);
        	
        	}
        	
        	break;
        	
        }
        
        // Actualiza el contador si sigue en ejecución - no se ha presionado stop
        if (EnEjecucion) {
        	Contador++;
        }
        
        // Presenta en pantalla el valor del contador formateado     
        CuadroTextoContador->value(Contador);
        
        // Presenta en pantalla el valor del tiempo de la marca formateado en ms     
        CuadroTextoTMarca->value((double)(tFinMarca - tInicioMarca)/1E6);
        	
	// DEBUG
	if (debug_listas) {
		rt_printk("Terminando iteración %lld\\n", i);
		i++;
	}   
	
}

// Stop si había un problema de marcaje
if (MarcajeOk == false) {
	
	//MarcajeOk = true;
	rt_printk("ControlEjecucionListas: Error MarcajeOk - Deteniendo la ejecución\\n");
	StopEjecucion();
	ErrorEjecucionListas = true;
	//return -1;
	return;
	
}

//return error;} {}
} 

Function {ControlMarkInProgress(int OnOff)} {open C return_type int
} {
  code {int error = false;

switch (Control) {

case DAQ:
	
	// Activa la señal de Mark In Progress y el Led
	if (OnOff == ON) {
	
	
	switch(TipoLaser){
		
		case 1: 
		// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE On\\n",error);
				error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, HIGH);
				if (error<0){
					rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE On\\n",error);
					ErrorDAQ = ON;
					ProcesarError();
				}
			}

			// Actualiza el Led del láser a rojo
			//LedLaser->color(FL_RED);	// Led rojo
		
		
			break;
		/*
			// configura la señal gate
			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
			if (error < 0){
				rt_printk("ERROR comedi_set_gate_source 0 laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
	
			// configura el modo del contador
			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
			if (error < 0){
				rt_printk("ERROR comedi_set_counter_mode laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// asigna el reloj: 20MHz clock
			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
			if (error < 0){
				rt_printk("ERROR comedi_set_clock_source laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set initial counter value by writing to channel 0
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks inicial laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set "load a" register to the number of clock ticks the counter output should remain low
			// by writing to channel 1.
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks load a laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set "load b" register to the number of clock ticks the counter output should remain high
			// writing to channel 2 
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write up_ticks load b laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
	
			// arma el contador
			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
			if (error < 0){
				rt_printk("ERROR comedi_arm laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
			break;
			*/
		case 0:
		
			// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - Mark In Progress On\\n",error);
				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, HIGH);
				if (error<0){
					rt_printk("comedi_dio_write error = %d - Mark In Progress On duplicado\\n",error);
					ErrorDAQ = ON;
					ProcesarError();
				}
			}
		
			// Actualiza el Led del láser a verde
			//LedLaser->color(FL_GREEN);	// Led verde
		
		
			break;
			}			
		
		

	}

	// Desctiva la señal de Mark In Progress y el Led	
	else {
			
		switch(TipoLaser){
			case 0:
			// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - Mark In Progress Off\\n",error);
				error = comedi_dio_write(comedi_device, comedi_subdevice_MarkInProgress, comedi_canalDO_MarkInProgress, LOW);
				if (error<0){
					rt_printk("comedi_dio_write error = %d - Mark In Progress Off duplicado\\n",error);
					ErrorDAQ = ON;
					ProcesarError();
				}
			}

			// Actualiza el Led del láser a rojo
			//LedLaser->color(FL_RED);	// Led rojo
		
		
			break;
			
			/*
			// Resetea el contador
			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
			if (error < 0){
				rt_printk("ERROR comedi_reset laser %d\\n", error);
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
			break;
			*/
			
			case 1:
		
			// Active High - las salidas están a 0V al inicializar
			error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, LOW);	
			if (error < 0) {
				rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE Off\\n",error);
				error = comedi_dio_write(comedi_device, comedi_subdevice_ExtractorEnable, comedi_canalDO_ExtractorEnable, LOW);
				if (error<0){
					rt_printk("comedi_dio_write error = %d - EXTRACTOR ENABLE Off\\n",error);
					ErrorDAQ = ON;
					ProcesarError();
				}
			}

			// Actualiza el Led del láser a rojo
			//LedLaser->color(FL_RED);	// Led rojo
		
		
			break;
		
		}		
		
		
	}

	
	break;

case FPGA:

	// OJO: en COMEDI se hacía con Active Low, es decir, al activar la señal hay que escribir 0V... ver en la FPGA
	// Creo que el comentario anterior es incorrecto...
	
	// Activa la señal de Mark In Progress y el Led
	if (OnOff == ON) {
	
		// Activa la señal de Mark in Progress
		outb((COMANDO_CONTROL|0x01), REGISTRO_ADDR);	
	}

	// Desctiva la señal de Mark In Progress y el Led	
	else {	

		// Desactiva la señal de Mark in Progress
		outb((COMANDO_CONTROL|0x00), REGISTRO_ADDR);	
	}	
	
	break;
	
} 

//LedLaser->redraw();		// Marca el Led para redraw
        
return error;} {}
} 

Function {EjecutarMicrovector(int lista)} {C return_type int
} {
  code {int error;
double Vx, Vy;		// para escribir en las salidas analógicas
lsampl_t AOdata; 	// para escribir en las salidas analógicas

// Si hay marcaje dinámico y no se trata de una prueba de marcaje hay que 
// leer las cuentas del encoder y actualizar los valores de la lista
if ((MarcajeDinamicoActivo > 0) && (PruebaMarcaje == false) && (ResetJumpList == false))\{
	
	// Velocidad variable: se utiliza el encoder para leer las cuentas actuales y calcular el incremento;
	// si se trata de velocidad constante el incremento se ha calculado al inicializar el marcaje
	if (MarcajeDinamicoActivo == 1) \{

		// Leer las cuentas del encoder
		//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasActual);
		//if (error < 0) \{
		//	rt_printk("LEER ENCODER comedi_data_read = %d\\n",error);
		//	ErrorDAQ = ON;
		//	ProcesarError();
		//\}
		
		// Calcular el incremento de cuentas
		if (ValorCuentasActual >= ValorCuentasAnterior) \{
			IncrementoCuentasPeriodo = (float)(ValorCuentasActual - ValorCuentasAnterior);
		\}
		else \{ 	//el contador ha sobrepasado el máximo de MaxdataContadorEncoder
			IncrementoCuentasPeriodo = (float)((MaxdataContadorEncoder - ValorCuentasAnterior) + ValorCuentasActual);
			//StopEjecucion();
			//LedEstado->label("Encoder: overflow");
			rt_printk("OVERFLOW MV %ld Actual:%d INCR:%f ACUM:%d\\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
			return false;
		\}
	
		// debug excesos del encoder
		if ((debug_encoder) && ((IncrementoCuentasPeriodo >= 10) || (IncrementoAcumulado<0))) \{
			
			//StopEjecucion();
			
			LedEstado->label("Encoder: incremento");
			rt_printk("MV%ld Actual:%d INCR:%f ACUM:%f\\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
			return false;
		
		\}
	
		// Guardar el valor leido para la próxima iteración
		ValorCuentasAnterior = ValorCuentasActual;
	
	\}
	
	// Acumula las cuentas
	IncrementoAcumulado += IncrementoCuentasPeriodo;
	
	//DEBUG
	if (debug_encoder == true) \{
		rt_printk("MV%ld Actual:%d INCR:%f ACUM:%f\\n", MicroVector, ValorCuentasActual, IncrementoCuentasPeriodo, IncrementoAcumulado);
	\}
		
\}

else \{	// Anula el incremento de cuentas
	IncrementoAcumulado = 0;
\}
	
// Ejecuta el microvector de la lista que se trate		
switch (lista) \{

case 0:	// Ejecución de la lista 0 para MoverGalvos
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza los galvos: 
	/////////////////////////////////////////////////////////////////////////////////////
	xBitsDouble = (double)(Lista0_xBits[MicroVector]);
	yBitsDouble = (double)(Lista0_yBits[MicroVector]);	
				
	// Coordenada X:
	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
	
	//rt_printk("xBitsDouble:%f Kx_Bits_a_Voltios:%f xBitsDouble * Kx_Bits_a_Voltios:%f \\n",xBitsDouble, Kx_Bits_a_Voltios, xBitsDouble * Kx_Bits_a_Voltios );
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vx) > VGalvoMax) \{
		
	    		rt_printk("ErrorCampo - Lista 0: MV=%ld Vx=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vx));

			ErroresConsecutivosCampoX++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoX = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vx);

		// escribe en el galvo X
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false; 
		\}
	
		break;

	case FPGA:

		// escribe en el galvo X
		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
		
		break;
	
	\} 
	
	// Coordenada Y:
	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vy) > VGalvoMax) \{

	    		rt_printk("ErrorCampo - Lista 0: MV=%ld Vy=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vy));
		
			ErroresConsecutivosCampoY++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoY = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vy);

		// escribe en el galvo Y
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false;
		\}
	
		break;

	case FPGA:

		// escribe en el galvo Y
		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
		
		break;
	
	\} 
		
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el laser: 
	/////////////////////////////////////////////////////////////////////////////////////
	
	if (Lista0_EstadoLaser[MicroVector] != EstadoLaser) \{ //Hay que cambiar el estado del laser
		Control_Laser(Lista0_EstadoLaser[MicroVector]);
	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza la posición:
	/////////////////////////////////////////////////////////////////////////////////////
	xValuesPosicion = (long)xBitsDouble;
	yValuesPosicion = (long)yBitsDouble;	
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el microvector: 
	/////////////////////////////////////////////////////////////////////////////////////			

	// Si era el último microvector ha terminado la ejecución de la lista
	//if ((MicroVector == (Lista0_NumeroMicroVectores - 1)) || (Lista0_NumeroMicroVectores == 0)) \{
	if (MicroVector == (Lista0_NumeroMicroVectores - 1)) \{
	
		Lista0_Exe = false;
		ResetJumpList = false;	
		
		if (debug_listas) \{
			rt_printk(">>COMPLETADA EJECUCIÓN LISTA %d MV=%ld Posición=%ld,%ld\\n", lista, Lista0_NumeroMicroVectores, xValuesPosicion, yValuesPosicion);
		\}
		
	\}
	
	// Si no, incrementar en microvector
	else \{
		MicroVector++;
	\}
			
	break;
	
case 1:	// Ejecución de la lista 1

  	//rt_printk("Lista 1: MV=%ld\\n", MicroVector);

	// Si hay un retardo de disparo pendiente comprobarlo ahora
	if ((MarcajeDinamicoActivo > 0) && ((RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional) > 0)	&& (EsperaRetardoDisparo == true)) \{
	
		// Si todavía no han pasado las cuentas correspondientes al retardo no continua
		if ((int)IncrementoAcumulado < (RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional)) \{
	
			return true;
		
		\}
	
		// Si ya han pasado resetea las variables de estado y continua con la ejecución de los microvectores
		else \{
	
			IncrementoAcumulado = 0;
			EsperaRetardoDisparo = false;
		\}	

	\}
	
	// Comprueba si el microvector ha supèrado el umbral, y si no vuelve, 
	// Sólo con la estrategia de fuera de campo
	if (Estrategia == 2) \{
	
			
		// Si el valor del upbral es negativo tiene que superar -MaximoBits para poder imprimirse
		if (Lista1_Umbral[MicroVector] < 0) \{
		
			if ((Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) < -MaximoBits) \{
				
				/*
				if (ImprimirMV)\{
					rt_printk("Espera umbral en Lista1 Microvector:%ld Umbral:%d Actual:%d\\n", MicroVector, Lista1_Umbral[MicroVector], Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
					ImprimirMV=false;
				\}
				*/
				
				return true;
		
			\}
		
		\}
		
		// Si es positivo para proseguir tiene que ser menor que MaximoBits
		else \{
		
			if ((Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) > MaximoBits) \{
		
				/*		
				if (ImprimirMV)\{
					rt_printk("Espera umbral en Lista1 Microvector:%ld Umbral:%d Actual:%d\\n", MicroVector, Lista1_Umbral[MicroVector], Lista1_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
					ImprimirMV=false;
				\}				
				*/
				
				return true;
		
			\}
			
		\} 
		
		//ImprimirMV = true;
	
	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza los galvos: 
	/////////////////////////////////////////////////////////////////////////////////////
	
	xBitsDouble = (double)(Lista1_xBits[MicroVector]+(IncrementoAcumulado*Kx_Cuentas_a_Bits));
	yBitsDouble = (double)(Lista1_yBits[MicroVector]+(IncrementoAcumulado*Ky_Cuentas_a_Bits));	
	
	// Coordenada X:
	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vx) > VGalvoMax) \{

	    		rt_printk("ErrorCampo - Lista 1: MV=%ld Vx=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vx));
		
			ErroresConsecutivosCampoX++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoX = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vx);

		// escribe en el galvo X
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false; 
		\}
	
		break;

	case FPGA:

		// escribe en el galvo X
		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
		
		break;
	
	\} 
	
	// Coordenada Y:
	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vy) > VGalvoMax) \{
		
	    		rt_printk("ErrorCampo - Lista 1: MV=%ld Vy=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vy));

			ErroresConsecutivosCampoY++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoY = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vy);

		// escribe en el galvo Y
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false;
		\}
	
		break;

	case FPGA:

		// escribe en el galvo Y
		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
		
		break;
	
	\} 		
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el laser: 
	/////////////////////////////////////////////////////////////////////////////////////
	
	if (Lista1_EstadoLaser[MicroVector] != EstadoLaser) \{ //Hay que cambiar el estado del laser
		Control_Laser(Lista1_EstadoLaser[MicroVector]);		
	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el tiempo de marca: 
	/////////////////////////////////////////////////////////////////////////////////////			
	
	if (MicroVector == 0) \{
	
		// Guarda el tiempo de inicio de la marca
		tInicioMarca = rt_get_time_ns();
		
		// Guarda el tiempo de fin de la marca hasta ahora, para evitar tiempos negativos
		tFinMarca = rt_get_time_ns();
	
	\}				
	
	else \{
	
		// Guarda el tiempo de fin de la marca hasta ahora
		tFinMarca = rt_get_time_ns();

	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza la posición:
	/////////////////////////////////////////////////////////////////////////////////////
	xValuesPosicion = (long) xBitsDouble;
	yValuesPosicion = (long) yBitsDouble;	
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el microvector: 
	/////////////////////////////////////////////////////////////////////////////////////	
		
	// Si era el último microvector ha terminado la ejecución de la lista
	if (MicroVector == (Lista1_NumeroMicroVectores - 1)) \{
		
		// debug
		if (debug_listas) \{
			rt_printk(">>COMPLETADA EJECUCIÓN LISTA %d MV=%ld Posición=%ld,%ld\\n", lista, Lista1_NumeroMicroVectores, xValuesPosicion, yValuesPosicion);
		\}
			
		// Si es una prueba de marcaje reactivar el interfaz
		if (PruebaMarcaje == true) \{
			
			Lista1_Exe = false;
		
		\}
		
		// Si no es una prueba es que se trata del bucle de marcaje:
		else \{

			// Prepara el movimiento de los galvos al origen de la lista
			//if (ResetJumpList == false) \{
			
				// Calcula el movimiento de los galvos al inicio de la lista
				//CalcularMoverGalvos(xValues[0], yValues[0]);

			//\}	
			
			// Detiene el encoder, si hay marcaje dinámico
			if (MarcajeDinamicoActivo > 0) \{
				
				IncrementoAcumulado = 0;
				
				// Hay que activar la siguiente espera de disparo
				EsperaRetardoDisparo = true;
				
			\}
			
			// Actualiza la señal de MarkInProgress y el Led del láser
			ControlMarkInProgress(OFF);
		
			// Calcula el movimiento de los galvos al inicio de la lista
			CalcularMoverGalvos(xValues[0], yValues[0]);
			
			// Ahora ya detiene la lista actual y lanza el movimiento de los galvos
			Lista1_Exe = false;
			MicroVector = 0;
			ResetJumpList = true;
			Lista0_Exe = true;
			
		\}
		
	\}
	
	// Si no, incrementar el microvector
	else \{
		MicroVector++;
	\}
			
	break;
	
case 2:// Ejecución de la lista 2
	
	// Si hay un retardo de disparo pendiente comprobarlo ahora
	if ((MarcajeDinamicoActivo > 0) && ((RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional) > 0)	&& (EsperaRetardoDisparo == true)) \{
	
		// Si todavía no han pasado las cuentas correspondientes al retardo no continua
		if ((int)IncrementoAcumulado < (RetardoDisparo_cuentas+RetardoDisparo_cuentas_adicional)) \{
	
			return true;
		
		\}
	
		// Si ya han pasado resetea las variables de estado y continua con la ejecución de los microvectores
		else \{
	
			IncrementoAcumulado = 0;
			EsperaRetardoDisparo = false;
		\}	

	\}
	
	// Comprueba si el microvector ha supèrado el umbral, y si no vuelve, 
	// Sólo con la estrategia de fuera de campo
	if (Estrategia == 2) \{
		
		// Si el valor del umpbral es negativo tiene que superar -MaximoBits para poder imprimirse
		if (Lista2_Umbral[MicroVector] < 0) \{
		
			if ((Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) < -MaximoBits) \{
				
				/*
				if (ImprimirMV)\{
					rt_printk("Espera umbral en Lista2 Microvector:%ld Umbral:%d Actual:%d\\n", MicroVector, Lista2_Umbral[MicroVector], Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
					ImprimirMV=false;
				\}
				*/
				
				return true;
		
			\}
		
		\}
		
		// Si es positivo para proseguir tiene que ser menor que MaximoBits
		else \{
		
			if ((Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits)) > MaximoBits) \{
		
				/*
				if (ImprimirMV)\{
					rt_printk("Espera umbral en Lista2 Microvector:%ld Umbral:%d Actual:%d\\n", MicroVector, Lista2_Umbral[MicroVector], Lista2_Umbral[MicroVector]+(int)(IncrementoAcumulado*Ku_Cuentas_a_Bits));		
					ImprimirMV=false;
				\}
				*/
				
				return true;
		
			\}
			
		\} 
		
		//ImprimirMV = true;
	
	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza los galvos: 
	/////////////////////////////////////////////////////////////////////////////////////
	
	xBitsDouble = (double)(Lista2_xBits[MicroVector]+(IncrementoAcumulado*Kx_Cuentas_a_Bits));
	yBitsDouble = (double)(Lista2_yBits[MicroVector]+(IncrementoAcumulado*Ky_Cuentas_a_Bits));	
				
	// Coordenada X:
	Vx = (double)(xBitsDouble * Kx_Bits_a_Voltios);
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vx) > VGalvoMax) \{

	    		rt_printk("ErrorCampo - Lista 2: MV=%ld Vx=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vx));
		
			ErroresConsecutivosCampoX++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoX >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoX = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vx);

		// escribe en el galvo X
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false; 
		\}
	
		break;

	case FPGA:

		// escribe en el galvo X
		EscribirGalvoX_FPGA(FPGA_from_phys(Vx));	
		
		break;
	
	\} 
	
	// Coordenada Y:
	Vy = (double)(yBitsDouble * Ky_Bits_a_Voltios);
	
	// Si está activado el control de errores de campo
    	if ((ControlarErrorCampo) && (ErrorCampo == OFF)) \{

		// Comprueba que no se excede el voltaje máximo de los galvos
		if (fabs(Vy) > VGalvoMax) \{

			rt_printk("ErrorCampo - Lista 2: MV=%ld Vy=%f mayor que VGalvoMax\\n", MicroVector, fabs(Vy));

			ErroresConsecutivosCampoY++;
		
	    		// Si se ha alcanzado el máximo de errores de campo devolver el error
		    	if (ErroresConsecutivosCampoY >= MaximoErroresConsecutivosCampo) \{
	    			ErrorCampo = ON;
	    			return false;
	    		\}
	    	
		\}
		
		else \{
		
			ErroresConsecutivosCampoY = 0;
		
		\}
	
	\}
	
	switch (Control) \{

	case DAQ:
	
		// Convierte los voltios en las unidades precisas para escribir en el driver
		AOdata = itaca_comedi_from_phys(Vy);

		// escribe en el galvo Y
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, AREF_GROUND, AOdata);
		if (error < 0) \{
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false;
		\}
	
		break;

	case FPGA:

		// escribe en el galvo Y
		EscribirGalvoY_FPGA(FPGA_from_phys(Vy));
		
		break;
	
	\} 		
		
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el laser: 
	/////////////////////////////////////////////////////////////////////////////////////
	
	if (Lista2_EstadoLaser[MicroVector] != EstadoLaser) \{ //Hay que cambiar el estado del laser
		Control_Laser(Lista2_EstadoLaser[MicroVector]);		
	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el tiempo de marca: 
	/////////////////////////////////////////////////////////////////////////////////////			
	
	if (MicroVector == 0) \{
	
		// Guarda el tiempo de inicio de la marca
		tInicioMarca = rt_get_time_ns();
		
		// Guarda el tiempo de fin de la marca hasta ahora, para evitar tiempos negativos
		tFinMarca = rt_get_time_ns();
	
	\}				
	
	else \{
	
		// Guarda el tiempo de fin de la marca hasta ahora
		tFinMarca = rt_get_time_ns();

	\}
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza la posición:
	/////////////////////////////////////////////////////////////////////////////////////
	xValuesPosicion = (long) xBitsDouble;
	yValuesPosicion = (long) yBitsDouble;	
	
	/////////////////////////////////////////////////////////////////////////////////////		
	// Actualiza el microvector: 
	/////////////////////////////////////////////////////////////////////////////////////			
		
	// Si era el último microvector ha terminado la ejecución de la lista
	if (MicroVector == (Lista2_NumeroMicroVectores - 1)) \{
		
		// debug
		if (debug_listas) \{
			rt_printk(">>COMPLETADA EJECUCIÓN LISTA %d MV=%ld Posición=%ld,%ld\\n", lista, Lista2_NumeroMicroVectores, xValuesPosicion, yValuesPosicion);
		\}
		
		// Si es una prueba de marcaje reactivar el interfaz
		if (PruebaMarcaje == true) \{
			
			Lista2_Exe = false;
		
		\}
		
		// Si no es una prueba es que se trata del bucle de marcaje:
		else \{				
			
			// Prepara el movimiento de los galvos al origen de la lista
			//if (ResetJumpList == false) \{
			
				// Calcula el movimiento de los galvos al inicio de la lista
				//CalcularMoverGalvos(xValues[0], yValues[0]);
			
			//\}
			
			// Detiene el encoder, si hay marcaje dinámico
			if (MarcajeDinamicoActivo > 0) \{
				
				IncrementoAcumulado = 0;
				
				// Hay que activar la siguiente espera de disparo
				EsperaRetardoDisparo = true;
				
			\}
			
			// Actualiza la señal de MarkInProgress y el Led del láser
			ControlMarkInProgress(OFF);
			
			// Calcula el movimiento de los galvos al inicio de la lista
			CalcularMoverGalvos(xValues[0], yValues[0]);
			
			// Ahora ya detiene la lista actual y lanza el movimiento de los galvos
			Lista2_Exe = false;
			MicroVector = 0;
			ResetJumpList = true;
			Lista0_Exe = true;
			
		\}	
		
	\}
	
	// Si no, incrementar el microvector
	else \{
		MicroVector++;
	\}
	
	break;

default:
	
	// Nunca se debería llegar aquí, ya que no se debería llamar a esta rutina si no hay una lista
	// en ejecución
	ErrorVectores = ON;
	rt_printk("EjecutarMicrovector: ErrorVectores\\n");
	return false;
	break;

\}

if ((debug_listas) && (error < 0)) \{
	rt_printk("ERROR DURANTE LA EJECUCIÓN DE LA LISTA %d EN EL MICROVECTOR %ld\\n", lista, MicroVector);
	return false;
\}

if (debug_EjecucionMvectores) \{

	rt_printk("LISTA %d MV %ld\\n", lista, MicroVector);
\}

// si llega hasta aquí es que todo ha ido bien
return true;} {}
} 

Function {ActualizarFechaHoraSerie()} {C return_type int
} {
  code {static int error = false;
static int actualizarlinea1bloque1, actualizarlinea1bloque2, actualizarlinea1bloque3;
static int actualizarlinea2bloque1, actualizarlinea2bloque2, actualizarlinea2bloque3;
static int actualizarlinea3bloque1, actualizarlinea3bloque2, actualizarlinea3bloque3;
static int actualizarlinea4bloque1, actualizarlinea4bloque2, actualizarlinea4bloque3;

static int statusfecha, statushora, statusnumeroserie;
static char strFecha[LongitudMaximaStringFecha], tmpFecha[LongitudMaximaStringFecha];
char strHora[LongitudMaximaStringHora], tmpHora[LongitudMaximaStringHora];
static unsigned int i, j, k;

// Variables para el cálculo de fecha y hora
static time_t curtime, tmptime;
static struct tm *loctime;
static struct tm *loctimelinea[NumeroLineasTexto][NumeroBloquesLinea];

// Variables para el cálculo de fecha y hora si hay que resetear el numero de serie por cambio de fecha
static time_t curtimeserie;
static struct tm *loctimeserie;
static char tmpfechaserie[LongitudMaximaStringFecha];

//if (debug_camposvariables) {
//	rt_printk("ActualizarFechaHoraSerie: \\n");
//}
 
// Inicialización de variables locales
actualizarlinea1bloque1 = false;
actualizarlinea1bloque2 = false;
actualizarlinea1bloque3 = false;
actualizarlinea2bloque1 = false;
actualizarlinea2bloque2 = false;
actualizarlinea2bloque3 = false;
actualizarlinea3bloque1 = false;
actualizarlinea3bloque2 = false;
actualizarlinea3bloque3 = false;
actualizarlinea4bloque1 = false;
actualizarlinea4bloque2 = false;
actualizarlinea4bloque3 = false;

statusfecha = false;
statushora = false;
statusnumeroserie = false;

// A ver si hay algún campo variable definido
for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		if (StatusFecha[i][j]) {statusfecha = true;}
		if (StatusHora[i][j]) {statushora = true;}
		if (StatusNumeroSerie[i][j]) {statusnumeroserie = true;}	
	
	}
	
}

// Si no hay ningún campo variable, vuelta a casa
if ( !(statusfecha) && !(statushora) && !(statusnumeroserie) ) {
	return 0;
}

// Obtener la fecha/hora actual si hay cálculos de fecha/hora
if ((statusfecha) || (statushora)) {

	// Get the current time
	curtime = time (NULL);
     	
	// Convert it to local time representation
	loctime = localtime (&curtime);

}

// Ahora vamos a hacer los cálculos, para cada línea
for (i=0; i<NumeroLineasTexto; i++) {

	for (j=0; j<NumeroBloquesLinea; j++) {
	
		// Fecha
		if (StatusFecha[i][j]) {
	
			// variable de fecha de la línea, por si hay caducidad
			loctimelinea[i][j] = localtime (&curtime);
		
			// Si hay caducidad, añadirla ahora
     			if (Caducidad[i][j]) {
     	
	     			// Añadir el número de meses de la caducidad (meses de 30 días) - arreglar
     				loctimelinea[i][j]->tm_mon += Caducidad[i][j];
     		
	     			// y recalcular la fecha
     				tmptime = mktime(loctimelinea[i][j]);
     				loctimelinea[i][j] = localtime (&tmptime);
     		
	     		}
  
			// Calcula el primer campo de la fecha formateada
			switch (ValorFormatoFecha1[i][j]) {

				case 0:	// " "
				strcpy (tmpFecha, "");
				break;
	
				case 1:	// DD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
				break;
	
				case 2:	// DDD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 3:	// DIA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 4:	// MM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
				break;
	
				case 5:	// MMM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 6:	// MES
				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 7:	// AA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
				break;
			
				case 8:	// AAAA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
				break;
			
				case 9:	// SS
				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
				break;
			
				case 10:// DS 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
				break;
			
				case 11:// JJ 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
				break;		
	
			}
		
		
			// Se copia en el string que tendrá la fecha formateada	
			strcpy (strFecha, tmpFecha);
			
			// Se añade el separador si procede
			if ((ValorSeparadorFecha[i][j] > 0) && (ValorFormatoFecha2[i][j] > 0)) {
				strcat (strFecha, SeparadorFecha[ValorSeparadorFecha[i][j]]);
			}	
		
			// Calcula el segundo campo de la fecha formateada
			switch (ValorFormatoFecha2[i][j]) {

				case 0:	// ""
				strcpy (tmpFecha, "");
				break;
	
				case 1:	// DD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
				break;
	
				case 2:	// DDD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 3:	// DIA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 4:	// MM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
				break;
	
				case 5:	// MMM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 6:	// MES
				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 7:	// AA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
				break;
			
				case 8:	// AAAA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
				break;
			
				case 9:	// SS
				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
				break;
			
				case 10:// DS 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
				break;
			
				case 11:// JJ 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
				break;		
	
			}
		
			// Se añade en el string que tendrá la fecha formateada	
			strcat (strFecha, tmpFecha);
		
			// Se añade el separador si procede
			if ((ValorSeparadorFecha[i][j] > 0) && (ValorFormatoFecha3[i][j] > 0)) {
				strcat (strFecha, SeparadorFecha[ValorSeparadorFecha[i][j]]);
			}
			
			// Calcula el tercer campo de la fecha formateada
			switch (ValorFormatoFecha3[i][j]) {

				case 0:	// " "
				strcpy (tmpFecha, "");
				break;	
	
				case 1:	// DD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%d", loctimelinea[i][j]);
				break;
	
				case 2:	// DDD
				strftime (tmpFecha, LongitudMaximaStringFecha, "%a", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 3:	// DIA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%A", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 4:	// MM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%m", loctimelinea[i][j]);
				break;
	
				case 5:	// MMM
				strftime (tmpFecha, LongitudMaximaStringFecha, "%b", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 6:	// MES
				strftime (tmpFecha, LongitudMaximaStringFecha, "%B", loctimelinea[i][j]);
				// Pasarlo todo a mayúsculas
				for (k=0; k<strlen(tmpFecha); k++) {
					tmpFecha[k] = Mayusculas(tmpFecha[k]);
				}
				break;
			
				case 7:	// AA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%y", loctimelinea[i][j]);
				break;
			
				case 8:	// AAAA
				strftime (tmpFecha, LongitudMaximaStringFecha, "%Y", loctimelinea[i][j]);
				break;
			
				case 9:	// SS
				strftime (tmpFecha, LongitudMaximaStringFecha, "%V", loctimelinea[i][j]);
			
				case 10:// DS 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%u", loctimelinea[i][j]);
				break;
			
				case 11:// JJ 
				strftime (tmpFecha, LongitudMaximaStringFecha, "%j", loctimelinea[i][j]);
				break;		
	
			}
		
			// Se añade en el string que tendrá la fecha formateada	
			strcat (strFecha, tmpFecha);
		
			// Hay que ver si ha cambiado
			if (strcmp(Fecha[i][j], strFecha)) {
	
				// Activa el flag de actualizar
				//actualizarfecha = true;
			
				// Copia el nuevo valor en la variable global
				strcpy(Fecha[i][j], strFecha);
	
				// Actualiza las líneas correspondientes
				switch (i) {
			
				case 0:
					
					switch(j) {
					
					case 0:
						actualizarlinea1bloque1 = true;
						break;
					case 1:
						actualizarlinea1bloque2 = true;
						break;
					case 2:
						actualizarlinea1bloque3 = true;
						break;
					}
					
					break;
				
				case 1:
					
					switch(j) {
					
					case 0:
						actualizarlinea2bloque1 = true;
						break;
					case 1:
						actualizarlinea2bloque2 = true;
						break;
					case 2:
						actualizarlinea2bloque3 = true;
						break;
					}
					
					break;
				
				case 2:
					
					switch(j) {
					
					case 0:
						actualizarlinea3bloque1 = true;
						break;
					case 1:
						actualizarlinea3bloque2 = true;
						break;
					case 2:
						actualizarlinea3bloque3 = true;
						break;
					}
					
					break;
					
				case 3:
					
					switch(j) {
					
					case 0:
						actualizarlinea4bloque1 = true;
						break;
					case 1:
						actualizarlinea4bloque2 = true;
						break;
					case 2:
						actualizarlinea4bloque3 = true;
						break;
					}
					
					break;
		
				}
		
				if (debug_camposvariables) {
		            		rt_printk("Actualizar Fecha[%d,%d] %s\\n", i, j, Fecha[i][j]);
	        	    	}   
		
			}
		
		}
			
		// Hora
		if (StatusHora[i][j]) {
	
			// calcula el primer campo de la hora formateada
			switch (ValorFormatoHora1[i][j]) {

				case 0:	// " "
				strcpy (tmpHora, "");
				break;
	
				case 1:	// HH
				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
				break;
	
				case 2:	// hh
				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
				break;
	
				case 3:	// MM
				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
				break;
			
				case 4:	// SS
				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
				break;
				
				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
				CalcularTurno(loctime, tmpHora);
				break;
				
			}
		
			// Se copia en el string que tendrá la hora formateada	
			strcpy (strHora, tmpHora);
		
			if ((ValorSeparadorHora[i][j] > 0) && (ValorFormatoHora2[i][j] > 0)) {
				strcat (strHora, SeparadorHora[ValorSeparadorHora[i][j]]);
			}
			
			// calcula el segundo campo de la hora formateada
			switch (ValorFormatoHora2[i][j]) {

				case 0:	// ""
				strcpy (tmpHora, "");
				break;
	
				case 1:	// HH
				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
				break;
	
				case 2:	// hh
				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
				break;
	
				case 3:	// MM
				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
				break;
			
				case 4:	// SS
				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
				break;
				
				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
				CalcularTurno(loctime, tmpHora);
				break;
	
			}
		
			// Se añade en el string que tendrá la hora formateada	
			strcat (strHora, tmpHora);
		
			// Se añade el separador si procede
			if ((ValorSeparadorHora[i][j] > 0) && (ValorFormatoHora3[i][j] > 0)) {
				strcat (strHora, SeparadorHora[ValorSeparadorHora[i][j]]);
			}
			
			// calcula el tercer campo de la hora formateada
			switch (ValorFormatoHora3[i][j]) {

				case 0:	// " "
				strcpy (tmpHora, "");
				break;
	
				case 1:	// HH
				strftime (tmpHora, LongitudMaximaStringHora, "%H", loctime);
				break;
	
				case 2:	// hh
				strftime (tmpHora, LongitudMaximaStringHora, "%I", loctime);
				break;
	
				case 3:	// MM
				strftime (tmpHora, LongitudMaximaStringHora, "%M", loctime);
				break;
			
				case 4:	// SS
				strftime (tmpHora, LongitudMaximaStringHora, "%S", loctime);
				break;
				
				case 5: // turno: pone en tmpHora el string de turno que corresponda a la hora actual
				CalcularTurno(loctime, tmpHora);
				break;
	
			}
		
			// Se añade en el string que tendrá la hora formateada	
			strcat (strHora, tmpHora);
		
			// Hay que ver si ha cambiado
			if (strcmp(Hora[i][j], strHora)) {
	
				// Activa el flag de actualizar
				//actualizarhora = true;
			
				// Copia el nuevo valor en la variable global
				strcpy(Hora[i][j], strHora);
	
				// Actualiza las líneas correspondientes
				switch (i) {
			
				case 0:
					
					switch(j) {
					
					case 0:
						actualizarlinea1bloque1 = true;
						break;
					case 1:
						actualizarlinea1bloque2 = true;
						break;
					case 2:
						actualizarlinea1bloque3 = true;
						break;
					}
					
					break;
				
				case 1:
					
					switch(j) {
					
					case 0:
						actualizarlinea2bloque1 = true;
						break;
					case 1:
						actualizarlinea2bloque2 = true;
						break;
					case 2:
						actualizarlinea2bloque3 = true;
						break;
					}
					
					break;
				
				case 2:
					
					switch(j) {
					
					case 0:
						actualizarlinea3bloque1 = true;
						break;
					case 1:
						actualizarlinea3bloque2 = true;
						break;
					case 2:
						actualizarlinea3bloque3 = true;
						break;
					}
					
					break;
					
				case 3:
					
					switch(j) {
					
					case 0:
						actualizarlinea4bloque1 = true;
						break;
					case 1:
						actualizarlinea4bloque2 = true;
						break;
					case 2:
						actualizarlinea4bloque3 = true;
						break;
					}
					
					break;
		
				}
				
				if (debug_camposvariables) {
	            			rt_printk("Actualizar Hora[%d,%d] %s\\n", i, j, Hora[i][j]);
	            		} 
	            	
			}
	
		}

		// Número de serie - qué pasa con el número de unidades por lote...
		if (StatusNumeroSerie[i][j]) {

			// Sólo se incrementa si se está marcando
			if (EnEjecucion) {
				
				
				// Get the current time
				curtimeserie = time (NULL);
     	
				// Convert it to local time representation
				loctimeserie = localtime (&curtimeserie);
				
				strftime (tmpfechaserie, LongitudMaximaStringFecha, "%d", loctimeserie);
				//strcpy(FechaInicioMarca,tmpfechaserie);
				//rt_printk("FechaInicioMarca %s\\n", FechaInicioMarca);
				//rt_printk("TMPFECHASERIE %s\\n", tmpfechaserie);
				
				// Hay lote
				if (NumeroUnidadesLote[i][j] > 1) {
				
					// incrementa el número en el lote
					NumeroUnidadesLoteActual[i][j]++;
			
					// mira a ver si ha terminado el lote
					if (NumeroUnidadesLoteActual[i][j] > NumeroUnidadesLote[i][j]) {
			
						// activa el flag de actualizar
						//actualizarserie = true;
				
						
						// actualiza el númeo de serie
						if (ResetSerieFecha == 0){
							NumeroSerie[i][j]++;
					
						}
						else {
							if (strcmp(tmpfechaserie,FechaInicioMarca)==0){
							NumeroSerie[i][j]++;
							}
							else {
							NumeroSerie[i][j]=NumeroSerieInicial[i][j];
							strcpy(FechaInicioMarca,tmpfechaserie);
							}
						}
						
						// reinicia TempLote
						NumeroUnidadesLoteActual[i][j] = 1;
				
					}
			
				}
		
				// No hay lote
				else {
			
					// activa el flag de actualizar
					//actualizarserie = true;
					
					
					// actualiza el númeo de serie
					if (ResetSerieFecha == 0){
						NumeroSerie[i][j]++;		
						}
					else {
					//rt_printk("FechaInicioMarca %s\\n", FechaInicioMarca);

						if (strcmp(tmpfechaserie,FechaInicioMarca)==0){
							NumeroSerie[i][j]++;
							//rt_printk("FechaInicioMarca %s\\n", FechaInicioMarca);
						}
						else {
							NumeroSerie[i][j]=NumeroSerieInicial[i][j];
							strcpy(FechaInicioMarca,tmpfechaserie);
						}
					}
					
				}
		
			}
	
			// Si el número de serie final existe, chequea si ha sido superado
			if (NumeroSerieFinal[i][j] > 0) {
		
				if (NumeroSerie[i][j] > NumeroSerieFinal[i][j]) {
		
					NumeroSerie[i][j] = NumeroSerieInicial[i][j];
					sprintf(strNumeroSerie[i][j], "%0*ld", NumeroDigitosNumeroSerie[i][j], NumeroSerie[i][j]);
			
				}
			
			}
		
			// si ha cambiado el valor
			//if (actualizarserie) {
		
				// Escribe el valor formateado en un string
				sprintf(strNumeroSerie[i][j], "%0*ld", NumeroDigitosNumeroSerie[i][j], NumeroSerie[i][j]);
	
				// Actualiza las líneas correspondientes
				switch (i) {
			
				case 0:
					
					switch(j) {
					
					case 0:
						actualizarlinea1bloque1 = true;
						break;
					case 1:
						actualizarlinea1bloque2 = true;
						break;
					case 2:
						actualizarlinea1bloque3 = true;
						break;
					}
					
					break;
				
				case 1:
					
					switch(j) {
					
					case 0:
						actualizarlinea2bloque1 = true;
						break;
					case 1:
						actualizarlinea2bloque2 = true;
						break;
					case 2:
						actualizarlinea2bloque3 = true;
						break;
					}
					
					break;
				
				case 2:
					
					switch(j) {
					
					case 0:
						actualizarlinea3bloque1 = true;
						break;
					case 1:
						actualizarlinea3bloque2 = true;
						break;
					case 2:
						actualizarlinea3bloque3 = true;
						break;
					}
					
					break;
					
				case 3:
					
					switch(j) {
					
					case 0:
						actualizarlinea4bloque1 = true;
						break;
					case 1:
						actualizarlinea4bloque2 = true;
						break;
					case 2:
						actualizarlinea4bloque3 = true;
						break;
					}
					
					break;
		
				}
				
				if (debug_camposvariables) {
	            			rt_printk("Actualizar strNumeroSerie[%d,%d] %s\\n", i, j, strNumeroSerie[i][j]);
	            		} 
		
			//}
	
		}

	}
	
}

if ((actualizarlinea1bloque1)||(actualizarlinea1bloque2)||(actualizarlinea1bloque3)||(actualizarlinea2bloque1)||(actualizarlinea2bloque2)||(actualizarlinea2bloque3)||(actualizarlinea3bloque1)||(actualizarlinea3bloque2)||(actualizarlinea3bloque3)||(actualizarlinea4bloque1)||(actualizarlinea4bloque2)||(actualizarlinea4bloque3)) {

	// Flag global
	Actualizar = true;
	
	// Actualiza las líneas
	if (actualizarlinea1bloque1) {
		LineaTexto_calcular(1,1);
	}
	
	if (actualizarlinea1bloque2) {
		LineaTexto_calcular(1,2);
	}
	
	if (actualizarlinea1bloque3) {
		LineaTexto_calcular(1,3);
	}
	
	if (actualizarlinea2bloque1) {
		LineaTexto_calcular(2,1);
	}
	
	if (actualizarlinea2bloque2) {
		LineaTexto_calcular(2,2);
	}
	
	if (actualizarlinea2bloque3) {
		LineaTexto_calcular(2,3);
	}
	
	if (actualizarlinea3bloque1) {
		LineaTexto_calcular(3,1);
	}
	
	if (actualizarlinea3bloque2) {
		LineaTexto_calcular(3,2);
	}
	
	if (actualizarlinea3bloque3) {
		LineaTexto_calcular(3,3);
	}
	
	if (actualizarlinea4bloque1) {
		LineaTexto_calcular(4,1);
	}
	
	if (actualizarlinea4bloque2) {
		LineaTexto_calcular(4,2);
	}
	
	if (actualizarlinea4bloque3) {
		LineaTexto_calcular(4,3);
	}
	
	//actualizarfecha = false;
	//actualizarhora = false;
	//actualizarserie = false;

}

else {

	// Flag global
	Actualizar = false;

}

return error;} {}
} 

Function {CalcularTurno(struct tm *loctime, char* returnstr)} {C return_type void
} {
  code {// Variables para el cálculo del turno
int hora, minuto, minutodia,i;
char tmpstr[LongitudMaximaStringHora];

// Calcula la hora actual a partir del parámetro loctime pasado a la función
strftime (tmpstr, LongitudMaximaStringHora, "%H", loctime);
hora = atoi(tmpstr);

// Calcula los minutos actuales a partir del parámetro loctime pasado a la función
strftime (tmpstr, LongitudMaximaStringHora, "%M", loctime);
minuto = atoi(tmpstr);

// Calcula el minuto en el total de minutos del día
minutodia = (hora*60) + minuto;

//rt_printk("Turno: %d:%d\\n", hora, minuto);

// El texto del primer turno que encaje en la hora se escribe en el string returnstr pasado como argumento de la función
for (i=0; i<NumeroTurnos; i++) {

	//rt_printk("Turno:%d minutodia:%d minutoinicio:%d minutofin:%d texto:%s\\n", i+1, minutodia, MinutoDiaInicioTurno[i], MinutoDiaFinTurno[i], TextoTurno[i]);

	if ((minutodia>=MinutoDiaInicioTurno[i]) && (minutodia<=MinutoDiaFinTurno[i])) {
	
		if (strlen(TextoTurno[i])) {
			strcpy(returnstr, TextoTurno[i]);
			//rt_printk("Turno:%d minutodia:%d minutoinicio:%d minutofin:%d texto:%s\\n", i+1, minutodia, MinutoDiaInicioTurno[i], MinutoDiaFinTurno[i], TextoTurno[i]);
		}
		
		return;

	}

}

// Si ha salido del bucle sin cuadrar con ningún turno escribe "" en el string de turno
strcpy(returnstr, "");

return;} {}
} 

Function {Mayusculas(char caracter)} {C return_type int
} {
  code {// si es una letra acentuada hay que quitar el acento
switch(caracter) {

	case 'á':
	case 'à': 
	case 'â':
	strcpy(&caracter,"A");
	break;
	
	case 'é':
	case 'è':
	case 'ê':
	strcpy(&caracter,"E");
	break;
	
	case 'í':
	case 'ì':
	case 'î':
	strcpy(&caracter,"I");
	break;
	
	case 'ó':
	case 'ò':
	case 'ô':
	strcpy(&caracter,"O");
	break;
	
	case 'ú':
	case 'ù':
	case 'û':
	strcpy(&caracter,"U");
	break;
	
	default:
	caracter = toupper(caracter);

}

return caracter;} {}
} 

Function {ObtenerPosicionActual()} {open C return_type int
} {
  code {int error = false;
lsampl_t AOdata; 		// para leer las entradas analógicas
short dato; 			// para leer las entradas analógicas

//Si estamos en la inicializacion del sistema fijamos un valor de 1 incluso si el error de galvos está desactivado
if (MovimientoInicialGalvos == 1){
	xValuesPosicionMedida = 30000;
	yValuesPosicionMedida = 30000;
	return error;
}

// Si no está activado el control de errores de galvos asignar la posición teórica y volver
if ((!ControlarErrorGalvos) || (Control == FPGA)) {

	xValuesPosicionMedida = xValuesPosicion;
	yValuesPosicionMedida = yValuesPosicion;
	return error;
	
}

// Leer la posición
switch (Control) {

case DAQ:
	
	// Coordenada X: lee la posición del galvo X
	error = comedi_data_read(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionX, 0, AREF_GROUND, &AOdata);

	if (error < 0) {
			
		rt_printk("ObtenerPosicionActual: comedi_data_read Posicion X error=%d\\n",error);
		ErrorDAQ = ON;
		ProcesarError();  			
	
	}	

	// La posición tiene que representarse en bits
	xValuesPosicionMedida = (long) (FactorPosicion * ((double)itaca_comedi_to_phys(AOdata) / Kx_Bits_a_Voltios));

	//printf("X AOdata:%d xValuesPosicion:%ld\\n", AOdata, xValuesPosicion);

	// Coordenada Y: lee la posición del galvo Y
	error = comedi_data_read(comedi_device, comedi_subdevice_AI, comedi_canalAI_PosicionY, 0, AREF_GROUND, &AOdata);

	if (error < 0) {
		
		rt_printk("ObtenerPosicionActual: comedi_data_read Posicion Y error=%d\\n",error);
		ErrorDAQ = ON;
		ProcesarError();  
	
	}	
			
	// La posición tiene que representarse en bits
	yValuesPosicionMedida = (long) (FactorPosicion * ((double)itaca_comedi_to_phys(AOdata) / Ky_Bits_a_Voltios));

	
	break;

case FPGA:

	// Leer la posiciÃ³n
	// Coordenada X: lee la posición del galvo X
	dato = LeerPosicionGalvoX_FPGA();

	// La posición tiene que representarse en bits
	xValuesPosicionMedida = (long) (FactorPosicion * ((double)FPGA_to_phys(dato) / Kx_Bits_a_Voltios));

	//printf("X dato:%d xValuesPosicion:%ld\\n", dato, xValuesPosicion);

	// Coordenada Y: lee la posición del galvo Y
	dato = LeerPosicionGalvoY_FPGA();
			
	// La posición tiene que representarse en bits
	yValuesPosicionMedida = (long) (FactorPosicion * ((double)FPGA_to_phys(dato) / Ky_Bits_a_Voltios));

	break;
	
} 		

//printf("Y AOdata:%d yValuesPosicion:%ld\\n", AOdata, yValuesPosicion);

if (debug_posicion) {
       	rt_printk("ObtenerPosicionActual::Teórica:%ld,%ld Medida:%ld,%ld\\n", xValuesPosicion, yValuesPosicion, xValuesPosicionMedida, yValuesPosicionMedida);
}

// Comprueba los valores calculados
if (xValuesPosicionMedida > MaximoBits) {
	xValuesPosicionMedida = MaximoBits;
	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
}

if (xValuesPosicionMedida < (-MaximoBits)) {
	xValuesPosicionMedida = -MaximoBits;
	//if (ControlarErrorGalvos) {ErrorGalvos = true;}

}

if (yValuesPosicionMedida > MaximoBits) {
	yValuesPosicionMedida = MaximoBits;
	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
}

if (yValuesPosicionMedida < (-MaximoBits)) {
	yValuesPosicionMedida = -MaximoBits;
	//if (ControlarErrorGalvos) {ErrorGalvos = true;}
}

return error;} {}
} 

Function {CalcularMoverGalvos(int xdestino, int ydestino)} {open C return_type int
} {
  code {// Mueve los galvos a la posición pasada en las coordenadas utilizando la lista 0 
// La lista 0 sólo se utiliza para esto, así que no se usan los comandos de start/close list, jump, etc, 
// sino que se hace todo a capón aquí para evitar líos de listas

double angulo, distancia;	// variable para conocer el ángulo de la recta
unsigned int numeromicrovectores, i;
double x, y;			// cálculos con coordenadas

long difX, difY;
long errorX, errorY;

// Si no está en el bucle de ejecución comprueba las coordenadas actuales
if (!EnEjecucion) {

	// Mide las coordenadas actuales y las devuelve en xValuesPosicionMedida e yValuesPosicionMedida
	//if (Control != FPGA) {
		ObtenerPosicionActual();
	//}
	
	// Calcula la diferencia entre la posición teórica y la medida
	difX = (long)abs(xValuesPosicion - xValuesPosicionMedida);
	difY = (long)abs(yValuesPosicion - yValuesPosicionMedida);

	errorX = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)xValuesPosicion) + ToleranciaPosicionBits);
	errorY = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)yValuesPosicion) + ToleranciaPosicionBits);

	if (debug_posicion) {
		rt_printk("CalcularMoverGalvos::difX=%ld errorX=%ld difY=%ld errorY=%ld\\n", difX, errorX, difY, errorY);
	}
	
	// Si la diferencia entre la posición teórica la la medida es mayor que el error en alguna coordenada
	// resetea la posición a la posición medida
	if (!((difX <= errorX) && (difY <= errorY))){ 

	     	rt_printk("\# Resetear coordenadas: de %d,%d a %d,%d\\n", xValuesPosicion, yValuesPosicion, xValuesPosicionMedida, yValuesPosicionMedida);

		xValuesPosicion = xValuesPosicionMedida;
		yValuesPosicion = yValuesPosicionMedida;
	
	}

}

// Con el cálculo de la matriz fuera de campo puede suceder que el inicio de la matriz esté fuera del campo
// En ese caso hay que limitar las coordenadas a los límites del campo
// Comprueba los valores calculados
if (xdestino > MaximoBits) {
	xdestino = MaximoBits;
}

if (xdestino < (-MaximoBits)) {
	xdestino = -MaximoBits;

}

if (ydestino > MaximoBits) {
	ydestino = MaximoBits;
}

if (ydestino < (-MaximoBits)) {
	ydestino = -MaximoBits;
}

if (debug_posicion) {
     	rt_printk("CalcularMoverGalvos::Desde %d,%d hasta %d,%d\\n", xValuesPosicion, yValuesPosicion, xdestino, ydestino);
}

// Calcula el incremento en bits de cada coordenada
x = xdestino - xValuesPosicion;
y = ydestino - yValuesPosicion;

errorX = (int)(fabs(ToleranciaPosicionTantoPorUno * (float)xdestino) + ToleranciaPosicionBits);
errorY = (int)(fabs(ToleranciaPosicionTantoPorUno * (float)ydestino) + ToleranciaPosicionBits);

// Si ya estábamos en el punto (con una aproximación menor al error ) volver sin hacer nada
if ((fabs(x) <= errorX) && (fabs(y) <= errorY)){ 
	
	if (debug_posicion) {
       		rt_printk("CalcularMoverGalvos::Return sin mover nada\\n");
	}
	
	return 0;
}

// Abre la lista 0
//result = Set_Start_List(0);
Lista0_NumeroMicroVectores = 0;
Lista0_Open = true;
		
// Descarga la lista 0:
// Calcula la distancia al punto destino en bits
distancia = sqrt(pow(x,2) + pow(y,2));

// Calcula el ángulo de la recta donde se alinean los microvectores
angulo = atan2(y,x);
	
// Calcula el número de microvectores
numeromicrovectores = (unsigned int) ceil((double)distancia/(double)JumpStepSize);

if (debug_Mvectores) {
	rt_printk("CalcularMoverGalvos::Microvectores Salto:%d \\n", numeromicrovectores);
}

// Inicialización del cálculo de los microvectores
x = xValuesPosicion;
y = yValuesPosicion;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Calcula las coordenadas los microvectores
////////////////////////////////////////////////////////////////////////////////////////////////////
for (i=1; i<=numeromicrovectores; i++) {

	// Siguiente coordenada: 
	
	// Si es el último microvector hay que utilizar las coordenadas destino
	if (i == numeromicrovectores) {
		x = xdestino;
		y = ydestino;
	}
	
	// Si no es el último, incrementar el valor de Jump Step Size	
	else {
		x = x + ((double)JumpStepSize * cos(angulo));
		y = y + ((double)JumpStepSize * sin(angulo));
	}
	
	// Almacenar los valores en la lista que se está procesando
	
	// Guarda los valores en la lista 0
	Lista0_xBits[Lista0_NumeroMicroVectores] = (int)x;
	Lista0_yBits[Lista0_NumeroMicroVectores] = (int)y;
		
	// Durante el salto el láser está apagado
	Lista0_EstadoLaser[Lista0_NumeroMicroVectores] = OFF;
		
	// Incrementa el índice para el siguiente microvector
	Lista0_NumeroMicroVectores++;
	
	// Controla que no se sobrepase el máximo
	if (Lista0_NumeroMicroVectores > NumeroMaximoMicroVectores) {
		rt_printk("CalcularMoverGalvos::ERROR DE NÚMERO DE MICROVECTORES - Salto\\n"); 
		//StopEjecucion();
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
	

} 

////////////////////////////////////////////////////////////////////////////////////////////////////
// RETARDO DE SALTO
////////////////////////////////////////////////////////////////////////////////////////////////////

// Calcula el número de periodos que dura el retardo de salto, redondeando por exceso
numeromicrovectores = (unsigned int) ceil((double)RetardoSalto/(double)PERIODO_MICROSEGUNDOS);

if (debug_Mvectores) {
	rt_printk("CalcularMoverGalvos::Microvectores Retardo Salto:%d \\n", numeromicrovectores);
}

// Mantiene el último valor calculado de las coordenadas en voltios
for (i=1; i<=numeromicrovectores; i++) {
	
	// Guarda los valores
	Lista0_xBits[Lista0_NumeroMicroVectores] = (int)x;
	Lista0_yBits[Lista0_NumeroMicroVectores] = (int)y;
		
	// Durante el salto el láser está apagado
	Lista0_EstadoLaser[Lista0_NumeroMicroVectores] = OFF;
		
	// Incrementa el índice para el siguiente microvector
	Lista0_NumeroMicroVectores++;
	
	// Controla que no se sobrepase el máximo
	if (Lista0_NumeroMicroVectores > NumeroMaximoMicroVectores) {
		rt_printk("CalcularMoverGalvos::ERROR DE NÚMERO DE MICROVECTORES - Retardo Salto\\n"); 
		//StopEjecucion();
		ErrorVectores = ON;
		ProcesarError();
		return -1;
	}
	
}

if (debug_Mvectores) {
       	rt_printk("CalcularMoverGalvos::JUMP - lista 0:%ld \\n", Lista0_NumeroMicroVectores-1);
}

// Cierra la lista 0
Lista0_Open = false; 

//for (i=0; i<Lista0_NumeroMicroVectores; i++) {
//	rt_printk("Lista 0 MV:%d x=%d y=%d\\n", i, Lista0_xBits[i], Lista0_yBits[i]);
//}

return 1;} {}
} 

Function {MoverGalvos()} {C return_type void
} {
  code {// Mueve los galvos a la posición pasada en las coordenadas utilizando la lista 0 
// Previamente se han calculado los vectores en la lista 0 con CalcularMoverGalvos(x,y)
// Ejecuta la lista 0 para mover los galvos

ResetJumpList = true; // Para que no se utilicen las cuentas del encoder para actualizar coordenadas

MicroVector = 0;	
Lista0_Exe = true;
	
// Espera a que termine la ejecución de la lista 0 que mueve los galvos
while ((Lista0_Exe) && (SistemaOk)) {
        	
	// Espera un periodo (100 microsegundos)
       	Fl::wait(PERIODO_WAIT);
        	
}

//rt_printk("Lista 0 ejecutada MV=%d\\n", MicroVector);} {}
} 

Function {ComprobarPosicion(int x_teorica, int y_teorica)} {C return_type int
} {
  code {// Comprueba que la posición actual corresponde a las coordenadas pasadas como parámetro
int errorPosicion;
long difX, difY;
long errorX, errorY;

// Mide las coordenadas actuales y las devuelve en xValuesPosicionMedida e yValuesPosicionMedida
ObtenerPosicionActual();

// Calcula la diferencia entre la posición teórica y la medida
difX = (long)abs(xValuesPosicion - xValuesPosicionMedida);
difY = (long)abs(yValuesPosicion - yValuesPosicionMedida);

errorX = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)xValuesPosicion) + ToleranciaPosicionBits);
errorY = (long)(fabs(ToleranciaPosicionTantoPorUno * (float)yValuesPosicion) + ToleranciaPosicionBits);

if (debug_posicion) {
	rt_printk("Comprobar Posición difX:%ld errorX:%ld difY:%ld errorY:%ld\\n", difX, errorX, difY, errorY);
}

// Si la diferencia de posición en ambas coordenadas es inferior al error, no hay error de posición
if ((difX <= errorX) && (difY <= errorY)) { 

	errorPosicion = false;
	
}

// en caso contrario sí hay error de posición
else {
      	
      	errorPosicion = true;
      	
      	rt_printk("Error Posicion: teórica %ld,%ld Medida: %ld,%ld\\n", xValuesPosicion, yValuesPosicion, xValuesPosicionMedida, yValuesPosicionMedida);
	
}

return errorPosicion;} {}
} 

Function {InicializarIndicadorHorizontal()} {return_type void
} {
  code {// Si está activado el centrado de la marca se puede desplazar un semicampo en mm
if (Centrado) {
	IndicadorHorizontal->maximum((int)Semicampo);
	IndicadorHorizontal->minimum((int)-Semicampo);
}
	
// Si no está activo hay que calcular el máximo y el mínimo en función de la orientación y el avance
else {

	switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
                
		case -180:
		case 180:
			
			// Si la estrategia es normal o átomos sólo puede haber un offset horizontal negativo
			if (Estrategia < 2){
				IndicadorHorizontal->maximum(0);
				IndicadorHorizontal->minimum(-Semicampo*2);
			}
			
			// Si la estrategia es fuera de campo puede haber un offset horizontal positivo arbitrario
			// y uno negativo igual, como máximo, al retardo de disparo
			else {
				IndicadorHorizontal->maximum(Semicampo*2);
				IndicadorHorizontal->minimum(-RetardoDisparo_mm);
			}
		
      			break;
        
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		case 0:
		case 360:
			
			// Si la estrategia es normal o átomos sólo puede haber un offset horizontal positivo
			if (Estrategia < 2){
				IndicadorHorizontal->maximum(Semicampo*2);
				IndicadorHorizontal->minimum(0);
			}
			
			// Si la estrategia es fuera de campo puede haber un offset horizontal negativo arbitrario
			// y uno positivo igual, como máximo, al retardo de disparo
			else {
				IndicadorHorizontal->maximum(RetardoDisparo_mm);
				IndicadorHorizontal->minimum(-Semicampo*2);
			}
						
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
            	// Puede haber un offset horizontal positivo o negativo
		case -270:
		case 90:
			
			IndicadorHorizontal->maximum(Semicampo);
			IndicadorHorizontal->minimum(-Semicampo);
            		
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		// Puede haber un offset horizontal positivo o negativo
		case -90:
		case 270:
			
			IndicadorHorizontal->maximum(Semicampo);
			IndicadorHorizontal->minimum(-Semicampo);
            		
			break;

        	}
        
}

// Si el valor actual del offset sale de los límites, ponerlo a 0
if ( (Horizontal < IndicadorHorizontal->minimum()) || (Horizontal > IndicadorHorizontal->maximum()) ) {

	Horizontal = 0;
	IndicadorHorizontal->value(Horizontal);

}

if (debug_resto){
	printf("Horizontal - Máximo:%f Mínimo:%f xOffsetPantalla:%d\\n", IndicadorHorizontal->maximum(), IndicadorHorizontal->minimum(), Horizontal);
}} {}
} 

Function {InicializarIndicadorVertical()} {return_type void
} {
  code {// Si está activado el centrado de la marca se puede desplazar un semicampo en mm
if (Centrado) {
	IndicadorVertical->maximum(Semicampo);
	IndicadorVertical->minimum(-Semicampo);
}
	
// Si no está activo hay que calcular el máximo y el mínimo en función de la orientación y el avance
else {

	switch (Orientacion - Avance) {
                
                // Las letras "avanzan" hacia la izquierda: hay que pegarlas a la derecha
		// Puede haber un offset vertical positivo o negativo
		case -180:
		case 180:
			
			IndicadorVertical->maximum(Semicampo);
			IndicadorVertical->minimum(-Semicampo);
			
      			break;
        
        	// Las letras "avanzan" hacia la derecha: hay que pegarlas a la izquierda
		// Puede haber un offset vertical positivo o negativo
		case 0:
		case 360:
			
			IndicadorVertical->maximum(Semicampo);
			IndicadorVertical->minimum(-Semicampo);
			
			break;
            
            	// Las letras "avanzan" hacia abajo: hay que pegarlas arriba
            	// Sólo puede haber un offset vertical negativo
		case -270:
		case 90:
						
			// Si la estrategia es normal o átomos sólo puede haber un offset vertical negativo
			if (Estrategia < 2){
				IndicadorVertical->maximum(0);
				IndicadorVertical->minimum(-Semicampo*2);
			}
			
			// Si la estrategia es fuera de campo puede haber un offset vertical positivo
			// igual, como máximo, al retardo de disparo
			else {
				IndicadorVertical->maximum(Semicampo*2);
				IndicadorVertical->minimum(-RetardoDisparo_mm);
				
			
			}
            		
			break;
	
		// Las letras "avanzan" hacia arriba: hay que pegarlas abajo
		// Sólo puede haber un offset vertical positivo
		case -90:
		case 270:
			
			// Si la estrategia es normal o átomos sólo puede haber un offset vertical positivo
			if (Estrategia < 2){
				IndicadorVertical->maximum(Semicampo*2);
				IndicadorVertical->minimum(0);
			}
			
			// Si la estrategia es fuera de campo puede haber un offset vertical negativo
			// igual, como máximo, al retardo de disparo
			else {
				IndicadorVertical->maximum(RetardoDisparo_mm);
				IndicadorVertical->minimum(-Semicampo*2);
			}
			
			
            		
			break;

        	}
        
}

// Si el valor actual del offset sale de los límites, ponerlo a 0
if ( (Vertical < IndicadorVertical->minimum()) || (Vertical > IndicadorVertical->maximum()) ) {

	Vertical = 0;
	IndicadorVertical->value(Vertical);
	
}

if (debug_resto){
	printf("Vertical - Máximo:%f Mínimo:%f xOffsetPantalla:%d\\n", IndicadorVertical->maximum(), IndicadorVertical->minimum(), Vertical);
}} {}
} 

Function {itaca_comedi_from_phys(double volts)} {return_type lsampl_t
} {
  code {// Devuelve un valor entero a partir de los voltios y el máximo entero del canal
// Se asume un rango de -10V a +10V
lsampl_t retval;

retval = (lsampl_t) (((kFromPhysAO/10.0) * volts) + kFromPhysAO);

if (debug_aodata) {

	rt_printk("V:%f AOData:%d\\n", volts, retval);

}

return retval;} {}
} 

Function {itaca_comedi_to_phys(lsampl_t dato)} {return_type double
} {
  code {// Devuelve un valor real a partir del dato leido y el máximo entero del canal
// Se asume un rango de -10V a +10V
double retval;

//retval = (lsampl_t) (((kFromPhysAO/10.0) * volts) + kFromPhysAO);

retval = (double) (((10.0/kFromPhysAO) * (double) dato ) - 10.0);

if (debug_aodata) {

	rt_printk("Dato:%d Volts:%f\\n", dato, retval);

}

return retval;} {}
} 

Function {itaca_comedi_reset(comedi_t *device, unsigned subdevice)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[1];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = 0;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_RESET;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {itaca_comedi_arm(comedi_t *device, unsigned subdevice, unsigned target)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[2];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = 0;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_ARM;
data[1] = target;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {itaca_comedi_set_counter_mode(comedi_t *device, unsigned subdevice, unsigned channel, unsigned mode_bits)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[2];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = channel;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_SET_COUNTER_MODE;
data[1] = mode_bits;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {itaca_comedi_set_clock_source(comedi_t *device, unsigned subdevice, unsigned clock, unsigned period_ns)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[3];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = 0;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_SET_CLOCK_SRC;
data[1] = clock;
data[2] = period_ns;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {itaca_comedi_set_gate_source(comedi_t *device, unsigned subdevice, unsigned channel,
	unsigned gate_index, unsigned gate_source)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[3];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = channel;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_SET_GATE_SRC;
data[1] = gate_index;
data[2] = gate_source;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {itaca_comedi_set_routing(comedi_t *device, unsigned subdevice, unsigned channel, unsigned routing)} {return_type lsampl_t
} {
  code {comedi_insn insn;
lsampl_t data[2];

memset(&insn, 0, sizeof(comedi_insn));
insn.insn = INSN_CONFIG;
insn.subdev = subdevice;
insn.chanspec = channel;
insn.data = data;
insn.n = sizeof(data) / sizeof(data[0]);
data[0] = INSN_CONFIG_SET_ROUTING;
data[1] = routing;

if(comedi_do_insn(device, &insn) >= 0) return 0;
else return -1;} {}
} 

Function {ActualizaUI(void *)} {C return_type void
} {
  code {CuadroTextoVLinea->redraw();} {}
} 

Function {ActualizaControlAcceso(void *)} {C return_type void
} {
  code {ControlAcceso = ON;} {}
} 

Function {ExitOrdenadamente()} {C return_type void
} {
  code {// Si no hay error de DAQ/FPGA
if ((ErrorDAQ == false) && (ErrorFPGA == false)) {

	// Flag para desactivar el timer de estado
	Apagar = true;

	// espera para dar tiempo a salir al bucle de estado
	usleep(100000);

	//if ((Control == DAQ) || ((Control == FPGA) && (!debug_FPGA))) {
	
		// Desactiva el láser
		Desactivar_Laser();
	
		// Lleva los galvos al origen
		if (CalcularMoverGalvos(0, 0) > 0){
			MoverGalvos();
		}
		
	//}

	switch (Control) {

	case DAQ:
	
		// Libera los recursos de la tarjeta ni pci 6221
		Desactivar_DAQ_comedi();

		break;

	case FPGA:

		// Desprograma la FPGA
		Desactivar_FPGA();	
	
		break;

	}
	
	// Desactiva el timer RT
	//if (!debug_FPGA) {
	
		// Desactiva el timer RT
		Desactivar_RTAI();
	
	//}
	
	// Desactiva el thread de estado
	if (!ENDESARROLLO) {
		Desactivar_thread_estado();
	}
	
	// Desactiva el timer de estado si no se está en desarrollo
	if (!ENDESARROLLO) {

		// Desactiva el watchdog
		write(fd_watchdog,"V",1);
		close(fd_watchdog);
	
	}

}
	
if (PuertoSerieActivo == ON) {
	Desactivar_PuertoSerie();
}

if (ConfiguracionModificada) {

	Escribir_Configuracion();
	
}

rt_printk("\\n\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# FIN \#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\n\\n");

// sale del programa	
exit(0);} {}
} 

Function {Inicializar_Widgets()} {C return_type void
} {
  code {//////////////////////////////////////////////////////////////////////////////
// Recarga el valor de los widgets de la ventana principal
IndicadorPotencia->value(PotenciaLaser);
IndicadorVelocidad->value(VelocidadMarcaje);

InicializarIndicadorHorizontal();
IndicadorHorizontal->value(Horizontal);
InicializarIndicadorVertical();
IndicadorVertical->value(Vertical);

ChoiceFuente->value(ValorFuente);

IndicadorAnchura->value(Anchura);
IndicadorEspaciado->value(Espaciado);
IndicadorSeparacion->value(SeparacionLineas);

CheckJustificacionCentro->value(JustificacionCentro);
CheckJustificacionIzquierda->value(JustificacionIzquierda);
CheckJustificacionDerecha->value(JustificacionDerecha);

// Presenta la información de las líneas

// Línea 1

// Bloque 1
LineaCalcular=1; 
BloqueCalcular=1; 
CargarTexto(); 
ProcesarTexto(); 

// Cuadro de texto de funcionalidad normal
CuadroTextoLinea1->value(LineaTexto1[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea1->deactivate();
}
IndicadorAlturaLinea1->value(AlturaLineaTexto1[BloqueCalcular-1]);
BotonDetallesLinea1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea1->deactivate();
}
else {
	CuadroTextoLinea1->activate();
}
	
// Cuadro de texto de funcionalidad de bloques
CuadroTextoLinea1Bloque1->value(LineaTexto1[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea1Bloque1->deactivate();
}
IndicadorAlturaLinea1Bloque1->value(AlturaLineaTexto1[BloqueCalcular-1]);
BotonDetallesLinea1Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea1Bloque1->deactivate();
}
else {
	CuadroTextoLinea1Bloque1->activate();
}

// Bloque 2
LineaCalcular=1; 
BloqueCalcular=2; 
CargarTexto(); 
ProcesarTexto(); 
	
CuadroTextoLinea1Bloque2->value(LineaTexto1[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea1Bloque2->deactivate();
}
IndicadorAlturaLinea1Bloque2->value(AlturaLineaTexto1[BloqueCalcular-1]);
BotonDetallesLinea1Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea1Bloque2->deactivate();
}
else {
	CuadroTextoLinea1Bloque2->activate();
}

// Bloque 3
LineaCalcular=1; 
BloqueCalcular=3; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea1Bloque3->value(LineaTexto1[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea1Bloque3->deactivate();
}
IndicadorAlturaLinea1Bloque3->value(AlturaLineaTexto1[BloqueCalcular-1]);
BotonDetallesLinea1Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea1Bloque3->deactivate();
}
else {
	CuadroTextoLinea1Bloque3->activate();
}

// Línea 2

// Bloque 1
LineaCalcular=2; 
BloqueCalcular=1; 
CargarTexto(); 
ProcesarTexto(); 

// Cuadro de texto de funcionalidad normal
CuadroTextoLinea2->value(LineaTexto2[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea2->deactivate();
}
IndicadorAlturaLinea2->value(AlturaLineaTexto2[BloqueCalcular-1]);
BotonDetallesLinea2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea2->deactivate();
}
else {
	CuadroTextoLinea2->activate();
}
// Cuadro de texto de funcionalidad de bloques
CuadroTextoLinea2Bloque1->value(LineaTexto2[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea2Bloque1->deactivate();
}
IndicadorAlturaLinea2Bloque1->value(AlturaLineaTexto2[BloqueCalcular-1]);
BotonDetallesLinea2Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea2Bloque1->deactivate();
}
else {
	CuadroTextoLinea2Bloque1->activate();
}

// Bloque 2
LineaCalcular=2; 
BloqueCalcular=2; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea2Bloque2->value(LineaTexto2[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea2Bloque2->deactivate();
}
IndicadorAlturaLinea2Bloque2->value(AlturaLineaTexto2[BloqueCalcular-1]);
BotonDetallesLinea2Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea2Bloque2->deactivate();
}
else {
	CuadroTextoLinea2Bloque2->activate();
}

// Bloque 3
LineaCalcular=2; 
BloqueCalcular=3; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea2Bloque3->value(LineaTexto2[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea2Bloque3->deactivate();
}
IndicadorAlturaLinea2Bloque3->value(AlturaLineaTexto2[BloqueCalcular-1]);
BotonDetallesLinea2Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea2Bloque3->deactivate();
}
else {
	CuadroTextoLinea2Bloque3->activate();
}

// Línea 3

// Bloque 1
LineaCalcular=3; 
BloqueCalcular=1; 
CargarTexto(); 
ProcesarTexto(); 

// Cuadro de texto de funcionalidad normal
CuadroTextoLinea3->value(LineaTexto3[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea3->deactivate();
}
IndicadorAlturaLinea3->value(AlturaLineaTexto3[BloqueCalcular-1]);
BotonDetallesLinea3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea3->deactivate();
}
else {
	CuadroTextoLinea3->activate();
}

// Cuadro de texto de funcionalidad de bloques
CuadroTextoLinea3Bloque1->value(LineaTexto3[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea3Bloque1->deactivate();
}
IndicadorAlturaLinea3Bloque1->value(AlturaLineaTexto3[BloqueCalcular-1]);
BotonDetallesLinea3Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea3Bloque1->deactivate();
}
else {
	CuadroTextoLinea3Bloque1->activate();
}

// Bloque 2
LineaCalcular=3; 
BloqueCalcular=2; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea3Bloque2->value(LineaTexto3[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea3Bloque2->deactivate();
}
IndicadorAlturaLinea3Bloque2->value(AlturaLineaTexto3[BloqueCalcular-1]);
BotonDetallesLinea3Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea3Bloque2->deactivate();
}
else {
	CuadroTextoLinea3Bloque2->activate();
}

// Bloque 3
LineaCalcular=3; 
BloqueCalcular=3; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea3Bloque3->value(LineaTexto3[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea3Bloque3->deactivate();
}
IndicadorAlturaLinea3Bloque3->value(AlturaLineaTexto3[BloqueCalcular-1]);
BotonDetallesLinea3Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea3Bloque3->deactivate();
}
else {
	CuadroTextoLinea3Bloque3->activate();
}

// Línea 4

// Bloque 1
LineaCalcular=4; 
BloqueCalcular=1; 
CargarTexto(); 
ProcesarTexto(); 

// Cuadro de texto de funcionalidad normal
CuadroTextoLinea4->value(LineaTexto4[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea4->deactivate();
}
IndicadorAlturaLinea4->value(AlturaLineaTexto4[BloqueCalcular-1]);
BotonDetallesLinea4->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea4->deactivate();
}
else {
	CuadroTextoLinea4->activate();
}

// Cuadro de texto de funcionalidad de bloques
CuadroTextoLinea4Bloque1->value(LineaTexto4[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea4Bloque1->deactivate();
}
IndicadorAlturaLinea4Bloque1->value(AlturaLineaTexto4[BloqueCalcular-1]);
BotonDetallesLinea4Bloque1->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea4Bloque1->deactivate();
}
else {
	CuadroTextoLinea4Bloque1->activate();
}

// Bloque 2
LineaCalcular=4; 
BloqueCalcular=2; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea4Bloque2->value(LineaTexto4[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea4Bloque2->deactivate();
}
IndicadorAlturaLinea4Bloque2->value(AlturaLineaTexto4[BloqueCalcular-1]);
BotonDetallesLinea4Bloque2->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea4Bloque2->deactivate();
}
else {
	CuadroTextoLinea4Bloque2->activate();
}

// Bloque 3
LineaCalcular=4; 
BloqueCalcular=3; 
CargarTexto(); 
ProcesarTexto(); 

CuadroTextoLinea4Bloque3->value(LineaTexto4[BloqueCalcular-1]);
if ( ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {
	CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);
	CuadroTextoLinea4Bloque3->deactivate();
}
IndicadorAlturaLinea4Bloque3->value(AlturaLineaTexto4[BloqueCalcular-1]);
BotonDetallesLinea4Bloque3->label(strTiposLinea[Idioma][ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1]]);
if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO){
	CuadroTextoLinea4Bloque3->deactivate();
}
else {
	CuadroTextoLinea4Bloque3->activate();
}} {}
} 

Function {ValidarSistema()} {C return_type int
} {
  code {// Valida el sistema: aplica una función hash sobre las MAC y comprueba que el resultado es el mismo
// que en el archivo /etc/conf.d/itaca

char strMacEth0[20], strMacEth1[20];	// strings para obtener las mac
char strEth0[20], strEth1[20], *str; 	// strings auxiliares
long long lMacEth0, lMacEth1;	// variables long para guardar las mac
FILE *fp;
long long valorcalculado, valorleido;
char record[255], *dato;	/* array to hold each "record" */ 
FILE *fichero;                  /* pointer to input file */

// Obtiene los string de las Mac
fp = popen("ifconfig eth0|grep HWaddr|awk '{print $5}'", "r");
if (fp == NULL) {

	rt_printk("Error al ejecutar el comando de validación\\n");
	rt_printk("Sistema NO Validado\\n");
	return 0;

}

fgets(strMacEth0, sizeof(strMacEth0)-1, fp);
pclose(fp);

fp = popen("ifconfig eth1|grep HWaddr|awk '{print $5}'", "r");
if (fp == NULL) {

	rt_printk("Error al ejecutar el comando de validación\\n");
	rt_printk("Sistema NO Validado\\n");
	return 0;

}
fgets(strMacEth1, sizeof(strMacEth1)-1, fp);
pclose(fp);

//rt_printk("str Mac eth0 = %s\\nstr Mac eth1 = %s\\n", strMacEth0, strMacEth1);

// Ahora hay que eliminar los dos puntos y concatenar los dígitos hexadecimales
strcpy(strEth0, "0x");
str = strtok (strMacEth0, ":");
strcat(strEth0, str);
strcat(strEth0, strtok(NULL, ":"));
strcat(strEth0, strtok(NULL, ":"));
strcat(strEth0, strtok(NULL, ":"));
strcat(strEth0, strtok(NULL, ":"));
strcat(strEth0, strtok(NULL, ":"));

strcpy(strEth1, "0x");
str = strtok (strMacEth1, ":");
strcat(strEth1, str);
strcat(strEth1, strtok(NULL, ":"));
strcat(strEth1, strtok(NULL, ":"));
strcat(strEth1, strtok(NULL, ":"));
strcat(strEth1, strtok(NULL, ":"));
strcat(strEth1, strtok(NULL, ":"));

//rt_printk("str eth0 = %s\\n str eth1 = %s\\n", strEth0, strEth1);

// Y ahora convertir el string en un número
lMacEth0 = (long long)(strtod(strEth0, NULL));
lMacEth1 = (long long)(strtod(strEth1, NULL));

valorcalculado = (lMacEth0 * 0x28660) + lMacEth1;

//rt_printk("eth0 = %lld\\n eth1 = %lld\\n valor = %lld\\n", lMacEth0, lMacEth1, valorcalculado);

// ahora hay que abrir el archivo y comparar los números
// función para leer datos de configuración globales del sistema

/* open the file to read */
fichero = fopen("/etc/conf.d/itaca", "r");		

if (fichero == NULL) {

	rt_printk("Error al abrir el fichero de validación\\n");
	rt_printk("Sistema NO Validado\\n");
	
	// si no está el archivo no se puede validar
	return 0;

}

// Lee el valor
fgets(record, sizeof(record), fichero);
dato = strtok(record, "\\t\\n");
//valorleido = (long long) (strtol(dato, NULL, 10));
valorleido = atoll(dato);

// cierra el archivo
fclose(fichero);

if (valorleido == valorcalculado) {

	ErrorValidacion = false;
	rt_printk("Sistema Validado\\n");
	return 1;

}

else {

	ErrorValidacion = true;
	ProcesarError();
	rt_printk("Sistema NO Validado. Leido=%lld\\n", valorleido);
	return 0;

}} {}
} 

Function {FPGA_from_phys(double volts)} {return_type {short int}
} {
  code {// Devuelve un valor entero a partir de los voltios y el máximo entero del canal
// Se asume un rango de -VGalvoRef_MaximoBitsV a +VGalvoRef_MaximoBitsV en la salida analógica, y de 0 a 4095 (12 bits) en digital
short retval;

retval = (short) ((kFromPhysFPGA * volts) + (10.0 * kFromPhysFPGA));

if (debug_aodata) {

	rt_printk("V:%f FPGA_Data:%d\\n", volts, retval);

}

return retval;} {}
} 

Function {FPGA_to_phys(short int dato)} {return_type double
} {
  code {// Devuelve un valor real a partir del dato leido y el máximo entero del canal
// Se asume un rango de -10V a +10V en la salida analógica, y de 0 a 4095 (12 bits) en digital
double retval;

retval = (double) (((double)dato/kFromPhysFPGA) - 1.0);

if (debug_aodata) {

	rt_printk("Dato:%d Volts:%f\\n", dato, retval);

}

return retval;} {}
} 

Function {EscribirGalvoX_FPGA(short valor)} {C return_type void
} {
  code {// Escribe la nueva posición del galvo X
static short valoranterior=2048; // guarda el valor anterior, inicializando a 0V (valor 2048) (FPGA)
BYTE LSB_byte, comando;
//RTIME t0, t1;

if (valor == valoranterior) {return;}

// Si el salto es mayor que 0.1V (0.5%) = 205 bits (4096/20V) pon traza
if ((valor - valoranterior) > 205) {

	rt_printk("\#\#\# Salto en X - Valor=%d Anterior=%d MV=%ld\\n", valor, valoranterior, MicroVector);

}

// guarda el valor
valoranterior = valor;

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_X | ((valor >> 8) & 0x000F));

//t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
//t1=rt_get_cpu_time_ns();
//rt_printk("t=%f\\n", float(t1-t0)/1000.0);} {}
} 

Function {EscribirGalvoY_FPGA(short valor)} {C return_type void
} {
  code {// Escribe la nueva posición del galvo Y
static short valoranterior=2048; // guarda el valor anterior, inicializando a 0V (valor 2048) (FPGA)
BYTE LSB_byte, comando;
//RTIME t0, t1;

if (valor == valoranterior) {return;}

// Si el salto es mayor que 0.1V (0.5%) = 205 bits (4096/20V) pon traza
if ((valor - valoranterior) > 205) {

	rt_printk("\#\#\# Salto en Y - Valor=%d Anterior=%d MV=%ld\\n", valor, valoranterior, MicroVector);

}

// guarda el valor
valoranterior = valor;

// Escribe el byte menos significativo en el registro data
LSB_byte = (unsigned char)(valor & 0x00FF);

//t0=rt_get_cpu_time_ns();
outb(LSB_byte, REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("%f ", float(t1-t0)/1000.0);

// Manda el comando a la FPGA: 
// escribe los 4 bits más significativos en el comando, y lo envía
comando = (unsigned char)(COMANDO_ESCRIBIR_POSICION_GALVO_Y | ((valor >> 8) & 0x000F));

//t0=rt_get_cpu_time_ns();
outb(comando, REGISTRO_ADDR);
//t1=rt_get_cpu_time_ns();
//rt_printk("t=%f\\n", float(t1-t0)/1000.0);} {}
} 

Function {LeerPosicionGalvoX_FPGA()} {C return_type short
} {
  code {// Lee la posición del galvo X
unsigned short posicion;

/*
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_X_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;
*/

return posicion;} {}
} 

Function {LeerPosicionGalvoY_FPGA()} {C return_type short
} {
  code {// Lee la posición del galvo Y
unsigned short posicion;

/*
BYTE LSB_byte, MSB_byte;

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_LSB, REGISTRO_ADDR);

// Lee el byte menos significativo
LSB_byte = inb(REGISTRO_DATA);

// Manda el comando a la FPGA
outb(COMANDO_LEER_POSICION_GALVO_Y_MSB, REGISTRO_ADDR);

// Lee el byte más significativo
MSB_byte = inb(REGISTRO_DATA);

// Compone el valor final
posicion = MSB_byte;
posicion <<= 8;
posicion += LSB_byte;
*/

return posicion;} {}
} 

Function {LeerCuentasEncoder_FPGA()} {C return_type {unsigned short}
} {
  code {// Lee las cuentas del encoder
unsigned short cuentas;
//RTIME t0, t1;

// Manda el comando a la FPGA
// Con este comando se copia el valor de las cuentas del encoder en la FPGA (8 bits)

//t0=rt_get_cpu_time_ns();
outb(COMANDO_LEER_CUENTAS_ENCODER, REGISTRO_ADDR);
//t1=rt_get_cpu_time_ns();
//rt_printk("Encoder outb:%f ", float(t1-t0)/1000.0);

// Lee el byteo
//t0=rt_get_cpu_time_ns();
cuentas = inb(REGISTRO_DATA);
//t1=rt_get_cpu_time_ns();
//rt_printk("inb:%f\\n", float(t1-t0)/1000.0);

return cuentas;} {}
} 

Function {Maximo(float a, float b, float c)} {return_type float
} {
  code {float max;

if (a > b) { max = a; }

else { max = b; }

if (c > max) { max = c; }

return max;} {}
} 

Function {Iniciar_Oscilador_Fibra()} {open C return_type int
} {
  code {int error = false;

// debug
if (debug_resto){
	printf("Entrando-----------------Inicializar_laser\\n");
}

// Calcula los ticks del tren de pulsos: sólo dependen de la frecuencia del reloj de la DAQ/FPGA, que se
// ha definido al inicializar el control
Laser_Up_Ticks = (unsigned short int)((PeriodoTrenPulsos*10*PotenciaLaser) + Clock_Period_ns / 2) / Clock_Period_ns;
Laser_Down_Ticks = (unsigned short int)((PeriodoTrenPulsos*1000) + Clock_Period_ns / 2) / Clock_Period_ns - Laser_Up_Ticks;

switch (Control) {

case DAQ:
	// configura la señal gate
			error = itaca_comedi_set_gate_source(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, NI_GPCT_DISABLED_GATE_SELECT | CR_EDGE);
			if (error < 0){
				rt_printk("ERROR comedi_set_gate_source 0 laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
	
			// configura el modo del contador
			error = itaca_comedi_set_counter_mode(comedi_device, comedi_subdevice_ContadorLaser, comedi_ContadorLaser_Canal, Counter_Mode);
			if (error < 0){
				rt_printk("ERROR comedi_set_counter_mode laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// asigna el reloj: 20MHz clock
			error = itaca_comedi_set_clock_source(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_TIMEBASE_1_CLOCK_SRC_BITS, Clock_Period_ns);
			if (error < 0){
				rt_printk("ERROR comedi_set_clock_source laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set initial counter value by writing to channel 0
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 0, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks inicial laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set "load a" register to the number of clock ticks the counter output should remain low
			// by writing to channel 1.
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 1, 0, 0, Laser_Down_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write down_ticks load a laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}

			// set "load b" register to the number of clock ticks the counter output should remain high
			// writing to channel 2 
			error = comedi_data_write(comedi_device, comedi_subdevice_ContadorLaser, 2, 0, 0, Laser_Up_Ticks);
			if (error < 0){
				rt_printk("ERROR comedi_data_write up_ticks load b laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
	
			// arma el contador
			error = itaca_comedi_arm(comedi_device, comedi_subdevice_ContadorLaser, NI_GPCT_ARM_IMMEDIATE);
			if (error < 0){
				rt_printk("ERROR comedi_arm laser\\n");
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
			
			//Escribe en la salida digital la señal de activación de galvos
			error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, LOW);	
			sleep(1);
			error = comedi_dio_write(comedi_device, comedi_subdevice_ActivacionGalvos, comedi_canalDO_ActivacionGalvos, HIGH);
			
			if(error < 0){
			rt_printk("comedi_dio_write = %d - comedi_canalDO_ActivacionGalvos ON \\n",error);
			ErrorDAQ = ON;
			ProcesarError();
			}
	break;

case FPGA:

	// Asegura que el láser está apagado
	outb((COMANDO_LASER|0x00), REGISTRO_ADDR);

	// Escribe la señal de Laser Enable
	outb((COMANDO_LASER_ENABLE|0x01), REGISTRO_ADDR);

	//rt_printk("Laser_Up_Ticks=%d	Laser_Down_Ticks=%d\\n", Laser_Up_Ticks, Laser_Down_Ticks);

	// Para que funcione la potencia al 100% tiene que haber al menos un pulso de bajada
	// if (laser_down_ticks == 0) {laser_down_ticks=1;}

	// Envía los datos de los ticks del tren de pulsos

	// Ticks Laser Up:

	// Byte menos significativo (LSB)
	outb((unsigned char)(Laser_Up_Ticks & 0x00FF), REGISTRO_DATA);

	// comando LSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_LSB), REGISTRO_ADDR);

	// Byte más significativo (MSB)
	outb((unsigned char)((Laser_Up_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

	// comando MSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_UP_TICKS_MSB), REGISTRO_ADDR);

	// Ticks Laser Down:

	// Byte menos significativo (LSB)
	outb((unsigned char)(Laser_Down_Ticks & 0x00FF), REGISTRO_DATA);

	// comando LSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_LSB), REGISTRO_ADDR);

	// Byte más significativo (MSB)
	outb((unsigned char)((Laser_Down_Ticks >> 8) & 0x00FF), REGISTRO_DATA);

	// comando MSB
	outb((COMANDO_LASER_TICKS|ARG_LASER_DOWN_TICKS_MSB), REGISTRO_ADDR);
	
	break;
	
} 

// debug
if (debug_resto){
	printf("Saliendo-----------------Inicializar_laser\\n");
}

return error;} {}
} 

Function {Llevar_Galvos_Origen()} {C return_type int
} {
  code {int error = false;

MovimientoInicialGalvos = 1;
// Mover los galvos al origen
		xValuesPosicion = 0;
		yValuesPosicion = 0;
		if (CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0){
			MoverGalvos();
		}
		
MovimientoInicialGalvos = 0;
/*
// escribe en el galvo X
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoX, 0, 0, 1);
		if (error < 0) {
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false; 
		}



// escribe en el galvo Y
		error = comedi_data_write(comedi_device, comedi_subdevice_AO, comedi_canalAO_GalvoY, 0, 0, 1);
		if (error < 0) {
			rt_printk("comedi_data_write error=%d\\n", error);
		    	ErrorDAQ = ON; 
    			return false;
		}
*/
return error;} {}
} 

Function {CalcularCorreccionVector(int xsincorregir, int ysincorregir)} {C return_type int
} {
  code {double xdeformada;
double ydeformada;
double xpincushion;
double ypincushion;
double factorcorreccionx;
double factorcorrecciony;
double angulox;
double anguloy;
double distanciabarrel;

if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("xsincorregir:%d ysincorregir:%d\\n", xsincorregir, ysincorregir);
	
}	


angulox = xsincorregir*17*6.28/32768/360;
anguloy = ysincorregir*17*6.28/32768/360;
if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("ANGULOX:%f ANGULOY:%f\\n", angulox, anguloy);	
}

//correccion pincushion
xpincushion=4000*tan(angulox)*(1 + (117000/4000/cos(anguloy)));
ypincushion=117000*tan(anguloy);
if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("Xpincushion:%f Ypincushion:%f\\n", xpincushion, ypincushion);
	
}

//correccion barrel
distanciabarrel=sqrt(pow(xpincushion/32678,2)+pow(ypincushion/32768,2));
xdeformada=xpincushion*(1-(0.05*distanciabarrel));
ydeformada=ypincushion*(1-(0.05*distanciabarrel));

	factorcorreccionx=xdeformada/xsincorregir;
	factorcorrecciony=ydeformada/ysincorregir;
	
if (xdeformada !=0) {
	xcorregido=int(xsincorregir*xsincorregir/xdeformada);
	}
else {
	xcorregido=0;
}
if (ydeformada!=0) {
	ycorregido=int(ysincorregir*ysincorregir/ydeformada);
	}
else {
	ycorregido=0;
}


if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
		//rt_printk(" X:%d Y:%d\\n", xcorregido, ycorregido);	
	
}
return 1;} {}
} 

Function {CalcularCorreccionMicrovector(double xsincorregirMV,double ysincorregirMV)} {C return_type int
} {
  code {double xdeformadaMV;
double ydeformadaMV;
double xpincushionMV;
double ypincushionMV;
double factorcorreccionxMV;
double factorcorreccionyMV;
double anguloxMV;
double anguloyMV;
double distanciabarrelMV;

if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("xsincorregirMV:%f ysincorregirMV:%f\\n", xsincorregirMV, ysincorregirMV);
	
}	


anguloxMV = xsincorregirMV*18*6.28/32768/360;
anguloyMV = ysincorregirMV*18*6.28/32768/360;
if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("ANGULOX:%f ANGULOY:%f\\n", anguloxMV, anguloyMV);	
}

//correccion pincushion
xpincushionMV=4000*tan(anguloxMV)*(1 + (110000/4000/cos(anguloyMV)));
ypincushionMV=110000*tan(anguloyMV);
if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
	//rt_printk("XpincushionMV:%f YpincushionMV:%f\\n", xpincushionMV, ypincushionMV);
	
}

//correccion barrel
distanciabarrelMV=sqrt(pow(xpincushionMV/32678,2)+pow(ypincushionMV/32768,2));
xdeformadaMV=xpincushionMV*(1-(0.05*distanciabarrelMV));
ydeformadaMV=ypincushionMV*(1-(0.05*distanciabarrelMV));

	factorcorreccionxMV=xdeformadaMV/xsincorregirMV;
	factorcorreccionyMV=ydeformadaMV/ysincorregirMV;
	
if (xdeformadaMV !=0) {
	xcorregidoMV=(xsincorregirMV*xsincorregirMV/xdeformadaMV);
	}
else {
	xcorregidoMV=0;
}
if (ydeformadaMV!=0) {
	ycorregidoMV=(ysincorregirMV*ysincorregirMV/ydeformadaMV);
	}
else {
	ycorregidoMV=0;
}


if (debug_vectores) {	
	//rt_printk("CalcularMatriz - Vectores: %ld\\n", NumeroVectores);
		
		//rt_printk(" X:%f Y:%f\\n", xcorregidoMV, ycorregidoMV);	
	
}
return 1;} {}
} 

Function {Parar_Oscilador_Fibra()} {open C return_type int
} {
  code {int error = false;

// Resetea el contador
			error = itaca_comedi_reset(comedi_device, comedi_subdevice_ContadorLaser);
			if (error < 0){
				rt_printk("ERROR comedi_reset laser %d\\n", error);
				ErrorDAQ = ON;
				ProcesarError();
				return -1;
			}
			return error;} {}
} 

Function {} {open C
} {
  code {// Inicialización 
rt_printk("\\n\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\# INICIO \#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\\n");

// Fija la apariencia plastic para todos los widgets
Fl::scheme("plastic");

// Elimina los recuadros de foco para todos los widgets
Fl::visible_focus(OFF);

// Inicializa variables de control de errores
ErrorDAQ = OFF;
ErrorFPGA = OFF;
ErrorRTAI = OFF;
ErrorGalvos = OFF;
ErrorLaserOk = OFF;	
ErrorTemperatura = OFF;
ErrorExtractor = OFF;	
ErrorVectores = OFF;
ErrorWatchdog = OFF;	
ErrorEncoder = OFF;
SistemaOk = true;
ConfiguracionModificada = false;
ErrorValidacion = OFF;

// leer datos de configuración del archivo itaca.conf
Leer_Configuracion();

// leer datos de marcaje representados en el interfaz del archivo itaca.gui
Leer_DAT("itaca.dat");

// Inicialización de parámetros de marcaje
Inicializar_Marcaje();

// Crear las ventanas emergentes de confirmar/cancelar prueba de marcaje, marcar, 
// apagar el sistema, modificar el texto, detalles de la línea, password, confirmar cargar
// y guardar trabajos

// Se presentarán de forma modal cuando sea preciso
Make_Window_Confirmar_Prueba();
Make_Window_Confirmar_Marcar();
Make_Window_Confirmar_Apagar();
Make_Window_Modificar_Texto();
Make_Window_Detalles_Linea();
Make_Window_Trabajos();
Make_Window_Password();
Make_Window_Confirmar_CargarTrabajo();
Make_Window_Confirmar_GuardarTrabajo();
Make_Window_Repeticiones();
Make_Window_Confirmar_BorrarTrabajo();

if (debug_FPGA) {Make_Window_FPGA();}

// Crear la ventana utilizada para presentar mensajes al usuario
Make_Window_Mensaje();

// Fija el locale del idioma elegido, para los mensajes de formateo de fechas
switch (Idioma) {

	case ESP:
	setlocale(LC_TIME, "es_ES");
	break;
	
	case ING:
	setlocale(LC_TIME, "en_US");
	break;
	
	case ITA:
	setlocale(LC_TIME, "it_IT");
	break;
	
}} {}
  Fl_Window VentanaPrincipal {open
    xywh {0 0 800 600} type Double color 7 selection_color 7 labelcolor 8 when 1 modal noborder size_range {800 600 800 600} visible
  } {
    Fl_Box LedLaser {
      label {LÁSER }
      xywh {165 3 27 27} box OFLAT_BOX color 30 labeltype NO_LABEL labelfont 8 labelsize 15 align 208 when 1
      code0 {o->color(FL_DARK3); // inicialización}
      code3 {switch (Idioma) {case ESP:o->label("LÁSER");break; case ING:o->label("LASER");break; case ITA:o->label("LASER");break;}}
    }
    Fl_Button LedEstado {
      label {Sistema Ok}
      callback {// Vuelve al estado inicial cuando se presiona el Led tras un error (rearma el sistema)
// Sólo si el error es de obturador, galvos, laser Ok,  
// Si es de RTAI o DAQ estará deshabilitado el botón

if (LedEstado->color() == (Fl_Color)1)  { // está rojo

	// Vuelve a poner el Led en verde
	LedEstado->color((Fl_Color)2); 	// Led verde
	LedEstado->redraw();		// Marca el Led para redraw
	
	// Actualiza el mensaje
	switch (Idioma) {
			
		case ESP:
		LedEstado->label("Sistema OK");
		break; 
			
		case ING:
		LedEstado->label("System OK");
		break;
			
		case ITA:
		LedEstado->label("Sistema OK");
		break;
			
	}
	  
	// Vuelve a activar los botones
	BotonMarcar->activate();
	BotonPrueba->activate();
	if (ServicioTecnico) {
		BotonLaser->activate();
		BotonCampo->activate();
	}
	
	// resetea el error de encoder
	ErrorEncoder = OFF;
	ContadorDisparosParado = 0;
	
	// resetea el error de campo
	ErrorCampo = OFF;
		
	// y actualiza el GUI
	Fl::flush();	

}}
      xywh {10 3 150 27} box RFLAT_BOX down_box RFLAT_BOX color 63 labelfont 8 labelsize 13 align 208
      code0 {//o->label("Sistema Ok"); //inicialización}
      code3 {switch (Idioma) {case ESP:o->label("Sistema Ok");break; case ING:o->label("System Ok");break; case ITA:o->label("Sistema Ok");break;}}
    }
    Fl_Box LogoItacaVentanaPrincipal {
      image {fls.png} xywh {631 0 165 65} color 7 labelsize 12 align 16
    }
    Fl_Box BoxVersionSW {
      label {Itaca v6.0}
      xywh {630 60 165 15} labelfont 8 labelsize 10 labelcolor 5 align 240
      code0 {// \#ifdef _68pines BoxVersionSW->label("Itaca v2.0.68p"); \#else BoxVersionSW->label("Itaca v2.0"); \#endif}
      code1 {// La línea comentada arriba está en la post inicialización, porque fluid no maneja bien las}
      code2 {// directivas del preprocesador}
    }
    Fl_Value_Output CuadroTextoContador {
      label Marcas
      callback {o->value(Contador);}
      xywh {250 3 70 27} box RFLAT_BOX color 47 labelfont 8 labelsize 12 textfont 8 textsize 12
      code0 {o->precision(0); o->value(Contador); //inicialización}
      code1 {//if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico}
      code3 {switch (Idioma) {case ESP:o->label("Marcas");break; case ING:o->label("Marks");break; case ITA:o->label("Stampe");break;}}
    }
    Fl_Value_Output CuadroTextoVLinea {
      label {V Línea}
      xywh {570 3 50 27} box RFLAT_BOX color 47 labelfont 8 labelsize 11 textfont 8 textsize 11
      code0 {o->precision(1); //inicialización}
      code1 {//if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico}
      code3 {switch (Idioma) {case ESP:o->label("V Línea");break; case ING:o->label("Line Speed");break; case ITA:o->label("V linea");break;}}
    }
    Fl_Value_Output CuadroTextoTMarca {
      label Tmark
      xywh {430 3 60 27} box RFLAT_BOX color 47 labelfont 8 labelsize 11 textfont 8 textsize 11
      code0 {o->precision(2); //inicialización}
      code1 {if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico}
      code3 {switch (Idioma) {case ESP:o->label("Tmarca");break; case ING:o->label("Tmark");break; case ITA:o->label("Tmark");break;}}
    }
    Fl_Group GrupoControlIntensidad {open
      xywh {10 35 180 120} box PLASTIC_DOWN_BOX color 170 selection_color 7 labeltype NO_LABEL labelsize 10 align 5
      code0 {//if (ControlAcceso) {o->deactivate();}}
    } {
      Fl_Counter IndicadorPotencia {
        label {Potencia (%)}
        callback {if (!ControlAcceso) {

	// Cambia la potencia
	PotenciaLaser = (int) o->value();

	// Inicializa de nuevo el láser, variando el tren de pulsos de acuerdo a la nueva potencia
	if ((!ErrorDAQ)&&(!ErrorFPGA)) {
		Inicializar_Laser();
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(PotenciaLaser);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 60 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 selection_color 54 labelfont 8 labelsize 15 align 5 when 6 minimum 1 maximum 100 step 1 value 50 textfont 8 textsize 15
        code0 {o->value(PotenciaLaser); //inicialización}
        code1 {if (o->value() == 0) {o->value(1);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Potencia (%)");break; case ING:o->label("Power (%)");break; case ITA:o->label("Potenza (%)");break;}}
      }
      Fl_Counter IndicadorVelocidad {
        label {Velocidad (mm/s)}
        callback {if (!ControlAcceso) {

	// Por debajo de 500 la velocidad varía de 25 en 25, por encima de 100 en 100
	if (VelocidadMarcaje > 500) {
		
		o->step(100);
	
	} 
	
	else if (VelocidadMarcaje < 500) {
		
		o->step(25);
		
	}
	
	else { // es 500!
	
		if (o->value() > VelocidadMarcaje) { // Incrementa
			
			o->step(100);
			o->value(600);
						
	
		}
		
		else {	// Decrementa
		
			o->step(25);
			o->value(475);
		
		}
	
	}
	
	// Cambia la velocidad de marcaje
	VelocidadMarcaje = (int) o->value();
	
	// Recalcula el MarkStepSize
	CalcularMarkStepSize();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {
	
	// Restaura el valor original
	o->value(VelocidadMarcaje);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 115 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 5 when 3 minimum 25 maximum 20000 step 100 value 1000 textfont 8 textsize 15
        code0 {o->value(VelocidadMarcaje); //inicialización}
        code1 {if (VelocidadMarcaje > 500) {o->step(100);} else {o->step(25);} // Por debajo de 500 varía de 25 en 25}
        code2 {if (o->value() == 0) {o->value(25);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Velocidad (mm/s)");break; case ING:o->label("Speed (mm/s)");break; case ITA:o->label("Velocità (mm/s)");break;}}
      }
    }
    Fl_Group GrupoControlMarca {
      xywh {10 160 180 435} box PLASTIC_DOWN_BOX color 36 selection_color 7 labeltype NO_LABEL labelsize 10 align 5
      code0 {//if (ControlAcceso) {o->deactivate();}}
    } {
      Fl_Counter IndicadorHorizontal {
        label {Horizontal (mm)}
        callback {if (!ControlAcceso) {

	// Cambia la posición horizontal
	Horizontal = (int) o->value();	// en mm

	xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion);	// en bits
	
	// Habrá que volver a calcular los parámetros relacionados
	Inicializar_Marcaje();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Horizontal);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 185 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 5 when 6 minimum -1000 maximum 1000 step 1 textfont 8 textsize 15
        code0 {InicializarIndicadorHorizontal(); // fija el máximo y el míinimo}
        code1 {o->value(Horizontal); //inicialización}
        code2 {xOffsetPantalla = (int)(Horizontal * CalibracionCorreccion); // en bits}
        code3 {switch (Idioma) {case ESP:o->label("Horizontal (mm)");break; case ING:o->label("Horizontal (mm)");break; case ITA:o->label("Orizzontale (mm)");break;}}
      }
      Fl_Counter IndicadorVertical {
        label {Vertical (mm)}
        callback {if (!ControlAcceso) {

	// Cambia la posición vertical
	Vertical = (int) o->value();	// en mm

	yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits

	// Habrá que volver a calcular los parámetros relacionados
	Inicializar_Marcaje();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Vertical);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 235 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 5 when 6 minimum -1000 maximum 1000 step 1 textfont 8 textsize 15
        code0 {InicializarIndicadorVertical(); // fija el máximo y el mínimo}
        code1 {o->value(Vertical); //inicialización}
        code2 {yOffsetPantalla = (int)(Vertical * CalibracionCorreccion); // en bits}
        code3 {switch (Idioma) {case ESP:o->label("Vertical (mm)");break; case ING:o->label("Vertical (mm)");break; case ITA:o->label("Verticale (mm)");break;}}
      }
      Fl_Choice ChoiceFuente {
        label Fuente
        callback {if (!ControlAcceso) {

	// Almacena el valor seleccionado en la variable ValorFuente
	ValorFuente = o->value();

	// Marca el archivo como no abierto
	ArchivoFuentesAbierto = false;
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(ValorFuente);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}} open
        xywh {20 289 160 30} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX selection_color 95 labelfont 8 labelsize 15 align 5 when 6 textfont 8 textsize 15
        code0 {int i; for (i=0; i<NumeroFuentes; i++) {o->add(Fuentes[Idioma][i]);}//inicialización}
        code1 {o->value(ValorFuente); // carga el valor inicial}
        code3 {switch (Idioma) {case ESP:o->label("Fuente");break; case ING:o->label("Font");break; case ITA:o->label("Fonte");break;}}
      } {}
      Fl_Counter IndicadorAnchura {
        label {Anchura (%)}
        callback {if (!ControlAcceso) {

	// Cambia la anchura de los caracteres
	Anchura = (int)o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Anchura);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 345 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 1 maximum 200 step 1 value 100 textfont 8 textsize 15
        code0 {o->value(Anchura); //inicialización}
        code1 {if (o->value() == 0) {o->value(100);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Anchura (%)");break; case ING:o->label("Width (%)");break; case ITA:o->label("Larghezza (%)");break;}}
      }
      Fl_Counter IndicadorEspaciado {
        label {Espaciado (%)}
        callback {if (!ControlAcceso) {

	// Cambia el espaciado entre caracteres
	Espaciado = (int) o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(Espaciado);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 400 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 5 when 6 minimum 1 maximum 200 step 1 value 100 textfont 8 textsize 15
        code0 {o->value(Espaciado); //inicialización}
        code1 {if (o->value() == 0) {o->value(100);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Espaciado (%)");break; case ING:o->label("Spacing (%)");break; case ITA:o->label("Spaziatura (%)");break;}}
      }
      Fl_Counter IndicadorSeparacion {
        label {Entre líneas (mm)}
        callback {if (!ControlAcceso) {

	// Cambia la separación entre líneas
	SeparacionLineas = (float)o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(SeparacionLineas);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {20 455 160 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 133 when 6 minimum 0.1 maximum 10 value 1 textfont 8 textsize 15
        code0 {o->value(SeparacionLineas); //inicialización}
        code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
        code3 {switch (Idioma) {case ESP:o->label("Entre líneas (mm)");break; case ING:o->label("Betw. lines (mm)");break; case ITA:o->label("Dist. linee (mm)");break;}}
      }
      Fl_Group SubgrupoJustificacion {
        label {Justificación} open
        xywh {20 510 160 75} box PLASTIC_UP_FRAME color 39 labelfont 8 labelsize 15 align 5
        code3 {switch (Idioma) {case ESP:o->label("Justificación");break; case ING:o->label("Justification");break; case ITA:o->label("Giustificazione");break;}}
      } {
        Fl_Round_Button CheckJustificacionCentro {
          label { Centro}
          callback {if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionCentro = (int) o->value();

	JustificacionIzquierda = OFF;
	CheckJustificacionIzquierda->value(OFF);

	JustificacionDerecha = OFF;
	CheckJustificacionDerecha->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionCentro);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {30 540 125 15} down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 15 when 6
          code0 {o->value(JustificacionCentro); //inicialización}
          code3 {switch (Idioma) {case ESP:o->label("Centro");break; case ING:o->label("Center");break; case ITA:o->label("Centro");break;}}
        }
        Fl_Round_Button CheckJustificacionDerecha {
          label { Derecha}
          callback {if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionDerecha = (int) o->value();

	JustificacionIzquierda = OFF;
	CheckJustificacionIzquierda->value(OFF);

	JustificacionCentro = OFF;
	CheckJustificacionCentro->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionDerecha);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {30 560 125 15} down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 15 when 6
          code0 {o->value(JustificacionDerecha); //inicialización}
          code3 {switch (Idioma) {case ESP:o->label("Derecha");break; case ING:o->label("Right");break; case ITA:o->label("Destra");break;}}
        }
        Fl_Round_Button CheckJustificacionIzquierda {
          label { Izquierda}
          callback {if (!ControlAcceso) {

	// Cambia la justificación
	o->value(ON);
	JustificacionIzquierda = (int) o->value();

	JustificacionCentro = OFF;
	CheckJustificacionCentro->value(OFF);

	JustificacionDerecha = OFF;
	CheckJustificacionDerecha->value(OFF);
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(JustificacionIzquierda);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {30 520 125 15} down_box PLASTIC_DOWN_BOX color 0 labelfont 8 labelsize 15 when 6
          code0 {o->value(JustificacionIzquierda); //inicialización}
          code1 {if ((!JustificacionIzquierda) && (!JustificacionCentro) && (!JustificacionDerecha)) {JustificacionIzquierda = ON; o->value(JustificacionIzquierda);}}
          code3 {switch (Idioma) {case ESP:o->label("Izquierda");break; case ING:o->label("Left");break; case ITA:o->label("Sinistra");break;}}
        }
      }
    }
    Fl_Group GrupoControlTexto {
      xywh {200 35 420 560} color 54 selection_color 7 labeltype NO_LABEL labelsize 10 align 5
      code0 {if (Funcionalidad != BLOQUES) {o->show();} else {o->hide();}}
    } {
      Fl_Group SubGrupoLinea1 {
        label {Línea 1}
        xywh {200 35 420 135} box PLASTIC_THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
      } {
        Fl_Output CuadroTextoLinea1 {
          label {Línea 1}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 60 380 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
        }
        Fl_Counter IndicadorAlturaLinea1 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto1[0] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 124 140 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textsize 15
          code0 {o->value(AlturaLineaTexto1[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea1 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {385 125 220 30} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 7 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[0][0]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea2 {
        label {Línea 2}
        xywh {200 175 420 135} box PLASTIC_THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
      } {
        Fl_Output CuadroTextoLinea2 {
          label {Línea 2}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 200 380 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
        }
        Fl_Counter IndicadorAlturaLinea2 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto2[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 264 140 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textsize 15
          code0 {o->value(AlturaLineaTexto2[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea2 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {385 265 220 30} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 7 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[1][0]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea3 {
        label {Línea 3}
        xywh {200 315 420 135} box PLASTIC_THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
      } {
        Fl_Output CuadroTextoLinea3 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 340 380 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
        }
        Fl_Counter IndicadorAlturaLinea3 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto3[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 404 140 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textsize 15
          code0 {o->value(AlturaLineaTexto3[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea3 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {385 405 220 30} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 7 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[2][0]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea4 {
        label {Línea 4} open
        xywh {200 455 420 135} box PLASTIC_THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}}
      } {
        Fl_Output CuadroTextoLinea4 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 480 380 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
        }
        Fl_Counter IndicadorAlturaLinea4 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto4[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {225 544 140 30} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textsize 15
          code0 {o->value(AlturaLineaTexto4[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea4 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;
	
	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {385 545 220 30} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 7 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[3][0]]);//inicialización}
        }
      }
    }
    Fl_Group GrupoControlTextoBloques {
      xywh {200 35 420 560} color 54 selection_color 7 labeltype NO_LABEL labelsize 10 align 5
      code0 {if (Funcionalidad == BLOQUES) {o->show();} else {o->hide();}}
    } {
      Fl_Group SubGrupoLinea1Bloques {
        label {Línea 1}
        xywh {200 35 420 140} box THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
      } {
        Fl_Output CuadroTextoLinea1Bloque1 {
          label {Línea 1}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 55 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque1->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
        }
        Fl_Counter IndicadorAlturaLinea1Bloque1 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto1[0] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 108 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto1[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea1Bloque1 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 140 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[0][0]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea1Bloque2 {
          label {Línea 1}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 55 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=2; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque2->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
        }
        Fl_Counter IndicadorAlturaLinea1Bloque2 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {
	
	AlturaLineaTexto1[1] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 108 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto1[1]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea1Bloque2 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;


	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 140 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][1] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[0][1]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea1Bloque3 {
          label {Línea 1}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 55 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=3; LineaCalcular=1; CargarTexto(); ProcesarTexto(); o->value(LineaTexto1[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea1Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea1Bloque3->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 1");break; case ING:o->label("Line 1");break; case ITA:o->label("Linea 1");break;}}
        }
        Fl_Counter IndicadorAlturaLinea1Bloque3 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto1[2] = o->value();
	
	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto1[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 108 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto1[2]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea1Bloque3 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 1;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();

}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 140 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[0][2] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[0][2]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea2Bloques {
        label {Línea 2}
        xywh {200 175 420 140} box THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
      } {
        Fl_Output CuadroTextoLinea2Bloque1 {
          label {Línea 2}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 195 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque1->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
        }
        Fl_Counter IndicadorAlturaLinea2Bloque1 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto2[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 248 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto2[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea2Bloque1 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 280 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[1][0]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea2Bloque2 {
          label {Línea 2}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;
	
	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 195 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=2; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque2->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
        }
        Fl_Counter IndicadorAlturaLinea2Bloque2 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto2[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 248 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto2[1]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea2Bloque2 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 280 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][1] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[1][1]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea2Bloque3 {
          label {Línea 2}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 195 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=3; LineaCalcular=2; CargarTexto(); ProcesarTexto(); o->value(LineaTexto2[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea2Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea2Bloque3->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 2");break; case ING:o->label("Line 2");break; case ITA:o->label("Linea 2");break;}}
        }
        Fl_Counter IndicadorAlturaLinea2Bloque3 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto2[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto2[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 248 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto2[2]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea2Bloque3 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;
	
	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 2;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 280 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[1][2] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[1][2]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea3Bloques {
        label {Línea 3} open
        xywh {200 315 420 140} box THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
      } {
        Fl_Output CuadroTextoLinea3Bloque1 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 335 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque1->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
        }
        Fl_Counter IndicadorAlturaLinea3Bloque1 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto3[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 388 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto3[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea3Bloque1 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 420 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[2][0]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea3Bloque2 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 335 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=2; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque2->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
        }
        Fl_Counter IndicadorAlturaLinea3Bloque2 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto3[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 388 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto3[1]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea3Bloque2 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 420 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][1] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[2][1]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea3Bloque3 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 335 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=3; LineaCalcular=3; CargarTexto(); ProcesarTexto(); o->value(LineaTexto3[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea3Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea3Bloque3->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 3");break; case ING:o->label("Line 3");break; case ITA:o->label("Linea 3");break;}}
        }
        Fl_Counter IndicadorAlturaLinea3Bloque3 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto3[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto3[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 388 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto3[2]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea3Bloque3 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 3;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 420 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[2][2] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[2][2]]);//inicialización}
        }
      }
      Fl_Group SubGrupoLinea4Bloques {
        label {Línea 4} open
        xywh {200 455 420 140} box THIN_DOWN_BOX color 7 selection_color 55 labelfont 9 labelsize 15 labelcolor 14 align 17
        code0 {//if (ControlAcceso) {o->deactivate();}}
        code1 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}}
      } {
        Fl_Output CuadroTextoLinea4Bloque1 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 475 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=1; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque1->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque1->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}}
        }
        Fl_Counter IndicadorAlturaLinea4Bloque1 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto4[0] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[0]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 528 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto4[0]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea4Bloque1 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 1;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {215 560 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][0] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[3][0]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea4Bloque2 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 475 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=2; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque2->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque2->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}}
        }
        Fl_Counter IndicadorAlturaLinea4Bloque2 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto4[1] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[1]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 528 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto4[1]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea4Bloque2 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 2;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {350 560 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][1] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[3][1]]);//inicialización}
        }
        Fl_Output CuadroTextoLinea4Bloque3 {
          label {Línea 3}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Cargar la ventana de modificar texto
	CargarVentanaModificarTexto();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 475 120 30} box PLASTIC_THIN_UP_BOX color 175 labeltype NO_LABEL labelfont 8 labelsize 15 align 5 textfont 8 textsize 15
          code0 {BloqueCalcular=3; LineaCalcular=4; CargarTexto(); ProcesarTexto(); o->value(LineaTexto4[BloqueCalcular-1]); //inicialización}
          code1 {if (ValorTipoLinea[LineaCalcular-1][BloqueCalcular-1] == GRAFICO) {CuadroTextoLinea4Bloque3->value(NombreArchivoPlt[LineaCalcular-1][BloqueCalcular-1]);CuadroTextoLinea4Bloque3->deactivate();}}
          code2 {o->clear_visible_focus(); // Para que no se vea "^" en el widget}
          code3 {switch (Idioma) {case ESP:o->label("Línea 4");break; case ING:o->label("Line 4");break; case ITA:o->label("Linea 4");break;}}
        }
        Fl_Counter IndicadorAlturaLinea4Bloque3 {
          label {Altura (mm)}
          callback {if (!ControlAcceso) {

	AlturaLineaTexto4[2] = o->value();

	// Si está marcando habrá que volver a calcular la matriz
	if (EnEjecucion) {Actualizar=true;}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(AlturaLineaTexto4[2]);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 528 120 24} type Simple box PLASTIC_THIN_UP_BOX color 8 labelfont 8 labelsize 15 align 37 when 6 minimum 1 maximum 100 value 2.5 textfont 8 textsize 15
          code0 {o->value(AlturaLineaTexto4[2]);}
          code1 {if (o->value() == 0) {o->value(1.0);} // No puede valer 0}
          code3 {switch (Idioma) {case ESP:o->label("Altura (mm)");break; case ING:o->label("Height (mm)");break; case ITA:o->label("Altezza (mm)");break;}}
        }
        Fl_Button BotonDetallesLinea4Bloque3 {
          label {Tipo Línea}
          callback {if (!ControlAcceso) {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Guarda todo, por si se cancela luego
	Escribir_DAT("itaca.dat");

	// Guarda el valor del bloque que se está calculando, para actualizar correctamente al volver
	BloqueCalcular = 3;

	// Guarda el valor de la línea que se está calculando, para actualizar correctamente al volver
	LineaCalcular = 4;

	// Carga los datos y muestra la ventana de detalles de la línea
	CargarVentanaDetallesLinea();
	
}

// Control de acceso activado:
else {

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
          xywh {485 560 120 25} box PLASTIC_THIN_UP_BOX down_box PLASTIC_THIN_DOWN_BOX color 39 labelfont 8 labelsize 15
          code0 {if (Funcionalidad == SOLOTEXTO) {ValorTipoLinea[3][2] = TEXTO; o->hide();}}
          code1 {else {o->show();}}
          code2 {o->label(strTiposLinea[Idioma][ValorTipoLinea[3][2]]);//inicialización}
        }
      }
    }
    Fl_Group GrupoControlOperacion {
      xywh {630 75 165 520} color 53 selection_color 7 labeltype NO_LABEL labelsize 10 align 5
    } {
      Fl_Light_Button BotonMarcar {
        label Marcar
        callback {// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaMarcar->show();}
        xywh {630 115 165 65} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 0 labelfont 8 labelsize 20 align 16
        code0 {if (!ENDESARROLLO) {o->deactivate();} // se inicia desactivado - tras inicializar los galvos se activa el botón}
        code3 {switch (Idioma) {case ESP:o->label("Marcar");break; case ING:o->label("Mark");break; case ITA:o->label("Stampa");break;}}
      }
      Fl_Light_Button BotonPrueba {
        label Prueba
        callback {// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaPrueba->show();}
        xywh {630 185 165 65} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 0 labelfont 8 labelsize 20 align 16
        code0 {if (!ENDESARROLLO) {o->deactivate();} // se inicia desactivado - tras inicializar los galvos se activa el botón}
        code3 {switch (Idioma) {case ESP:o->label("Prueba");break; case ING:o->label("Test");break; case ITA:o->label("Prova");break;}}
      }
      Fl_Button BotonStop {
        label Stop
        callback {// Ha sido ordenado desde el interfaz:
ModoImpresionSerie = false;

// Detiene la ejecución
StopEjecucion();


if (debug_listas) {
	rt_printk("\\n>>>>>>>>>>>>DETENIDA EJECUCIÓN LISTA \\n\\n");
}}
        xywh {630 255 165 65} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 7 labelfont 8 labelsize 20
        code0 {o->deactivate(); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Stop");break; case ING:o->label("Stop");break; case ITA:o->label("Stop");break;}}
      }
      Fl_Button BotonTrabajos {
        label Trabajos
        callback {// Muestra la ventana de trabajos
CargarVentanaTrabajos();}
        xywh {630 325 165 40} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 23 selection_color 7 labelfont 8
        code0 {//o->deactivate(); //inicialización}
        code3 {switch (Idioma) {case ESP:o->label("Trabajos");break; case ING:o->label("Jobs");break; case ITA:o->label("Lavoro");break;}}
      }
      Fl_Button BotonTablaPrecorte {
        label {Tabla-Precorte}
        callback {// Muestra la ventana de repeticiones
VentanaPrincipal->deactivate();
CargarVentanaRepeticiones();}
        xywh {630 370 165 40} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 23 selection_color 7 labelfont 8
        code0 {if (ControlTablaPrecorte) {o->show();} //inicialización}
        code1 {else {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Tabla-Precorte");break; case ING:o->label("Table-Slitting");break; case ITA:o->label("Quadro-Pretagliato");break;}}
      }
      Fl_Button BotonApagar {
        label Apagar
        callback {// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
VentanaPrincipal->deactivate();
	
VentanaApagarSistema->show();}
        xywh {630 525 165 70} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 7 labelfont 8 labelsize 20
        code3 {switch (Idioma) {case ESP:o->label("Apagar");break; case ING:o->label("Exit");break; case ITA:o->label("Spegnere");break;}}
      }
      Fl_Light_Button BotonLaser {
        label {Láser}
        callback {if (!ControlAcceso) {

	if (o->value() == ON) { // el usuario ha hecho click en el botón y lo ha activado, o sea que previamente estaba desactivado

		// Desactiva los botones de operaciones
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		BotonTrabajos->deactivate();
		CounterVelocidadLinea->deactivate();
		CounterEncoder->deactivate();
		BotonCampo->deactivate();
		BotonApagar->deactivate();
		BotonLaser->deactivate();
	
		// Activa el botón de Stop
		BotonStop->activate();
	
		// Actualiza el Led del láser a amarillo
		LedLaser->color(FL_YELLOW);
		LedLaser->redraw();	

		// Fuerza la actualización del interfaz
		Fl::flush();
	
		// Mover los galvos al origen
		xValuesPosicion = 0;
		yValuesPosicion = 0;
		if (CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0){
			MoverGalvos();
		}
							
		// Actualiza la señal de MarkInProgress y el Led del láser
		ControlMarkInProgress(ON);

		// Enciende el láser
		Control_Laser(ON);
	
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(OFF);

	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {715 75 80 35} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 0 labelfont 10 labelsize 12 labelcolor 1
        code0 {if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico}
        code1 {//o->deactivate(); // se inicia desactivado - tras inicializar los galvos se activa el botÂ´on}
        code3 {switch (Idioma) {case ESP:o->label("Láser");break; case ING:o->label("Laser");break; case ITA:o->label("Laser");break;}}
      }
      Fl_Light_Button BotonCampo {
        label Campo
        callback {if (!ControlAcceso) {

	if (o->value() == ON) { // el usuario ha hecho click en el botón y lo ha activado, o sea que previamente estaba desactivado

		// Desactiva los grupos de control de intensidad, de marca y de texto
		GrupoControlIntensidad->deactivate();
		GrupoControlMarca->deactivate();
		GrupoControlTexto->deactivate();

		// Desactiva los botones de operaciones
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		BotonTrabajos->deactivate();
		CounterVelocidadLinea->deactivate();
		CounterEncoder->deactivate();
		BotonLaser->deactivate();
		BotonCampo->deactivate();
		BotonApagar->deactivate();

		// Activa el botón de stop
		BotonStop->activate();

		// Actualiza el led del láser
		LedLaser->color(FL_YELLOW);
		LedLaser->redraw();
		
		// Fuerza la actualización del interfaz	
		Fl::flush();
	
		// Calcula la matriz correspondiente al campo
		CalcularMatrizCampo();
		//Inicia Oscilador Fibra
		switch(TipoLaser){
		case 1:
		Iniciar_Oscilador_Fibra();
		sleep(1);
		break;
		}	
		// Mueve los galvos al inicio de la lista
		if (CalcularMoverGalvos(xValues[0], yValues[0]) > 0){
			MoverGalvos();
		}
		
		// Activa el flag de prueba de marcaje
		PruebaMarcaje = true;
		ResetJumpList = false;

		// Descarga la lista 1
		DescargarLista(1);
		
		// Desactiva la espera del disparo de la fotocélula
		EsperaFotocelula = false;
	
		// Desactiva la espera del retardo de disparo
		EsperaRetardoDisparo = false;

		// Desactiva la espera de la separación entre disparos
		EsperaSeparacionEntreDisparos = false;

		// Desactiva las cuentas de marcaje dinámico 
		IncrementoAcumulado = 0;

		// Activa señal de MarkInProgress y el Led del láser
		ControlMarkInProgress(ON);

		// Ejecuta la lista 1
		MarcajeOk = true;
		EjecutarLista(1);
		
		// Espera a que termine la ejecución de la lista actual:
		while (((Lista1_Exe) || (Lista0_Exe)) && (PruebaMarcaje) && (SistemaOk)) {
        	
			// Espera un periodo
        		Fl::wait(PERIODO_WAIT);
        		
		}
		
		// Restaura el interfaz
		StopEjecucion();
		//Para Oscilador Fibra
		switch(TipoLaser){
		case 1:
		Parar_Oscilador_Fibra();
		break;
		}
		
	}
	
}

// Control de acceso activado:
else {

	// Restaura el valor original
	o->value(OFF);
	
	// Desactiva la ventana principal para que resalte la ventana emergente que saldrá a continuación
	VentanaPrincipal->deactivate();

	// Cargar la ventana de password
	CargarVentanaPassword();

}}
        xywh {630 75 80 35} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 0 labelfont 10 labelsize 12
        code0 {if (ServicioTecnico) {o->show();} else {o->hide();} // Activación segun Servicio Técnico}
        code1 {//o->deactivate(); // se inicia desactivado - tras inicializar los galvos se activa el botÂ´on}
        code3 {switch (Idioma) {case ESP:o->label("Campo");break; case ING:o->label("Field");break; case ITA:o->label("Campo");break;}}
      }
      Fl_Counter CounterEncoder {
        label {Encoder (cuentas/mm)}
        callback {// Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
CalibracionEncoder = o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Si está marcando habrá que volver a calcular la matriz
if (EnEjecucion) {Actualizar=true;}

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");}
        xywh {630 430 165 35} box PLASTIC_THIN_UP_BOX color 48 labelsize 12 align 5 when 6 minimum 1 maximum 10000 textfont 13 textsize 12
        code0 {o->value(CalibracionEncoder);}
        code1 {if ((!ServicioTecnico) || (MarcajeDinamicoActivo != 1)) {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Encoder (cuentas/mm)");break; case ING:o->label("Encoder (counts/mm)");break; case ITA:o->label("Encoder (conta/mm)");break;}}
      }
      Fl_Counter CounterVelocidadLinea {
        label {Velocidad línea (m/min)}
        callback {// Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
VelocidadLinea = o->value();

// Actualiza también el indicador en la parte de arriba de la pantalla
CuadroTextoVLinea->value(VelocidadLinea);

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Si está marcando habrá que volver a calcular la matriz
if (EnEjecucion) {Actualizar=true;}

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");}
        xywh {630 430 165 35} box PLASTIC_THIN_UP_BOX color 48 labelsize 12 align 5 when 6 minimum 0.1 maximum 1000 textfont 13 textsize 12
        code0 {o->value(VelocidadLinea);}
        code1 {if ((!ServicioTecnico) || (MarcajeDinamicoActivo != 2)) {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Velocidad línea (m/min)");break; case ING:o->label("Line speed (m/min)");break; case ITA:o->label("Velocità linea (m/min)");break;}}
      }
      Fl_Counter CounterRetardoDisparo {
        label {Retardo disparo (mm)}
        callback {// Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
RetardoDisparo_mm = (int)o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Y los límites del desplazamiento horizontal y vertical
InicializarIndicadorHorizontal();
InicializarIndicadorVertical();

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");}
        xywh {630 485 165 35} box PLASTIC_THIN_UP_BOX color 48 labelsize 12 align 5 when 6 minimum 0 maximum 1000 step 1 textfont 13 textsize 12
        code0 {o->value(RetardoDisparo_mm);}
        code1 {o->lstep(10.0); // fija el incremento de la flecha doble del contador}
        code2 {if ((!ServicioTecnico) || (TipoDisparo != DISPAROEXTERNO)) {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Retardo disparo (mm)");break; case ING:o->label("trigger delay (mm)");break; case ITA:o->label("Ritardo trigger (mm)");break;}}
      }
      Fl_Counter CounterSeparacionEntreDisparos {
        label {Separación (mm)}
        callback {// Se ha modificado: habrá que guardar la configuración
ConfiguracionModificada = true;

// Asigna el nuevo valor
SeparacionEntreDisparos_mm = (int)o->value();

// Habrá que volver a calcular los parámetros relacionados
Inicializar_Marcaje();

// Guarda los datos modificados
Escribir_Configuracion();
Escribir_DAT("itaca.dat");}
        xywh {630 485 165 35} box PLASTIC_THIN_UP_BOX color 48 labelsize 12 align 133 when 6 minimum 1 maximum 10000 step 1 value 1 textfont 13 textsize 12
        code0 {o->value(SeparacionEntreDisparos_mm); //inicialización}
        code1 {o->lstep(10.0); // fija el incremento de la flecha doble del contador}
        code2 {if ((!ServicioTecnico) || (TipoDisparo == DISPAROEXTERNO)) {o->hide();}}
        code3 {switch (Idioma) {case ESP:o->label("Separación (mm)");break; case ING:o->label("Separation (mm)");break; case ITA:o->label("Separazione (mm)");break;}}
      }
    }
    Fl_Button BotonFPGA {
      label FPGA
      callback {VentanaPrincipal->hide();
VentanaFPGA->show();}
      xywh {630 2 165 48} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 5 selection_color 7 labelfont 8 labelsize 15
      code0 {if (debug_FPGA) {o->show();} else {o->hide();}; //inicialización}
    }
    Fl_Button BotonResetContador {
      label Reset
      callback {Contador = 0;
CuadroTextoContador->value(Contador);}
      xywh {330 3 50 27} box PLASTIC_UP_BOX down_box PLASTIC_DOWN_BOX color 8 selection_color 0 labelfont 8 labelsize 12
    }
  }
  code {// Post Inicialización, tras crear el GUI

// versión SW
\#ifdef _68pines
	BoxVersionSW->label("Itaca v6.0.30.68p");
\#else 
	BoxVersionSW->label("Itaca v6.0.33"); 
\#endif

// Si está en desarrollo hay que manifestarlo!!
if (ENDESARROLLO) {

	BoxVersionSW->label("Desarrollo v5.07");
	
}

if (PuertoSerieActivo == ON) {

	Inicializar_PuertoSerie();
	
	// Arranca el timer del puerto serie
	Fl::add_timeout(0.1, ControlPuertoSerie);

}
	
// Inicializar sistema de control:
Inicializar_Control();

// Espera 1 segundo antes de seguir para dar tiempo a los galvos a inicializarse
sleep(1);

// Inicializa el cálculo y presentación de la velocidad de línea
switch (MarcajeDinamicoActivo) {

// desactivado
case 0:
	CuadroTextoVLinea->hide();
	CuadroTextoVLinea->value();
	CounterVelocidadLinea->hide();
	CounterEncoder->hide();
	break;
	
// activado, valocidad variable (lectura de encoder)
case 1:
	// Inicializa el encoder
	//Inicializar_Encoder();
	
	// Inicializar la lectura de cuentas del encoder
	//error = comedi_data_read(comedi_device, comedi_subdevice_ContadorEncoder, comedi_ContadorEncoder_Canal, 0, AREF_GROUND, &ValorCuentasAnterior_Estado);
	//if (error < 0) {
	//	rt_printk("ESTADO: LEER ENCODER comedi_data_read = %d\\n",error);
	//	ErrorDAQ = ON;
	//	ProcesarError();
	//}
	
	//CuadroTextoVLinea->deactivate();
	ValorCuentasAnterior_Estado = ValorCuentasActual;
	
	CounterVelocidadLinea->hide();
	
	if (ServicioTecnico) {
		CounterEncoder->show();
	}
	else {
		CounterEncoder->hide();
	}
	
	break;

// activado, con velocidad constante (fijada en itaca.conf)
case 2:
	CuadroTextoVLinea->deactivate();
	CuadroTextoVLinea->value(VelocidadLinea);
	
	if (ServicioTecnico) {
		CounterVelocidadLinea->show();
	}
	else {
		CounterVelocidadLinea->hide();
	}
	
	CounterEncoder->hide();
	
	break;
	
// error
default:
	break;
	
}

// Si no hay problema con la DAQ/FPGA sigue normalmente
if ((ErrorDAQ == false) && (ErrorFPGA == false)) {
	
	// Coloca los galvos en el origen
	Inicializar_Galvos();
	
	// Inicializa el láser: señal de enable y tren de pulsos
	// Al inicializar el láser se llama a ControlLaser(OFF), para asegurar que está apagado
	Inicializar_Laser();
	
	// Inicializa el encoder
	Inicializar_Encoder();
	
	// Inicializar RTAI y el timer en tiempo real
	Inicializar_RTAI();
		
	// Arranca el timer de estado, incluyendo la gestión del watchdog, si no está en desarrollo
	if (!ENDESARROLLO){
		Inicializar_thread_estado();
	}
	
	// thread check
	if (MarcajeDinamicoActivo == 1) {
		Fl::add_check(ActualizaUI);
	}

	// Activa los botones de marcaje
	BotonMarcar->activate();
	BotonPrueba->activate();
	
	// Mover los galvos al origen
	// La posicion inicial corresponde a las coordenadas 0,0 con comedi, y a -10,-10 con FPGA
	if (Control == DAQ) {
		xValuesPosicion = 0;
		yValuesPosicion = 0;
		
		if ((CalcularMoverGalvos(xValuesPosicion,yValuesPosicion) > 0) && (!debug_FPGA)) {
			MoverGalvos();
		}
		
	}
	
	else if (Control == FPGA) {
		
		// CAMBIAR: la FPGA se inicia poniendo 0 en el DAC, es decir, -10V (o el máximo
		// definido) - desde ahí hay que ir por microsteps hasta el origen
		EscribirGalvoX_FPGA(FPGA_from_phys(0.0));
		EscribirGalvoY_FPGA(FPGA_from_phys(0.0));	
	}
	
}

// Si hay problema con la DAQ/FPGA procesa el error
else {

	//Actualiza el Led de estado
	switch (Control) {

	case DAQ:
	
		switch (Idioma) {
	
		case ESP:
			LedEstado->label("DAQ");
			break; 
			
		case ING:
			LedEstado->label("DAQ");
			break; 
			
		case ITA:
			LedEstado->label("DAQ");
			break;
	
		}
		
		break;

	case FPGA:
		
		switch (Idioma) {
	
		case ESP:
			LedEstado->label("FPGA");
			break; 
			
		case ING:
			LedEstado->label("FPGA");
			break; 
			
		case ITA:
			LedEstado->label("FPGA");
			break;
	
		}
			
		break;
	
	} 	

	
			
	LedEstado->color((Fl_Color)1); 	// Led rojo
	LedEstado->redraw();		// Marca el Led para redraw
	LedEstado->deactivate();	// Y lo desactiva, ya que no se puede recuperar de un error de DAQ
	Fl::flush();			// Redraw all

	// Desactiva los botones de marcaje, ya que no se pueden usar
	//if (!ENDESARROLLO) {
		
		BotonMarcar->deactivate();
		BotonPrueba->deactivate();
		BotonCampo->deactivate();
		BotonLaser->deactivate();
	
	//}
	
}

// Validación del sistema
if (!ValidarSistema()) {

	ErrorValidacion = ON;
	
	//Actualiza el Led de estado
	switch (Idioma) {
	
		case ESP:
		LedEstado->label("Validación");
		break; 
			
		case ING:
		LedEstado->label("Validation");
		break; 
			
		case ITA:
		LedEstado->label("Convalida");
		break;
	
	}
			
	LedEstado->color(FL_YELLOW); 	// Led amarillo
	LedEstado->redraw();		// Marca el Led para redraw
	LedEstado->deactivate();	// Y lo desactiva, ya que no se puede recuperar de un error de validación
	Fl::flush();			// Redraw all

	// Desactiva los botones de marcaje, ya que no se pueden usar
	//if (!ENDESARROLLO) {
		
		BotonMarcar->deactivate();
	//	BotonMarcar->hide();		// Para que no se pueda marcar de ninguna manera
	//	BotonPrueba->deactivate();
	//	BotonCampo->deactivate();
	//	BotonLaser->deactivate();
	
	//}

}

rt_printk("\# Inicialización completa \#\\n");

Llevar_Galvos_Origen();} {}
} 

Function {Leer_Entradas_Temperatura()} {open C return_type int
} {
  code {int error = false;} {}
} 

Function {Salida_PWM_Ventilador()} {open C return_type int
} {
  code {int error = false;} {}
} 
